<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2019 (Released January 1, 2019) -->
<HTML lang="EN">
<HEAD>
<TITLE>Next Extensions</TITLE>
<META NAME="description" CONTENT="Next Extensions">
<META NAME="keywords" CONTENT="zxnext_notes">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2019">

<LINK REL="STYLESHEET" HREF="zxnext_notes.css">

<LINK REL="previous" HREF="node138.html">
<LINK REL="next" HREF="node140.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node140.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node136.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node138.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html1149"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A> 
<A ID="tex2html1151"
  HREF="node187.html">
<IMG WIDTH="43" HEIGHT="24" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A
 HREF="node140.html">Ports</A>
<B> Up:</B> <A
 HREF="node136.html">NextZXOS</A>
<B> Previous:</B> <A
 HREF="node138.html">esxDOS compatible API</A>
 &nbsp; <B>  <A ID="tex2html1150"
  HREF="node1.html">Contents</A></B> 
 &nbsp; <B>  <A ID="tex2html1152"
  HREF="node187.html">Index</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H2><A ID="SECTION001033000000000000000">
Next Extensions</A>
</H2>

<P>
$0085 <SPAN  CLASS="textbf">DISK_FILEMAP</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img74.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_disk_filemap(uint8_t handle,struct esx_filemap *fmap)
\end{lstlisting}">
<BR>

<P>
Obtain a map of card addresses describing the space occupies by the
file. Can be called multiple times if the buffer is filled, continuing
from previous.

<P>
Entry:

<UL>
<LI>A=file handle (just opened, or following previous DISK_FILEMAP calls)
</LI>
<LI>IX=buffer
</LI>
<LI>DE=max entries (each 6 bytes: 4 byte address, 2 byte sector count)
</LI>
</UL>
Exit (success):
<BR>
Fc=0
<BR>
DE=max entries-number of entries returned
<BR>
HL=address in buffer after last entry
<BR>
A=card flags: bit 0=card id (0 or 1)
<BR>
bit 1=0 for byte addressing, 1 for block addressing

<P>
Exit (failure):
<BR>
Fc=1
<BR>
A=error

<P>
NOTES:
<BR>
Each entry may describe an area of the file between 2K and just under 32MB
<BR>
in size, depending upon the fragmentation and disk format.
<BR>
Please see example application code, stream.asm, for full usage information
<BR>(available separately or at the end of this document).

<P>
<SPAN  CLASS="textbf">DISK_STREAM_BYTES</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img75.svg"
 ALT="\begin{lstlisting}[language=C]
void *esx_disk_stream_bytes(void *dst,uint16_t len)
\end{lstlisting}">
<BR>

<P>
$0087 <SPAN  CLASS="textbf">DISK_STREAM_END</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img76.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_disk_stream_end(void)
\end{lstlisting}">
<BR>

<P>
Stop current streaming operation.
<BR>
Entry: A=card flags
<BR>
Exit (success): Fc=0
<BR>
Exit (failure): Fc=1, A=esx_edevicebusy

<P>
NOTES:
<BR>
This call must be made to terminate a streaming operation.
<BR>
Please see example application code, stream.asm, for full usage information
<BR>(available separately or at the end of this document).

<P>
<SPAN  CLASS="textbf">DISK_STREAM_SECTORS</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img77.svg"
 ALT="\begin{lstlisting}[language=C]
void *esx_disk_stream_sectors(void *dst,uint8_t sectors)
\end{lstlisting}">
<BR>

<P>
$0086 <SPAN  CLASS="textbf">DISK_STREAM_START</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img78.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_disk_stream_start(struct esx_filemap_entry *entry)
\end{lstlisting}">
<BR>

<P>
Start reading from the card in streaming mode.
<BR>
Entry: IXDE=card address
<BR>
BC=number of 512-byte blocks to stream
<BR>
A=card flags
<BR>
Exit (success): Fc=0
<BR>
B=0 for SD/MMC protocol, 1 for IDE protocol
<BR>
C=8-bit data port
<BR>
Exit (failure): Fc=1, A=esx_edevicebusy

<P>
NOTES:
<BR>
On the Next, this call always returns with B=0 (SD/MMC protocol) and C=$EB
<BR>
When streaming using the SD/MMC protocol, after every 512 bytes you must read
<BR>
a 2-byte CRC value (which can be discarded) and then wait for a $FE value
<BR>
indicating that the next block is ready to be read.
<BR>
Please see example application code, stream.asm, for full usage information
<BR>(available separately or at the end of this document).

<P>
<SPAN  CLASS="textbf">DOS_CATALOG</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img79.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_dos_catalog(struct esx_cat *cat)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">DOS_CATALOG_NEXT</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img80.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_dos_catalog_next(struct esx_cat *cat)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">DOS_GETSET_DRIVE</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img81.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_dos_get_drive(void)
unsigned char esx_dos_set_drive(unsigned char drive)
\end{lstlisting}">
<BR>

<P>
$00A9 <SPAN  CLASS="textbf">F_CHDIR</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img82.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_chdir(unsigned char *pathname)
\end{lstlisting}">
<BR>

<P>
Change directory.
<BR>
Entry:
<BR>
A=drive specifier (overridden if filespec includes a drive)
<BR>
IX=path, null-terminated
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
$00AF <SPAN  CLASS="textbf">F_CHMOD</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img83.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_chmod(unsigned char *filename, uint8_t attr_mask, uint8_t attr)
\end{lstlisting}">
<BR>

<P>
Modify file attributes.
<BR>
Entry:
<BR>
A=drive specifier (overridden if filespec includes a drive)
<BR>
IX=filespec, null-terminated
<BR>
B=attribute values bitmap
<BR>
C=bitmap of attributes to change (1=change, 0=do not change)

<P>
Bitmasks for B and C are any combination of:
<BR>
A_WRITE %00000001
<BR>
A_READ %10000000
<BR>
A_RDWR %10000001
<BR>
A_HIDDEN %00000010
<BR>
A_SYSTEM %00000100
<BR>
A_ARCH %00100000
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
$009B<SPAN  CLASS="textbf">F_CLOSE</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img84.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_close(unsigned char handle)
\end{lstlisting}">
<BR>

<P>
Close a file or directory.
<BR>
Entry:
<BR>
A=file handle or directory handle
<BR>
Exit (success):
<BR>
Fc=0
<BR>
A=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
<SPAN  CLASS="textbf">F_CLOSEDIR</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img85.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_closedir(unsigned char handle)
\end{lstlisting}">
<BR>

<P>
$00A0 <SPAN  CLASS="textbf">F_FGETPOS</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img86.svg"
 ALT="\begin{lstlisting}[language=C]
uint32_t esx_f_fgetpos(unsigned char handle)
\end{lstlisting}">
<BR>

<P>
Get current file position.
<BR>
Entry:
<BR>
A=file handle
<BR>
Exit (success):
<BR>
Fc=0
<BR>
BCDE=current position
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
$00A1 <SPAN  CLASS="textbf">F_FSTAT</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img87.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_fstat(unsigned char handle, struct esx_stat *es)
\end{lstlisting}">
<BR>

<P>
Get file information/status.
<BR>
Entry:
<BR>
A=file handle
<BR>
IX=11-byte buffer address
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
NOTES:
<BR>
The following details are returned in the 11-byte buffer:
<BR>+0(1) '*'
<BR>+1(1) $81
<BR>+2(1) file attributes (MS-DOS format)
<BR>+3(2) timestamp (MS-DOS format)
<BR>+5(2) datestamp (MS-DOS format)
<BR>+7(4) file size in bytes

<P>
$00A2 <SPAN  CLASS="textbf">F_FTRUNC</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img88.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_ftrunc(unsigned char handle, uint32_t size)
\end{lstlisting}">
<BR>

<P>
Truncate/extend file.
<BR>
Entry:
<BR>
A=file handle
<BR>
BCDE=new filesize
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
NOTES:
<BR>
Sets the filesize to precisely BCDE bytes.
<BR>
If BCDE&lt;current filesize, the file is trunctated.
<BR>
If BCDE&gt;current filesize, the file is extended. The extended part is erased
<BR>
with zeroes.
<BR>
The file position is unaffected. Therefore, if truncating, make sure to
<BR>
set the file position within the file before further writes (otherwise it
<BR>
will be extended again).
<BR>+3DOS headers are included as part of the filesize. Truncating such files is
<BR>
not recommended.

<P>
<SPAN  CLASS="textbf">F_GET_CANONICAL_PATH</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img89.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_get_canonical_path(char *pathname, char *canonical)
\end{lstlisting}">
<BR>

<P>
$00A8 <SPAN  CLASS="textbf">F_GETCWD</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img90.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_getcwd(unsigned char *buf)
\end{lstlisting}">
<BR>

<P>
Get current working directory.
<BR>
Entry:
<BR>
A=drive
<BR>
IX=buffer for null-terminated path
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
<SPAN  CLASS="textbf">F_GETCWD_DRIVE</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img91.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_getcwd_drive(unsigned char drive, char *buf)
\end{lstlisting}">
<BR>

<P>
$00B1 <SPAN  CLASS="textbf">F_GETFREE</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img92.svg"
 ALT="\begin{lstlisting}[language=C]
uint32_t esx_f_getfree(void)
\end{lstlisting}">
<BR>

<P>
Gets free space on drive.
<BR>
Entry:
<BR>
A=drive specifier
<BR>
Exit (success):
<BR>
Fc=0
<BR>
BCDE=number of 512-byte blocks free on drive
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
$00AA <SPAN  CLASS="textbf">F_MKDIR</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img93.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_mkdir(unsigned char *pathname)
\end{lstlisting}">
<BR>

<P>
Create directory.
<BR>
Entry:
<BR>
A=drive specifier (overridden if filespec includes a drive)
<BR>
IX=path, null-terminated
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
$009A <SPAN  CLASS="textbf">F_OPEN</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img94.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_open(unsigned char *filename,unsigned char mode)
\end{lstlisting}">
<BR>

<P>
Open a file.
<BR>
Entry:
<BR>
A=drive specifier (overridden if filespec includes a drive)
<BR>
IX=filespec, null-terminated
<BR>
B=access modes, a combination of:
<BR>
any/all of:
<BR>
esx_mode_read $01 request read access
<BR>
esx_mode_write $02 request write access
<BR>
esx_mode_use_header $40 read/write +3DOS header
<BR>
plus one of:
<BR>
esx_mode_open_exist $00 only open existing file
<BR>
esx_mode_open_creat $08 open existing or create file
<BR>
esx_mode_creat_noexist $04 create new file, error if exists
<BR>
esx_mode_creat_trunc $0c create new file, delete existing

<P>
DE=8-byte buffer with/for +3DOS header data (if specified in mode)
<BR>(NB: filetype will be set to $ff if headerless file was opened)
<BR>
Exit (success):
<BR>
Fc=0
<BR>
A=file handle
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
$00A3 <SPAN  CLASS="textbf">F_OPENDIR</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img95.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_opendir(unsigned char *dirnam...
...gned char esx_f_opendir_ex(unsigned char *dirname,uint8_t mode)
\end{lstlisting}">
<BR>

<P>
Open directory.
<BR>
Entry:
<BR>
A=drive specifier (overridden if filespec includes a drive)
<BR>
IX=directory, null-terminated
<BR>
B=access mode (only esx_mode_use_header and esx_mode_use_lfn matter)
<BR>
any/all of:
<BR>
esx_mode_use_lfn $10 return long filenames
<BR>
esx_mode_use_header $40 read/write +3DOS headers
<BR>
Exit (success):
<BR>
A=dir handle
<BR>
Fc=0

<P>
$009A <SPAN  CLASS="textbf">F_OPEN</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img96.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_open_p3(unsigned char *filename,unsigned char mode,struct esx_p3_hdr *h)
\end{lstlisting}">
<BR>

<P>
Open a file.
<BR>
Entry:
<BR>
A=drive specifier (overridden if filespec includes a drive)
<BR>
IX=filespec, null-terminated
<BR>
B=access modes, a combination of:
<BR>
any/all of:
<BR>
esx_mode_read $01 request read access
<BR>
esx_mode_write $02 request write access
<BR>
esx_mode_use_header $40 read/write +3DOS header
<BR>
plus one of:
<BR>
esx_mode_open_exist $00 only open existing file
<BR>
esx_mode_open_creat $08 open existing or create file
<BR>
esx_mode_creat_noexist $04 create new file, error if exists
<BR>
esx_mode_creat_trunc $0c create new file, delete existing

<P>
DE=8-byte buffer with/for +3DOS header data (if specified in mode)
<BR>(NB: filetype will be set to $ff if headerless file was opened)
<BR>
Exit (success):
<BR>
Fc=0
<BR>
A=file handle
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
$009D <SPAN  CLASS="textbf">F_READ</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img97.svg"
 ALT="\begin{lstlisting}[language=C]
uint16_t esx_f_read(unsigned char handle, void *dst, size_t nbytes)
\end{lstlisting}">
<BR>

<P>
Read bytes from file.
<BR>
Entry:
<BR>
A=file handle
<BR>
IX=address
<BR>
BC=bytes to read
<BR>
Exit (success):
<BR>
Fc=0
<BR>
BC=bytes actually read (also in DE)
<BR>
HL=address following bytes read
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
BC=bytes actually read
<BR>
A=error code

<P>
NOTES:
<BR>
EOF is not an error, check BC to determine if all bytes requested were read.

<P>
$00A4 <SPAN  CLASS="textbf">F_READDIR</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img98.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_readdir(unsigned char handle,struct esx_dirent *dirent)
\end{lstlisting}">
<BR>

<P>
Read next directory entry.
<BR>
Entry:
<BR>
A=handle
<BR>
IX=buffer
<BR>
Exit (success):
<BR>
A=number of entries returned (0 or 1)
<BR>
If 0, there are no more entries
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
Buffer format:
<BR>
1 byte file attributes (MSDOS format)
<BR>? bytes file/directory name, null-terminated
<BR>
2 bytes timestamp (MSDOS format)
<BR>
2 bytes datestamp (MSDOS format)
<BR>
4 bytes file size

<P>
NOTES:
<BR>
If the directory was opened with the esx_mode_use_lfn bit, long filenames
<BR>(up to 260 bytes plus terminator) are returned; otherwise short filenames
<BR>(up to 12 bytes plus terminator) are returned.
<BR>
If opened with the esx_mode_use_header bit, after the normal entry follows the
<BR>
8-byte +3DOS header (for headerless files, type=$ff, other bytes=zero).

<P>
$00B0 <SPAN  CLASS="textbf">F_RENAME</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img99.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_rename(unsigned char *old, unsigned char *new)
\end{lstlisting}">
<BR>

<P>
Rename or move a file.
<BR>
Entry:
<BR>
A=drive specifier (overridden if filespec includes a drive)
<BR>
IX=source filespec, null-terminated
<BR>
DE=destination filespec, null-terminated
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
$00A7 <SPAN  CLASS="textbf">F_REWINDDIR</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img100.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_rewinddir(unsigned char handle)
\end{lstlisting}">
<BR>

<P>
Rewind directory position to the start of the directory.
<BR>
Entry:
<BR>
A=handle
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
$00AB <SPAN  CLASS="textbf">F_RMDIR</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img101.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_rmdir(unsigned char *pathname)
\end{lstlisting}">
<BR>

<P>
Remove directory.
<BR>
Entry:
<BR>
A=drive specifier (overridden if filespec includes a drive)
<BR>
IX=path, null-terminated
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
$009F <SPAN  CLASS="textbf">F_SEEK</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img102.svg"
 ALT="\begin{lstlisting}[language=C]
uint32_t esx_f_seek(unsigned char handle, uint32_t distance, unsigned char whe
nce)
\end{lstlisting}">
<BR>

<P>
Seek to position in file.
<BR>
Entry:
<BR>
A=file handle
<BR>
BCDE=bytes to seek
<BR>
IXL=seek mode:
<BR>
esx_seek_set $00 set the fileposition to BCDE
<BR>
esx_seek_fwd $01 add BCDE to the fileposition
<BR>
esx_seek_bwd $02 subtract BCDE from the fileposition
<BR>
Exit (success):
<BR>
Fc=0
<BR>
BCDE=current position
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
NOTES:
<BR>
Attempts to seek past beginning/end of file leave BCDE=position=0/filesize
<BR>
respectively, with no error.

<P>
$00A6 <SPAN  CLASS="textbf">F_SEEKDIR</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img103.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_seekdir(unsigned char handle,uint32_t pos)
\end{lstlisting}">
<BR>

<P>
Set current directory position.
<BR>
Entry:
<BR>
A=handle
<BR>
BCDE=offset in directory to seek to (as returned by F_TELLDIR)
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
$00AC <SPAN  CLASS="textbf">F_STAT</SPAN>

<P>
Get unopened file information/status.
<BR>
Entry:
<BR>
A=drive specifier (overridden if filespec includes a drive)
<BR>
IX=filespec, null-terminated
<BR>
DE=11-byte buffer address
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
NOTES:
<BR>
The following details are returned in the 11-byte buffer:
<BR>+0(1) drive specifier
<BR>+1(1) $81
<BR>+2(1) file attributes (MS-DOS format)
<BR>+3(2) timestamp (MS-DOS format)
<BR>+5(2) datestamp (MS-DOS format)
<BR>+7(4) file size in bytes

<P>
$009C <SPAN  CLASS="textbf">F_SYNC</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img104.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_sync(unsigned char handle)
\end{lstlisting}">
<BR>

<P>
Sync file changes to disk.
<BR>
Entry:
<BR>
A=file handle
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
$00A5 <SPAN  CLASS="textbf">F_TELLDIR</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img105.svg"
 ALT="\begin{lstlisting}[language=C]
uint32_t esx_f_telldir(unsigned char handle)
\end{lstlisting}">
<BR>

<P>
Get current directory position.
<BR>
Entry:
<BR>
A=handle
<BR>
Exit (success):
<BR>
BCDE=current offset in directory
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
$00AE <SPAN  CLASS="textbf">F_TRUNC</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img106.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_trunc(unsigned char *filename,uint32_t size
)
\end{lstlisting}">
<BR>

<P>
Truncate/extend unopened file.
<BR>
Entry:
<BR>
A=drive specifier (overridden if filespec includes a drive)
<BR>
IX=source filespec, null-terminated
<BR>
BCDE=new filesize
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
NOTES:
<BR>
Sets the filesize to precisely BCDE bytes.
<BR>
If BCDE&lt;current filesize, the file is trunctated.
<BR>
If BCDE&gt;current filesize, the file is extended. The extended part is erased
<BR>
with zeroes.
<BR>+3DOS headers are included as part of the filesize. Truncating such files is
<BR>
not recommended.

<P>
$00AD <SPAN  CLASS="textbf">F_UNLINK</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img107.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_f_unlink(unsigned char *filename)
\end{lstlisting}">
<BR>

<P>
Delete file.
<BR>
Entry:
<BR>
A=drive specifier (overridden if filespec includes a drive)
<BR>
IX=filespec, null-terminated
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
$009E <SPAN  CLASS="textbf">F_WRITE</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img108.svg"
 ALT="\begin{lstlisting}[language=C]
uint16_t esx_f_write(unsigned char handle, void *src, size_t nbytes)
\end{lstlisting}">
<BR>

<P>
Write bytes to file.
<BR>
Entry:
<BR>
A=file handle
<BR>
IX=address
<BR>
BC=bytes to write
<BR>
Exit (success):
<BR>
Fc=0
<BR>
BC=bytes actually written
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
BC=bytes actually written

<P>
<SPAN  CLASS="textbf">IDE_BANK_ALLOC</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img109.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_bank_alloc(unsigned char banktype)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">IDE_BANK_AVAIL</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img110.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_bank_avail(unsigned char banktype)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">IDE_BANK_FREE</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img111.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_bank_free(unsigned char banktype, unsigned char page)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">IDE_BANK_RESERVE</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img112.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_bank_reserve(unsigned char banktype,unsigned char page)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">IDE_BANK_TOTAL</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img113.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_bank_total(unsigned char banktype)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">IDE_BROWSER</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img114.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_browser(uint8_t browsercaps, void *filetypes, char *help, char *dst_sfn, char *dst_lfn)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">IDE_GET_LFN</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img115.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_get_lfn(struct esx_lfn *dir, struct esx_cat_entry *query)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">IDE_MODE_GET</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img116.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_mode_get(struct esx_mode *mode)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">IDE_MODE_SET</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img117.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_ide_mode_set(struct esx_mode *mode)
\end{lstlisting}">
<BR>

<P>
$0088 <SPAN  CLASS="textbf">M_DOSVER</SPAN>

<P>
Get API version/mode information.
<BR>
Entry:
<BR>-
<BR>
Exit:
<BR>
For esxDOS &lt;= 0.8.6
<BR>
Fc=1, error
<BR>
A=14 ("no such device")

<P>
For NextOS:
<BR>
Fc=0, success
<BR>
B='N',C='X' (NextOS signature)
<BR>
DE=NextOS version in BCD format: D=major, E=minor version number
<BR>
eg for NextOS v1.94, DE=$0194
<BR>
HL=A=0 if running in NextOS mode (and zero flag is set)
<BR>
HL,A&lt;&gt;0 if running in 48K mode (and zero flag is reset)

<P>
$0092 <SPAN  CLASS="textbf">M_DRVAPI</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img118.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_m_drvapi(struct esx_drvapi *)
\end{lstlisting}">
<BR>

<P>
Access API for installable drivers.
<BR>
Entry:
<BR>
C=driver id (0=driver API)
<BR>
B=call id
<BR>
HL,DE=other parameters
<BR>
Exit (success):
<BR>
Fc=0
<BR>
other values depend on API call
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=0, driver not found
<BR>
else A=driver-specific error code (esxDOS error code for driver API)
<BR>
If C=0, the driver API is selected and calls are as follows:
<BR>(Note that these are not really useful for user applications; they are used
<BR>
by the .install/.uninstall dot commands).

<P>
B=0, query the RTC
<BR>(returns the same results as M_GETDATE)

<P>
B=1, install a driver
<BR>
D=number of relocations (0-255)
<BR>
E=driver id, with bit 7=1 if should be called on an IM1 interrupt
<BR>
HL=address of 512-byte driver code followed by D x 2-byte reloc offsets
<BR>
Possible error values are:
<BR>
esx_eexist (18) driver with same id already installed
<BR>
esx_einuse (23) no free driver slots available
<BR>
esx_eloadingko (26) bad relocation table

<P>
B=2, uninstall a driver
<BR>
E=driver id (bit 7 ignored)

<P>
B=3, get paging value for driver banks
<BR>
C=port (always $e3 on ZXNext)
<BR>
A=paging value for DivMMC bank containing drivers (usually $82)

<P>
$0095 <SPAN  CLASS="textbf">M_ERRH</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img119.svg"
 ALT="\begin{lstlisting}[language=C]
void esx_m_errh(void (*handler)(uint8_t error))
\end{lstlisting}">
<BR>

<P>
Install error handler for dot command.
<BR>
Entry: HL=address of error handler within dot command
<BR>(0 to change back to standard handler)

<P>
NOTES:
<BR>
Can only be used from within a dot command.
<BR>
If any BASIC error occurs during a call to ROM3 (using RST $10 or RST $18)
<BR>
then your error handler will be entered with:
<BR>
DE=address that would have been returned to if the error had not
<BR>
occurred
<BR>
A=BASIC error code-1 (eg 8=9 STOP statement)

<P>
$008F <SPAN  CLASS="textbf">M_EXECCMD</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img120.svg"
 ALT="\begin{lstlisting}[language=C]
uint16_t esx_m_execcmd(unsigned char *cmdline)
\end{lstlisting}">
<BR>

<P>
Execute a dot command.
<BR>
Entry:
<BR>
IX=address of commandline, excluding the leading "."
<BR>
terminated with $00 (or $0d, or ':')
<BR>
Exit (success):
<BR>
Fc=0
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code (0 means user-defined error)
<BR>
HL=address of user-defined error message within dot command

<P>
NOTES:
<BR>
The dot command name can be fully-pathed if desired. If just a name is
<BR>
provided, it is opened from the C:/BIN directory.
<BR>
eg: defm "hexdump afile.txt",0 ; runs c:/bin/hexdump
<BR>
defm "./mycommand.dot afile.txt",0 ; runs mycommand.dot in current
<BR>
<P>
If A=0, the dot command has provided its own error message but this is not
<BR>
normally accessible. It can be read using the M_GETERR hook.
<BR>
This hook cannot be used from within another dot command.

<P>
$008E <SPAN  CLASS="textbf">M_GETDATE</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img121.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_m_getdate(struct dos_tm *)
\end{lstlisting}">
<BR>

<P>
Get the current date/time.
<BR>
Entry:
<BR>-
<BR>
Exit:
<BR>
Fc=0 if RTC present and providing valid date/time, and:
<BR>
BC=date, in MS-DOS format
<BR>
DE=time, in MS-DOS format
<BR>
Fc=1 if no RTC, or invalid date/time, and:
<BR>
BC=0
<BR>
DE=0

<P>
$0093 <SPAN  CLASS="textbf">M_GETERR</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img122.svg"
 ALT="\begin{lstlisting}[language=C]
void esx_m_geterr(uint16_t error,unsigned char *msg)
\end{lstlisting}">
<BR>

<P>
Entry:
<BR>
A=esxDOS error code, or 0=user defined error from dot command
<BR>
if A=0, IX=error message address from dot command

<P>
B=0, generate BASIC error report (does not return)
<BR>
B=1, return error message to 32-byte buffer at DE

<P>
NOTES:
<BR>
Dot commands may use this call to fetch a standard esxDOS error message
<BR>(with B=1), but must not use it to generate an error report (with B=0) as
<BR>
this would short-circuit the tidy-up code.
<BR>
User programs may use the call to generate any custom error message (and not
<BR>
just a custom message returned by a dot command). To do this, enter with
<BR>
A=0 and IX=address of custom message, where IX&gt;=$4000.
<BR>
Custom error messages must be terminated with bit 7 set on the final
<BR>
character.

<P>
$008D <SPAN  CLASS="textbf">M_GETHANDLE</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img123.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_m_gethandle(void)
\end{lstlisting}">
<BR>

<P>
Get the file handle of the currently running dot command
<BR>
Entry:
<BR>-
<BR>
Exit:
<BR>
A=handle
<BR>
Fc=0

<P>
NOTES:
<BR>
This call allows dot commands which are &gt;8K to read further data direct
<BR>
from their own file (for loading into another memory area, or overlaying
<BR>
as required into the normal 8K dot command area currently in use).
<BR>
On entry to a dot command, the file is left open with the file pointer
<BR>
positioned directly after the first 8K.
<BR>
This call returns meaningless results if not called from a dot command.

<P>
$0089 <SPAN  CLASS="textbf">M_GETSETDRV</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img124.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_m_getdrv(void)
unsigned char esx_m_setdrv(unsigned char drive)
\end{lstlisting}">
<BR>

<P>
Get or set the default drive.
<BR>
Entry:
<BR>
A=0, get the default drive
<BR>
A&lt;&gt;0, set the default drive to A
<BR>
bits 7..3=drive letter (0=A...15=P)
<BR>
bits 2..0=drive number (0) - change: set a bit so drive A can be selected
<BR>
Exit (success):
<BR>
Fc=0
<BR>
A=default drive, encoded as:
<BR>
bits 7..3=drive letter (0=A...15=P)
<BR>
bits 2..0=drive number (0)
<BR>
Exit (failure):
<BR>
Fc=1
<BR>
A=error code

<P>
NOTE:
<BR>
This call isn't really very useful, as it is not necessary to provide a
<BR>
specific drive to calls which need a drive/filename.
<BR>
For such calls, you can instead provide:
<BR>
A='*' use the default drive
<BR>
A='$' use the system drive (C:, where the NEXTOS and BIN directories are)

<P>
$0091 <SPAN  CLASS="textbf">M_SETCAPS</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img125.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_m_setcaps(unsigned char caps)
\end{lstlisting}">
<BR>

<P>
Entry: A=capabilities to set:
<BR>
bit 7=1, do not erase new file data in f_truncate/f_ftruncate
<BR>(increases performance of these calls)
<BR>
bits 0..6: reserved, must be zero
<BR>
Exit: Fc=0, success
<BR>
E=previous capabilities

<P>
NOTE: This call is only available from NextOS v1.98M+.
<BR>
Earlier versions will return with Fc=1 (error) and A=esx_enocmd
<BR>
NOTE: You should save the original value of the capabilities which is
<BR>
returned in E. After completing the calls you need with your altered
<BR>
capabilities, restore the original value by calling M_SETCAPS again
<BR>
with the value that was previously returned in E.
<BR>
This will ensure that other programs running after you have exited
<BR>
will continue to see the original expected behaviour.

<P>
$008B <SPAN  CLASS="textbf">M_TAPEIN</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img126.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_m_tapein_close(void)
unsigned c...
...s(uint16_t block)
unsigned char esx_m_tapein_toggle_pause(void)
\end{lstlisting}">
<BR>

<P>
Tape input redirection control.
<BR>
Entry:
<BR>
B=0, in_open:
<BR>
Attach tap file with name at IX, drive in A
<BR>
B=1, in_close:
<BR>
Detach tap file
<BR>
B=2, in_info:
<BR>
Return attached filename to buffer at IX and drive in A
<BR>
B=3, in_setpos:
<BR>
Set position of tape pointer to block DE (0=start)
<BR>
B=4, in_getpos:
<BR>
Get position of tape pointer, in blocks, to HL
<BR>
B=5, in_pause:
<BR>
Toggles pause delay when loading SCREEN$
<BR>
On exit, A=1 if pause now enabled, A=0 if not
<BR>
B=6, in_flags:
<BR>
Set tape flags to A
<BR>
bit 0: 1=pause delay at SCREEN$ (as set by in_pause)
<BR>
bit 1: 1=simulate tape loading with border/sound

<P>
$008C <SPAN  CLASS="textbf">M_TAPEOUT</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img127.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char esx_m_tapeout_close(void)
unsigned ...
...ame)
unsigned char esx_m_tapeout_trunc(unsigned char *filename)
\end{lstlisting}">
<BR>

<P>
Tape output redirection control.
<BR>
Entry:
<BR>
B=0, out_open:
<BR>
Create/attach tap file with name at IX for appending, drive A
<BR>
B=1, out_close:
<BR>
Detach tap file
<BR>
B=2, out_info:
<BR>
Return attached filename to buffer at IX and drive in A
<BR>
B=3, out_trunc:
<BR>
Create/overwrite tap file with name at IX, drive A

<P>
<SPAN  CLASS="textbf">SLICE_DIRENT</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img128.svg"
 ALT="\begin{lstlisting}[language=C]
struct esx_dirent_slice *esx_slice_dirent(struct esx_dirent *)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">EXTENDED_SNA_LOAD</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img129.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char extended_sna_load(unsigned char handle)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">P3DOS_COPY_CSTR_TO_PSTR</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img130.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char *p3dos_copy_cstr_to_pstr(char *pdst, const char *csrc)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">P3DOS_COPY_PSTR_TO_CSTR</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img131.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char *p3dos_copy_pstr_to_cstr(char *cdst, const char *psrc)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">P3DOS_CSTR_TO_PSTR</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img132.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char *p3dos_cstr_to_pstr(unsigned char *s)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">P3DOS_DOSNAME_FROM_CATNAME</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img133.svg"
 ALT="\begin{lstlisting}[language=C]
char *p3dos_dosname_from_catname(char *dosname, char *catname)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">P3DOS_EDRV_FROM_PDRV</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img134.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char p3dos_edrv_from_pdrv(unsigned char pdrv)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">P3DOS_PDRV_FROM_EDRV</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img135.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char p3dos_pdrv_from_edrv(unsigned char edrv)
\end{lstlisting}">
<BR>

<P>
<SPAN  CLASS="textbf">P3DOS_PSTR_TO_CSTR</SPAN>

<P>
<BR>
<IMG STYLE=""
 SRC="img136.svg"
 ALT="\begin{lstlisting}[language=C]
unsigned char *p3dos_pstr_to_cstr(unsigned char *s)
\end{lstlisting}">
<BR>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A
 HREF="node140.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node136.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node138.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html1149"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A> 
<A ID="tex2html1151"
  HREF="node187.html">
<IMG WIDTH="43" HEIGHT="24" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A
 HREF="node140.html">Ports</A>
<B> Up:</B> <A
 HREF="node136.html">NextZXOS</A>
<B> Previous:</B> <A
 HREF="node138.html">esxDOS compatible API</A>
 &nbsp; <B>  <A ID="tex2html1150"
  HREF="node1.html">Contents</A></B> 
 &nbsp; <B>  <A ID="tex2html1152"
  HREF="node187.html">Index</A></B> </DIV>
<!--End of Navigation Panel-->

</BODY>
</HTML>
