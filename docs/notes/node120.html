<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2019 (Released January 1, 2019) -->
<HTML lang="EN">
<HEAD>
<TITLE>+3DOS compatible API</TITLE>
<META NAME="description" CONTENT="+3DOS compatible API">
<META NAME="keywords" CONTENT="zxnext_notes">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2019">

<LINK REL="STYLESHEET" HREF="zxnext_notes.css">

<LINK REL="next" HREF="node121.html">
<LINK REL="previous" HREF="node119.html">
<LINK REL="next" HREF="node121.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node121.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node119.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node119.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html949"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A> 
<A ID="tex2html951"
  HREF="node156.html">
<IMG WIDTH="43" HEIGHT="24" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A
 HREF="node121.html">esxDOS compatible API</A>
<B> Up:</B> <A
 HREF="node119.html">NextZXOS</A>
<B> Previous:</B> <A
 HREF="node119.html">NextZXOS</A>
 &nbsp; <B>  <A ID="tex2html950"
  HREF="node1.html">Contents</A></B> 
 &nbsp; <B>  <A ID="tex2html952"
  HREF="node156.html">Index</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H2><A ID="SECTION001031000000000000000">
+3DOS compatible API</A>
</H2>
Generally to make these calls, you need to set up: place ROM 2 at
$0000-$3fff, RAM bank 7 at $c000-$ffff, stack below $bfe0, and
set up the parameters for the call in the indicated registers. Call
the function at its address. Then, restore your system to its previous
configuration. In general the carry bit of F is cleared on error with
the error code in A. Calls generally affect the contnts of AF, BC, DE,
HL, and IX leaving AF', BC', DE', HL', IY, and SP intact. To simplify,
descriptions will assume this is true and only indicate exceptions to
the rule.

<P>
$0056 <SPAN  CLASS="textbf">IDE_STREAM_OPEN</SPAN>

<P>
Open stream to a channel

<P>
$0059 <SPAN  CLASS="textbf">IDE_STREAM_CLOSE</SPAN>

<P>
Close stream and attached channel

<P>
$005c <SPAN  CLASS="textbf">IDE_STREAM_IN</SPAN>

<P>
Get byte from current stream

<P>
$005f <SPAN  CLASS="textbf">IDE_STREAM_OUT</SPAN>

<P>
Write byte to current stream

<P>
$0062 <SPAN  CLASS="textbf">IDE_STREAM_PTR</SPAN>

<P>
Get or set pointer information for current stream

<P>
$00A0 <SPAN  CLASS="textbf">IDE_VERSION</SPAN>

<P>
Get IDEDOS version number

<P>
$00A3 <SPAN  CLASS="textbf">IDE_INTERFACE</SPAN>

<P>
Initialise card interfaces
$00A6 <SPAN  CLASS="textbf">IDE_INIT</SPAN>

<P>
Initialise IDEDOS

<P>
$00A9 <SPAN  CLASS="textbf">IDE_DRIVE</SPAN>

<P>
Get unit handle

<P>
$00AC <SPAN  CLASS="textbf">IDE_SECTOR_READ</SPAN>

<P>
Low-level sector read

<P>
$00AF <SPAN  CLASS="textbf">IDE_SECTOR_WRITE</SPAN>

<P>
Low-level sector write

<P>
$00B2 <SPAN  CLASS="textbf">IDE_FORMAT</SPAN>

<P>
Format a partition

<P>
$00B5 <SPAN  CLASS="textbf">IDE_PARTITION_FIND</SPAN>

<P>
Find named partition

<P>
$00B8 <SPAN  CLASS="textbf">IDE_PARTITION_NEW</SPAN>

<P>
Create partition

<P>
$00BB <SPAN  CLASS="textbf">IDE_PARTITION_INIT</SPAN>

<P>
Initialise partition

<P>
$00BE <SPAN  CLASS="textbf">IDE_PARTITION_ERASE</SPAN>

<P>
Delete a partition

<P>
$00C1 <SPAN  CLASS="textbf">IDE_PARTITION_RENAME</SPAN>

<P>
Rename a partition

<P>
$00C4 <SPAN  CLASS="textbf">IDE_PARTITON_READ</SPAN>

<P>
Read a partition entry

<P>
$00C7 <SPAN  CLASS="textbf">IDE_PARTITION_WRITE</SPAN>

<P>
Write a partition entry

<P>
$00CA <SPAN  CLASS="textbf">IDE_PARTITION_WINFO</SPAN>

<P>
Write type-specific partition information

<P>
$00CD <SPAN  CLASS="textbf">IDE_PARTITION_OPEN</SPAN>

<P>
Open a partition

<P>
$00D0 <SPAN  CLASS="textbf">IDE_PARTITION_CLOSE</SPAN>

<P>
Close a partition

<P>
$00D3 <SPAN  CLASS="textbf">IDE_PARTITION_GETINFO</SPAN>

<P>
Get byte from type-specific partition information

<P>
$00D6 <SPAN  CLASS="textbf">IDE_PARTITION_SETINFO</SPAN>

<P>
Set byte in type-specific partition information

<P>
<A NAME="4185"></A>
$00D9 (217) <SPAN  CLASS="textbf">IDE_SWAP_OPEN</SPAN>

<P>
Open a swap partition (file)

<P>
A swap file will be opened on success. The file must be unfragmented
or the call will return with error $4a (rc_fragmented). Further swap
related calls will use units related to the selected block size.

<P>
Entry:
<table width="90%"><tr><td valign="top">&nbsp;A bits 0-6 = block size, 1-32 512-byte sectors
  <table width="90%">  <tr><td valign="top">&nbsp;A bit 7 = 0, open available system swap file
    (c:/nextzxos/swp-N.p3d) that is large enough.
  </td></tr>
<tr><td valign="top">&nbsp;BC=max block size required
  </td></tr></table>

  <table width="90%">  <tr><td valign="top">&nbsp;A bit 7 = 1, open indicated swap file
    (c:/nextzxos/swp-N.p3d) that is large enough.
  </td></tr>
<tr><td valign="top">&nbsp;BC=$ff terminated pointer to swap file name
  </td></tr></table>
</td></tr></table>

Exit: IX=swap handle

<P>
$00DC <SPAN  CLASS="textbf">IDE_SWAP_CLOSE</SPAN>

<P>
Close a swap partition

<P>
$00DF <SPAN  CLASS="textbf">IDE_SWAP_OUT</SPAN>

<P>
Write block to swap partition

<P>
$00E2 <SPAN  CLASS="textbf">IDE_SWAP_IN</SPAN>

<P>
Read block from swap partition

<P>
<A NAME="4196"></A>
$00E5 (231) <SPAN  CLASS="textbf">IDE_SWAP_EX</SPAN>

<P>
Exchange block with swap partition

<P>
Deprecated, use IDE_SWAP_IN and IDE_SWAP_OUT

<P>
$00E8 <SPAN  CLASS="textbf">IDE_SWAP_POS</SPAN>

<P>
Get current block number in swap partition

<P>
$00EB <SPAN  CLASS="textbf">IDE_SWAP_MOVE</SPAN>

<P>
Set current block number in swap partition

<P>
$00EE <SPAN  CLASS="textbf">IDE_SWAP_RESIZE</SPAN>

<P>
Change block size of swap partition

<P>
<A NAME="4201"></A>
$00F1 (241) <SPAN  CLASS="textbf">IDE_DOS_MAP</SPAN>

<P>
Map drive to partition or physical device

<P>
Entry:
<table width="90%"><tr><td valign="top">&nbsp;A = Unit 0-15 (4=RAMdisk)</td></tr>
<tr><td valign="top">&nbsp;BC=partition number (A != 4)</td></tr>
<tr><td valign="top">&nbsp;A = $ff for filesystem image</td></tr>
<tr><td valign="top">&nbsp;BC=$ff terminated image filename</td></tr>
<tr><td valign="top">&nbsp;L=drive letter A-P
</td></tr></table>

Exit: IX is preserved

<P>
<A NAME="4205"></A>
$00F4 (244) <SPAN  CLASS="textbf">IDE_DOS_UNMAP</SPAN>

<P>
Unmap drive

<P>
Remove mapping from the specified drive

<P>
Entry: L=drive letter A-P
<BR>
Exit: IX is preserved

<P>
<A NAME="4207"></A>
$00F7 (247) <SPAN  CLASS="textbf">IDE_DOS_MAPPING</SPAN>

<P>
Get drive mapping

<P>
Entry:
<table width="90%"><tr><td valign="top">&nbsp;L=drive letter A-P</td></tr>
<tr><td valign="top">&nbsp;BC=pointer to 18-byte buffer
</td></tr></table>

Exit:
<table width="90%"><tr><td valign="top">&nbsp;Zero set: drive not mapped</td></tr>
<tr><td valign="top">&nbsp;Zero clear:
  <table width="90%">  <tr><td valign="top">&nbsp;A=Unit 0-15, 4=RAMdisk, $ff=filesystem image
  </td></tr>
<tr><td valign="top">&nbsp;BC=partition number
  </td></tr>
<tr><td valign="top">&nbsp;buffer contains description or nothing
  </td></tr></table>
</td></tr>
<tr><td valign="top">&nbsp;IX is preserved
</td></tr></table>

<P>
$00FA <SPAN  CLASS="textbf">IDE_DOS_UNPERMANENT</SPAN>

<P>
Remove permanent drive mapping

<P>
<A NAME="4216"></A>
$00FD (253) <SPAN  CLASS="textbf">IDE_SNAPLOAD</SPAN>

<P>
Load a snapshot

<P>
Loads a supported snapshot (currently .Z80, .SNA, .O, or .P). Call
must be made in layer 0 mode. For .O and .P SP bust be &lt;$8000.

<P>
Entry: HL=$ff terminated filespec
Exit: Does not return on success.

<P>
$0100 <SPAN  CLASS="textbf">DOS_INITIALISE</SPAN>

<P>
Initialise +3DOS

<P>
$0103 <SPAN  CLASS="textbf">DOS_VERSION</SPAN>

<P>
Get +3DOS issue and version numbers

<P>
<A NAME="4220"></A>
$0106 (262) <SPAN  CLASS="textbf">DOS_OPEN</SPAN>

<P>
Create and/or open a file

<P>
Opeens the file corresponding to the filename pointed to by HL.

<P>
Entry:
<table width="90%"><tr><td valign="top">&nbsp;B = File number 0-15</td></tr>
<tr><td valign="top">&nbsp;C = Access mode required
  <table width="90%">  <tr><td valign="top">&nbsp;1 = exclusive-read
  </td></tr>
<tr><td valign="top">&nbsp;2 = exclusive-write
  </td></tr>
<tr><td valign="top">&nbsp;3 = exclusive-read/write
  </td></tr>
<tr><td valign="top">&nbsp;5 = shared-read
  </td></tr></table>
</td></tr>
<tr><td valign="top">&nbsp;D = Create action
  <table width="90%">  <tr><td valign="top">&nbsp;0 - Error if file does not exist  
  </td></tr>
<tr><td valign="top">&nbsp;1 - Create and open new file with header
  </td></tr>
<tr><td valign="top">&nbsp;2 - Create and open new file without header
  </td></tr></table>
</td></tr>
<tr><td valign="top">&nbsp;E = Open action
  <table width="90%">  <tr><td valign="top">&nbsp;0 - Error if file already exist  s
  </td></tr>
<tr><td valign="top">&nbsp;1 - Open file and read header
  </td></tr>
<tr><td valign="top">&nbsp;2 - Open file and ignore header
  </td></tr>
<tr><td valign="top">&nbsp;3 - Erase filename.BAK, rename file to filename.BAK, follow
    create action
  </td></tr>
<tr><td valign="top">&nbsp;4 - Erase existing file, follow create action
  </td></tr></table>
</td></tr>
<tr><td valign="top">&nbsp;HL = Address of filename (no wildcards, unless D=0 and E=1 or 2)
</td></tr></table>

Exit:
<table width="90%"><tr><td valign="top">&nbsp;New file: Zero set</td></tr>
<tr><td valign="top">&nbsp;Existing file: Zero clear
</td></tr></table>

<P>
$0109 <SPAN  CLASS="textbf">DOS_CLOSE</SPAN>

<P>
Close a file

<P>
$010C <SPAN  CLASS="textbf">DOS_ABANDON</SPAN>

<P>
Abandon a file

<P>
$010F <SPAN  CLASS="textbf">DOS_REF_HEAD</SPAN>

<P>
Point at the header data for this file

<P>
$0112 <SPAN  CLASS="textbf">DOS_READ</SPAN>

<P>
Read bytes into memory

<P>
$0115 <SPAN  CLASS="textbf">DOS_WRITE</SPAN>

<P>
Write bytes from memory

<P>
$0118 <SPAN  CLASS="textbf">DOS_BYTE_READ</SPAN>

<P>
Read a byte

<P>
$011B <SPAN  CLASS="textbf">DOS_BYTE_WRITE</SPAN>

<P>
Write a byte

<P>
<A NAME="4239"></A>
$011E (286) <SPAN  CLASS="textbf">DOS_CATALOG</SPAN>

<P>
Catalog disk directory

<P>
Fills a buffer with part of the directory indicated by the path
pointed to by HL. If the buffer is filled with zeros, the call places
the first n entries from the directory into the buffer. If it begins
with a directory entry, it fills the buffer starting with that
directory entry. Directory entries are 13 bytes long and consist of an
8-byte filename, a 3-byte type (extension), and a 2-byte size. Shorter
filenames and types are padded with spaces. The most significant bit
of the filename and type may be set to indicicate extra information
about the file.

<P>
Entry:
<table width="90%"><tr><td valign="top">&nbsp;B = size of buffer in entries</td></tr>
<tr><td valign="top">&nbsp;C = Filter
  <table width="90%">  <tr><td valign="top">&nbsp;bit 0: Include system files
  </td></tr>
<tr><td valign="top">&nbsp;bit 1: Set bit 7 of f7 if entry has a valid long file name
  </td></tr>
<tr><td valign="top">&nbsp;bit 2: Include directories, set bit 7 of f8 for directories
  </td></tr>
<tr><td valign="top">&nbsp;bits 3-7: reserved (0) 
  </td></tr></table>
</td></tr>
<tr><td valign="top">&nbsp;DE = Address of buffer</td></tr>
<tr><td valign="top">&nbsp;HL = Address of directory name (wildcards permitted)
</td></tr></table>

Exit:
<table width="90%"><tr><td valign="top">&nbsp;B = number of completed entries, if the size that is passed,
  there may be more entries</td></tr>
<tr><td valign="top">&nbsp;HL = Directory handle for long filenames, used by
  IDE_GET_LFN
</td></tr></table>

<P>
<A NAME="4247"></A>
$0121 (289) <SPAN  CLASS="textbf">DOS_FREE_SPACE</SPAN>

<P>
Free space on disk

<P>
How much free space is on this disk?

<P>
Entry: A = Drive, ASCII A-P
<BR>
Exit:
<table width="90%"><tr><td valign="top">&nbsp;HL = Free space in kB up to 65535k</td></tr>
<tr><td valign="top">&nbsp;BCDE = Free space in kB
</td></tr></table>

<P>
$0124 <SPAN  CLASS="textbf">DOS_DELETE</SPAN>

<P>
Delete a file

<P>
$0127 <SPAN  CLASS="textbf">DOS_RENAME</SPAN>

<P>
Rename a file

<P>
$012A <SPAN  CLASS="textbf">DOS_BOOT</SPAN>

<P>
Boot an operating system or other program

<P>
$012D <SPAN  CLASS="textbf">DOS_SET_DRIVE</SPAN>

<P>
Set/get default drive

<P>
$0130 <SPAN  CLASS="textbf">DOS_SET_USER</SPAN>

<P>
Set/get default user number

<P>
<A NAME="4256"></A>
$0133 (307) <SPAN  CLASS="textbf">DOS_GET_POSITION</SPAN>

<P>
Get file pointer for random access

<P>
Entry: B = File number
<BR>
Exit: DEHL = File Pointer

<P>
$0136 <SPAN  CLASS="textbf">DOS_SET_POSITION</SPAN>

<P>
Set file pointer for random access

<P>
<A NAME="4259"></A>
$0139 (313) <SPAN  CLASS="textbf">DOS_GET_EOF</SPAN>

<P>
Get end of file position for random access

<P>
Gets the first position after the last byte written without
considering soft-EOF. This does not accect the file pointer.

<P>
Entry: B = File number
<BR>
Exit: DEHL = EOF position

<P>
$013C <SPAN  CLASS="textbf">DOS_GET_1346</SPAN>

<P>
Get memory usage in pages 1&nbsp; 3&nbsp; 4&nbsp; 6

<P>
$013F <SPAN  CLASS="textbf">DOS_SET_1346</SPAN>

<P>
Re-allocate memory usage in pages 1&nbsp; 3&nbsp; 4&nbsp; 6

<P>
$0142 <SPAN  CLASS="textbf">DOS_FLUSH</SPAN>

<P>
Bring disk up to date

<P>
$0145 <SPAN  CLASS="textbf">DOS_SET_ACCESS</SPAN>

<P>
Change open file's access mode

<P>
$0148 <SPAN  CLASS="textbf">DOS_SET_ATTRIBUTES</SPAN>

<P>
Change a file's attributes

<P>
$014B <SPAN  CLASS="textbf">DOS_OPEN_DRIVE</SPAN>

<P>
Open a drive as a single file

<P>
$014E <SPAN  CLASS="textbf">DOS_SET_MESSAGE</SPAN>

<P>
Enable/disable error messages

<P>
$0151 <SPAN  CLASS="textbf">DOS_REF_XDPB</SPAN>

<P>
Point at XDPB for low level disk access

<P>
$0154 <SPAN  CLASS="textbf">DOS_MAP_B</SPAN>

<P>
Map B: onto unit 0 or 1

<P>
$0157 <SPAN  CLASS="textbf">DD_INTERFACE</SPAN>

<P>
Is the floppy disk driver interface present?

<P>
$015A <SPAN  CLASS="textbf">DD_INIT</SPAN>

<P>
Initialise disk driver

<P>
$015D <SPAN  CLASS="textbf">DD_SETUP</SPAN>

<P>
Specify drive parameters

<P>
$0160 <SPAN  CLASS="textbf">DD_SET_RETRY</SPAN>

<P>
Set try/retry count

<P>
$0163 <SPAN  CLASS="textbf">DD_READ_SECTOR</SPAN>

<P>
Read a sector

<P>
$0166 <SPAN  CLASS="textbf">DD_WRITE_SECTOR</SPAN>

<P>
Write a sector

<P>
$0169 <SPAN  CLASS="textbf">DD_CHECK_SECTOR</SPAN>

<P>
Check a sector

<P>
$016C <SPAN  CLASS="textbf">DD_FORMAT</SPAN>

<P>
Format a track

<P>
$016F <SPAN  CLASS="textbf">DD_READ_ID</SPAN>

<P>
Read a sector identifier

<P>
$0172 <SPAN  CLASS="textbf">DD_TEST_UNSUITABLE</SPAN>

<P>
Test media suitability

<P>
$0175 <SPAN  CLASS="textbf">DD_LOGIN</SPAN>

<P>
Log in disk, initialise XDPB

<P>
$0178 <SPAN  CLASS="textbf">DD_SEL_FORMAT</SPAN>

<P>
Pre-initialise XDPB for DD FORMAT

<P>
$017B <SPAN  CLASS="textbf">DD_ASK_1</SPAN>

<P>
Is unit 1 (external drive) present?

<P>
$017E <SPAN  CLASS="textbf">DD_DRIVE_STATUS</SPAN>

<P>
Fetch drive status

<P>
$0181 <SPAN  CLASS="textbf">DD_EQUIPMENT</SPAN>

<P>
What type of drive?

<P>
$0184 <SPAN  CLASS="textbf">DD_ENCODE</SPAN>

<P>
Set intercept routine for copy protection

<P>
$0187 <SPAN  CLASS="textbf">DD_L_XDPB</SPAN>

<P>
Initialise an XDPB from a disk specification

<P>
$018A <SPAN  CLASS="textbf">DD_L_DPB</SPAN>

<P>
Initialise a DPB from a disk specification

<P>
$018D <SPAN  CLASS="textbf">DD_L_SEEK</SPAN>

<P>
uPD765A seek driver

<P>
$0190 <SPAN  CLASS="textbf">DD_L_READ</SPAN>

<P>
uPD765A read driver

<P>
$0193 <SPAN  CLASS="textbf">DD_L_WRITE</SPAN>

<P>
uPD765A write driver

<P>
$0196 <SPAN  CLASS="textbf">DD_L_ON_MOTOR</SPAN>

<P>
Motor on, wait for motor-on time

<P>
$0199 <SPAN  CLASS="textbf">DD_L_T_OFF_MOTOR</SPAN>

<P>
Start the motor-off ticker

<P>
$019C <SPAN  CLASS="textbf">DD_L_OFF_MOTOR</SPAN>

<P>
Turn the motor off

<P>
$01a2 <SPAN  CLASS="textbf">IDE_IDENTIFY</SPAN>

<P>
Return IDE drive identity information

<P>
$01a5 <SPAN  CLASS="textbf">IDE_PARTITIONS</SPAN>

<P>
Get number of open partitions

<P>
<A NAME="4296"></A>
$01b1 (433) <SPAN  CLASS="textbf">IDE_PATH</SPAN>

<P>
Create, delete, change or get directory

<P>
Read or manipulate the IDE path (directory), does not affect what the
current default drive is.
<BR>
rc_path_change: change directory
<BR>
rc_path_get: get current directory
<BR>
rc_path_make: create a new directory
<BR>
rc_path_delete: remove a directory

<P>
Entry:
<table width="90%"><tr><td valign="top">&nbsp;A=reason code
  <table width="90%">  <tr><td valign="top">&nbsp;0=rc_path_change
  </td></tr>
<tr><td valign="top">&nbsp;1=rc_path_get
  </td></tr>
<tr><td valign="top">&nbsp;2=rc_path_make
  </td></tr>
<tr><td valign="top">&nbsp;3=rc_path_delete
  </td></tr></table>

  </td></tr>
<tr><td valign="top">&nbsp;HL=pointer to $ff terminated filespec or buffer for
    returned filespec data (256 bytes)
</td></tr></table>

Exit: IY is affected

<P>
<A NAME="4302"></A>
$01b4 (436) <SPAN  CLASS="textbf">IDE_CAPACITY</SPAN>

<P>
Get card capacity

<P>
Entry: C=unit (0 or 1)
<BR>
Exit: DEHL=total card capacity in 512-byte sectors

<P>
<A NAME="4304"></A>
$01b7 (439) <SPAN  CLASS="textbf">IDE_GET_LFN</SPAN>

<P>
Get long filename

<P>
Obtain a long file name and other file information.

<P>
Entry:
<table width="90%"><tr><td valign="top">&nbsp;HL=address of filespec provided by last DOS_CATALOG call</td></tr>
<tr><td valign="top">&nbsp;IX=directory handle provided by last DOS_CATALOG call</td></tr>
<tr><td valign="top">&nbsp;DE=address of a file entry filled by the last DOS_CATALOG call</td></tr>
<tr><td valign="top">&nbsp;BC=address of a 261-byte buffer to receive the long filename
</td></tr></table>

Exit:
<table width="90%"><tr><td valign="top">&nbsp;buffer contains file name</td></tr>
<tr><td valign="top">&nbsp;BC=date (MS-DOS format)</td></tr>
<tr><td valign="top">&nbsp;DE=time (MS-DOS format)</td></tr>
<tr><td valign="top">&nbsp;HLIX=filesize, bytes (for directories 0)
</td></tr></table>

<P>
<A NAME="4310"></A>
$01ba (442) <SPAN  CLASS="textbf">IDE_BROWSER</SPAN>

<P>
File browser

<P>
Run the file browser. The filetypes buffer pointed to by HL is a $ff
terminated buffer of filetypes. Each filetype consists of a length
followed by a type description. Types are the file extension, wild
cards ? and * are permitted, a colon (:) and an optional command to
execute on the filetype with vertical bar representing the filemane in
the command. The help text may contain window control codes, but if
the character size is changed, it must be returned to size 5 at the
end of the string.

<P>
Entry:
<table width="90%"><tr><td valign="top">&nbsp;IY=$5c3a (ERR_NR)</td></tr>
<tr><td valign="top">&nbsp;HL=address of supported filetypes buffer</td></tr>
<tr><td valign="top">&nbsp;DE=address of $ff terminated help text</td></tr>
<tr><td valign="top">&nbsp;A=browser capability mask
  <table width="90%">  <tr><td valign="top">&nbsp;bit 0: BROSWERCAPS_COPY - files may be copied
  </td></tr>
<tr><td valign="top">&nbsp;bit 1: BROSWERCAPS_RENAME - files/dirs may be renamed
  </td></tr>
<tr><td valign="top">&nbsp;bit 2: BROSWERCAPS_MKDIR - directories may be created
  </td></tr>
<tr><td valign="top">&nbsp;bit 3: BROSWERCAPS_ERASE - files/dirs may be deleted
  </td></tr>
<tr><td valign="top">&nbsp;bit 4: BROSWERCAPS_REMOUNT - SD card may be remounted
  </td></tr>
<tr><td valign="top">&nbsp;bit 5: BROSWERCAPS_UNMOUNT - drives may be unmounted
  </td></tr>
<tr><td valign="top">&nbsp;bit 6: reserved (0)
  </td></tr>
<tr><td valign="top">&nbsp;bit 7: BROSWERCAPS_SYSCFG - system use - use browser.cfg
  </td></tr></table>
</td></tr></table>

Exit:
<table width="90%"><tr><td valign="top">&nbsp;Zero flag set: file selected (ENTER pressed)
  <table width="90%">  <tr><td valign="top">&nbsp;HL=address of short $ff terminated filename in RAM 7
  </td></tr>
<tr><td valign="top">&nbsp;DE=address of long $ff teminated filename in RAM 7
  </td></tr></table>
</td></tr>
<tr><td valign="top">&nbsp;Zero flag clear: no file selected (SPACE/BREAK pressed)
</td></tr></table>

<P>
<A NAME="4320"></A>
$01bd (445) <SPAN  CLASS="textbf">IDE_BANK</SPAN>

<P>
Allocate or free 8K pages in ZX or DivMMC memory

<P>
$01c0 <SPAN  CLASS="textbf">IDE_BASIC</SPAN>

<P>
Execute a BASIC command line

<P>
$01c3 <SPAN  CLASS="textbf">IDE_WINDOW_LINEIN</SPAN>

<P>
Input line from current window stream

<P>
$01c6 <SPAN  CLASS="textbf">IDE_WINDOW_STRING</SPAN>

<P>
Output string to current window stream

<P>
$01c9 <SPAN  CLASS="textbf">IDE_INTEGER_VAR</SPAN>

<P>
Get or set NextBASIC integer variable

<P>
$01cc <SPAN  CLASS="textbf">IDE_RTC</SPAN>

<P>
Query the real-time-clock module

<P>
$01cf <SPAN  CLASS="textbf">IDE_DRIVER</SPAN>

<P>
Access the driver API

<P>
$01d2 <SPAN  CLASS="textbf">IDE_MOUNT</SPAN>

<P>
Unmount/remount SD cards

<P>
$01d2 <SPAN  CLASS="textbf">IDE_MOUNT</SPAN>

<P>
Unmount/remount SD cards

<P>
$01d5 <SPAN  CLASS="textbf">IDE_MODE</SPAN>

<P>
Query NextBASIC display mode info, or change mode

<P>
$01d8 <SPAN  CLASS="textbf">IDE_TOKENISER</SPAN>

<P>
Convert BASIC between plain text &amp; tokenised forms

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A
 HREF="node121.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node119.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node119.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html949"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A> 
<A ID="tex2html951"
  HREF="node156.html">
<IMG WIDTH="43" HEIGHT="24" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A
 HREF="node121.html">esxDOS compatible API</A>
<B> Up:</B> <A
 HREF="node119.html">NextZXOS</A>
<B> Previous:</B> <A
 HREF="node119.html">NextZXOS</A>
 &nbsp; <B>  <A ID="tex2html950"
  HREF="node1.html">Contents</A></B> 
 &nbsp; <B>  <A ID="tex2html952"
  HREF="node156.html">Index</A></B> </DIV>
<!--End of Navigation Panel-->

</BODY>
</HTML>
