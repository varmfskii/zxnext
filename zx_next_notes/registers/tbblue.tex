\section{ZX SPECTRUM NEXT I/O PORT SYSTEM AND REGISTERS}
February 25, 2019  Phoebus Dokos

TBBlue stores configuration state in a field of registers. These
registers are accessible via two io ports or via the special nextreg
instructions.

Port 0x243B (9275) is used to set the register number, listed below.

Port 0x253B (9531) is used to access the register value.

Some registers are accessible only during the initialization process.

Registers:

2.00.27

\begin{verbatim}
(R) 0x00 (00) => Machine ID
00000001 = DE1A
00000010 = DE2A
00000101 = FBLABS
00000110 = VTRUCCO
00000111 = WXEDA
00001000 = EMULATORS *
00001010 = ZX Spectrum Next *
00001011 = Multicore
11111010 = ZX Spectrum Next Anti-brick *
* = Relevant for ZX Next machines & software

(R) 0x01 (01) => Core Version
bits 7-4 = Major version number
bits 3-0 = Minor version number
(see register 0x0E for sub minor version number)

(R/W) 0x02 (02) => Reset:
bits 7-3 = Reserved, must be 0
bit 2 = (R) Power-on reset (PoR)
bit 1 = (R/W) Reading 1 indicates a Hard-reset.
If written 1 causes a Hard Reset.
bit 0 = (R/W) Reading 1 indicates a Soft-reset.
If written 1 causes a Soft Reset.

(R/W) 0x03 (03) => Set machine type
A write to this register disables the IPL in config mode
(0x0000-0x3FFF is mapped to RAM instead of the internal ROM)
bit 7 = (W) lock timing
= (R) register 0x44 second byte indicator
bits 6-4 = Timing:
(always writable if bit 7 is set)
000 or 001 = ZX 48K
010 = ZX 128K/+2 (Grey)
011 = ZX +2A-B/+3e/Next Native
100 = Pentagon 128K
bit 3 = Reserved, must be 0
bits 2-0 = Machine type (writable in config mode only):
000 = Config mode
001 = ZX 48K
010 = ZX 128K/+2 (Grey)
011 = ZX +2A-B/+3e/Next Native
100 = Pentagon 128K

(W) 0x04 (04) => Set page RAM, only in config mode (no IPL):
bits 7-5 = Reserved, must be 0
bits 4-0 = RAM bank mapped to 0x0000-0x3FFF
(64 x 16k pages = 1024K, 0 after a PoR or Hard-reset)

(R/W) 0x05 (05) => Peripheral 1 setting:
bits 7-6 = joystick 1 mode (LSB)
bits 5-4 = joystick 2 mode (LSB)
bit 3 = joystick 1 mode (MSB)
bit 2 = 50/60 Hz mode (0 = 50Hz, 1 = 60Hz)(0 after a PoR or Hard-reset)
bit 1 = joystick 2 mode (MSB)
bit 0 = Enable Scandoubler (1 = enabled)(1 after a PoR or Hard-reset)
Joystick modes:
000 = Sinclair 2 (67890)
001 = Kempston 1 (port 0x1F)
010 = Cursor (56780)
011 = Sinclair 1 (12345)
100 = Kempston 2 (port 0x37)
101 = MD 1 (3 or 6 button joystick port 0x1F)
110 = MD 2 (3 or 6 button joystick port 0x37)

(R/W) 0x06 (06) => Peripheral 2 setting:
bit 7 = Enable turbo mode (0 = disabled, 1 = enabled)
(0 after a PoR or Hard-reset)
bit 6 = DMA mode (0 = zxn dma, 1 = z80 dma)
(Only ZX Next board, 0 after a PoR or Hard-reset)
bit 5 = Enable Lightpen (1 = enabled)(0 after a PoR or Hard-reset)
bit 4 = DivMMC automatic paging (1 = enabled)(0 after a PoR or Hard-reset)
bit 3 = Enable Multiface (1 = enabled)(0 after a PoR or Hard-reset)
bit 2 = PS/2 mode (0 = keyboard, 1 = mouse)
(exchanges the keyboard/mouse pins on the PS/2 connector)
(0 after a PoR or Hard-reset)
bits 1-0 = Audio chip mode (00 = YM, 01 = AY, 1X = Disabled)

(R/W) 0x07 (07) => Turbo mode:
bit 1-0 = Turbo (00 = 3.5MHz, 01 = 7MHz, 10 = 14MHz)
(00 after a PoR or Hard-reset)

(R/W) 0x08 (08) => Peripheral 3 setting:
bit 7 = 128K paging enable (inverse of port 0x7ffd, bit 5)
Use "1" to disable the locked paging.
bit 6 = "1" to disable RAM contention. (0 after a reset)
bit 5 = Stereo mode (0 = ABC, 1 = ACB)(0 after a PoR or Hard-reset)
bit 4 = Enable internal speaker (1 = enabled)(1 after a PoR or Hard-reset)
bit 3 = Enable Specdrum/Covox (1 = enabled)(0 after a PoR or Hard-reset)
bit 2 = Enable Timex modes (1 = enabled)(0 after a PoR or Hard-reset)
bit 1 = Enable TurboSound (1 = enabled)(0 after a PoR or Hard-reset)
bit 0 = Reserved, must be 0

(R/W) 0x09 (09) => Peripheral 4 setting:
bit 7 = Mono setting for AY 2 (1 = mono, 0 default)
bit 6 = Mono setting for AY 1 (1 = mono, 0 default)
bit 5 = Mono setting for AY 0 (1 = mono, 0 default)
bit 4 = Sprite id lockstep (1 = Nextreg 0x34 and IO Port 0x303B are in lockstep, 0 default)
bit 3 = Disables Kempston port ($DF) if set
bit 2 = Disables divMMC ports ($E3, $E7, $EB) if set
bits 1-0 = scanlines (0 after a PoR or Hard-reset)
00 = scanlines off
01 = scanlines 75%
10 = scanlines 50%
11 = scanlines 25%

(R) 0x0E (14) => Core Version (sub minor number)
(see register 0x01 for the major and minor version number)

(R) 0x10 (16) => Anti-brick system
bits 7-2 = Reserved, must be 0
bit 1 = Button DivMMC (1 = pressed)
bit 0 = Button Multiface (1 = pressed)

(W) 0x10 (16) => Core Boot
bit 7 = Start selected core (1 = start)
bits 6-5 = Reserved, must be 0
bits 4-0 = Core ID 0-31 (writable in config mode only, default is 2)

(R/W) 0x11 (17) => Video Timing (writable in config mode only)
bits 7-3 = Reserved, must be 0
bits 2-0 = Mode (VGA = 0..6, HDMI = 7)
000 = Base VGA timing, clk28 = 28000000
001 = VGA setting 1, clk28 = 28571429
010 = VGA setting 2, clk28 = 29464286
011 = VGA setting 3, clk28 = 30000000
100 = VGA setting 4, clk28 = 31000000
101 = VGA setting 5, clk28 = 32000000
110 = VGA setting 6, clk28 = 33000000
111 = HDMI, clk28 = 27000000
50/60Hz selection depends on bit 2 of register 0x05

(R/W) 0x12 (18) => Layer 2 RAM bank
bits 7-6 = Reserved, must be 0
bits 5-0 = RAM bank (point to bank 8 after a Reset, NextZXOS modifies to 9)

(R/W) 0x13 (19) => Layer 2 RAM shadow bank
bits 7-6 = Reserved, must be 0
bits 5-0 = RAM bank (point to bank 11 after a Reset, NextZXOS modifies to 12)

(R/W) 0x14 (20) => Global transparency color
bits 7-0 = Transparency color value (0xE3 after a reset)
(Note: this value is 8-bit, so the transparency is compared
against only by the MSB bits of the final 9-bit colour)
(Note2: this only affects Layer 2, ULA and LoRes. Sprites use
register 0x4B for transparency and tilemap uses nextreg 0x4C)

(R/W) 0x15 (21) => Sprite and Layers system
bit 7 = LoRes mode, 128 x 96 x 256 colours (1 = enabled)
bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on top)
bit 5 = Enable sprite clipping in over border mode (1 = enabled)
bits 4-2 = set layers priorities:
Reset default is 000, sprites over the Layer 2, over the ULA graphics
000 - S L U
001 - L S U
010 - S U L
011 - L U S
100 - U S L
101 - U L S
110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7
111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]
bit 1 = Over border (1 = yes)(Back to 0 after a reset)
bit 0 = Sprites visible (1 = visible)(Back to 0 after a reset)

(R/W) 0x16 (22) => Layer2 Offset X
bits 7-0 = X Offset (0-255)(0 after a reset)

(R/W) 0x17 (23) => Layer2 Offset Y
bits 7-0 = Y Offset (0-191)(0 after a reset)

(R/W) 0x18 (24) => Clip Window Layer 2
bits 7-0 = Coords of the clip window
1st write - X1 position
2nd write - X2 position
3rd write - Y1 position
4rd write - Y2 position
Reads do not advance the clip position
The values are 0,255,0,191 after a Reset

(R/W) 0x19 (25) => Clip Window Sprites
bits 7-0 = Cood. of the clip window
1st write - X1 position
2nd write - X2 position
3rd write - Y1 position
4rd write - Y2 position
The values are 0,255,0,191 after a Reset
Reads do not advance the clip position
When the clip window is enabled for sprites in "over border" mode,
the X coords are internally doubled and the clip window origin is
moved to the sprite origin inside the border.

(R/W) 0x1A (26) => Clip Window ULA/LoRes
bits 7-0 = Coord. of the clip window
1st write = X1 position
2nd write = X2 position
3rd write = Y1 position
4rd write = Y2 position
The values are 0,255,0,191 after a Reset
Reads do not advance the clip position

(R/W) 0x1B (27) => Clip Window Tilemap
bits 7-0 = Coord. of the clip window
1st write = X1 position
2nd write = X2 position
3rd write = Y1 position
4rd write = Y2 position
The values are 0,159,0,255 after a Reset
Reads do not advance the clip position
The X coords are internally doubled.

(W) 0x1C (28) => Clip Window control
bits 7-4 = Reserved, must be 0
bit 3 - reset the tilemap clip index
bit 2 - reset the ULA/LoRes clip index.
bit 1 - reset the sprite clip index.
bit 0 - reset the Layer 2 clip index.

(R) 0x1C (28) => Clip Window control
(may change)
bits 7-6 = Tilemap clip index
bits 5-4 = Layer 2 clip index
bits 3-2 = Sprite clip index
bits 1-0 = ULA clip index

(R) 0x1E (30) => Active video line (MSB)
bits 7-1 = Reserved, always 0
bit 0 = Active line MSB (Reset to 0 after a reset)

(R) 0x1F (31) = Active video line (LSB)
bits 7-0 = Active line LSB (0-255)(Reset to 0 after a reset)

(R/W) 0x22 (34) => Line Interrupt control
bit 7 = (R) INT flag, 1=During INT
(even if the processor has interrupt disabled)
bits 6-3 = Reserved, must be 0
bit 2 = If 1 disables original ULA interrupt (Reset to 0 after a reset)
bit 1 = If 1 enables Line Interrupt (Reset to 0 after a reset)
bit 0 = MSB of Line Interrupt line value (Reset to 0 after a reset)

(R/W) 0x23 (35) => Line Interrupt value LSB
bits 7-0 = Line Interrupt line value LSB (0-255)(Reset to 0 after a reset)

(W) 0x28 (40) => High address of Keymap
bits 7-1 = Reserved, must be 0
bit 0 = MSB address

(W) 0x29 (41) => Low address of Keymap
bits 7-0 = LSB adress

(W) 0x2A (42) => High data to Keymap
bits 7-1 = Reserved, must be 0
bit 0 = MSB data

(W) 0x2B (43) => Low data to Keymap
(writing this register the address is auto-incremented)
bits 7-0 = LSB data

(W) 0x2D (45) => SpecDrum port 0xDF / DAC A+C mirror
bits 7-0 = Data to be written to mono DAC
(this port can be used to generate mono audio using the copper)

(R/W) 0x2F (47) => Tilemap Offset X MSB
bits 7-2 = Reserved, must be 0
bits 1-0 = MSB X Offset
Meaningful Range is 0-319 in 40 char mode, 0-639 in 80 char mode

(R/W) 0x30 (48) => Tilemap Offset X LSB
bits 7-0 = LSB X Offset
Meaningful range is 0-319 in 40 char mode, 0-639 in 80 char mode

(R/W) 0x31 (49) => Tilemap Offset Y
bits 7-0 = Y Offset (0-255)

(R/W) 0x32 (50) => ULA / LoRes Offset X
bits 7-0 = X Offset (0-255)(Reset to 0 after a reset)
ULA can only scroll in multiples of 8 pixels so the lowest 3 bits have no effect at this time.
LoRes scrolls in "half-pixels" at the same resolution and smoothness as Layer 2.

(R/W) 0x33 (51) => ULA / LoRes Offset Y
bits 7-0 = Y Offset (0-191)(Reset to 0 after a reset)
LoRes scrolls in "half-pixels" at the same resolution and smoothness as Layer 2.

(R/W) 0x34 (52) => Sprite Number
If the sprite number is in lockstep with io port 0x303B (nextreg 0x09 bit 4 is set)
bits 7 = Pattern address offset (Add 128 to pattern address)
bits 6-0 = Sprite number 0-127, Pattern number 0-63
Selects which sprite has its attributes connected to the following registers.
Effectively performs an out to port 0x303B with the same value
Otherwise
bit 7 = Ignored
bits 6-0 = Sprite number 0-127
Selects which sprite has its attributes connected to the following registers.
Bit 7 always reads back as zero.

(W) 0x35 (53) => Sprite Attribute 0
(W) 0x75 (117) => Sprite Attribute 0 with automatic post increment of Sprite Number
bits 7-0 = LSB of X coordinate

(W) 0x36 (54) => Sprite Attribute 1
(W) 0x76 (118) => Sprite Attribute 1 with automatic post increment of Sprite Number
bits 7-0 = LSB of Y coordinate

(W) 0x37 (55) => Sprite Attribute 2
(W) 0x77 (119) => Sprite Attribute 2 with automatic post increment of Sprite Number
bits 7-4 = Palette offset added to top 4 bits of sprite colour index
bit 3 = X mirror
bit 2 = Y mirror
bit 1 = Rotate
bit 0 = MSB of X coordinate (palette offset indicator for relative sprites)

(W) 0x38 (56) => Sprite Attribute 3
(W) 0x78 (120) => Sprite Attribute 3 with automatic post increment of Sprite Number
bit 7 = Visible flag (1 = displayed)
bit 6 = Extended attribute (1 = Sprite Attribute 4 is active)
bits 5-0 = Pattern used by sprite (0-63)

(W) 0x39 (57) => Sprite Attribute 4
(W) 0x79 (121) => Sprite Attribute 4 with automatic post increment of Sprite Number
4-bit Sprites
bit 7 = H (1 = sprite uses 4-bit patterns)
bit 6 = N6 (0 = use the first 128 bytes of the pattern else use the last 128 bytes)
bit 5 = 1 if relative sprites are composite, 0 if relative sprites are unified
Scaling
bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
bit 0 = MSB of Y coordinate
A relative mode is enabled if H,N6 = 01 that changes this byte format. Documentation
for sprites can be found at specnext.com.
If this attribute is not active, the sprite behaves as if this byte is zero.

(R/W) 0x40 (64) => Palette Index
bits 7-0 = Select the palette index to change the associated colour.
For the ULA only, INKs are mapped to indices 0-7, Bright INKS to indices 8-15,
PAPERs to indices 16-23 and Bright PAPERs to indices 24-31.
In ULANext mode, INKs come from a subset of indices 0-127 and PAPERs come from
a subset of indices 128-255. The number of active indices depends on the number
of attribute bits assigned to INK and PAPER out of the attribute byte.
The ULA always takes border colour from paper.

(R/W) 0x41 (65) => Palette Value (8 bit colour)
bits 7-0 = Colour for the palette index selected by the register 0x40.
(Format is RRRGGGBB - the lower blue bit of the 9-bit colour will
be a logical OR of blue bits 1 and 0 of this 8-bit value.)
After the write, the palette index is auto-incremented to the next index
if the auto-increment is enabled at reg 0x43. Reads do not auto-increment.

(R/W) 0x42 (66) => ULANext Attribute Byte Format
bits 7-0 = Mask indicating which bits of an attribute byte are used to represent INK.
The rest will represent PAPER. (15 on reset)
The mask can only indicate a solid sequence of bits on the right side of
the attribute byte (1, 3, 7, 15, 31, 63, 127 or 255).
INKs are mapped to base index 0 in the palette and PAPERs and border are
mapped to base index 128 in the palette.
The 255 value enables the full ink colour mode making all the palette
entries INK. PAPER and border both take on the fallback colour
(nextreg 0x4A) in this mode.

(R/W) 0x43 (67) => Palette Control
bit 7 = '1' to disable palette write auto-increment.
bits 6-4 = Select palette for reading or writing:
000 = ULA first palette
100 = ULA second palette
001 = Layer 2 first palette
101 = Layer 2 second palette
010 = Sprites first palette
110 = Sprites second palette
011 = Tilemap first palette
111 = Tilemap second palette
bit 3 = Select Sprites palette (0 = first palette, 1 = second palette)
bit 2 = Select Layer 2 palette (0 = first palette, 1 = second palette)
bit 1 = Select ULA palette (0 = first palette, 1 = second palette)
bit 0 = Enabe ULANext mode if 1. (0 after a reset)

(R/W) 0x44 (68) => Palette Value (9 bit colour)
Two consecutive writes are needed to write the 9 bit colour
1st write:
bits 7-0 = RRRGGGBB
2nd write.
If writing a L2 palette
-----------------------------------------------------------------------
bit 7 = 1 for L2 priority colour, 0 for normal
Priority colour will always be on top even on an SLU priori-
ty arrangement. If you need the exact same colour on priori-
ty and non priority locations you will need to program the
same colour twice changing bit 7 to 0 for the second colour
bits 6-1 = Reserved, must be 0
bit 0 = lsb B

If writing another palette
-----------------------------------------------------------------------
bits 7-1 = Reserved, must be 0
bit 0 = lsb B

After the two consecutives writes the palette index is
auto-incremented if the auto-increment is enabled by reg 0x43.

Reads only return the 2nd byte and do not auto-increment.

(R/W) 0x4A (74) => Transparency colour fallback
bits 7-0 = Set the 8 bit colour used if all layers are transparent.
(black on reset = 0)

(R/W) 0x4B (75) => Transparency index for sprites
bits 7-0 = Set the index value (0xE3 after reset)
For 4-bit sprites only the bottom 4-bits are relevant.

(R/W) 0x4C (76) => Transparency index for the tilemap
bits 7-4 = Reserved, must be 0
bits 3-0 = Set the index value (0xF after reset)

(R/W) 0x50 (80) => MMU slot 0
bits 7-0 = Set a Spectrum RAM page at position 0x0000 to 0x1fff
(255 after a reset)
Pages can be from 0 to 223 on a fully expanded Next.
A 255 value causes the ROM to become visible.

(R/W) 0x51 (81) => MMU slot 1
bits 7-0 = Set a Spectrum RAM page at position 0x2000 to 0x3fff
(255 after a reset)
Pages can be from 0 to 223 on a full expanded Next.
A 255 value causes the ROM to become visible.

(R/W) 0x52 (82) => MMU slot 2
bits 7-0 = Set a Spectrum RAM page at position 0x4000 to 0x5fff
(10 after a reset)
Pages can be from 0 to 223 on a full expanded Next.

(R/W) 0x53 (83) => MMU slot 3
bits 7-0 = Set a Spectrum RAM page at position 0x6000 to 0x7FFF
(Reset to 11 after a reset)
Pages can be from 0 to 223 on a full expanded Next.

(R/W) 0x54 (84) => MMU slot 4
bits 7-0 = Set a Spectrum RAM page at position 0x8000 to 0x9FFF
(4 after a reset)
Pages can be from 0 to 223 on a full expanded Next.

(R/W) 0x55 (85) => MMU slot 5
bits 7-0 = Set a Spectrum RAM page at position 0xA000 to 0xBFFF
(Reset to 5 after a reset)
Pages can be from 0 to 223 on a full expanded Next.

(R/W) 0x56 (86) => MMU slot 6
bits 7-0 = Set a Spectrum RAM page at position 0xC000 to 0xDFFF
(0 after a reset)
Pages can be from 0 to 223 on a full expanded Next.

(R/W) 0x57 (87) => MMU slot 7
bits 7-0 = Set a Spectrum RAM page at position 0xE000 to 0xFFFF
(1 after a reset)
Pages can be from 0 to 223 on a full expanded Next.
\end{verbatim}
Writing to ports 0x1FFD, 0x7FFD and 0xDFFD writes 255 to MMU0 and MMU1
and writes appropriate values to MMU6 and MMU7 to map in the selected 16k bank.

+3 special modes override the MMUs if used.
\begin{verbatim}
(W) 0x60 (96) => Copper data
bits 7-0 = Byte to write to copper instruction memory.
Note that each copper instruction is two bytes long.
After a write, the index is auto-incremented to the next memory position.

(W) 0x61 (97) => Copper control LO bit
bits 7-0 = Copper instruction memory address LSB.
(Index is set to 0 after a reset)

(W) 0x62 (98) => Copper control HI bit
bits 7-6 = Start control
00 = Copper fully stopped
01 = Copper start, execute the list from index 0, and loop to the start
10 = Copper start, execute the list from last point, and loop to the
start
11 = Copper start, execute the list from index 0, and restart the list
when the raster reaches position (0,0)
bits 2-0 = Copper instruction memory address MSB

(R/W) 0x68 (104) => ULA Control
bit 7 = 1 to disable ULA output
bit 6 = 0 to select the ULA colour for blending in SLU modes 6 & 7
= 1 to select the ULA/tilemap mix for blending in SLU modes 6 & 7
bits 5-1 = Reserved must be 0
bit 0 = 1 to enable stencil mode when both the ULA and tilemap are enabled
(if either are transparent the result is transparent otherwise the
result is a logical AND of both colours)

(R/W) 0x6B (107) => Tilemap Control
bit 7 = 1 to enable the tilemap
bit 6 = 0 for 40x32, 1 for 80x32
bit 5 = 1 to eliminate the attribute entry in the tilemap
bit 4 = palette select
bits 3-2 = Reserved set to 0
bit 1 = 1 to activate 512 tile mode
bit 0 = 1 to force tilemap on top of ULA

(R/W) 0x6C (108) => Default Tilemap Attribute
bits 7-4 = Palette Offset
bit 3 = X mirror
bit 2 = Y mirror
bit 1 = Rotate
bit 0 = ULA over tilemap
(bit 8 of the tile number if 512 tile mode is enabled)
Active tile attribute if bit 5 of nextreg 0x6B is set.

(R/W) 0x6E (110) => Tilemap Base Address
bits 7-6 = Read back as zero, write values ignored
bits 5-0 = MSB of address of the tilemap in Bank 5
The value written is an offset into Bank 5 allowing the tilemap to be placed
at any multiple of 256 bytes.
Writing a physical MSB address in 0x40-0x7f or 0xc0-0xff range is permitted.
The value read back should be treated as having a fully significant 8-bit value.

(R/W) 0x6F (111) => Tile Definitions Base Address
bits 7-6 = Read back as zero, write values ignored
bits 5-0 = MSB of address of tile definitions in Bank 5
The value written is an offset into Bank 5 allowing tile definitions to be placed
at any multiple of 256 bytes.
Writing a physical MSB address in 0x40-0x7f or 0xc0-0xff range is permitted.
The value read back should be treated as having a fully significant 8-bit value.

(W) 0x75 (117) => Sprite Attribute 0 with automatic post increment of Sprite Number
See nextreg 0x35

(W) 0x76 (118) => Sprite Attribute 1 with automatic post increment of Sprite Number
See nextreg 0x36

(W) 0x77 (119) => Sprite Attribute 2 with automatic post increment of Sprite Number
See nextreg 0x37

(W) 0x78 (120) => Sprite Attribute 3 with automatic post increment of Sprite Number
See nextreg 0x38

(W) 0x79 (121) => Sprite Attribute 4 with automatic post increment of Sprite Number
See nextreg 0x39

(W) 0xFF (255) => Debug LEDs (DE-1, DE-2 am Multicore only)
\end{verbatim}
The following ports are in use on the ZX Spectrum Next

TBBlue / ZX Spectrum Next Peripheral Ports
\begin{verbatim}
+-+-++-------------------+---------+--------------------------------+-------------------
| | ||AAAA AAAA AAAA AAAA| | |
| | ||1111 1100 0000 0000| | |
|R|W||5432 1098 7654 3210|Port(hex)|Description |Disable
+-+-++-------------------+---------+--------------------------------+-------------------
|*|*||XXXX XXXX XXXX XXX0| 0xfe |ULA |
|*|*||XXXX XXXX 1111 1111| 0xff |Timex video, floating bus |Nextreg 0x08 bit 2
| |*||0XXX XXXX XXXX XX01| 0x7ffd |ZX Spectrum 128 memory |Port 0x7ffd bit 5
| |*||01XX XXXX XXXX XX01| 0x7ffd |ZX Spectrum 128 memory +3 only |Port 0x7ffd bit 5
| |*||1101 XXXX XXXX XX01| 0xdffd |ZX Spectrum 128 memory (precedence over AY) |Port 0x7ffd bit 5
| |*||0001 XXXX XXXX XX01| 0x1ffd |ZX Spectrum +3 memory |Port 0x7ffd bit 5
|*| ||0000 XXXX XXXX XX01| |ZX Spectrum +3 floating bus |Port 0x7ffd bit 5
|*|*||0010 0100 0011 1011| 0x243b |NextREG Register Select |
|*|*||0010 0101 0011 1011| 0x253b |NextREG data/value |
| |*||0001 0000 0011 1011| 0x103b |i2c SCL (rtc) |
|*|*||0001 0001 0011 1011| 0x113b |i2c SDA (rtc) |
|*|*||0001 0010 0011 1011| 0x123b |Layer 2 |
|*|*||0001 0011 0011 1011| 0x133b |UART tx (esp) |
|*|*||0001 0100 0011 1011| 0x143b |UART rx (esp) |
|*|*||XXXX XXXX 0110 1011| 0x6b |zxnDMA |
|*|*||11XX XXXX XXXX X101| 0xfffd |AY reg |Nextreg 0x06 bit 0
| |*||10XX XXXX XXXX X101| 0xbffd |AY dat |Nextreg 0x06 bit 0
| |*||XXXX XXXX 0000 1111| 0x0f |DAC A |Nextreg 0x08 bit 3
| |*||XXXX XXXX 1111 0001| 0xf1 |DAC A (precedence over XXFD) |Nextreg 0x08 bit 3
| |*||XXXX XXXX 0011 1111| 0x3f |DAC A |Nextreg 0x08 bit 3
| |*||XXXX XXXX 1101 1111| 0xdf |DAC A,C specdrum |Nextreg 0x08 bit 3
| |*||XXXX XXXX 0001 1111| 0x1f |DAC B |Nextreg 0x08 bit 3
| |*||XXXX XXXX 1111 0011| 0xf3 |DAC B |Nextreg 0x08 bit 3
| |*||XXXX XXXX 0100 1111| 0x4f |DAC C |Nextreg 0x08 bit 3
| |*||XXXX XXXX 1111 1001| 0xf9 |DAC C (precedence over XXFD) |Nextreg 0x08 bit 3
| |*||XXXX XXXX 0101 1111| 0x5f |DAC D |Nextreg 0x08 bit 3
| |*||XXXX XXXX 1111 1011| 0xfb |DAC D |Nextreg 0x08 bit 3
| |*||XXXX XXXX 1110 0111| 0xe7 |SPI /CS (sd card, flash, rpi) |Nextreg 0x09 bit 2
|*|*||XXXX XXXX 1110 1011| 0xeb |SPI /DATA |Nextreg 0x09 bit 2
|*|*||XXXX XXXX 1110 0011| 0xe3 |divMMC Control |Nextreg 0x09 bit 2
|*| ||XXXX 1011 1101 1111| 0xfbdf |Kempston mouse x |Nextreg 0x09 bit 3
|*| ||XXXX 1111 1101 1111| 0xffdf |Kempston mouse y |Nextreg 0x09 bit 3
|*| ||XXXX 1010 1101 1111| 0xfadf |Kempston mouse wheel, buttons |Nextreg 0x09 bit 3
|*| ||XXXX XXXX 0001 1111| 0x1f |Kempston joy 1 |Nextreg 0x05
|*| ||XXXX XXXX 0011 0111| 0x37 |Kempston joy 2 |Nextreg 0x05
|*|*||XXXX XXXX 0001 1111| 0x1f |Multiface 1 disable |
|*| ||XXXX XXXX 1001 1111| 0x9f |Multiface 1 enable |
|*|*||XXXX XXXX 0011 1111| 0x3f |Multiface 128 disable |
|*| ||XXXX XXXX 1011 1111| 0xbf |Multiface 128 enable |
|*|*||XXXX XXXX 1011 1111| 0xbf |Multiface +3 disable |
|*| ||XXXX XXXX 0011 1111| 0x3f |Multiface +3 enable |
|*|*||0011 0000 0011 1011| 0x303b |Sprite slot, flags |
| |*||XXXX XXXX 0101 0111| 0x57 |Sprite attributes |
| |*||XXXX XXXX 0101 1011| 0x5b |Sprite pattern |
+-+-++-------------------+---------+--------------------------------+
\end{verbatim}
