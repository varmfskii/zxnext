\section{ZX Spectrum Next Registers}
February 25, 2019  Phoebus Dokos

TBBlue stores configuration state in a field of registers. These
registers are accessible via two I/O ports or via the special nextreg
instructions.

Port \$243B (9275) is used to set the register number, listed below.

Port \$253B (9531) is used to access the register value.

Some registers are accessible only during the initialization process.

2.00.27

(R) \$00 (00) $\Rightarrow$ Machine ID
\begin{itemize}
\item[] 00000001 = DE1A
\item[] 00000010 = DE2A
\item[] 00000101 = FBLABS
\item[] 00000110 = VTRUCCO
\item[] 00000111 = WXEDA
\item[] 00001000 = EMULATORS *
\item[] 00001010 = ZX Spectrum Next *
\item[] 00001011 = Multicore
\item[] 11111010 = ZX Spectrum Next Anti-brick *
\end{itemize}
* = Relevant for ZX Next machines \& software

(R) \$01 (01) $\Rightarrow$ Core Version
\begin{itemize}
\item[] bits 7-4 = Major version number
\item[] bits 3-0 = Minor version number
\end{itemize}
(see register \$0E for sub minor version number)

(R/W) \$02 (02) $\Rightarrow$ Reset:
\begin{itemize}
\item[] bits 7-3 = Reserved, must be 0
\item[] bit 2 = (R) Power-on reset (PoR)
\item[] bit 1 = (R/W) Reading 1 indicates a Hard-reset.\\
  If written 1 causes a Hard Reset.
\item[] bit 0 = (R/W) Reading 1 indicates a Soft-reset.\\
  If written 1 causes a Soft Reset.
\end{itemize}

(R/W) \$03 (03) $\Rightarrow$ Set machine type\\
A write to this register disables the IPL in config mode\\
(\$0000-\$3FFF is mapped to RAM instead of the internal ROM)
\begin{itemize}
\item[] bit 7 = (W) lock timing\\
  = (R) register \$44 second byte indicator
\item[] bits 6-4 = Timing:\\
  (always writable if bit 7 is set)
  \begin{itemize}
  \item[] 000 or 001 = ZX 48K
  \item[] 010 = ZX 128K/+2 (Grey)
  \item[] 011 = ZX +2A-B/+3e/Next Native
  \item[] 100 = Pentagon 128K
  \item[] bit 3 = Reserved, must be 0
  \item[] bits 2-0 = Machine type (writable in config mode only):
  \item[] 000 = Config mode
  \item[] 001 = ZX 48K
  \item[] 010 = ZX 128K/+2 (Grey)
  \item[] 011 = ZX +2A-B/+3e/Next Native
  \item[] 100 = Pentagon 128K
  \end{itemize}
\end{itemize}

(W) \$04 (04) $\Rightarrow$ Set page RAM, only in config mode (no IPL):
\begin{itemize}
\item[] bits 7-5 = Reserved, must be 0
\item[] bits 4-0 = RAM bank mapped to \$0000-\$3FFF
\end{itemize}
(64 x 16k pages = 1024K, 0 after a PoR or Hard-reset)

(R/W) \$05 (05) $\Rightarrow$ Peripheral 1 setting:
\begin{itemize}
\item[] bits 7-6 = joystick 1 mode (LSB)
\item[] bits 5-4 = joystick 2 mode (LSB)
\item[] bit 3 = joystick 1 mode (MSB)
\item[] bit 2 = 50/60 Hz mode (0 = 50Hz, 1 = 60Hz)(0 after a PoR or Hard-reset)
\item[] bit 1 = joystick 2 mode (MSB)
\item[] bit 0 = Enable Scandoubler (1 = enabled)(1 after a PoR or Hard-reset)
\end{itemize}
Joystick modes:
\begin{itemize}
\item[] 000 = Sinclair 2 (67890)
\item[] 001 = Kempston 1 (port \$1F)
\item[] 010 = Cursor (56780)
\item[] 011 = Sinclair 1 (12345)
\item[] 100 = Kempston 2 (port \$37)
\item[] 101 = MD 1 (3 or 6 button joystick port \$1F)
\item[] 110 = MD 2 (3 or 6 button joystick port \$37)
\end{itemize}

(R/W) \$06 (06) $\Rightarrow$ Peripheral 2 setting:
\begin{itemize}
\item[] bit 7 = Enable turbo mode (0 = disabled, 1 = enabled)\\
  (0 after a PoR or Hard-reset)
\item[] bit 6 = DMA mode (0 = zxn dma, 1 = z80 dma)\\
  (Only ZX Next board, 0 after a PoR or Hard-reset)
\item[] bit 5 = Enable Lightpen (1 = enabled)(0 after a PoR or Hard-reset)
\item[] bit 4 = DivMMC automatic paging (1 = enabled)(0 after a PoR or
  Hard-reset)
\item[] bit 3 = Enable Multiface (1 = enabled)(0 after a PoR or Hard-reset)
\item[] bit 2 = PS/2 mode (0 = keyboard, 1 = mouse)\\
  (exchanges the keyboard/mouse pins on the PS/2 connector)\\
  (0 after a PoR or Hard-reset)
\item[] bits 1-0 = Audio chip mode (00 = YM, 01 = AY, 1X = Disabled)
\end{itemize}

(R/W) \$07 (07) $\Rightarrow$ Turbo mode:
\begin{itemize}
\item[] bit 1-0 = Turbo (00 = 3.5MHz, 01 = 7MHz, 10 = 14MHz)
\end{itemize}
(00 after a PoR or Hard-reset)

(R/W) \$08 (08) $\Rightarrow$ Peripheral 3 setting:
\begin{itemize}
\item[] bit 7 = 128K paging enable (inverse of port \$7ffd, bit 5)\\
  Use "1" to disable the locked paging.
\item[] bit 6 = "1" to disable RAM contention. (0 after a reset)
\item[] bit 5 = Stereo mode (0 = ABC, 1 = ACB)(0 after a PoR or Hard-reset)
\item[] bit 4 = Enable internal speaker (1 = enabled)(1 after a PoR or
  Hard-reset)
\item[] bit 3 = Enable Specdrum/Covox (1 = enabled)(0 after a PoR or
  Hard-reset)
\item[] bit 2 = Enable Timex modes (1 = enabled)(0 after a PoR or
  Hard-reset)
\item[] bit 1 = Enable TurboSound (1 = enabled)(0 after a PoR or
  Hard-reset)
\item[] bit 0 = Reserved, must be 0
\end{itemize}

(R/W) \$09 (09) $\Rightarrow$ Peripheral 4 setting:
\begin{itemize}
\item[] bit 7 = Mono setting for AY 2 (1 = mono, 0 default)
\item[] bit 6 = Mono setting for AY 1 (1 = mono, 0 default)
\item[] bit 5 = Mono setting for AY 0 (1 = mono, 0 default)
\item[] bit 4 = Sprite id lockstep (1 = Nextreg \$34 and IO Port
  \$303B are in lockstep, 0 default)
\item[] bit 3 = Disables Kempston port (\$DF) if set
\item[] bit 2 = Disables divMMC ports (\$E3, \$E7, \$EB) if set
\item[] bits 1-0 = scanlines (0 after a PoR or Hard-reset)
  \begin{itemize}
  \item[] 00 = scanlines off
  \item[] 01 = scanlines 75\%
  \item[] 10 = scanlines 50\%
  \item[] 11 = scanlines 25\%
  \end{itemize}
\end{itemize}

(R) \$0E (14) $\Rightarrow$ Core Version (sub minor number)\\
(see register \$01 for the major and minor version number)

(R) \$10 (16) $\Rightarrow$ Anti-brick system
\begin{itemize}
\item[] bits 7-2 = Reserved, must be 0
\item[] bit 1 = Button DivMMC (1 = pressed)
\item[] bit 0 = Button Multiface (1 = pressed)
\end{itemize}

(W) \$10 (16) $\Rightarrow$ Core Boot
\begin{itemize}
\item[] bit 7 = Start selected core (1 = start)
\item[] bits 6-5 = Reserved, must be 0
\item[] bits 4-0 = Core ID 0-31 (writable in config mode only, default is 2)
\end{itemize}

(R/W) \$11 (17) $\Rightarrow$ Video Timing (writable in config mode only)
\begin{itemize}
\item[] bits 7-3 = Reserved, must be 0
\item[] bits 2-0 = Mode (VGA = 0..6, HDMI = 7)
  \begin{itemize}
  \item[] 000 = Base VGA timing, clk28 = 28000000
  \item[] 001 = VGA setting 1, clk28 = 28571429
  \item[] 010 = VGA setting 2, clk28 = 29464286
  \item[] 011 = VGA setting 3, clk28 = 30000000
  \item[] 100 = VGA setting 4, clk28 = 31000000
  \item[] 101 = VGA setting 5, clk28 = 32000000
  \item[] 110 = VGA setting 6, clk28 = 33000000
  \item[] 111 = HDMI, clk28 = 27000000
  \end{itemize}
\end{itemize}
50/60Hz selection depends on bit 2 of register \$05

(R/W) \$12 (18) $\Rightarrow$ Layer 2 RAM bank
\begin{itemize}
\item[] bits 7-6 = Reserved, must be 0
\item[] bits 5-0 = RAM bank (point to bank 8 after a Reset, NextZXOS
  modifies to 9)
\end{itemize}

(R/W) \$13 (19) $\Rightarrow$ Layer 2 RAM shadow bank
\begin{itemize}
\item[] bits 7-6 = Reserved, must be 0
\item[] bits 5-0 = RAM bank (point to bank 11 after a Reset, NextZXOS
  modifies to 12)
\end{itemize}

(R/W) \$14 (20) $\Rightarrow$ Global transparency color
\begin{itemize}
\item[] bits 7-0 = Transparency color value (\$E3 after a reset)
\end{itemize}
(Note: this value is 8-bit, so the transparency is compared against
only by the MSB bits of the final 9-bit colour)\\
(Note2: this only affects Layer 2, ULA and LoRes. Sprites use register
\$4B for transparency and tilemap uses nextreg \$4C)

(R/W) \$15 (21) $\Rightarrow$ Sprite and Layers system
\begin{itemize}
\item[] bit 7 = LoRes mode, 128 x 96 x 256 colours (1 = enabled)
\item[] bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on top)
\item[] bit 5 = Enable sprite clipping in over border mode (1 = enabled)
\item[] bits 4-2 = set layers priorities:\\
  Reset default is 000, sprites over the Layer 2, over the ULA graphics
  \begin{itemize}
  \item[] 000 - S L U
  \item[] 001 - L S U
  \item[] 010 - S U L
  \item[] 011 - L U S
  \item[] 100 - U S L
  \item[] 101 - U L S
  \item[] 110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7
  \item[] 111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]
  \end{itemize}
\item[] bit 1 = Over border (1 = yes)(Back to 0 after a reset)
\item[] bit 0 = Sprites visible (1 = visible)(Back to 0 after a reset)
\end{itemize}

(R/W) \$16 (22) $\Rightarrow$ Layer2 Offset X
\begin{itemize}
\item[] bits 7-0 = X Offset (0-255)(0 after a reset)
\end{itemize}

(R/W) \$17 (23) $\Rightarrow$ Layer2 Offset Y
\begin{itemize}
\item[] bits 7-0 = Y Offset (0-191)(0 after a reset)
\end{itemize}

(R/W) \$18 (24) $\Rightarrow$ Clip Window Layer 2
\begin{itemize}
\item[] bits 7-0 = Coords of the clip window
  \begin{itemize}
  \item[] 1st write - X1 position
  \item[] 2nd write - X2 position
  \item[] 3rd write - Y1 position
  \item[] 4rd write - Y2 position
  \end{itemize}
\end{itemize}
Reads do not advance the clip position\\
The values are 0,255,0,191 after a Reset

(R/W) \$19 (25) $\Rightarrow$ Clip Window Sprites
\begin{itemize}
\item[] bits 7-0 = Cood. of the clip window
  \begin{itemize}
  \item[] 1st write - X1 position
  \item[] 2nd write - X2 position
  \item[] 3rd write - Y1 position
  \item[] 4rd write - Y2 position
  \end{itemize}
\end{itemize}
The values are 0,255,0,191 after a Reset\\
Reads do not advance the clip position

When the clip window is enabled for sprites in "over border" mode, the
X coords are internally doubled and the clip window origin is moved to
the sprite origin inside the border.

(R/W) \$1A (26) $\Rightarrow$ Clip Window ULA/LoRes
\begin{itemize}
\item[] bits 7-0 = Coord. of the clip window
  \begin{itemize}
  \item[] 1st write = X1 position
  \item[] 2nd write = X2 position
  \item[] 3rd write = Y1 position
  \item[] 4rd write = Y2 position
  \end{itemize}
\end{itemize}
The values are 0,255,0,191 after a Reset\\
Reads do not advance the clip position

(R/W) \$1B (27) $\Rightarrow$ Clip Window Tilemap
\begin{itemize}
\item[] bits 7-0 = Coord. of the clip window
  \begin{itemize}
  \item[] 1st write = X1 position
  \item[] 2nd write = X2 position
  \item[] 3rd write = Y1 position
  \item[] 4rd write = Y2 position
  \end{itemize}
\end{itemize}
The values are 0,159,0,255 after a Reset\\
Reads do not advance the clip position\\
The X coords are internally doubled.

(W) \$1C (28) $\Rightarrow$ Clip Window control
\begin{itemize}
\item[] bits 7-4 = Reserved, must be 0
\item[] bit 3 - reset the tilemap clip index
\item[] bit 2 - reset the ULA/LoRes clip index.
\item[] bit 1 - reset the sprite clip index.
\item[] bit 0 - reset the Layer 2 clip index.
\end{itemize}

(R) \$1C (28) $\Rightarrow$ Clip Window control\\
(may change)
\begin{itemize}
\item[] bits 7-6 = Tilemap clip index
\item[] bits 5-4 = Layer 2 clip index
\item[] bits 3-2 = Sprite clip index
\item[] bits 1-0 = ULA clip index
\end{itemize}

(R) \$1E (30) $\Rightarrow$ Active video line (MSB)
\begin{itemize}
\item[] bits 7-1 = Reserved, always 0
\item[] bit 0 = Active line MSB (Reset to 0 after a reset)
\end{itemize}

(R) \$1F (31) = Active video line (LSB)
\begin{itemize}
\item[] bits 7-0 = Active line LSB (0-255)(Reset to 0 after a reset)
\end{itemize}

(R/W) \$22 (34) $\Rightarrow$ Line Interrupt control
\begin{itemize}
\item[] bit 7 = (R) INT flag, 1=During INT\\
  (even if the processor has interrupt disabled)
\item[] bits 6-3 = Reserved, must be 0
\item[] bit 2 = If 1 disables original ULA interrupt (Reset to 0 after a reset)
\item[] bit 1 = If 1 enables Line Interrupt (Reset to 0 after a reset)
\item[] bit 0 = MSB of Line Interrupt line value (Reset to 0 after a reset)
\end{itemize}

(R/W) \$23 (35) $\Rightarrow$ Line Interrupt value LSB
\begin{itemize}
\item[] bits 7-0 = Line Interrupt line value LSB (0-255)(Reset to 0
  after a reset)
\end{itemize}

(W) \$28 (40) $\Rightarrow$ High address of Keymap
\begin{itemize}
\item[] bits 7-1 = Reserved, must be 0
\item[] bit 0 = MSB address
\end{itemize}

(W) \$29 (41) $\Rightarrow$ Low address of Keymap
\begin{itemize}
\item[] bits 7-0 = LSB adress
\end{itemize}

(W) \$2A (42) $\Rightarrow$ High data to Keymap
\begin{itemize}
\item[] bits 7-1 = Reserved, must be 0
\item[] bit 0 = MSB data
\end{itemize}

(W) \$2B (43) $\Rightarrow$ Low data to Keymap\\
(writing this register the address is auto-incremented)
\begin{itemize}
\item[] bits 7-0 = LSB data
\end{itemize}

(W) \$2D (45) $\Rightarrow$ SpecDrum port \$DF / DAC A+C mirror
\begin{itemize}
\item[] bits 7-0 = Data to be written to mono DAC
\end{itemize}
(this port can be used to generate mono audio using the copper)

(R/W) \$2F (47) $\Rightarrow$ Tilemap Offset X MSB
\begin{itemize}
\item[] bits 7-2 = Reserved, must be 0
\item[] bits 1-0 = MSB X Offset
\end{itemize}
Meaningful Range is 0-319 in 40 char mode, 0-639 in 80 char mode

(R/W) \$30 (48) $\Rightarrow$ Tilemap Offset X LSB
\begin{itemize}
\item[] bits 7-0 = LSB X Offset
\end{itemize}
Meaningful range is 0-319 in 40 char mode, 0-639 in 80 char mode

(R/W) \$31 (49) $\Rightarrow$ Tilemap Offset Y
\begin{itemize}
\item[] bits 7-0 = Y Offset (0-255)
\end{itemize}

(R/W) \$32 (50) $\Rightarrow$ ULA / LoRes Offset X
\begin{itemize}
\item[] bits 7-0 = X Offset (0-255)(Reset to 0 after a reset)
\end{itemize}
ULA can only scroll in multiples of 8 pixels so the lowest 3 bits have
no effect at this time.\\
LoRes scrolls in "half-pixels" at the same resolution and smoothness
as Layer 2.

(R/W) \$33 (51) $\Rightarrow$ ULA / LoRes Offset Y
\begin{itemize}
\item[] bits 7-0 = Y Offset (0-191)(Reset to 0 after a reset)
\end{itemize}
LoRes scrolls in "half-pixels" at the same resolution and smoothness
as Layer 2.

(R/W) \$34 (52) $\Rightarrow$ Sprite Number

If the sprite number is in lockstep with io port \$303B (nextreg \$09
bit 4 is set)
\begin{itemize}
\item[] bits 7 = Pattern address offset (Add 128 to pattern address)
\item[] bits 6-0 = Sprite number 0-127, Pattern number 0-63
\end{itemize}
Selects which sprite has its attributes connected to the following
registers.  Effectively performs an out to port \$303B with the same
value\\
Otherwise
\begin{itemize}
\item[] bit 7 = Ignored
\item[] bits 6-0 = Sprite number 0-127\\
  Selects which sprite has its attributes connected to the following registers.
\item[] Bit 7 always reads back as zero.
\end{itemize}

(W) \$35 (53) $\Rightarrow$ Sprite Attribute 0\\
(W) \$75 (117) $\Rightarrow$ Sprite Attribute 0 with automatic post
increment of Sprite Number
\begin{itemize}
\item[] bits 7-0 = LSB of X coordinate
\end{itemize}

(W) \$36 (54) $\Rightarrow$ Sprite Attribute 1\\
(W) \$76 (118) $\Rightarrow$ Sprite Attribute 1 with automatic post
increment of Sprite Number
\begin{itemize}
\item[] bits 7-0 = LSB of Y coordinate
\end{itemize}

(W) \$37 (55) $\Rightarrow$ Sprite Attribute 2\\
(W) \$77 (119) $\Rightarrow$ Sprite Attribute 2 with automatic post
increment of Sprite Number
\begin{itemize}
\item[] bits 7-4 = Palette offset added to top 4 bits of sprite colour index
\item[] bit 3 = X mirror
\item[] bit 2 = Y mirror
\item[] bit 1 = Rotate
\item[] bit 0 = MSB of X coordinate (palette offset indicator for
  relative sprites)
\end{itemize}

(W) \$38 (56) $\Rightarrow$ Sprite Attribute 3\\
(W) \$78 (120) $\Rightarrow$ Sprite Attribute 3 with automatic post
increment of Sprite Number
\begin{itemize}
\item[] bit 7 = Visible flag (1 = displayed)
\item[] bit 6 = Extended attribute (1 = Sprite Attribute 4 is active)
\item[] bits 5-0 = Pattern used by sprite (0-63)
\end{itemize}

(W) \$39 (57) $\Rightarrow$ Sprite Attribute 4\\
(W) \$79 (121) $\Rightarrow$ Sprite Attribute 4 with automatic post
increment of Sprite Number\\
4-bit Sprites
\begin{itemize}
\item[] bit 7 = H (1 = sprite uses 4-bit patterns)
\item[] bit 6 = N6 (0 = use the first 128 bytes of the pattern else
  use the last 128 bytes)
\item[] bit 5 = 1 if relative sprites are composite, 0 if relative
  sprites are unified Scaling
\item[] bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
\item[] bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
\item[] bit 0 = MSB of Y coordinate
\end{itemize}
A relative mode is enabled if H,N6 = 01 that changes this byte
format. Documentation for sprites can be found at specnext.com.\\
If this attribute is not active, the sprite behaves as if this byte is
zero.

(R/W) \$40 (64) $\Rightarrow$ Palette Index
\begin{itemize}
\item[] bits 7-0 = Select the palette index to change the associated colour.
\end{itemize}
For the ULA only, INKs are mapped to indices 0-7, Bright INKS to
indices 8-15, PAPERs to indices 16-23 and Bright PAPERs to indices
24-31.\\
In ULANext mode, INKs come from a subset of indices 0-127 and PAPERs
come from a subset of indices 128-255. The number of active indices
depends on the number of attribute bits assigned to INK and PAPER out
of the attribute byte.  The ULA always takes border colour from paper.

(R/W) \$41 (65) $\Rightarrow$ Palette Value (8 bit colour)
\begin{itemize}
\item[] bits 7-0 = Colour for the palette index selected by the register \$40.
\end{itemize}
(Format is RRRGGGBB - the lower blue bit of the 9-bit colour will be a
logical OR of blue bits 1 and 0 of this 8-bit value.)\\
After the write, the palette index is auto-incremented to the next
index if the auto-increment is enabled at reg \$43. Reads do not
auto-increment.

(R/W) \$42 (66) $\Rightarrow$ ULANext Attribute Byte Format
\begin{itemize}
\item[] bits 7-0 = Mask indicating which bits of an attribute byte are
  used to represent INK. The rest will represent PAPER.
\end{itemize}
(15 on reset)\\
The mask can only indicate a solid sequence of bits on the right side
of the attribute byte (1, 3, 7, 15, 31, 63, 127 or 255).\\
INKs are mapped to base index 0 in the palette and PAPERs and border
are mapped to base index 128 in the palette.\\
The 255 value enables the full ink colour mode making all the palette
entries INK. PAPER and border both take on the fallback colour
(nextreg \$4A) in this mode.

(R/W) \$43 (67) $\Rightarrow$ Palette Control
\begin{itemize}
\item[] bit 7 = '1' to disable palette write auto-increment.
\item[] bits 6-4 = Select palette for reading or writing:
  \begin{itemize}
  \item[] 000 = ULA first palette
  \item[] 100 = ULA second palette
  \item[] 001 = Layer 2 first palette
  \item[] 101 = Layer 2 second palette
  \item[] 010 = Sprites first palette
  \item[] 110 = Sprites second palette
  \item[] 011 = Tilemap first palette
  \item[] 111 = Tilemap second palette
  \end{itemize}
\item[] bit 3 = Select Sprites palette (0 = first palette, 1 = second palette)
\item[] bit 2 = Select Layer 2 palette (0 = first palette, 1 = second palette)
\item[] bit 1 = Select ULA palette (0 = first palette, 1 = second palette)
\item[] bit 0 = Enabe ULANext mode if 1. (0 after a reset)
\end{itemize}

(R/W) \$44 (68) $\Rightarrow$ Palette Value (9 bit colour)\\
Two consecutive writes are needed to write the 9 bit colour
\begin{itemize}
\item[] 1st write:
  \begin{itemize}
  \item[] bits 7-0 = RRRGGGBB
  \end{itemize}
\item[] 2nd write.
  If writing a L2 palette\\
  \begin{itemize}
  \item[] bit 7 = 1 for L2 priority colour, 0 for normal\\
    Priority colour will always be on top even on an SLU priority
    arrangement. If you need the exact same colour on priority and non
    priority locations you will need to program the same colour twice
    changing bit 7 to 0 for the second colour
  \item[] bits 6-1 = Reserved, must be 0
  \item[] bit 0 = lsb B
  \end{itemize}
  If writing another palette
  \begin{itemize}
  \item[] bits 7-1 = Reserved, must be 0
  \item[] bit 0 = lsb B
  \end{itemize}
\end{itemize}
After the two consecutives writes the palette index is
auto-incremented if the auto-increment is enabled by reg \$43.\\
Reads only return the 2nd byte and do not auto-increment.

(R/W) \$4A (74) $\Rightarrow$ Transparency colour fallback
\begin{itemize}
\item[] bits 7-0 = Set the 8 bit colour used if all layers are transparent.
\end{itemize}
(black on reset = 0)

(R/W) \$4B (75) $\Rightarrow$ Transparency index for sprites
\begin{itemize}
\item[] bits 7-0 = Set the index value (\$E3 after reset)
\end{itemize}
For 4-bit sprites only the bottom 4-bits are relevant.

(R/W) \$4C (76) $\Rightarrow$ Transparency index for the tilemap
\begin{itemize}
\item[] bits 7-4 = Reserved, must be 0
\item[] bits 3-0 = Set the index value (\$F after reset)
\end{itemize}

(R/W) \$50 (80) $\Rightarrow$ MMU slot 0
\begin{itemize}
\item[] bits 7-0 = Set a Spectrum RAM page at position \$0000 to \$1fff
\end{itemize}
(255 after a reset)\\
Pages can be from 0 to 223 on a fully expanded Next.\\
A 255 value causes the ROM to become visible.

(R/W) \$51 (81) $\Rightarrow$ MMU slot 1
\begin{itemize}
\item[] bits 7-0 = Set a Spectrum RAM page at position \$2000 to \$3fff
\end{itemize}
(255 after a reset)\\
Pages can be from 0 to 223 on a full expanded Next.\\
A 255 value causes the ROM to become visible.

(R/W) \$52 (82) $\Rightarrow$ MMU slot 2
\begin{itemize}
\item[] bits 7-0 = Set a Spectrum RAM page at position \$4000 to \$5fff
\end{itemize}
(10 after a reset)\\
Pages can be from 0 to 223 on a full expanded Next.

(R/W) \$53 (83) $\Rightarrow$ MMU slot 3
\begin{itemize}
\item[] bits 7-0 = Set a Spectrum RAM page at position \$6000 to \$7FFF
\end{itemize}
(Reset to 11 after a reset)\\
Pages can be from 0 to 223 on a full expanded Next.

(R/W) \$54 (84) $\Rightarrow$ MMU slot 4
\begin{itemize}
\item[] bits 7-0 = Set a Spectrum RAM page at position \$8000 to \$9FFF
\end{itemize}
(4 after a reset)\\
Pages can be from 0 to 223 on a full expanded Next.

(R/W) \$55 (85) $\Rightarrow$ MMU slot 5
\begin{itemize}
\item[] bits 7-0 = Set a Spectrum RAM page at position \$A000 to \$BFFF
\end{itemize}
(Reset to 5 after a reset)\\
Pages can be from 0 to 223 on a full expanded Next.

(R/W) \$56 (86) $\Rightarrow$ MMU slot 6
\begin{itemize}
\item[] bits 7-0 = Set a Spectrum RAM page at position \$C000 to \$DFFF
\end{itemize}
(0 after a reset)\\
Pages can be from 0 to 223 on a full expanded Next.

(R/W) \$57 (87) $\Rightarrow$ MMU slot 7
\begin{itemize}
\item[] bits 7-0 = Set a Spectrum RAM page at position \$E000 to \$FFFF
\end{itemize}
(1 after a reset)\\
Pages can be from 0 to 223 on a full expanded Next.

Writing to ports \$1FFD, \$7FFD and \$DFFD writes 255 to MMU0 and MMU1
and writes appropriate values to MMU6 and MMU7 to map in the selected
16k bank.\\
+3 special modes override the MMUs if used.

(W) \$60 (96) $\Rightarrow$ Copper data
\begin{itemize}
\item[] bits 7-0 = Byte to write to copper instruction memory.
\end{itemize}
Note that each copper instruction is two bytes long.\\
After a write, the index is auto-incremented to the next memory position.

(W) \$61 (97) $\Rightarrow$ Copper control LO bit
\begin{itemize}
\item[] bits 7-0 = Copper instruction memory address LSB.
\end{itemize}
(Index is set to 0 after a reset)

(W) \$62 (98) $\Rightarrow$ Copper control HI bit
\begin{itemize}
\item[] bits 7-6 = Start control
  \begin{itemize}
  \item[] 00 = Copper fully stopped
  \item[] 01 = Copper start, execute the list from index 0, and loop
    to the start
  \item[] 10 = Copper start, execute the list from last point, and
    loop to the start
  \item[] 11 = Copper start, execute the list from index 0, and
    restart the list when the raster reaches position (0,0)
  \end{itemize}
\item[] bits 2-0 = Copper instruction memory address MSB
\end{itemize}

(R/W) \$68 (104) $\Rightarrow$ ULA Control
\begin{itemize}
\item[] bit 7 = 1 to disable ULA output
\item[] bit 6 = 0 to select the ULA colour for blending in SLU modes 6
  \& 7\\
  = 1 to select the ULA/tilemap mix for blending in SLU modes 6 \& 7
\item[] bits 5-1 = Reserved must be 0
\item[] bit 0 = 1 to enable stencil mode when both the ULA and tilemap are enabled
\end{itemize}
(if either are transparent the result is transparent otherwise the
result is a logical AND of both colours)

(R/W) \$6B (107) $\Rightarrow$ Tilemap Control
\begin{itemize}
\item[] bit 7 = 1 to enable the tilemap
\item[] bit 6 = 0 for 4\$32, 1 for 8\$32
\item[] bit 5 = 1 to eliminate the attribute entry in the tilemap
\item[] bit 4 = palette select
\item[] bits 3-2 = Reserved set to 0
\item[] bit 1 = 1 to activate 512 tile mode
\item[] bit 0 = 1 to force tilemap on top of ULA
\end{itemize}

(R/W) \$6C (108) $\Rightarrow$ Default Tilemap Attribute
\begin{itemize}
\item[] bits 7-4 = Palette Offset
\item[] bit 3 = X mirror
\item[] bit 2 = Y mirror
\item[] bit 1 = Rotate
\item[] bit 0 = ULA over tilemap
\end{itemize}
(bit 8 of the tile number if 512 tile mode is enabled)\\
Active tile attribute if bit 5 of nextreg \$6B is set.

(R/W) \$6E (110) $\Rightarrow$ Tilemap Base Address
\begin{itemize}
\item[] bits 7-6 = Read back as zero, write values ignored
\item[] bits 5-0 = MSB of address of the tilemap in Bank 5
\end{itemize}
The value written is an offset into Bank 5 allowing the tilemap to be
placed at any multiple of 256 bytes.\\
Writing a physical MSB address in \$40-\$7f or \$c0-\$ff range is
permitted.\\
The value read back should be treated as having a fully significant
8-bit value.

(R/W) \$6F (111) $\Rightarrow$ Tile Definitions Base Address
\begin{itemize}
\item[] bits 7-6 = Read back as zero, write values ignored
\item[] bits 5-0 = MSB of address of tile definitions in Bank 5
\end{itemize}
The value written is an offset into Bank 5 allowing tile definitions
to be placed at any multiple of 256 bytes.\\
Writing a physical MSB address in \$40-\$7f or \$c0-\$ff range is
permitted.\\
The value read back should be treated as having a fully significant
8-bit value.

(W) \$75 (117) $\Rightarrow$ Sprite Attribute 0 with automatic post
increment of Sprite Number\\
See nextreg \$35

(W) \$76 (118) $\Rightarrow$ Sprite Attribute 1 with automatic post
increment of Sprite Number\\
See nextreg \$36

(W) \$77 (119) $\Rightarrow$ Sprite Attribute 2 with automatic post
increment of Sprite Number\\
See nextreg \$37

(W) \$78 (120) $\Rightarrow$ Sprite Attribute 3 with automatic post
increment of Sprite Number\\
See nextreg \$38

(W) \$79 (121) $\Rightarrow$ Sprite Attribute 4 with automatic post
increment of Sprite Number\\
See nextreg \$39

(W) \$FF (255) $\Rightarrow$ Debug LEDs (DE-1, DE-2 am Multicore only)
