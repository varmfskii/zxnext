'\" t
.\" Automatically generated by Pandoc 2.11.1
.\"
.TH "ZX Spectrum Next Programming Notes" "" "" "" ""
.hy
.SH Introduction
.PP
The ZX Spectrum Next is an extension of the original ZX Spectrum
implemented in FPGA which implements many of the common additions to the
system includin the characteristics of all of the original ZX Spectrum
line, including the Timex/Sinclair 2068, along with a number of
characteristics to modernize the design.
.PP
This document is an attempt to consolidate the programming interface for
the ZX Spectrum Next into a single location.
This document started when much of the documentation on the ZX Spectrum
Next site (https://www.specnext.com/) was out of date and/or difficult
to figure out.
The way to figure out how things actually worked was to either dig
through the forums and ask questions or find someones code that
implemented a particular bit of functionality and reverse engineer it.
The situation has greatly improved and this document may even be
redundant at this point.
.PP
Description from http://www.specnext.com/about/:
.PP
The Spectrum Next is fully implemented with FPGA technology, ensuring it
can be upgraded and enhanced while remaining truly compatible with the
original hardware by using special memory chips and clever design.
Here\[cq]s what under the hood of the machine:
.IP \[bu] 2
Processor: Z80n normal and turbo modes
.IP \[bu] 2
Memory: 1024Kb RAM (expandable to 2048Kb on board)
.IP \[bu] 2
Video: Multilayer video implementing classic ZX Spectrum, Timex
Hi-Resolution, Timex Hi-Colour, LoRes, Layer 2, and Tilemap video modes
with Hardware sprites
.IP \[bu] 2
Video Output: RGB, VGA, HDMI
.IP \[bu] 2
Storage: SD Card slot, with DivMMC-compatible protocol
.IP \[bu] 2
Audio: ZX Spectrum 1-bit audio, Turbo Sound Next (3x AY-3-8912 audio
chips with stereo output), stereo PCM audio, and ability to use Pi
accelerator as a sound source
.IP \[bu] 2
Joystick: DB9 compatible with Cursor, Kempston and Interface 2 protocols
(selectable)
.IP \[bu] 2
PS/2 port: Mouse with Kempston mode emulation and an external keyboard
.IP \[bu] 2
Special: Multiface functionality for memory access, savegames, cheats
etc.
.IP \[bu] 2
Tape support: Mic and Ear ports for tape loading and saving
.IP \[bu] 2
Expansion: Original external bus expansion port and accelerator
expansion port
.IP \[bu] 2
Accelerator board (optional): Pi Zero with GPU / 1Ghz CPU / 512Mb RAM
.IP \[bu] 2
Network (optional): Wi Fi module
.IP \[bu] 2
Extras: Real Time Clock (optional), internal speaker (optional)
.SH Video
.PP
ZX Spectrum Next video splits the display types into four categories
(layer 1 (ULA/Timex/LoRes), layer 2, layer 3 (tilemap) and sprites)
which have their own sets of controls for colour palettes, clipping, and
scrolling.
Some aspects of ULA and tilemap are tied together, but all the rest
operate in a largely independent manner using a layering system.
The ULA category has a number of separate video modes that it can use.
One of these (LoRes) is incompatible with using tilemaps (This may have
change in the most recent cores).
.SS General Features
.PP
There are a number of control features for the various video modes that
are done in a unified fashion.
These features are layering and transparency, palettes, scrolling, and
clipping.
For the sake of convenience we will occasionally talk about a global
coordinate system for graphics on the ZX Next.
This coordinate system has (0, 0) at the upper left corner of the usable
display area and (319, 255) at the lower right corner.
Individual pixels generally correspond to integer locations in this
grid, but some modes may either double or halve this grid.
This will be discussed in the sections for each of the video layers.
.SS Video Layering and Transparency
.PP
Video for the ZX Next is composed of a number of features and layers
each of which may have its own set of video modes.
Not all of these features are mandatory.
.PP
By composing together the border colour and transparency fallback color,
layer 1 (ULA, Timex modes, or LoRes), layer 2
(256\[u2005]\[tmu]\[u2005]192\[u2005]\[tmu]\[u2005]256,
320\[u2005]\[tmu]\[u2005]256\[u2005]\[tmu]\[u2005]256, or
640\[u2005]\[tmu]\[u2005]256\[u2005]\[tmu]\[u2005]16), layer 3 (16 or 2
colour tiles), and sprites; we generate the full video display.
.PP
The border/transparency fallback is the bottom with the ordering of the
layers controlled by a combination of the video layering register (Next
register $15 (21) bits 4-2), the interaction of layers 1 and 3 (Next
register $6B (107) bit 0), and whether or not a pixel in layer 2 is set
as a priority colour.
.PP
Register (R/W) $15 () \[rA] Sprite and Layer System Setup
.IP \[bu] 2
bit 7 = LoRes mode (0 on reset)
.IP \[bu] 2
bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on top) (0
on reset)
.IP \[bu] 2
bit 5 = Enable sprite clipping in over border mode (0 on reset)
.IP \[bu] 2
bits 4-2 = set layers priorities (000 on reset)
.RS 2
.IP \[bu] 2
000 - S L U
.IP \[bu] 2
001 - L S U
.IP \[bu] 2
010 - S U L
.IP \[bu] 2
011 - L U S
.IP \[bu] 2
100 - U S L
.IP \[bu] 2
101 - U L S
.IP \[bu] 2
110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7
.IP \[bu] 2
111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]
.RE
.IP \[bu] 2
bit 1 = Enable Sprites Over border (0 on reset)
.IP \[bu] 2
bit 0 = Enable Sprites (0 on reset)
.PP
Transparency for Layer 2, Layer 1, and 1-bit Tilemaps are controlled by
Next register $14 (20) and defaults to $E3.
Sprites and 4-bit Tilemaps have their own registers ($4B and $4C
respectively) for setting their transparency index (not colour).
This colour ignores the state of the least significant blue bit, so $E3
equates to both $1C6 and $1C7.
For Sprites and Tilemaps transparency is determined by colour index.
For Sprites this is controlled by register $4B (with only the least
significant 4-bits being relevant for 16-colour Sprites).
For Tilemaps, the transparency index is set by register $4C.
If all layers are transparent, the transparency fallback colour is
displayed.
This is set by register $4A.
.PP
Register (R/W) $14 () \[rA] Global transparency color
.IP \[bu] 2
bits 7-0 = Transparency color value ($E3 after a reset)
.PP
(Note: this value is 8-bit, so the transparency is compared against only
by the MSB bits of the final 9-bit colour)
.PD 0
.P
.PD
(Note2: this only affects Layer 2, ULA and LoRes.
Sprites use register $4B for transparency and tilemap uses nextreg $4C)
.PP
Register (R/W) $4A () \[rA] Fallback Colour Value
.IP \[bu] 2
bits 7-0 = 8-bit colour if all layers are transparent ($E3 on reset)
.PP
(black on reset = 0)
.PP
Register (R/W) $4B () \[rA] Sprite Transparency Index
.IP \[bu] 2
bits 7-0 = Index value ($E3 if reset)
.PP
For 4-bit sprites only the bottom 4-bits are relevant.
.PP
Register (R/W) $4C () \[rA] Level 3 Transparency Index
.IP \[bu] 2
bits 7-4 = Reserved, must be 0
.IP \[bu] 2
bits 3-0 = Index value ($0F on reset)
.SS Palette
.SS Next Colour Palettes
.PP
Each video mode group has a pair of palettes assigned to it a primary
and an alternate palette.
Each palette entry is actually a 9-bit value (RRRGGGBBB) and can be set
by selecting a palette using nextreg $43 (palette control), the entry
using nextreg $40 (palette index), then writing the value into nextreg
$44 (palette value, 9-bit) using pairs of consecutive writes for each
palette value or nextreg $41 (palette value, 8-bit).
Once a palette index has been selected writes automatically increment
the palette index number so it is possible to efficiently write the
values for a collection of palette entries.
.PP
Register (R/W) $40 () \[rA] Palette Index Select
.IP \[bu] 2
bits 7-0 = Palette Index Number
.PP
Selects the palette index to change the associated colour
.PP
For ULA only, INKs are mapped to indices 0 through 7, BRIGHT INKs to
indices 8 through 15, PAPERs to indices 16 through 23 and BRIGHT PAPERs
to indices 24 through 31.
In EnhancedULA mode, INKs come from a subset of indices from 0 through
127 and PAPERs from a subset of indices from 128 through 255.
.PP
The number of active indices depends on the number of attribute bits
assigned to INK and PAPER out of the attribute byte.
.PP
In ULAplus mode, the last 64 entries (indices 192 to 255) hold the
ULAplus palette.
The ULA always takes border colour from PAPER for standard ULA and
Enhanced ULA
.PP
Register (R/W) $41 () \[rA] 8-bit Palette Data
.IP \[bu] 2
bits 7-0 = Colour Entry in RRRGGGBB format
.PP
The lower blue bit of the 9-bit internal colour will be the logical or
of bits 0 and 1 of the 8-bit entry.
After each write, the palette index auto-increments if aut-increment has
been enabled (NextReg $43 bit 7), Reads do not auto-increment.
.PP
Register (R/W) $43 () \[rA] Palette Control
.IP \[bu] 2
bit 7 = Disable palette write auto-increment.
.IP \[bu] 2
bits 6-4 = Select palette for reading or writing:
.RS 2
.IP \[bu] 2
000 = ULA first palette
.IP \[bu] 2
100 = ULA second palette
.IP \[bu] 2
001 = Layer 2 first palette
.IP \[bu] 2
101 = Layer 2 second palette
.IP \[bu] 2
010 = Sprite first palette
.IP \[bu] 2
110 = Sprite second palette
.IP \[bu] 2
011 = Layer 3 first palette
.IP \[bu] 2
111 = Layer 3 second palette
.RE
.IP \[bu] 2
bit 3 = Select Sprite palette (0 = first palette, 1 = second palette)
.IP \[bu] 2
bit 2 = Select Layer 2 palette (0 = first palette, 1 = second palette)
.IP \[bu] 2
bit 1 = Select ULA palette (0 = first palette, 1 = second palette)
.IP \[bu] 2
bit 0 = Enable EnhancedULA mode if 1.
(0 after a reset)
.PP
Register (R/W) $44 () \[rA] 9-bit Palette Data
.PD 0
.P
.PD
Non Level 2
.IP \[bu] 2
1st write
.IP \[bu] 2
bits 7-0 = MSB (RRRGGGBB)
.IP \[bu] 2
2nd write
.IP \[bu] 2
bits 7-1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = LSB (B)
.PP
Level 2
.IP \[bu] 2
1st write
.IP \[bu] 2
bits 7-0 = MSB (RRRGGGBB)
.IP \[bu] 2
2nd write
.IP \[bu] 2
bit 7 = Priority
.IP \[bu] 2
bits 6-1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = LSB (B)
.PP
9-bit Palette Data is entered in two consecutive writes; the second
write autoincrements the palette index if auto-increment is enabled in
NextREG $43 bit 7
.PP
If writing an L2 palette, the second write\[cq]s D7 holds the L2
priority bit which if set (1) brings the colour defined at that index on
top of all other layers.
If you also need the same colour in regular priority (for example: for
enviromental masking) you will have to set it up again, this time with
no priority.
.PP
Reads return the second byte and do not autoincrement.
Writes to nextreg $40, $41, $41, or $43 reset to the first write.
.SS Scrolling
.PP
The ZX Spectrum Next has four sets of scrolling registers to
independently contol the display offsets of various video modes (Layer2,
ULA, Tilemap, and LoRes).
When the video is offset, the portion that is pushed off the screen (to
the left and or top) then becomes visible on the opposite side of the
screen so that the video offset values are effectively the coordinates
of the origin in a toroidal universe.
.SS Clipping
.PP
The ZX Spectrum Next has four clipping registers create a window of the
layer that is visible.
Clipping is managed by a set of four successive writes to the clipping
register applicable for the video mode.
If a section is masked off by clipping, it is as if the area were the
transparency colour and the video lyers behind it become visible.
.SS Layer 1
.PP
Layer 1 Mode summary
.TS
tab(@);
l c c c.
T{
Mode
T}@T{
Resolution
T}@T{
Colour
T}@T{
T}
_
T{
ULA
T}@T{
256\[tmu]192
T}@T{
ULA 8\[tmu]8
T}@T{
T}
T{
Timex Alt
T}@T{
256\[tmu]192
T}@T{
ULA 8\[tmu]8
T}@T{
T}
T{
HiCol
T}@T{
256\[tmu]192
T}@T{
ULA 8\[tmu]1
T}@T{
T}
T{
HiRes
T}@T{
512\[tmu]192
T}@T{
2 colours
T}@T{
T}
T{
128 Alt
T}@T{
256\[tmu]192
T}@T{
ULA 8\[tmu]8
T}@T{
T}
T{
LoRes
T}@T{
128\[tmu]96
T}@T{
256 colours
T}@T{
T}
T{
Rad
T}@T{
128\[tmu]96
T}@T{
16 colours
T}@T{
T}
.TE
.PP
The Layer 1 consists of ZX Spectrum ULA video, Timex video modes, and
the Spectrum Next\[cq]s lores video modes all use 16k memory bank 5 or 7
with the data coming from some combination of addresses $0000-$17FF
(bitmap 1), $1800-$1AFF (attribute 1), $2000-$37FF (bitmap 2), and
$3800-$3AFF (attribute 2) within the selected bank.
Assuming default memory mapping and the use of bank 5 this will be
mapped as some combination of memory $4000-$57FF, $5800-$5AFF,
$6000-$77FF, $780-$7AFF.
All of the modes other than the lores mode can either use the default ZX
Spectrum colours, ULANext mode, or an emulation of ULAplus.
In the Spectrum and Timex modes all colours are either Paper
(foreground), paper (background), or border colours.
.PP
Layer 1 Memory Map
.TS
tab(@);
l c c c c c c.
T{
T}@T{
BM 1
T}@T{
Attr 1
T}@T{
BM 2
T}@T{
Attr 2
T}@T{
BM a
T}@T{
Attr a
T}
_
T{
Bank
T}@T{
5
T}@T{
5
T}@T{
5
T}@T{
5
T}@T{
7
T}@T{
7
T}
T{
start
T}@T{
$0000
T}@T{
$1800
T}@T{
$2000
T}@T{
$3800
T}@T{
$0000
T}@T{
$1800
T}
T{
end
T}@T{
$17FF
T}@T{
$1AFF
T}@T{
$37FF
T}@T{
$3AFF
T}@T{
$17FF
T}@T{
$1AFF
T}
T{
ULA
T}@T{
*
T}@T{
*
T}@T{
T}@T{
T}@T{
T}@T{
T}
T{
Timex Alt
T}@T{
T}@T{
T}@T{
*
T}@T{
*
T}@T{
T}@T{
T}
T{
HiCol
T}@T{
*
T}@T{
T}@T{
*
T}@T{
T}@T{
T}@T{
T}
T{
HiRes
T}@T{
*
T}@T{
T}@T{
*
T}@T{
T}@T{
T}@T{
T}
T{
128 Alt
T}@T{
T}@T{
T}@T{
T}@T{
T}@T{
*
T}@T{
*
T}
T{
LoRes
T}@T{
*
T}@T{
T}@T{
*
T}@T{
T}@T{
T}@T{
T}
T{
Rad
T}@T{
1
T}@T{
T}@T{
2
T}@T{
T}@T{
T}@T{
T}
.TE
.SS Colour Attributes
.PP
The ZX Spectrum Next has three major modes for colour attributes: the ZX
Spectrum attribute mapping, which is augmented by using the ZX Spectrum
Next\[cq]s palette; ULANext, which allows the user to how many
foreground and how many background colous are to be selected by the
attribute bytes; and an emulation of ULAplus.
.SS ULA Colour
.PP
In ULA colour INKs are mapped to indices 0-7, Bright INKS to indices
8-15, PAPERs to indices 16-23 and Bright PAPERs to indices 24-31.
This is the default state for interpreting ULA palettes.
.SS ULANext
.PP
The ULANext modes use a varying number of bits from the attribute byte
to determine the ink colours as the palette index from the appropriate
bits (all others being zero) and the paper colours coming from the
indicated value+128 with palette format 255 being a special case where
all the bits determine the ink colour while the paper is always palette
index 128.
The ULA always takes border colour from paper.
ULANext is enabled using bit 0 of nextreg $43 (palette control) and
controlled with nextreg $42 (ULA Next attribute byte format)
.SS ULAplus
.PP
The ZX Next emulates ULAPlus using the last 64 (192-255) entries of the
ULA palette.
ULAplus is controlled using two ports: $BF3B (register port) and $FF3B
(data port)
.SS I/O ports
.PP
ULAplus is controlled by two ports.
.PP
$BF3B is the register port (write only)
.PP
The byte output will be interpreted as follows:
.IP \[bu] 2
Bits 7-6: Select the register group.
Two groups are currently available:
.RS 2
.IP \[bu] 2
00=palette group
.PD 0
.P
.PD
When this group is selected, the sub-group determines the entry in the
palette table (0-63).
.IP \[bu] 2
01=mode group
.PD 0
.P
.PD
The sub-group is (optionally) used to mirror the video functionality of
Timex port $FF as follows:
.RE
.IP \[bu] 2
Bits 5-0: Select the register sub-group
.IP \[bu] 2
Mode group
.IP \[bu] 2
Bits 5-3: Sets the screen colour in hi-res mode.
.RS 2
.IP \[bu] 2
000=Black on White
.IP \[bu] 2
001=Blue on Yellow
.IP \[bu] 2
010=Red on Cyan
.IP \[bu] 2
011=Magenta on Green
.IP \[bu] 2
100=Green on Magenta
.IP \[bu] 2
101=Cyan on Red
.IP \[bu] 2
110=Yellow on Blue
.IP \[bu] 2
111=White on Black
.RE
.IP \[bu] 2
Bits 2-0: Screen mode.
.RS 2
.IP \[bu] 2
000=screen 0 (bank 5)
.IP \[bu] 2
001=screen 1 (bank 5)
.IP \[bu] 2
010=hi-colour (bank 5)
.IP \[bu] 2
100=screen 0 (bank 7)
.IP \[bu] 2
101=screen 1 (bank 7)
.IP \[bu] 2
110=hi-colour (bank 7)
.IP \[bu] 2
110=hi-res (bank 5)
.IP \[bu] 2
111=hi-res (bank 7)
.RE
.PP
$FF3B is the data port (read/write)
.PP
When the palette group is selected, the byte written will describe the
color.
.PP
When the mode group is selected, the byte output will be interpreted as
follows:
.IP \[bu] 2
Bit 0: ULAplus palette on (1) / off (0)
.IP \[bu] 2
Bit 1: (optional) grayscale: on (1) / off (0) (same as turing the color
off on the television)
.PP
Implementations that support the Timex video modes use the $FF register
as the primary means to set the video mode, as per the Timex machines.
It is left to the individual implementations to determine if reading the
port returns the previous write or the floating bus.
.SS GRB palette entries
.PP
G3R3B2 encoding
.PD 0
.P
.PD
For a device using the GRB colour space the palette entry is interpreted
as follows
.IP \[bu] 2
Bits 7-5: Green intensity.
.IP \[bu] 2
Bits 4-2: Red intensity.
.IP \[bu] 2
Bits 1-0: Blue intensity.
.PP
This colour space uses a sub-set of 9-bit GRB.
The missing lowest blue bit is set to OR of the other two blue bits (Bb
becomes 000 for 00, and Bb1 for anything else).
This gives access to a fixed half the potential 512 colour palette.
The reduces the jump in intensity in the lower range in the earlier
version of the specification.
It also means the standard palette can now be represented by the ULAplus
palette.
.SS Grayscale palette entries
.PP
This is an optional ULAPlus feature that is not supported on the Next.
.PP
In grayscale mode, each palette entry describes an intensity from zero
to 255.
This can be achieved by simply removing the colour from the output
signal.
.SS Limitations
.PP
Although in theory 64 colours can be displayed at once, in practice this
is usually not possible except when displaying colour bars, because the
four CLUTs are mutually exclusive; it is not possible to mix colours
from two CLUTs in the same cell.
However, with software palette cycling it is possible to display all 256
colours on screen at once.
.SS Emulation
.PP
The 64 colour mode lookup table is organized as 4 palettes of 16
colours.
.PP
Bits 7 and 6 of each Spectrum attribute byte (normally used for FLASH
and BRIGHT) will be used as an index value (0-3) to select one of the
four colour palettes.
.PP
Each colour palette has 16 entries (8 for INK, 8 for PAPER).
Bits 0 to 2 (INK) and 3 to 5 (PAPER) of the attribute byte will be used
as indexes to retrieve colour data from the selected palette.
.PP
With the standard Spectrum display, the BORDER colour is the same as the
PAPER colour in the first CLUT.
For example BORDER 0 would set the border to the same colour as PAPER 0
(with the BRIGHT and FLASH bits not set).
.PP
The complete index can be calculated as
.PD 0
.P
.PD
ink_colour = (FLASH * 2 + BRIGHT) * 16 + INK paper_colour = (FLASH * 2 +
BRIGHT) * 16 + PAPER + 8
.SS Palette file format
.PP
The palette format doubles as the BASIC patch loader.
This enables you to edit patches produced by other people.
.IP
.nf
\f[C]
; 64 colour palette file format (internal) - version 1.0
; copyright (c) 2009 Andrew Owen
;
; The palette file is stored as a BASIC program with embedded machine code

header:

db 0x00 ; program file
db 0x14, 0x01, \[dq]64colour\[dq] ; file name
dw 0x0097 ; data length
dw 0x0000 ; autostart line
dw 0x0097 ; program length

basic:

; 0 RANDOMIZE USR ((PEEK VAL \[dq]2
; 3635\[dq]+VAL \[dq]256\[dq]*PEEK VAL \[dq]23636\[dq]
; )+VAL \[dq]48\[dq]): LOAD \[dq]\[dq]: REM

db 0x00, 0x00, 0x93, 0x00, 0xf9, 0xc0, 0x28, 0x28
db 0xbe, 0xb0, 0x22, 0x32, 0x33, 0x36, 0x33, 0x35
db 0x22, 0x2b, 0xb0, 0x22, 0x32, 0x35, 0x36, 0x22
db 0x2a, 0xbe, 0xb0, 0x22, 0x32, 0x33, 0x36, 0x33
db 0x36, 0x22, 0x29, 0x2b, 0xb0, 0x22, 0x34, 0x38
db 0x22, 0x29, 0x3a, 0xef, 0x22, 0x22, 0x3a, 0xea

start:

di ; disable interrupts
ld hl, 38 ; HL = length of code
add hl, bc ; BC = entry point (start) from BASIC
ld bc, 0xbf3b ; register select
ld a, 64 ; mode group
out (c), a ;
ld a, 1 ;
ld b, 0xff ; choose register port
out (c), a ; turn palette mode on
xor a ; first register

setreg:

ld b, 0xbf ; choose register port
out (c), a ; select register
ex af, af\[aq] ; save current register select
ld a, (hl) ; get data
ld b, 0xff ; choose data port
out (c), a ; set it
ex af, af\[aq] ; restore current register
inc hl ; advance pointer
inc a ; increase register
cp 64 ; are we nearly there yet?
jr nz, setreg ; repeat until all 64 have been done
ei ; enable interrupts
ret ; return

; this is where the actual data is stored. The following is an example palette.

registers:

db 0x00, 0x02, 0x18, 0x1b, 0xc0, 0xc3, 0xd8, 0xdb ; INK
db 0x00, 0x02, 0x18, 0x1b, 0xc0, 0xc3, 0xd8, 0xdb ; PAPER
db 0x00, 0x03, 0x1c, 0x1f, 0xe0, 0xe3, 0xfc, 0xff ; +BRIGHT
db 0x00, 0x03, 0x1c, 0x1f, 0xe0, 0xe3, 0xfc, 0xff ;
db 0xdb, 0xd8, 0xc3, 0xc0, 0x1b, 0x18, 0x02, 0x00 ; +FLASH
db 0xdb, 0xd8, 0xc3, 0xc0, 0x1b, 0x18, 0x02, 0x00 ;
db 0xff, 0xfc, 0xe3, 0xe0, 0x1f, 0x1c, 0x03, 0x00 ; +BRIGHT/
db 0xff, 0xfc, 0xe3, 0xe0, 0x1f, 0x1c, 0x03, 0x00 ; +FLASH

terminating_byte:

db 0x0d 
\f[R]
.fi
.SS Layer 1 Scrolling
.PP
Layer 1 has two sets of scrolling registers.
One for the the legacy modes (ZX Spectrum, Alternate Page, Timex
Hi-Resoulution, and Timex Hi-colour) and a second set for the two ZX
Spextrum Next specific LoRes modes.
All modes scroll as if they were 256\[u2005]\[tmu]\[u2005]192 screens
located at global coordinates (32, 32) to (287, 223), The registers for
the legacy modes are $26 and $27 and the registers for the LoRes modes
are $32 and $33.
.PP
Register (R/W) $26 () \[rA] ULA Horizontal Scroll Control
.IP \[bu] 2
bits 7-0 = ULA X Offset (0-255) (0 on reset)
.PP
Register (R/W) $27 () \[rA] ULA Vertical Scroll Control
.IP \[bu] 2
bits 7-0 = ULA Y Offset (0-191) (0 on reset)
.PP
Register (R/W) $32 () \[rA] Layer 1,0 (LoRes) Horizontal Scroll Control)
.IP \[bu] 2
bits 7-0 = X Offset (0-255) ($00 on reset)
.PP
Layer 1,0 (LoRes) scrolls in \[dq]half-pixels\[dq] at the same
resolution and smoothness as Layer 2.
.PP
Register (R/W) $33 () \[rA] Layer 1,0 (LoRes) Vertical Scroll Control)
.IP \[bu] 2
bits 7-0 = Y Offset (0-191) ($00 on reset)
.PP
Layer 1,0 (LoRes) scrolls in \[dq]half-pixels\[dq] at the same
resolution and smoothness as Layer 2.
.SS Layer 1 Clipping
.PP
All of the modes in the Layer 1 share a single clipping register, $1A.
The clip index may alternately be set using register $1C.
This is expecially useful for reading the current clipping coordinates
as reads on the clipping register do not change the index.
Note that clipping coordinates are based on a full display area for the
mode of 256\[u2005]\[tmu]\[u2005]192 resolution even though not all
modes have that resolution.
.PP
Register (R/W) $1A () \[rA] Layer 0 (ULA/LoRes) Clip Window Definition
.IP \[bu] 2
bits 7-0 = Coord.
of the clip window
.RS 2
.IP \[bu] 2
1st write = X1 position
.IP \[bu] 2
2nd write = X2 position
.IP \[bu] 2
3rd write = Y1 position
.IP \[bu] 2
4rd write = Y2 position
.RE
.PP
The values are 0,255,0,191 after a Reset
.PD 0
.P
.PD
Reads do not advance the clip position
.PP
Register (R/W) $1C () \[rA] Clip Window Control
.PD 0
.P
.PD
Read
.IP \[bu] 2
bits 7-6 = Layer 3 Clip Index
.IP \[bu] 2
bits 5-4 = Layer 0/1 Clip Index
.IP \[bu] 2
bits 3-2 = Sprite clip index
.IP \[bu] 2
bits 1-0 = Layer 2 Clip Index
.PP
Write
.IP \[bu] 2
bits 7-4 = Reserved, must be 0
.IP \[bu] 2
bit 3 - reset Layer 3 clip index
.IP \[bu] 2
bit 2 - reset Layer 0/1 clip index
.IP \[bu] 2
bit 1 - reset sprite clip index.
.IP \[bu] 2
bit 0 - reset Layer 2 clip index.
.SS ZX Spectrum Mode
.PP
Timex mode 0
.PP
This is the default ULA mode and has its origins in the original ZX
Spectrum.
It uses 256\[u2005]\[tmu]\[u2005]192 pixels located at global
coordinates (32, 32) to (287, 223) with 8\[u2005]\[tmu]\[u2005]8 colour
attribute areas mapped into a 32\[u2005]\[tmu]\[u2005]24 grid.
If Timex modes are not enabled, this and the LoRes mode are the only
ones available, so you would switch back to this mode by writing
000xxxxx to Next register $15 (21, the sprites and layers register).
If another Timex mode is enabled, then this is mode 0 so you would write
0 to port $ff to enable it.
This is a 256\[u2005]\[tmu]\[u2005]192 video mode.
The bitmap 1 area is used for selection between ink and paper colours
with one bit per pixel and the attribute 1 area for colour attributes.
.PP
The easiest way to visualize the mapping of this mode is to think of the
256\[u2005]\[tmu]\[u2005]192 area as being divided into a
32\[u2005]\[tmu]\[u2005]24 grid of 8\[u2005]\[tmu]\[u2005]8 characters.
IF we consider X and Y as the position in the grid and R to the the row
within the character.
For ink/paper selection, 0=paper, 1=ink and the entries are stored left
to right as lsb to msb within the bye.
The address for a pixel value is:
0\f[I]R\f[R]~4~\f[I]R\f[R]~3~\f[I]Y\f[R]~2~\f[I]Y\f[R]~1~\f[I]Y\f[R]~0~\f[I]R\f[R]~2~\f[I]R\f[R]~1~\f[I]R\f[R]~0~\f[I]C\f[R]~4~\f[I]C\f[R]~3~\f[I]C\f[R]~2~\f[I]C\f[R]~1~\f[I]C\f[R]~0~.
Each 8\[u2005]\[tmu]\[u2005]8 cell has its own colour attribute where
the address for an attribute cell is
0110\f[I]R\f[R]~4~\f[I]R\f[R]~3~\f[I]R\f[R]~2~\f[I]R\f[R]~1~\f[I]R\f[R]~0~\f[I]C\f[R]~4~\f[I]C\f[R]~3~\f[I]C\f[R]~2~\f[I]C\f[R]~1~\f[I]C\f[R]~0~
in other words mapped lineally column-wise starting at the beginning of
the attribute 1 area.
.PP
Code:
.IP
.nf
\f[C]
  ;; from any other Timex mode:
  ld a,$00
  ld c,$ff
  out (c),a

  ;; from LoRes mode:
  ld bc,$243B ; next register select port
  ld a,$15
  out (c),a
  ld bc,$253B ; next register r/w port
  in a,(c)
  and $7f
  out (c),a
\f[R]
.fi
.SS Alternate Page Mode
.PP
Timex mode 1
.PP
This mode is the same as ZX Spectrum mode except it is at an alternate
addresses.
Alternate page mode is selected by enabling Timex modes by writing
00xxxx1xx to Next register $08 (8, Peripheral 3 setting) then writing 1
to the Timex ULA port ($ff).
It is identical to ZX Spectrum mode except the pixel are mapped to the
bitmap 2 area giving use pixel addresses of
1\f[I]R\f[R]~4~\f[I]R\f[R]~3~\f[I]Y\f[R]~2~\f[I]Y\f[R]~1~\f[I]Y\f[R]~0~\f[I]R\f[R]~2~\f[I]R\f[R]~1~\f[I]R\f[R]~0~\f[I]C\f[R]~4~\f[I]C\f[R]~3~\f[I]C\f[R]~2~\f[I]C\f[R]~1~\f[I]C\f[R]~0~
and the attributes to the attribute 2 area with addresses of
1110\f[I]R\f[R]~4~\f[I]R\f[R]~3~\f[I]R\f[R]~2~\f[I]R\f[R]~1~\f[I]R\f[R]~0~\f[I]C\f[R]~4~\f[I]C\f[R]~3~\f[I]C\f[R]~2~\f[I]C\f[R]~1~\f[I]C\f[R]~0~.
.PP
Code:
.IP
.nf
\f[C]
;; disable LoRes mode:
ld bc,$243B ; next register select port
ld a,$15
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
and $7f
out (c),a
;; set Timex mode
ld bc,$243B ; next register select port
ld a,$08
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
or $04
out (c),a
;; set alternate page mode
ld c,$ff
ld a,$01
out (c),a
\f[R]
.fi
.SS Timex Hi-Colour Mode
.PP
Timex mode 2
.PP
This mode is a 256\[u2005]\[tmu]\[u2005]192 video mode located at global
coordinates (32, 32) to (287, 223) with 8\[u2005]\[tmu]\[u2005]1 colour
attribute mapping on a 32\[u2005]\[tmu]\[u2005]192 grid.
It is selected by writing 2 to the Timex ULA port ($ff).
Pixel mapping in this mode is the same as in ZX Spectrum mode using the
bitmap 1 area based on
0\f[I]R\f[R]~4~\f[I]R\f[R]~3~\f[I]Y\f[R]~2~\f[I]Y\f[R]~1~\f[I]Y\f[R]~0~\f[I]R\f[R]~2~\f[I]R\f[R]~1~\f[I]R\f[R]~0~\f[I]C\f[R]~4~\f[I]C\f[R]~3~\f[I]C\f[R]~2~\f[I]C\f[R]~1~\f[I]C\f[R]~0~.
The colour attributes use the bitmap 2 area with
8\[u2005]\[tmu]\[u2005]1 colour attribute areas corresponding to the
addresses
1\f[I]R\f[R]~4~\f[I]R\f[R]~3~\f[I]Y\f[R]~2~\f[I]Y\f[R]~1~\f[I]Y\f[R]~0~\f[I]R\f[R]~2~\f[I]R\f[R]~1~\f[I]R\f[R]~0~\f[I]C\f[R]~4~\f[I]C\f[R]~3~\f[I]C\f[R]~2~\f[I]C\f[R]~1~\f[I]C\f[R]~0~.
.PP
Code:
.IP
.nf
\f[C]
;; disable LoRes mode:
ld bc,$243B ; next register select port
ld a,$15
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
and $7f
out (c),a
;; set Timex mode
ld bc,$243B ; next register select port
ld a,$08
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
or $04
out (c),a
;; set hi-colour mode
ld c,$ff
ld a,$02
out (c),a
\f[R]
.fi
.SS Timex Hi-Resolution Mode
.PP
Timex mode 6
.PP
This is a monochrome 512\[u2005]\[tmu]\[u2005]192 video mode located at
global coordinates (32, 32) to (287, 223) with each pixel being half
width.
It is selected by writing to the Timex ULA port ($ff with values that
also select which two colours (or colour entries in ULANext mode) you
use.
.PP
Pixels are mapped into both the bitmap 1 and bitmap 2 areas where
8-pixel wide character columns alternate between the two bitmap areas.
The pixels within a byte being rendered left to right lsb to msb as in
other Spectrum video modes.
The addresses for each row within a character are based on a
64\[u2005]\[tmu]\[u2005]32 grid of 8\[u2005]\[tmu]\[u2005]8 characters
which using a 64\[u2005]\[tmu]\[u2005]24 R, C, and Y scheme gives us
addresses of the form
\f[I]C\f[R]~0~\f[I]R\f[R]~4~\f[I]R\f[R]~3~\f[I]Y\f[R]~2~\f[I]Y\f[R]~1~\f[I]Y\f[R]~0~\f[I]R\f[R]~2~\f[I]R\f[R]~1~\f[I]R\f[R]~0~\f[I]C\f[R]~5~\f[I]C\f[R]~4~\f[I]C\f[R]~3~\f[I]C\f[R]~2~\f[I]C\f[R]~1~.
.PP
Code:
.IP
.nf
\f[C]
;; disable LoRes mode:
ld bc,$243B ; next register select port
ld a,$15
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
and $7f
out (c),a
;; set Timex mode
ld bc,$243B ; next register select port
ld a,$08
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
or $04
out (c),a
;; set hi-res mode, black on white
ld c,$ff
ld a,$06
out (c),a
\f[R]
.fi
.SS Lo-Resolution Mode
.PP
This is a Spectrum Next specific video mode with a resolution of
128\[u2005]\[tmu]\[u2005]96 located at global coordinates (32, 32) to
(287, 223) with each pixel being double height and double width
replacing the old Radistan mode.
It can either allow for 16 colours, in which case it uses either the
bitmap 1 area or the bitmap 2 area, or 256 colours using both bitmap 1
and bitmap 2.
The colour of each pixel can be selected independently with data ordered
linearly in a row major fashion.
In the case of 16 colour mode, the nybbles describing the colours are X
major (MSN LSN).
Scrolling is by half pixels and uses different registers ($32 and $33)
from the rest of the ULA group modes.
LoRes mode is enabled by writing
100\f[I]x\f[R]\f[I]x\f[R]\f[I]x\f[R]\f[I]x\f[R]\f[I]x\f[R] to Next
register $15 (the sprites and layers register) with Next register $6A
used to decide whether it is 16 or 256 colours.
.PP
Register (R/W) $15 () \[rA] Sprite and Layer System Setup
.IP \[bu] 2
bit 7 = LoRes mode (0 on reset)
.IP \[bu] 2
bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on top) (0
on reset)
.IP \[bu] 2
bit 5 = Enable sprite clipping in over border mode (0 on reset)
.IP \[bu] 2
bits 4-2 = set layers priorities (000 on reset)
.RS 2
.IP \[bu] 2
000 - S L U
.IP \[bu] 2
001 - L S U
.IP \[bu] 2
010 - S U L
.IP \[bu] 2
011 - L U S
.IP \[bu] 2
100 - U S L
.IP \[bu] 2
101 - U L S
.IP \[bu] 2
110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7
.IP \[bu] 2
111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]
.RE
.IP \[bu] 2
bit 1 = Enable Sprites Over border (0 on reset)
.IP \[bu] 2
bit 0 = Enable Sprites (0 on reset)
.PP
Register (R/W) $32 () \[rA] Layer 1,0 (LoRes) Horizontal Scroll Control)
.IP \[bu] 2
bits 7-0 = X Offset (0-255) ($00 on reset)
.PP
Layer 1,0 (LoRes) scrolls in \[dq]half-pixels\[dq] at the same
resolution and smoothness as Layer 2.
.PP
Register (R/W) $33 () \[rA] Layer 1,0 (LoRes) Vertical Scroll Control)
.IP \[bu] 2
bits 7-0 = Y Offset (0-191) ($00 on reset)
.PP
Layer 1,0 (LoRes) scrolls in \[dq]half-pixels\[dq] at the same
resolution and smoothness as Layer 2.
.PP
Register (R/W) $6A () \[rA] Layer 1,0 (LoRes) Control
.IP \[bu] 2
bits 7-6 = reserved, must be 0
.IP \[bu] 2
bit 5 = Enable Radistan (16-colour) (0 on reset)
.IP \[bu] 2
bit 4 = Radistan DFILE switch (xor with bit 0 of port $ff) (0 on reset)
.IP \[bu] 2
bits 3-0 = Radistsan palette offset (0 on reset)
.IP \[bu] 2
bits 1-0 = ULAplus palette offset (0 on reset)
.PP
Code: 256 colour
.IP
.nf
\f[C]
;; enable LoRes mode:
nextreg $15,$80
;; 256-colour mode
ld bc,$243B ; next register select port
ld a,$6A
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
and $EF ; lores radistan control
out (c),a
\f[R]
.fi
.PP
Code: 16 colour
.IP
.nf
\f[C]
;; enable LoRes mode:
nextreg $15,$80
;; 16-colour mode
nextreg $6A,$10
\f[R]
.fi
.SS Layer 2
.PP
Layer 2 is a for bitmapped graphics.
It supports modes with
256\[u2005]\[tmu]\[u2005]192\[u2005]\[tmu]\[u2005]256 resolution at
global coordinates (32, 32) to (287, 223) mapped linearly left to
right/top to bottom,
320\[u2005]\[tmu]\[u2005]256\[u2005]\[tmu]\[u2005]256 resolution at
global coordinates (0, 0) to (318, 255) mapped top to bottom/left to
right, and 640\[u2005]\[tmu]\[u2005]256\[u2005]\[tmu]\[u2005]16
resolution at global coordinates (0, 0) to (319, 255) with half width
pixels mapped so that the nybbles in a byte are adjacent columns (MSN on
the left) and bytes running top to bottom/left to right.
It can be mapped starting at any 16k memory blocks.
The 256\[u2005]\[tmu]\[u2005]192\[u2005]\[tmu]\[u2005]256 mode requires
3 consecutive blocks (48k) while the others use 5 consecutive blocks
(80k).
.SS Configuration
.PP
Layer 2 is enabled using port $123B or register $69.
The mode is selected using register $70.
How layer 2 memory is overlaid on main memory is controled by port $123B
and register $70.
The location in memory is controlled by register $12 with a shadow area
pointed to by register $13 for double buffering.
Finally port $123B is used to select either the main RAM area or the
shadow RAM area for rendering the layer.
.PP
Port $123B () Layer 2
.PD 0
.P
.PD
Bit 4 = 0
.IP \[bu] 2
bits 7-6 = Video RAM bank select
.RS 2
.IP \[bu] 2
00 = first 16k
.IP \[bu] 2
01 = second 16k
.IP \[bu] 2
10 = third 16k
.IP \[bu] 2
11 = first 48k
.RE
.IP \[bu] 2
bit 5 = Reserved, must be 0
.IP \[bu] 2
bit 4 = 0
.IP \[bu] 2
bit 3 = Shadow layer 2 select
.IP \[bu] 2
bit 2 = Enable layer 2 read paging
.IP \[bu] 2
bit 1 = Layer 2 visible (mirrored in register $69)
.IP \[bu] 2
bit 0 = Enable layer 2 write paging
.PP
Bit 4 = 1
.IP \[bu] 2
bits 7-5 = Reserved, must be 0
.IP \[bu] 2
bit 4 = 1
.IP \[bu] 2
bit 3 = Reserved, must be 0
.IP \[bu] 2
bit 2-0 = 16k bank relative offset
.PP
Register (R/W) $12 () \[rA] Layer 2 Active RAM bank
.IP \[bu] 2
bits 7-6 = Reserved, must be 0
.IP \[bu] 2
bits 5-0 = RAM bank (point to bank 8 after a Reset, NextZXOS modifies to
9)
.PP
Register (R/W) $13 () \[rA] Layer 2 Shadow RAM bank
.IP \[bu] 2
bits 7-6 = Reserved, must be 0
.IP \[bu] 2
bits 5-0 = RAM bank (point to bank 11 after a Reset, NextZXOS modifies
to 12)
.PP
Register (R/W) $69 () \[rA] Display Control 1
.IP \[bu] 2
bit 7 = Layer 2 Enable (Port $123B bit 1 alias)
.IP \[bu] 2
bit 6 = ULA Shadow display enable (Port $7FFD bit 3 alias)
.IP \[bu] 2
bits 5-0 = Timex alias (Port $FF alias)
.PP
Register (R/W) $70 () \[rA] Layer 2 Control
.IP \[bu] 2
bits 7-6 = Reserved, must be 0
.IP \[bu] 2
bits 5-4 = Resolution (00 on soft reset)
.RS 2
.IP \[bu] 2
00 = 256\[u2005]\[tmu]\[u2005]192\[u2005]\[tmu]\[u2005]256
.IP \[bu] 2
01 = 320\[u2005]\[tmu]\[u2005]256\[u2005]\[tmu]\[u2005]256
.IP \[bu] 2
10 = 640\[u2005]\[tmu]\[u2005]256\[u2005]\[tmu]\[u2005]16
.IP \[bu] 2
11 = Do not use
.RE
.IP \[bu] 2
bits 3-0 = Palette offset ($0 on soft reset)
.SS Layer 2 256\[u2005]\[tmu]\[u2005]192, Write only overlaid on ROM
.IP
.nf
\f[C]
p_layer2: defl $123b
start:
  ld bc,p_layer2
  ld a,$03       ; enable, wo, 1st 16k
  out (c),a
  call wrtpage
  ld bc,p_layer2
  ld a,$43       ; enable, wo, 2nd 16k
  out (c),a
  call wrtpage
  ld bc,p_layer2
  ld a,$83       ; enable, wo, 3rd 16k
  out (c),a
  call wrtpage
  ret
wrtpage:  
  ld hl,$0000
  ld bc,$0040    ; 40*256 writes
loop:
  ld (hl),b
  inc hl
  djnz loop
  dec c
  jr nz,loop
\f[R]
.fi
.SS Layer 2 256\[u2005]\[tmu]\[u2005]192 resolution
.IP
.nf
\f[C]
r_mmu_7:  defl $57
r_disp1:  defl $69
r_layer2: defl $70
start:
  nextreg r_disp1,$80  ; enable layer 2
  nextreg r_layer2,$00 ; 256x192x256
  ld a,$12             ; page 18=bank 9
loop1:
  nextreg r_mmu_7,a    ; map page into slot 7
  ld bc,$0020          ; 20*256 = 8k
  ld hl,$E000          ; address of slot 7
loop2:
  ld (hl),b
  inc hl
  djnz loop2
  dec c
  jp NZ,loop2
  inc a
  cp $18               ; stop at page 24
  jp NZ,loop1
\f[R]
.fi
.SS Layer 2 320\[u2005]\[tmu]\[u2005]256 resolution
.IP
.nf
\f[C]
r_mmu_7:  defl $57
r_disp1:  defl $69
r_layer2: defl $70
start:
  nextreg r_disp1,$80  ; enable layer 2
  nextreg r_layer2,$10 ; 320x256x256
  ld a,$12             ; page 18=bank 9
loop1:
  nextreg r_mmu_7,a    ; map page into slot 7
  ld bc,$0020          ; 20*256 = 8k
  ld hl,$E000          ; start of slot 7
loop2:
  ld (hl),b
  inc hl
  djnz loop2
  dec c
  jp NZ,loop2
  inc a
  cp $1C               ; stop at page 28
  jp NZ,loop1
\f[R]
.fi
.SS Layer 2 640\[u2005]\[tmu]\[u2005]256 resolution
.IP
.nf
\f[C]
r_mmu_7:  defl $57
r_disp1:  defl $69
r_layer2:  defl $70
start:
  nextreg r_disp1, $80   ; enable layer 2
  nextreg r_layer2, $20  ; 640x256x16
  ld a, $12    ; page 18=bank 9
loop1:
  nextreg r_mmu_7, a  ; map page into slot 7
  ld bc, $0020    ; 20*256 = 8k
  ld hl, $E000    ; start address for slot 7
loop2:
  ld (hl), b
  inc hl
  djnz loop2
  dec c
  jp NZ, loop2
  inc a
  cp $1C      ; stop at page 28
  jp NZ, loop1
\f[R]
.fi
.SS Scrolling
.PP
Scrolling Layer 2 is controlled by registers $16 and $17.
(Is there a third scrolling register for layer 2?)
.PP
Register (R/W) $16 () \[rA] Layer 2 Horizontal Scroll Control
.IP \[bu] 2
bits 7-0 = X Offset (0-255)(0 on reset)
.PP
Register (R/W) $17 () \[rA] Layer 2 Vertical Scroll Control
.IP \[bu] 2
bits 7-0 = Y Offset (0-191)(0 on reset)
.SS Clipping
.PP
The Clip area for is based on the local coordinate system for the mode
in question and is set using register $18 with the option of selection
which write in active using register $1C.
.PP
Register (R/W) $18 () \[rA] Layer 2 Clip Window Definition
.IP \[bu] 2
bits 7-0 = Coords of the clip window
.RS 2
.IP \[bu] 2
1st write - X1 position
.IP \[bu] 2
2nd write - X2 position
.IP \[bu] 2
3rd write - Y1 position
.IP \[bu] 2
4rd write - Y2 position
.RE
.PP
Reads do not advance the clip position
.PD 0
.P
.PD
The values are 0,255,0,191 after a Reset
.PP
Register (R/W) $1C () \[rA] Clip Window Control
.PD 0
.P
.PD
Read
.IP \[bu] 2
bits 7-6 = Layer 3 Clip Index
.IP \[bu] 2
bits 5-4 = Layer 0/1 Clip Index
.IP \[bu] 2
bits 3-2 = Sprite clip index
.IP \[bu] 2
bits 1-0 = Layer 2 Clip Index
.PP
Write
.IP \[bu] 2
bits 7-4 = Reserved, must be 0
.IP \[bu] 2
bit 3 - reset Layer 3 clip index
.IP \[bu] 2
bit 2 - reset Layer 0/1 clip index
.IP \[bu] 2
bit 1 - reset sprite clip index.
.IP \[bu] 2
bit 0 - reset Layer 2 clip index.
.SS Layer 3 (Tilemap) Mode
.PP
Started with documentation by Phoebus Dokos, February 25, 2019.
Partially rewritten for clarity and to add core 3.00.00 features.
.SS General Description
.PP
The tilemap is a hardware character oriented display.
It uses a set of user defined 4-bit, 16-colour, or 1-bit, 2-colour
8\[u2005]\[tmu]\[u2005]8 tiles.
The tiles can be dispplayed in two resolutions:
40\[u2005]\[tmu]\[u2005]32 tiles (320\[u2005]\[tmu]\[u2005]256 pixels)
and 80\[u2005]\[tmu]\[u2005]32 tiles (640\[u2005]\[tmu]\[u2005]256
pixels).
.PP
The display area on screen is the same as the sprite layer, meaning it
overlaps the standard 256\[u2005]\[tmu]\[u2005]192 area by 32 pixels on
all sides.
Vertically this is larger than the physical HDMI display, which will cut
off the top and bottom character rows making the visible area
40\[u2005]\[tmu]\[u2005]30 or 80\[u2005]\[tmu]\[u2005]30, but the full
area is visible on VGA.
.PP
The obvious application for the tilemap is for a fast, clearly readable
and wide multicoloured character display.
Less obvious perhaps is that it can also be used to make fast and wide
resolution full colour backgrounds with easily animated components such
as have historically been used in many games.
.PP
The tilemap is defined by two data structures and configured using four
NextRegs.
The NextRegs are $6b (107), Tilemap Control; $6c (108), Default Tilemap
Attribute, $6c (110); Tilemap Base Address; and $6d (111) Tile
Definitions Base Address.
.SS Data Structures
.SS Tilemap
.PP
The first data structure is the tilemap itself which indicates what
characters occupy each cell on screen.
Each tilemap entry is either one or two bytes.
.PP
If entries are two bytes each, the first byte for each entry is bits 0-7
of the tile number, while the second byte is an attribute byte which is
interpreted acctording to the mode set in the tilemap control register
($6b).
For 40\[u2005]\[tmu]\[u2005]32 resolution, a full size tilemap will
occupy 2560 bytes, and for 80\[u2005]\[tmu]\[u2005]32 resolution the
space taken is twice that at 5120 bytes.
The tilemap entries are stored in X-major order and each two-byte
tilemap entry consists of a tile number byte (bits 0-7 of the tile
number) followed an attribute byte:
.PP
Tilemap Attribute Byte 4-bit
.IP \[bu] 2
bits 7-4 : most significant 4-bits of palette entry
.IP \[bu] 2
bit 3 : x mirror
.IP \[bu] 2
bit 2 : y mirror
.IP \[bu] 2
bit 1 : rotate
.IP \[bu] 2
bit 0 : ULA over tilemap (in 512 tile mode, bit 8 of the tile number)
.PP
Tilemap Attribute Byte 1-bit
.IP \[bu] 2
bits 7-1 : most significan 7-bits of palette entry
.IP \[bu] 2
bit 0 : ULA over tilemap (in 512 tile mode, bit 8 of the tile number)
.PP
The character displayed is indicated by the \[lq]tile number\[rq] which
can be thought of as an ASCII code.
The tile number is normally eight bits allowing up to 256 unique tiles
to be displayed but this can be extended to nine bits for 512 unique
tiles if 512 tile mode is enabled via the Tilemap Control register
($6b).
.PP
The other bits are tile attributes that modify how the tile image is
drawn.
Their function is the same as the equivalent sprite attributes for
sprites.
Bits apply rotation then mirroring, and colour can be shifted with a
palette offset.
If 512 tile mode is not enabled, bit 8 will determine if the tile is
above or below the ULA display on a per tile basis.
.PP
When using 1-byte tilemap entries, the map consists of the tile numbers
for tile in the map with the tilemap attribute byte for every tile
coming from the default tilemap attribute register ($6c).
.SS Tile Definitions
.PP
The second data structure is the tile definitions themselves.
To find the difinition for a specific tile you would look at (base
address) + (tile number) * (definition size).
.PP
For 4-bit, 16-colour, tiles, each 8\[u2005]\[tmu]\[u2005]8 tile takes up
32 bytes.
Each pixel uses four bits to select one of 16 colours.
A tile is defined in X major order with packing in the X direction in
the same way that 4-bit sprites are defined.
The 4-bit colour of each pixel is augmented by the 4-bit palette offset
from the tilemap in the most significant bits to form an 8-bit colour
index that is looked up in the tilemap palette to determine the final
9-bit colour sent to the display.
Ane of the 16 colours for each tile is the transparency color.
.PP
For 1-bit, 2-colour, tiles, each 8\[u2005]\[tmu]\[u2005]8 tile takes up
8 bytes.
Each pixel uses one bit to select one of two colours.
A tile is defined in X major order with packing in the X direction.
The 1-bit colour of each pixel is augmented by the 7-bit palette offset
from the tilemap in the most significant bits to form an 8-bit colour
index that is looked up in the tilemap palette to determine the final
9-bit colour sent to the display.
Transparency for each tile is according to the global transparency
colour.
.SS Memory Organization & Display Layer
.PP
The tilemap is a logical extension of the ULA and its data structures
are contained in 16k banks 5 and 7 (first half only).
If both the ULA and tilemap are enabled, this means that the
tilemap\[cq]s map and tile definitions should be arranged within the 24k
to avoid overlap with the display ram used by the ULA.
.PP
The tilemap exists on the same display layer as the ULA.
The graphics generated by the ULA and tilemap are combined before being
forwarded to the SLU layer system as layer U.
.SS Combining ULA & Tilemap
.PP
The combination of the ULA and tilemap is done in one of two modes: the
standard mode or the stencil mode.
.PP
The standard mode uses bit 8 of a tile\[cq]s tilemap entry to determine
if a tile is above or below the ULA.
The source of the final pixel generated is then the topmost
non-transparent pixel.
If the ULA or tilemap is disabled then they are treated as transparent.
.PP
The stencil mode will only be applied if both the ULA and tilemap are
enabled.
In the stencil mode, the final pixel will be transparent if either the
ULA or tilemap are transparent.
Otherwise the final pixel is a logical AND of the corresponding colour
bits.
The stencil mode allows one layer to act as a cut-out for the other.
.SS Programming Tilemap mode
.PP
Register (R/W) $6B () \[rA] Layer 3 (Tilemap) Control
.IP \[bu] 2
bit 7 = Layer 3 Enable (0 on reset)
.IP \[bu] 2
bit 6 = Layer 3 Size control (0 on reset)
.RS 2
.IP \[bu] 2
0 = 40x32
.IP \[bu] 2
1 = 80x32
.RE
.IP \[bu] 2
bit 5 = Disable Arrtibute Entry (0 on reset)
.IP \[bu] 2
bit 4 = palette select (0 on reset)
.IP \[bu] 2
bit 3 = Enable Text mode (1-bit tilemap) (0 on reset)
.IP \[bu] 2
bit 2 = Reserved, must be 0
.IP \[bu] 2
bit 1 = Activate 512 tile mode (0 on reset)
.IP \[bu] 2
bit 0 = Enable Layer 3 on top of ULA (0 on reset)
.PP
Bits 7 & 6 enable the tilemap and select resolution.
Bit 4 selects one of two tilemap palettes used for final colour lookup.
Bit 5 changes the structure of the tilemap so that it contains only
8-bit tilemap entries instead of 16-bit tilemap entries.
If 8-bit, the tilemap only contains tile numbers and the attributes are
instead taken from nextreg $6C.
.PP
Bit 5 determines whether the attribute byte for each tile come from the
tilemap (0) or from the default tile attribute register (1).
.PP
Bit 4 selects either the primary tilemap palette (0) or the secondary
tilemap palette (1).
.PP
Bit 3 selects whether to use 4-bit, 16-colour, or 1-bit 2-colour tiles.
.PP
Bit 1 activates 512 tile mode.
In this mode, the \[lq]ULA over tilemap\[rq] bit in a tile\[cq]s
attribute is re-purposed as the ninth bit of the tile number, allowing
up to 512 unique tiles to be displayed.
In this mode, the ULA is always on top of the tilemap.
.PP
Bit 0 forces the tilemap to be on top of the ULA.
It can be useful in 512 tile mode to change the relative display order
of the ULA and tilemap.
.PP
Register (R/W) $6C () \[rA] Default Layer 3 Attribute*
.IP \[bu] 2
bits 7-4 = Palette Offset ($00 on reset)
.IP \[bu] 2
bit 3 = X mirror (0 on reset)
.IP \[bu] 2
bit 2 = Y mirror (0 on reset)
.IP \[bu] 2
bit 1 = Rotate (0 on reset)
.IP \[bu] 2
bit 0 = Bit 8 of the tile number (512 tile mode) (0 on reset)
.IP \[bu] 2
bit 0 = ULA over tilemap (256 tile mode) (0 on reset)
.PP
*Active tile attribute if bit 5 of nextreg $6B is set.
.PP
If bit 5 of nextreg $6B is set, the tilemap structure is modified to
contain only 8-bit tile numbers instead of the usual 16-bit tilemap
entries.
In this case, the tile attributes used are taken from this register
instead.
.PP
Register (R/W) $6E () \[rA] Layer 3 Tilemap Base Address
.IP \[bu] 2
bit 7 = Bank Select (3.01.08)
.RS 2
.IP \[bu] 2
0 = Bank 5
.IP \[bu] 2
1 = Bank 7
.RE
.IP \[bu] 2
bit 6 = Reserved, must be 0
.IP \[bu] 2
bits 5-0 = MSB of address of the tilemap in Bank 5 (16k) or 7 (8k) ($2C
on reset)
.PP
Soft Reset default $2C - This is because the address is $6C00 so the MSB
is $6C.
But the stored value is only the lower 6 bits so it\[cq]s an offset into
the 16k Bank 5.
To calculate therefore subtract $40 leaving you with $2C.
.PP
The value written is an offset into the 16k Bank 5 or the 8k lower half
of Bank 7 allowinf the tilemap to be placed at any multiple of 256
bytes.
.PP
This register determines the tilemap\['i]s base address in bank 5.
The base address is the MSB of an offset into the 16k bank, allowing the
tilemap to begin at any multiple of 256 bytes in the bank.
Writing a physical MSB address in $40-$7f or $c0-$ff, corresponding to
traditional ULA physical addresses, is permitted.
The value read back should be treated as a fully significant 8-bit
value.
.PP
The tilemap will be 40\[u2005]\[tmu]\[u2005]32 or
80\[u2005]\[tmu]\[u2005]32 in size depending on the resolution selected
in nextreg $6B.
Each entry in the tilemap is normally two bytes but can be one byte if
attributes are eliminated by setting bit 5 of nextreg $6B.
.PP
Register (R/W) $6F () \[rA] Layer 3 Tile Definitions Base Address
.IP \[bu] 2
bit 7 = Select bank (3.01.08)
.RS 2
.IP \[bu] 2
0 = Bank 5
.IP \[bu] 2
1 = Bank 7
.RE
.IP \[bu] 2
bit 6 = Reserved, must be 0
.IP \[bu] 2
bits 5-0 = MSB of address of the tile definitions in Bank 5 (16k) or 7
(8k) ($0C on reset)
.PP
Soft Reset default $0C - This is because the address is $4C00 so the MSB
is $4C.
But the stored value is only the lower 6 bits so it\[cq]s an offset into
the 16k Bank 5.
To calculate therefore subtract $40 leaving you with $0C.
.PP
The value written is an offset into the 16k Bank 5 or the 8k lower half
of Bank 7 allowing the tilemap to be placed at any multiple of 256
bytes.
.PP
This register determines the base address of tile definitions in bank 5.
As with nextreg $6E, the base address is the MSB of the an offset into
the 16k bank, allowing tile definitions to begin at any multiple of 256
bytes in the bank.
Writing a physical MSB address in $40-$7f or $c0-$ff, corresponding to
traditional ULA physical addresses, is permitted.
The value read back should be treated as a fully significant 8-bit
value.
.PP
Each tile definition is 32 bytes in size and is located at address:
.PD 0
.P
.PD
Tile Def Base Addr + 32 * (Tile Number)
.PP
Register (R/W) $4C () \[rA] Level 3 Transparency Index
.IP \[bu] 2
bits 7-4 = Reserved, must be 0
.IP \[bu] 2
bits 3-0 = Index value ($0F on reset)
.PP
Defines the transparent colour index for 4-bit tiles.
The 4-bit pixels of a tile definition are compared to this value to
determine if they are transparent.
In the case of 1-bit tiles transparency is determined by comparing the
final pixel colour against the global transparency colour.
.PP
For palette information see palette section.
.PP
Register (R/W) $1B () \[rA] Layer 3 (Tilemap) Clip Window Definition
.IP \[bu] 2
bits 7-0 = Coord.
of the clip window
.RS 2
.IP \[bu] 2
1st write = X1 position
.IP \[bu] 2
2nd write = X2 position
.IP \[bu] 2
3rd write = Y1 position
.IP \[bu] 2
4rd write = Y2 position
.RE
.PP
The values are 0,159,0,255 after a Reset
.PD 0
.P
.PD
Reads do not advance the clip position
.PD 0
.P
.PD
The X coords are internally doubled.
.PP
The tilemap display surface extends 32 pixels around the central
256\[u2005]\[tmu]\[u2005]192 display.
The origin of the clip window is the top left corner of this area 32
pixels to the left and 32 pixels above the central
256\[u2005]\[tmu]\[u2005]192 display.
The X coordinates are internally doubled to cover the full 320 pixel
width of the surface.
The clip window indicates the portion of the tilemap display that is
non-transparent and its indicated extent is inclusive; it will extend
from X1*2 to X2*2+1 horizontally and from Y1 to Y2 vertically.
.PP
Register (R/W) $2F () \[rA] Layer 3 (Tilemap) Horizontal Scroll Control
MSB
.IP \[bu] 2
bits 7-2 = Reserved, must be 0
.IP \[bu] 2
bits 1-0 = X Offset MSB ($00 on reset)
.PP
Meaningful Range is 0-319 in 40 char mode, 0-639 in 80 char mode
.PP
Register (R/W) $30 () \[rA] Layer 3 (Tilemap) Horizontal Scroll Control
LSB
.IP \[bu] 2
bits 7-0 = X Offset LSB ($00 on reset)
.PP
Meaningful range is 0-319 in 40 char mode, 0-639 in 80 char mode
.PP
Register (R/W) $31 () \[rA] Layer 3 (Tilemap) Vertical Scroll Control
.IP \[bu] 2
bits 7-0 = Y Offset (0-255) )$00 on reset)
.PP
Register (R/W) $68 () \[rA] ULA Control
.IP \[bu] 2
bit 7 = Disable ULA output (0 on reset)
.IP \[bu] 2
bit 6-5 = Color blending control for layering modes 6 & 7 (3.01.01)
.RS 2
.IP \[bu] 2
00 = ULA as blend colour
.IP \[bu] 2
01 = No blending
.IP \[bu] 2
10 = ULA/Tilemap mix result as blend colour
.IP \[bu] 2
11 = Tilemap as blend colour
.RE
.IP \[bu] 2
bit 4 = Cancel entries in 8x5 matrix for extended keys (3.01.04)
.IP \[bu] 2
bit 3 = Enable ULAplus (0 on reset)
.IP \[bu] 2
bit 2 = Enable ULA half pixel scroll (0 on reset)
.IP \[bu] 2
may change
.IP \[bu] 2
bit 1 = Reserved (must be 0)
.IP \[bu] 2
bit 0 = Enable stencil mode (0 on reset)
.IP \[bu] 2
When ULA and Layer 3 are enabled, if either are transparent, the result
is transparent, otherwise the result is the logical AND of both colours.
.PP
Bit 0 can be set to choose stencil mode for the combined output of the
ULA and tilemap.
Bit 6 determines what colour is used in SLU modes 6 & 7 where the ULA is
combined with Layer 2 to generate highlighting effects.
.SS Changes Since 2.00.26
.IP "1." 3
512 Tile Mode.
In 2.00.26, the 512 tile mode was automatically selected when the ULA
was disabled.
With the ULA disabled, the tilemap attribute bit \[lq]ULA on top\[rq]
was re-purposed to be bit 8 of the tile number.
In 2.00.27, selection of the 512 tile mode is moved to bit 1 of Tilemap
Control nextreg $6B.
This way 512 tile mode can be independently chosen without disabling the
ULA.
The \[lq]ULA on top\[rq] bit is still taken as bit 8 of the tile number
and in the 512 mode, the tilemap is always displayed underneath the ULA.
.IP "2." 3
Tilemap Always On Top of ULA.
In 2.00.27, bit 0 of Tilemap Control nextreg $6B is used to indicate
that the tilemap should always be displayed on top of the ULA.
This allows the tilemap to display over the ULA when in 512 mode.
.IP "3." 3
1-bit tilemaps.
In 3.00.00, a number of modifications were made to accomidate 1-bit
tilemaps.
.SS Future Direction
.PP
The following compatible changes may be applied at a later date:
.IP "1." 3
Addition of a bit to Tilemap Control to select a reduced tilemap area of
size 32\[u2005]\[tmu]\[u2005]24 or 64\[u2005]\[tmu]\[u2005]24 that
covers the ULA screen.
.IP "2." 3
Addition of a bit to Tilemap Control to select split addressing where
the tilemap\[cq]s tiles and attributes as well as the tile definitions
are split between the two 8k halves of the 16k ULA ram in the same way
that the two Timex display files are split.
The intention is to make it easier for the tilemap to co-exist with all
the display modes of the ULA.
.SS Sprites
.PP
February 25, 2019 Victor Trucco
.PP
The Spectrum Next has a hardware sprite system with the following
characteristics:
.IP \[bu] 2
Total of 128 sprites
.IP \[bu] 2
Display surface is 320\[u2005]\[tmu]\[u2005]256 overlapping the ULA
screen by 32 pixels on each side
.IP \[bu] 2
Minimum of 100 sprites per scanline*
.IP \[bu] 2
Choice of 512 colours for each pixel
.IP \[bu] 2
Site of each sprite is 16\[u2005]\[tmu]\[u2005]16 pixels but sprites can
be magnified 2\[tmu], 4\[tmu] or 8\[tmu] horizontally and vertically
.IP \[bu] 2
Sprites can be mirrored and rotated
.IP \[bu] 2
Sprites can be grouped together to form larger sprites under the control
of a single anchor
.IP \[bu] 2
A 16K pattern memory can contain 64 8-bit sprite images or 128 4-bit
sprite images and combinations in-between
.IP \[bu] 2
A per sprite palette offset allows sprites to share images but colour
them differently
.IP \[bu] 2
A nextreg interface allows the copper to move sprites during the video
frame
.PP
*A minimum of 100 16\[u2005]\[tmu]\[u2005]16 sprites is guaranteed to be
displayed in any scanline.
Any additional sprites will not be displayed with the hardware ensuring
sprites are not partially plotted.
.PP
The actual limit is determined by how many 28MHz clock cycles there are
in a scanline.
The sprite hardware is able to plot one pixel cycle and uses one cycle
to qualify each sprite.
Since the number of cycles there are in a scanline varies with video
timing (HDMI, VGA), the number of pixels that can be plotted also varies
but the minimum will be 1600 pixels per line including overhead cycles
needed to qualify 100 sprites.
Since sprites magified horizontally involve plotting more pixels,
2\[tmu], 4\[tmu], and 8\[tmu] sprites will take more cycles to plot and
the presence of these sprites in a line will reduce the total number of
sprites that can be plotted.
.SS Sprite Patterns
.PP
Sprite patterns are the images that each sprite can take on.
The images are stored in a 16K memory internal to the FPGA and are
identified by pattern number.
A particular sprite chooses a pattern by storing a pattern number in its
attributes.
.PP
All sprites are 16\[u2005]\[tmu]\[u2005]16 pixels in size but the come
in two flavours: 4-bit and 8-bit.
The bit width describes how many bits are used to code the colour of
each pixel.
.PP
An 8-bit sprite uses a full byte to colour each of its pixels so that
each pixel can be one of 256 colours.
In this case, a 16\[u2005]\[tmu]\[u2005]16 sprite requires 256 bytes of
pattern memory to store its image.
.PP
A 4-bit sprite uses a nibble to colour each of its pixels so that each
pixel can be one of 16 colours.
In this case, a 16\[u2005]\[tmu]\[u2005]16 sprite requires just 128
bytes of pattern memory to store its image.
.PP
The 16K pattern memory can contain any combination of these images,
whether they are 128 bytes or 256 bytes and their locations in the
pattern memory are described by a pattern number.
This pattern number is 7 bits with bits named as follows:
.SS Pattern Number
.IP
.nf
\f[C]
N5 N4 N3 N2 N1 N0 N6
\f[R]
.fi
.PP
N6, despite the name, is the least significant bit.
.PP
This 7-bit pattern number can identify 128 patterns in the 16k pattern
memory, each of which are 128 bytes in size.
The full 7-bits are therefore used for 4-bit sprites.
.PP
For 8-bit sprites, N6=0 always.
The remaining 6 bits can identify 64 patterns, each of which is 256
bytes in size.
.PP
The N5:N0,N6 bits are stored in a particular sprite\[cq]s attributes to
identify which image a sprite uses.
.SS 8-Bit Sprite Patterns
.PP
The 16\[u2005]\[tmu]\[u2005]16 pixel image uses 8-bits for each pixel so
that each pixel can be one of 256 colours.
One colour indicates transparency and this is programmed into the Sprite
Transparency Index register (nextreg $4B).
By default the transparent value is $E3.
.PP
As an example of an 8-bit sprite, let\[cq]s have a look at figure 1.1.
.PP
[IMAGE: Pattern Example]
.PP
Using the default palette, which is initialised with RGB332 colours from
0-255, the hexadecimal values for this pattern arranged in a
16\[u2005]\[tmu]\[u2005]16 array are shown below:
.IP
.nf
\f[C]
04040404040404E3E3E3E3E3E3E3E3E3
04FFFFFFFFFF04E3E3E3E3E3E3E3E3E3
04FFFBFBFBFF04E3E3E3E3E3E3E3E3E3
04FFFBF5F5FBFF04E3E3E3E3E3E3E3E3
04FFFBF5A8A8FBFF04E3E3E3E3E3E3E3
04FFFFFBA844A8FBFF04E3E3E3E3E3E3
040404FFFBA844A8FBFF04E3E3E3E3E3
E3E3E304FFFBA84444FBFF04E304E3E3
E3E3E3E304FFFB444444FBFF044D04E3
E3E3E3E3E304FFFB44444444FA4D04E3
E3E3E3E3E3E304FFFB44FFF54404E3E3
E3E3E3E3E3E3E304FF44F5A804E3E3E3
E3E3E3E3E3E3E3E304FA4404A804E3E3
E3E3E3E3E3E3E3044D4D04E304F504E3
E3E3E3E3E3E3E3E30404E3E3E304FA04
E3E3E3E3E3E3E3E3E3E3E3E3E3E30404
\f[R]
.fi
.PP
Here $E3 is used as the transparent index.
.PP
These 256 bytes would be stored in pattern memory in left to right, top
to bottom order.
.SS 4-Bit Sprite Patterns
.PP
The 16\[u2005]\[tmu]\[u2005]16 pixel image uses 4-bits for each pixel so
that each pixel can be one of 16 colours.
One colour indicates transparency and this is programmed into the lower
4-bits of the Sprite Transparency Index register (nextreg $4B).
By default the transparency value is $3.
Note that the same register is shared with 8-bit patterns to identify
the transparent index.
.PP
Since each pixel only occupies 4-bits, two pixels are stored in each
byte.
The leftmost pixel is stored in the upper 4-bits and the rightmost pixel
is stored in the lower 4-bits.
.PP
As an example we will use the same sprite image as was given in the
8-bit pattern example.
Here only the lower 4 bits of each pixel is retained to confine each
pixel\[cq]s color to 4-bits:
.IP
.nf
\f[C]
4444444333333333
4FFFFF4333333333
4FBBBF4333333333
4FB55BF433333333
4FB588BF43333333
4FFB848BF4333333
444FB848BF433333
3334FB844BF43433
33334FB444BF4D43
333334FB4444AD43
3333334FB4F54433
33333334F4584333
333333334A448433
33333334DD434543
33333333443334A4
3333333333333344
\f[R]
.fi
.PP
$3 is used as the transparent index.
.PP
These 128 bytes would be stored in pattern memory in left to right, top
to bottom order.
.PP
The actual colour that will appear on screen will depend on the palette,
described below.
The default palette will not likely generate suitable colours for 4-bit
sprites.
.SS Sprite Palette
.PP
Each pixel of a sprite image is 8-bit for 8-bit patterns or 4-bit for
4-bit patterns.
The pixel value is known as a pixel colour index.
This colour index is combined with the sprite\[cq]s palette offset.
The palette offset is a 4-bit value added to the top 4-bits of the pixel
colour index.
The purpose of the palette offset is to allow a sprite to change the
colour of an image.
.PP
The final sprite colour index generated by the sprite hardware is then
the sum of the pixel index and the 4-bit palette offset.
In pictures using binary math:
.IP
.nf
\f[C]
8-bit Sprite
PPPP0000
+ IIIIIIII
----------
SSSSSSSS

4-bit Sprite
PPPP0000
+ 0000IIII
----------
SSSSSSSS = PPPPIIII
\f[R]
.fi
.PP
Where \[lq]PPPP\[rq] is the 4-bit palette offset from the sprite\[cq]s
attributes and the \[lq]I\[rq]s represent the pixel value from the
sprite pattern.
The final sprite index is represented by the 8-bit value
\[lq]SSSSSSSS\[rq].
.PP
For 4-bit sprites the palette offset can be thought of as selecting one
of 16 different 16-colour palettes.
.PP
This final 8-bit sprite index is then passed through the sprite palette
which acts like a lookup table that returns the 9-bit RGB333 colour
associated with the sprite index.
.PP
At power up, the sprite palette is initialized such that the sprite
index passes through unchanged and is therefore interpretted as an
RGB332 colour.
The missing third blue bit is generated as the logical OR of the two
other blue bits.
In short, for 8-bit sprites, the sprite index also acts like the colour
when using the default palette.
.SS Sprite Attributes
.PP
A sprite\[cq]s attributes is a list of properties that determine how and
where the sprite is drawn.
.PP
Each sprite is described by either 4 or 5 attribute bytes listed below:
.PP
Sprite Attribute 0
.IP
.nf
\f[C]
X X X X X X X X
\f[R]
.fi
.PP
The least significant eight bits of the sprite\[cq]s X coordinate.
The ninth bit is found in sprite attribute 2.
.PP
Sprite Attribute 1
.IP
.nf
\f[C]
Y Y Y Y Y Y Y Y
\f[R]
.fi
.PP
The least significant eight bits of the sprite\[cq]s Y coordinate.
The ninth bit is optional and is found in attribute 4.
.PP
Sprite Attribute 2
.IP
.nf
\f[C]
P P P P XM YM R X8/PR
\f[R]
.fi
.PP
P = 4-bit Palette Offset
.PD 0
.P
.PD
XM = 1 to mirror the sprite image horizontally
.PD 0
.P
.PD
YM = 1 to mirror the sprite image vertically
.PD 0
.P
.PD
R = 1 to rotate the sprite image 90 degrees clockwise
.PD 0
.P
.PD
X8 = Ninth bit of the sprite\[cq]s X coordinate
.PD 0
.P
.PD
PR = 1 to indicate P is relative to the anchor\[cq]s palette offset
(relative sprites only)
.PD 0
.P
.PD
Rotation is applied before mirroring.
.PD 0
.P
.PD
Relative sprites, described below, replace X8 with PR.
.PP
[IMAGE: All Rotate and Mirror Flags]
.PP
Sprite Attribute 3
.IP
.nf
\f[C]
V E N5 N4 N3 N2 N1 N0
\f[R]
.fi
.PP
V = 1 to make the sprite visible
.PD 0
.P
.PD
E = 1 to enable attribute byte 4
.PD 0
.P
.PD
N = Sprite pattern to use 0-63
.PD 0
.P
.PD
If E=0, the sprite is fully described by sprite attributes 0-3.
The sprite pattern is an 8-bit one identified by pattern N=0-63.
The sprite is an anchor and cannot be made relative.
The sprite is displayed as if sprite attribute 4 is zero.
.PD 0
.P
.PD
If E=1, the sprite is further described by sprite attribute 4.
.PP
Sprite Attribute 4
.IP "A." 3
Extended Anchor Sprite
.RS 4
.IP
.nf
\f[C]
H N6 T X X Y Y Y8
\f[R]
.fi
.PP
H = 1 if the sprite pattern is 4-bit
.PD 0
.P
.PD
N6 = 7th pattern bit if the sprite pattern is 4-bit
.PD 0
.P
.PD
T = 0 if relative sprites are composite type else 1 for unified type
.PD 0
.P
.PD
XX = Magnification in the X direction (00 = 1\[tmu], 01 = 2\[tmu], 10 =
4\[u2005]\[tmu]\[u2005]4, 11 = 8\[tmu])
.PD 0
.P
.PD
YY = Magnification in the Y direction (00 = 1\[tmu], 01 = 2\[tmu], 10 =
4\[tmu], 11 = 8\[tmu])
.PD 0
.P
.PD
Y8 = Ninth bit of the sprite\[cq]s Y coordinate
.PD 0
.P
.PD
H,N6 must not equal 0,1 as this combination is used to indicate a
relative sprite.
.RE
.IP "B." 3
Relative Sprite, Composite Type
.RS 4
.IP
.nf
\f[C]
0 1 N6 X X Y Y PO
\f[R]
.fi
.PP
N6 = 7th pattern bit if the sprite pattern is 4-bit
.PD 0
.P
.PD
XX = Magnification in the X direction (00 = 1\[tmu], 01 = 2\[tmu], 10 =
4\[tmu], 11 = 8\[tmu])
.PD 0
.P
.PD
YY = Magnification in the Y direction (00 = 1\[tmu], 01 = 2\[tmu], 10 =
4\[tmu], 11 = 8\[tmu])
.PD 0
.P
.PD
PO = 1 to indicate the sprite pattern number is relative to the
anchor\[cq]s
.RE
.IP "C." 3
Relative Sprite, Unified Type
.RS 4
.IP
.nf
\f[C]
0 1 N6 0 0 0 0 PO
\f[R]
.fi
.PP
N6 = 7th pattern bit if the sprite pattern is 4-bit
.PD 0
.P
.PD
PO = 1 to indicate the sprite pattern number is relative to the
anchor\[cq]s
.RE
.PP
The display surface for sprites is 320\[u2005]\[tmu]\[u2005]256.
The X coordinate of the sprite is nine bits, ranging over 0-511, and the
Y coordinate is optionally nine bits again ranging over 0-511 or is
eight bits ranging over 0-255.
The full extent 0-511 wraps on both axes, meaning a sprite 16 pixels
wide plotted at X coordinate 511 would see its first pixel not displayed
(coordinate 511) and the following pixels displayed in coordinates 0-14.
.PP
The full display area is visible in VGA.
However, the HDMI display is vertically shorter so the top eight pixel
rows (Y = 0-7) and the bottom eight pixel rows (Y = 248-255) will not be
visible on an HDMI display.
.PP
Sprites can be fully described by sprite attributes 0-3 if the E bit in
sprite attribute 3 is zero.
These sprites are compatible with the original sprite module from core
versions prior to 2.00.26.
.PP
If the E bit is set then a fifth sprite attribute, sprite attribute 4,
becomes active.
This attribute introduces scaling, 4-bit patterns, and relative sprites.
Scaling is self-explanatory and 4-bit patterns were described in the
last section.
Relative sprites are described in the next section.
.SS Relative Sprites
.PP
Normal sprites (sprites that are not relative) are known as anchor
sprites.
As the sprite module draws sprites in the order 0-127 (there are 128
sprites), it internally stores characteristics of the last anchor sprite
seen.
If following sprites are relative, they inherit some of these
characteristics, which allows relative sprites to have, among other
things, coordinates relative to the anchor.
This means moving the anchor sprite also causes its relatives to move
with it.
.PP
There are two types of relative sprites supported known as
\[lq]Composite Sprites\[rq] and \[lq]Unified Sprites\[rq].
The type is determined by the anchor in the T bit of sprite attribute 4.
.IP "A." 3
Composite Sprites
.PD 0
.P
.PD
The sprite module records the following information from the anchor:
.RS 4
.IP \[bu] 2
Anchor.visible
.IP \[bu] 2
Anchor.Y
.IP \[bu] 2
Anchor.palette_offset
.IP \[bu] 2
Anchor.N (pattern number)
.IP \[bu] 2
Anchor.H (indicates if the sprite uses 4-bit patterns)
.PP
These recorded items are not used by composite sprites:
.IP \[bu] 2
Anchor.rotate
.IP \[bu] 2
Anchor.xmirror
.IP \[bu] 2
Anchor.ymirror
.IP \[bu] 2
Anchor.xscale
.IP \[bu] 2
Anchor.yscale
.PP
The anchor determines if all its relative sprites use 4-bit patterns or
not.
.PP
The visibility of a particular relative sprite is the result of ANDing
the anchor\[cq]s visibility with the relative sprite\[cq]s visibility.
In other words, if the anchor is invisible then so are all its
relatives.
.PP
Relative sprites only have 8-bit X and Y coordinates (the ninth bits are
taken for other purposes).
These are signed offsets from the anchor\[cq]s X,Y coordinate.
Moving the anchor moves all its relatives along with it.
.PP
If the relative sprite has its PR bit set in sprite attribute 2, then
the anchor\[cq]s palette offset is added to the relative sprite\[cq]s to
determine the active palette offset for the relative sprite.
Otherwise the relative sprite uses its own palette offset as usual.
.PP
If the relative sprite has its PO bit set in sprite attribute 4, then
the anchor\[cq]s pattern number is added to the relative sprite\[cq]s to
determine the pattern used for display.
Otherwise the relative sprite uses its own pattern number as usual.
The intention is to supply a method to easily animate a large sprite by
manipulating the pattern number in the anchor.
.PP
A composite sprite is like a collection of independent sprites tied to
an anchor.
.RE
.IP "B." 3
Unified Sprites
.RS 4
.PP
Unified sprites are a further extension of the composite type.
The same information is recorded from the anchor and the same behaviour
as described under composite sprites applies.
.PP
The difference is the collection of anchor and relatives is treated as
if it were a single 16\[u2005]\[tmu]\[u2005]16 sprite.
The anchor\[cq]s rotation, mirror, and scaling bits apply to all its
relatives.
Rotating the anchor causes all the relatives to rotate around the
anchor.
Mirroring the anchor causes the relatives to mirror around the anchor.
The sprite hardware will automatically adjust X,Y coords and rotation,
scaling and mirror bits of all relatives according to settings in the
anchor.
.PP
Unified sprites should be defined as if all its parts are
16\[u2005]\[tmu]\[u2005]16 in size with the anchor controlling the look
of the whole.
.PP
A unified sprite is like a big version of an individual
16\[u2005]\[tmu]\[u2005]16 sprite controlled by the anchor.
.RE
.SS Programming Sprites
.PP
Sprites are created via three io registers and a nextreg interface.
.PP
Port $303B () Sprite Slot/Flags
.PD 0
.P
.PD
Write: Sprite Slot Select
.PD 0
.P
.PD
select sprite slot for Sprite Attribute and Sprite Pattern ports which
independently auto-increment
.PD 0
.P
.PD
Read: Sprite status
.IP \[bu] 2
bits 7-2 = reserved
.IP \[bu] 2
bit 1 = Max sprites per line
.IP \[bu] 2
bit 0 = Collision flag
.IP
.nf
\f[C]
X S S S S S S S
N6 X N N N N N N
\f[R]
.fi
.PP
A write to this port has two effects.
.PP
One is it selects one of 128 sprites for writing sprite attributes via
port $57.
.PP
The other is it selects one of 128 4-bit patterns in pattern memory for
writing sprite patterns via port $5B.
The N6 bit shown is the least significant in the 7-bit pattern number
and should always be zero when selecting one of 64 8-bit patterns
indicated by N.
.PP
Port $57 () Sprite Attributes
.PD 0
.P
.PD
Byte 1
.IP \[bu] 2
bits 7-0 = LSB of X coordinate (bit 8 is in byte 3)
.PP
Byte 2
.IP \[bu] 2
bits 7-0 = LSB of Y coordinate (bit 8 is in byte 5)
.PP
Byte 3
.IP \[bu] 2
bits 7-4 = Palette Offset
.IP \[bu] 2
bit 3 = Enable X Mirror
.IP \[bu] 2
bit 2 = Enable Y Mirror
.IP \[bu] 2
bit 1 = Enable Roration
.IP \[bu] 2
bit 0 = By Sprite Type
.RS 2
.IP \[bu] 2
Anchor = MSB of X coordinate
.IP \[bu] 2
Relative = Enable relative palette offset
.RE
.PP
Byte 4
.IP \[bu] 2
bit 7 = Enable visibility
.IP \[bu] 2
bit 6 = Enable Byte 5
.IP \[bu] 2
bit 5-0 = Pattern Index (\[lq]name\[rq])
.PP
Byte 5 (optional)
.PD 0
.P
.PD
Anchor
.IP \[bu] 2
bit 7-6 = type and pattern
.RS 2
.IP \[bu] 2
00 = 8-bit color
.IP \[bu] 2
01 = relative
.IP \[bu] 2
10 = 4-bit color, lower half of pattern (bytes 0-127)
.IP \[bu] 2
11 = 4-bit color, upper half of pattern (byets 128-255)
.RE
.IP \[bu] 2
bit 5 = Attached relative sprite type
.RS 2
.IP \[bu] 2
0 = composite
.IP \[bu] 2
1 = big sprite
.RE
.IP \[bu] 2
bit 4-3 = X-axis scale factor
.RS 2
.IP \[bu] 2
00 = 1\[tmu]
.IP \[bu] 2
01 = 2\[tmu]
.IP \[bu] 2
10 = 4\[tmu]
.IP \[bu] 2
11 = 8\[tmu]
.RE
.IP \[bu] 2
bit 2-1 = Y-axis scale factor
.IP \[bu] 2
bit 0 = MSB of Y coordinate
.PP
Composite Relative
.IP \[bu] 2
bits 7-6 = 01
.IP \[bu] 2
bit 5 = N6
.PD 0
.P
.PD
8-bit
.RS 2
.IP \[bu] 2
Reserved, must be 0
.PP
4-bit
.IP \[bu] 2
0 = lower half of pattern (bytes 0-127)
.IP \[bu] 2
1 = upper half of pattern (bytes 128-255)
.RE
.IP \[bu] 2
bit 4-3 = X-axis scale factor
.IP \[bu] 2
bit 2-1 = Y-axis scale factor
.IP \[bu] 2
bit 0 = Enable relative pattern offset
.PP
Big-sprite Relative
.IP \[bu] 2
bits 7-6 = 01
.IP \[bu] 2
bit 5 = N6
.PD 0
.P
.PD
8-bit
.RS 2
.IP \[bu] 2
Reserved, must be 0
.PP
4-bit
.IP \[bu] 2
0 = lower half of pattern (bytes 0-127)
.IP \[bu] 2
1 = upper half of pattern (bytes 128-255)
.RE
.IP \[bu] 2
bit 4-1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = Enable relative pattern offset
.PP
Once a sprite is selected via port $303B, its attributes can be written
to this port one byte after another.
Sprites can have either four or five attribute bytes and the internal
attribute pointer will move onto the next sprite after those four or
five attribute bytes are written.
This means you can select a sprite via port $303B and write attributes
for as many sequential sprites as desired.
The attribute pointer will roll over from sprite 127 to sprite 0.
.PP
Port $5B () Sprite Pattern
.PD 0
.P
.PD
Load data into sprite pattern memory auto-incrementing.
Port $303B can be used to set the starting sprite pattern number.
.PP
Once a pattern number is selected via port $303B, the 256-byte or
128-byte pattern can be written to this port.
The internal pattern pointer auto-increments after each write so as many
sequential patterns as desired can be written.
The internal pattern pointer will roll over from pattern 127 to pattern
0 (4-bit patterns) or from pattern 63 to pattern 0 (8-bit patterns)
automatically.
.PP
Port $303B (R)
.IP
.nf
\f[C]
0 0 0 0 0 0 M C
\f[R]
.fi
.PP
M = 1 if the maximum number of sprites per line was exceeded
.PD 0
.P
.PD
C = 1 if any two displayed sprites collide on screen
.PD 0
.P
.PD
Reading this port automatically resets the M and C bits.
.PP
Besides the i/o interface, there is a nextreg interface to sprite
attributes.
The nextreg interface allows the copper to manipulate sprites and grants
the program random access to a sprite\[cq]s individual attribute bytes.
.PP
Register (R/W) $34 () \[rA] Sprite Number
.PD 0
.P
.PD
Lockstep (NextReg $09 bit 4 set)
.IP \[bu] 2
bit 7 = Pattern address offset (Add 128 to pattern address)
.IP \[bu] 2
bits 6-0 = Sprite number 0-127, Pattern number 0-63
.IP \[bu] 2
effectively performs an out to port $303B
.PP
No Lockstep (NextReg $09 bit 4 clear)
.IP \[bu] 2
bit 7 = Reserved, must be 0
.IP \[bu] 2
bits 6-0 = Sprite number 0-127
.PP
This register selects which sprite has its attributes connected to the
sprite attribute registers
.PP
Register (W) $35 () \[rA] Sprite Attribute 0
.IP \[bu] 2
bits 7-0 = Sprite X coordinate LSB (MSB in NextReg $37)
.PP
Register (W) $75 () \[rA] Sprite Attribute 0 (Auto-incrementing)
.PD 0
.P
.PD
See nextreg $35
.PP
Register (W) $36 () \[rA] Sprite Attribute 1
.IP \[bu] 2
bits 7-0 = Sprite Y coordinate LSB (MSB in NextReg $39)
.PP
Register (W) $76 () \[rA] Sprite Attribute 1 (Auto-incrementing)
.PD 0
.P
.PD
See nextreg $36
.PP
Register (W) $37 () \[rA] Sprite Attribute 2
.IP \[bu] 2
bits 7-4 = 4-bit Palette offset
.IP \[bu] 2
bit 3 = Enable horizontal mirror (reverse)
.IP \[bu] 2
bit 2 = Enable vertical mirror (reverse)
.IP \[bu] 2
bit 1 = Enable 90^\f[I]O\f[R]^ Clockwise Rotation
.PP
Normal Sprites
.IP \[bu] 2
bit 0 = X coordinate MSB
.PP
Relative Sprites
.IP \[bu] 2
bit 0 = Palette offset is relative to anchor sprite
.PP
Rotation is applied before mirroring
.PP
Register (W) $77 () \[rA] Sprite Attribute 2 (Auto-incrementing)
.PD 0
.P
.PD
See nextreg $37
.PP
Register (W) $38 () \[rA] Sprite Attribute 3
.IP \[bu] 2
bit 7 = Enable Visiblity
.IP \[bu] 2
bit 6 = Enable Attribute 4 (0 = Attribute 4 effectively $00)
.IP \[bu] 2
bits 5-0 = Sprite Pattern Number
.PP
Register (W) $78 () \[rA] Sprite Attribute 3 (Auto-incrementing)
.PD 0
.P
.PD
See nextreg $38
.PP
Register (W) $39 () \[rA] Sprite Attribute 4
.PD 0
.P
.PD
Normal Sprites
.IP \[bu] 2
bit 7 = 4-bit pattern switch (0 = 8-bit sprite, 1 = 4-bit sprite)
.IP \[bu] 2
bit 6 = Pattern number bit-7 for 4-bit, 0 for 8-bit
.IP \[bu] 2
bit 5 = Type of attached relative sprites (0 = Composite, 1 = Unified)
.IP \[bu] 2
bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
.IP \[bu] 2
bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
.IP \[bu] 2
bit 0 = MSB of Y coordinate
.PP
Relative, Composite Sprites
.IP \[bu] 2
bit 7-6 = 01
.IP \[bu] 2
bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit
.IP \[bu] 2
bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
.IP \[bu] 2
bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
.IP \[bu] 2
bit 0 = Pattern number is relative to anchor
.PP
Relative, Unified Sprites
.IP \[bu] 2
bit 7-6 = 01
.IP \[bu] 2
bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit
.IP \[bu] 2
bits 4-1 = 0000
.IP \[bu] 2
bit 0 = Pattern number is relative to anchor
.PP
Register (W) $79 () \[rA] Sprite Attribute 4 (Auto-incrementing)
.PD 0
.P
.PD
See nextreg $39
.SS Global Control of Sprites
.PP
The following nextreg are also of interest for sprites.
.PP
Register (R/W) $09 () \[rA] Peripheral 4 setting:
.IP \[bu] 2
bit 7 = PSG 2 Mono Enable (0 on hard reset)
.IP \[bu] 2
bit 6 = PSG 1 Mono Enable (0 on hard reset)
.IP \[bu] 2
bit 5 = PSG 0 Mono Enable (0 on hard reset)
.IP \[bu] 2
bit 4 = Sprite ID lockstep enable (1 = Nextreg $34 and IO Port $303B are
in lockstep, 0 on reset)
.IP \[bu] 2
bit 3 = divMMC mapRAM bit Control (reset bit 7 of port $E3)
.IP \[bu] 2
bit 2 = HDMI audio mute (0 on hard reset)
.IP \[bu] 2
bits 1-0 = scanlines
.RS 2
.IP \[bu] 2
00 = scanlines off
.IP \[bu] 2
01 = scanlines 12.5%
.IP \[bu] 2
10 = scanlines 25%
.IP \[bu] 2
11 = scanlines 50%
.RE
.IP \[bu] 2
In Sprite lockstep, NextREG $34 and Port $303B are in lockstep
.PP
Register (R/W) $15 () \[rA] Sprite and Layer System Setup
.IP \[bu] 2
bit 7 = LoRes mode (0 on reset)
.IP \[bu] 2
bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on top) (0
on reset)
.IP \[bu] 2
bit 5 = Enable sprite clipping in over border mode (0 on reset)
.IP \[bu] 2
bits 4-2 = set layers priorities (000 on reset)
.RS 2
.IP \[bu] 2
000 - S L U
.IP \[bu] 2
001 - L S U
.IP \[bu] 2
010 - S U L
.IP \[bu] 2
011 - L U S
.IP \[bu] 2
100 - U S L
.IP \[bu] 2
101 - U L S
.IP \[bu] 2
110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7
.IP \[bu] 2
111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]
.RE
.IP \[bu] 2
bit 1 = Enable Sprites Over border (0 on reset)
.IP \[bu] 2
bit 0 = Enable Sprites (0 on reset)
.PP
The sprite module draws sprites in the order 0-127 in each scanline.
Bit 6 determines whether sprite 0 is topmost or sprite 127 is topmost.
.PP
Bits 4:2 determine layer priority and how sprites overlay or are
obscured by other layers.
.PP
Register (R/W) $19 () \[rA] Sprite Clip Window Definition
.IP \[bu] 2
bits 7-0 = Cood.
of the clip window
.RS 2
.IP \[bu] 2
1st write - X1 position
.IP \[bu] 2
2nd write - X2 position
.IP \[bu] 2
3rd write - Y1 position
.IP \[bu] 2
4rd write - Y2 position
.RE
.PP
The values are 0,255,0,191 after a Reset
.PD 0
.P
.PD
Reads do not advance the clip position
.PP
When the clip window is enabled for sprites in \[dq]over border\[dq]
mode, the X coords are internally doubled and the clip window origin is
moved to the sprite origin inside the border.
.PP
When the clip window is enabled for sprites in \[lq]over border\[rq]
mode, the X coords are internally doubled and the clip window origin is
moved to the sprite origin inside the border.
.PP
Sprites will only be visible inside the clipping window.
When not in over-border mode (bit 1 of nextreg $15) the clipping window
is given in ULA screen coordinates with 0,0 correspoding to the top left
corner of the ULA screen.
In over-border mode, the clipping window\[cq]s origin is moved to the
sprite coordinate origin 32 pixels to the left and 32 pixels above the
ULA screen origin.
.PP
Regardless, sprite position is always in sprite coordinates with 32,32
corresponding to the top left corner of the ULA screen.
.PP
Register (R/W) $1C () \[rA] Clip Window Control
.PD 0
.P
.PD
Read
.IP \[bu] 2
bits 7-6 = Layer 3 Clip Index
.IP \[bu] 2
bits 5-4 = Layer 0/1 Clip Index
.IP \[bu] 2
bits 3-2 = Sprite clip index
.IP \[bu] 2
bits 1-0 = Layer 2 Clip Index
.PP
Write
.IP \[bu] 2
bits 7-4 = Reserved, must be 0
.IP \[bu] 2
bit 3 - reset Layer 3 clip index
.IP \[bu] 2
bit 2 - reset Layer 0/1 clip index
.IP \[bu] 2
bit 1 - reset sprite clip index.
.IP \[bu] 2
bit 0 - reset Layer 2 clip index.
.PP
Register (R/W) $4B () \[rA] Sprite Transparency Index
.IP \[bu] 2
bits 7-0 = Index value ($E3 if reset)
.PP
For 4-bit sprites only the bottom 4-bits are relevant.
.SH Audio
.SS ZX Spectrum 1-bit
.PP
The baseline sound of the ZX Spectrum was produced by toggling the Ear
bit (bit 4) of $fe (254) The ULA port to produce 1-bit audio.
It is enabled by bit 4 of Next register $08 (8).
While this does work on the ZX Spectrum Next, there are other much
better methods and this is only supported for backward compatibility.
.PP
Code:
.IP
.nf
\f[C]
;; enable internal speaker
ld bc,$243B
ld a,$08
out (c),a
ld bc,$253B
in a,(c)
or $10
out (c),a
\f[R]
.fi
.SS Sampled 8-bit
.PP
The ZX Next has four 8-bit D/A audio channels connected to provide
sampled stereo sound.
Channels A and B are the left channels, while C and D are the right
channels.
In order use 8-bit sound, it must first be enabled by setting bit 3 on
nextreg $08.
In order to emulate legacy hardware there are a number of ports that can
be used to control the four channels additionally these are mirrored to
three nextregs to enable driving audio using the copper.
Channel A is mapped to ports $0f, $3f, and $f1; channel B to ports $1f
and $f3 and nextreg $2C; channel C to ports $4f, and $f9 and nextreg
$2E; and channel D to: $5f and $fb; with port $df connected to both
channel A and C and nextreg $2D connected to both channel A and D.
.PP
Code:
.IP
.nf
\f[C]
;; enable SpecDrum/Convox audio
ld bc,$243B
ld a,$08
out (c),a
ld bc,$253B
in a,(c)
or $08
out (c),a
\f[R]
.fi
.SS Turbosound
.PP
TurboSound consists of the implementation of three AY-3-8912 chips.
To enable TurboSound set bit 1 of Next Register $08 (8).
Once enabled the sound chips and registers of the sound chips are
selected using port $fffd (65533) TurboSound Next Control while the
registers are accessed using $bffd () Sound Chip Register Access.
To enable access to a particular chip write 111111xx to the control
register where 01=AY1, 10=AY2, and 11=AY3.
Access to particular registers of the selected chip is selected by
writing the register number to the control register.
You can then access a chip register using the access port.
.PP
Code:
.IP
.nf
\f[C]
;; enable TurboSound audio
ld bc,$243B
ld a,$08
out (c),a
ld bc,$253B
in a,(c)
or $02
out (c),a
\f[R]
.fi
.PP
Each of the three AY chips has three channels, A, B, and C whose mapping
is controlled by bit 5 of Next register 0x08 (8).
.PP
Register (R/W) $00 () \[rA] Channel A fine tune
.PP
Register (R/W) $01 () \[rA] Channel A coarse tune (4 bits)
.PP
Register (R/W) $02 () \[rA] Channel B fine tune
.PP
Register (R/W) $03 () \[rA] Channel B coarse tune (4 bits)
.PP
Register (R/W) $04 () \[rA] Channel C fine tune
.PP
Register (R/W) $05 () \[rA] Channel C coarse tune (4 bits)
.PP
Register (R/W) $06 () \[rA] Noise period (5 bits)
.PP
Register (R/W) $07 () \[rA] Tone Enable
.IP \[bu] 2
bit 5 = Channel C tone enable (0=enable, 1=disable)
.IP \[bu] 2
bit 4 = Channel B tone enable (0=enable, 1=disable)
.IP \[bu] 2
bit 3 = Channel A tone enable (0=enable, 1=disable)
.IP \[bu] 2
bit 2 = Channel C noise enable (0=enable, 1=disable)
.IP \[bu] 2
bit 1 = Channel B noise enable (0=enable, 1=disable)
.IP \[bu] 2
bit 0 = Channel A noise enable (0=enable, 1=disable)
.PP
Register (R/W) $08 () \[rA] Channel A amplitude
.IP \[bu] 2
bit 4 = enable fixed amplitude
.RS 2
.IP \[bu] 2
0 = fixed amplitude
.IP \[bu] 2
1 = use envelope generator (bits 0-3 ignored)
.RE
.IP \[bu] 2
bits 3-0 = value of fixed amplitude
.PP
Register (R/W) $09 () \[rA] Channel B amplitude
.IP \[bu] 2
bit 4 = enable fixed amplitude
.RS 2
.IP \[bu] 2
0 = fixed amplitude
.IP \[bu] 2
1 = use envelope generator (bits 0-3 ignored)
.RE
.IP \[bu] 2
bits 3-0 = value of fixed amplitude
.PP
Register (R/W) $0A () \[rA] Channel C amplitude
.IP \[bu] 2
bit 4 = enable fixed amplitude
.RS 2
.IP \[bu] 2
0 = fixed amplitude
.IP \[bu] 2
1 = use envelope generator (bits 0-3 ignored)
.RE
.IP \[bu] 2
bits 3-0 = value of fixed amplitude
.PP
Register (R/W) $0B () \[rA] Envelope period fine
.PP
Register (R/W) $0C () \[rA] Envelope period coarse
.PP
Register (R/W) $0D () \[rA] Envelope shape
.IP \[bu] 2
bit 3 = Continue
.RS 2
.IP \[bu] 2
0 = drop to amplitude 0 after 1 cycle
.IP \[bu] 2
1 = use `Hold' value
.RE
.IP \[bu] 2
bit 2 = Attack
.RS 2
.IP \[bu] 2
0 = generator counts down
.IP \[bu] 2
1 = generator counts up
.RE
.IP \[bu] 2
bit 1 = Alternate
.PD 0
.P
.PD
hold = 0
.RS 2
.IP \[bu] 2
0 = generator resets after each cycle
.IP \[bu] 2
1=generator reverses direction each cycle
.PP
hold=1
.IP \[bu] 2
0 = hold final value
.IP \[bu] 2
1 = hold initial value
.RE
.IP \[bu] 2
bit 0 = Hold
.RS 2
.IP \[bu] 2
0 = cycle continuously
.IP \[bu] 2
1 = perform one cycle and hold
.RE
.SS Pi Audio
.PP
If connected the Pi Zero is configured to use the ZX Next as a soundcard
over an I^2^S interface making the Raspberry Pi a fully configurable
audio source for the ZX Spectrum Next.
.SH Memory
.PP
The ZX Spectrum Next commonly has with either 1MB or 2MB SRAM memory.
This is more the 64kB directly addressable by its Z80N CPU.
It is therefore necessary to use some form of memory paging to address
all of the memory.
This is accomplished using 8k pages or 16k banks.
256k of the total memory is used by the ROM images and device specific
RAM leaving either 768k (pages 0-95/banks 0-47) or 1792k (pages
0-223/banks 0-111) that can be paged in as RAM.
Pages 10, 11, and 14 are a little odd in that rather than coming from
the normal SRAM, they come from BRAM internal to the FPGA.
.SS Memory Management
.PP
There are a number of different systems for controling memory papping
into the 64k memory space of the Z80N CPU in the ZX Next: ZX Next native
memory paging, ZX Spectrum 128, ZX Spectrum +3, divMMC, and Multiface.
.SS Default Layout
.PP
The default mapping of memory banks is the same as on 128k Spectrum
models with a ROM0 (128k editor and menu system) mapped in at
$0000-$3FFF, bank 5 at $4000-$7FFF, bank 2 at $8000-$BFFF, and bank 0 at
$C000-$FFFF.
.SS RAM
.SS ZX Spectrum Next Native
.PP
Registers $50 to $57 control the which SRAM pages are in each of the
eight memory slots.
Registers $50 and $51 support the special value $FF which indicates that
the currently selected ROM is to be mapped into slots 0 and/or 1
($0000-$3FFF).
.PP
Register (R/W) $50 () \[rA] MMU Slot 0 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $0000 to $1FFF ($ff on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PD 0
.P
.PD
A 255 value causes the ROM to become visible.
.PP
Register (R/W) $51 () \[rA] MMU Slot 1 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $2000 to $3FFF ($ff on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PD 0
.P
.PD
A 255 value causes the ROM to become visible.
.PP
Register (R/W) $52 () \[rA] MMU Slot 2 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $4000 to $5FFF ($0A on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PP
Register (R/W) $53 () \[rA] MMU Slot 3 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $6000 to $7FFF ($0B on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PP
Register (R/W) $54 () \[rA] MMU Slot 4 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $8000 to $9FFF ($04 on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PP
Register (R/W) $55 () \[rA] MMU Slot 5 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $A000 to $BFFF ($05 on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PP
Register (R/W) $56 () \[rA] MMU Slot 6 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $C000 to $DFFF ($00 on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PP
Register (R/W) $57 () \[rA] MMU Slot 7 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $E000 to $FFFF ($01 on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PP
Writing to ports $1FFD, $7FFD and $DFFD writes $FF to MMU0 and MMU1 and
writes appropriate values to MMU6 and MMU7 to map in the selected 16k
bank.
.PP
+3 special modes override the MMUs if used.
.PP
In addition the ZX Next has special controls which allow the data area
for Layer 2 to be overlaied on memory in a fashion that permits
selective read or write access.
For details see the section on Layer 2 video.
.SS ZX Spectrum 128
.PP
In addition to the native memory management, the ZX Next supports a
memory management system that is an expanded, and backward compatible,
version of the the system used on earlier ZX Spectrum models.
This system uses registers $1FFD, $7FFD, and $DFFD.
.PP
Port $1FFD () Plus 3 Memory Paging Control
.IP \[bu] 2
bits 7-3 = Unused, nust be 0
.IP \[bu] 2
bit 2 = High bit of ROM selection (low bit is in Port $7FFD)
.RS 2
.IP \[bu] 2
00 = ROM0 = 128k editor and menu system
.IP \[bu] 2
01 = ROM1 = 128k syntax checker
.IP \[bu] 2
10 = ROM2 = +3DOS
.IP \[bu] 2
11 = ROM3 = 48k BASIC
.RE
.IP \[bu] 2
bit 1 = Special mode: Low bit of memory configuration number
.IP \[bu] 2
bit 0 = Paging mode
.RS 2
.IP \[bu] 2
0 = Normal
.IP \[bu] 2
1 = Special
.RE
.PP
You should echo writes to $5B67
.PP
Port $7FFD () Memory Paging Control
.IP \[bu] 2
bits 6-7 = reserved
.IP \[bu] 2
bit 5 = Lock memory paging
.IP \[bu] 2
bit 4 = low bit of ROM Select (high bit is in Port $1FFD)
.RS 2
.IP \[bu] 2
00 = ROM0 = 128k editor and menu system
.IP \[bu] 2
01 = ROM1 = 128k syntax checker
.IP \[bu] 2
10 = ROM2 = +3DOS
.IP \[bu] 2
11 = ROM3 = 48k BASIC
.RE
.IP \[bu] 2
bit 3 = Shadow screen toggle
.IP \[bu] 2
bits 2-0 = LSB of Bank number for slot 4 (MSB is in Port $DFFD)
.PP
Disable with bit 5 port $7FFD
.PP
Port $DFFD () Next Memory Bank Select
.IP \[bu] 2
bits 7-4 = Reserved, must be 0
.IP \[bu] 2
bits 3-0 = MSB of bank number for slot 4 (LSB is in Port $7FFD)
.SS Spectrum 128 Standard Paging
.PP
128-style memory management can only alter the bank addressed at $c000
(16k-slot 4, or 8k-slots 7-8).
The active 16k-bank at $c000 is selected by writing the 3 LSBs of the
16k-bank number to the bottom 3 bits of Memory Paging Control ($7FFD),
and the 4 MSBs to the bottom 4 bits of Next Memory Bank Select ($DFFD).
(The reason for the division is that the original Spectrum 128, having
only 128k of memory, only needed 3 bits.)
.PP
If you are using the standard interrupt handler or OS routines, then any
time you write to Memory Paging Control ($7FFD) you should also store
the value at $5B5C.
Any time you write to Plus 3 Memory Paging Control ($1FFD) you should
also store the value at $5B67.
There is no corresponding system variable for the Next-only Next Memory
Bank Select ($DFFD) and standard OS routines may not support the
extended banks properly.
.SS Paging out ROM
.PP
ROM can be paged out by enabling AllRam mode, or by using Next memory
management.
Beware that some programs may assume that they can find ROM service
routines at fixed addresses between $0000-$3fff.
More importantly, if the default interrupt mode (IM 1) is set, the Z80
will jump the program counter to $0038 every frame expecting to find an
interrupt handler there.
If it does not, pain and suffering will likely result.
DI is your friend.
On the plus side, this does allow you to write your own interrupt
handler without the nuisance of using IM 2.
.SS Spectrum 128 Special Paging
.PP
\[lq]Special paging mode\[rq] (also called \[lq]AllRam mode\[rq] or
\[lq]CP/M mode\[rq]) is enabled by writing a value with the LSB set to
Plus 3 Memory Paging Control ($1FFD).
Depending on the 3 low bits of this value a memory configuration is
selected as follows:
.SS ROM
.PP
The ZX Spectrum Next had several ROMS: ROM0 (16k) - 128k editor and menu
system, ROM1 (16k) - 128k syntax checker, ROM2 (16k) - +3DOS, ROM3 (16k)
- 48k BASIC, divMMC/esxDOS ROM (8k), divMMC RAM (128k), Multiface ROM
(8k) and Alternate ROM (16k).
.SS ZX Next native
.PP
Slots 0 and 1 select use by ROM by selecting page $FF.
Which what ROM is mapped in is determined by the other memory management
system.
If the rest of the system selected the 48k ROM, Nextreg $8C determines
whether the actual 48k ROM, or the ZX Next Alternate ROM is in use.
In addition, it is possible to enable writing to the Alternate ROM.
.PP
Register (R/W) $8C () \[rA] Alternate ROM
.PD 0
.P
.PD
Immediate
.IP \[bu] 2
bit 7 = Alt ROM Enable (0 on hard reset)
.IP \[bu] 2
bit 6 = Alt ROM visible ONLY during writes (0 on hard reset)
.IP \[bu] 2
bit 5 = Reserved, must be 0
.IP \[bu] 2
bit 4 = 48k ROM Lock (0 on hard reset)
.PP
After Soft Reset (copied into bits 7-4)
.IP \[bu] 2
bit 3 = Alt ROM Enable (0 on hard reset)
.IP \[bu] 2
bit 2 = Alt ROM visible ONLY during writes (0 on hard reset)
.IP \[bu] 2
bit 1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = 48k ROM Lock (0 on hard reset)
.SS ZX Spectrum 128k
.SS ROM paging and selection
.PP
$0000-$3fff is usually mapped to ROM.
This area can only be fully remapped using Next memory management.
ROM is not considered one of the numbered banks; it is mapped to the two
8k-banks by default, or by setting their 8k-bank numbers to 255.
.PP
The 128k Spectrum has 2 ROM pages.
Which of these is mapped is selected by altering Bit 4 of Memory Paging
Control ($7FFD).
The +2a/+3 has 4 ROM pages; the extra bit needed to select between these
is bit 2 of Plus 3 Memory Paging Control ($1FFD).
This maintains compatibility with the original machines\[cq] ROM paging
as long as the ROM is not paged out.
.SS divMMC
.PP
The divMMC ROM mapping can take priority when it is enabled by port $E3
or, when automapping has been enabled by nextreg $06, when it has been
automapped due to reading one of the appropriate addresses.
Port $E3 also controls whether the divMMC maps the esxDOS ROM or divMMC
RAM page 3 into slot 0 and which divMMC RAM page is mapped into slot 1.
.PP
Port $E3 () divMMC Control
.PD 0
.P
.PD
Disable with bit 2 of Nextreg $09
.IP \[bu] 2
bit 7 = conmem, enable divMMC memory
.IP \[bu] 2
bit 6 = mapram, enable divMMC allRAM mode
.IP \[bu] 2
bits 3-0 = bank, selected divMMC ram bank for $2000-$3FFF region
.IP \[bu] 2
conmem can be used to manually control divMMC mapping.
When enabled
.PD 0
.P
.PD
$0000-$1FFF contains esxDOS ROM or esxDOS page 3
.PD 0
.P
.PD
$2000-$3FFF contains esxDOS RAM page selected by bits 3-0
.IP \[bu] 2
divMMC automatically maps itself in when instruction fetches hit
specific addresses in the ROM.
When this happens, the esxDOS ROM (or divMMC bank 3 if mapram is set)
appears in $0000-$1FFF and the selected divMMC bank appears as RAM in
$2000-$3FFF
.IP \[bu] 2
bit 6 can only be set, once set only a power cycle can reset it.
nextreg $09 bit 3 can be set to reset this bit.
.PP
divMMC automapping is normally disabled by NextZXOS see nextreg $06 bit
4.
.PD 0
.P
.PD
Register (R/W) $06 () \[rA] Peripheral 2 Settings
.IP \[bu] 2
bit 7 = F8 CPU Speed Hotkey Enable (1 on reset)
.IP \[bu] 2
bit 6 = Enable classic audio mode (beep and tape to internal speaker,
other audio to ear and HDMI, 3.01.02)
.IP \[bu] 2
bit 5 = F3 50Hz/60Hz Hotkey Enable (1 on reset)
.IP \[bu] 2
bit 4 = divMMC Automap/NMI Enable (0 on hard reset)
.IP \[bu] 2
bit 3 = NMI Button Enable (0 on hard reset)
.IP \[bu] 2
bit 2 = PS/2 Mode (0 = keyboard, 1 = mouse)
.IP \[bu] 2
bits 1-0 = PSG Mode (00 = YM, 01 = AY, 11 = hold all PSGs in Reset)
.SS Multiface
.PP
Need to find useful docs on the Multiface memory.
.PP
9f 1-In, 128-In2
.PD 0
.P
.PD
1f 1-Out
.PD 0
.P
.PD
bf 128-In, 3-Out
.PD 0
.P
.PD
3f 128-Out, 3-In, 3-button
.PD 0
.P
.PD
7f3f 3-7ffd
.PD 0
.P
.PD
1f3f 3-1ffd
.SS Interactions between paging methods
.PP
Changes made in 128 style and Next style memory management are
synchronized.
The most recent change always has priority.
This means that
.PP
using 128-style memory management to select a new 16k-bank in 16k-slot 4
will update the MMU registers for the two 8k-slots with the
corresponding 8k-bank numbers.
enabling AllRam mode will update all of the 8k-bank values with the
appropriate 8k-slot numbers.
These may then be overwritten using Next memory management without
needing to alter the value at port $1FFD.
Since the 128-style memory management ports are not readable, there is
no synchronization applicable in the other direction.
.SS Memory Map
.SS Global Memory Map
.PP
.TS
tab(@);
l l l.
T{
\f[B]Physical Address\f[R]
T}@T{
\f[B]Size\f[R]
T}@T{
\f[B]Description\f[R]
T}
_
T{
$000000-$00FFFF
T}@T{
64k
T}@T{
ZX Spectrum ROM (ROM0-3)
T}
T{
$010000-$011FFF
T}@T{
8k
T}@T{
EsxDOS ROM
T}
T{
$012000-$013FFF
T}@T{
8k
T}@T{
Multiface ROM
T}
T{
$014000-$017FFF
T}@T{
16k
T}@T{
EsxDOS Extra ROM
T}
T{
$018000-$01BFFF
T}@T{
16k
T}@T{
Alternate ROM
T}
T{
$01C000-$01FFFF
T}@T{
16k
T}@T{
Multiface RAM
T}
T{
$020000-$03FFFF
T}@T{
128k
T}@T{
DivMMC RAM
T}
T{
$040000-$0FFFFF
T}@T{
768k
T}@T{
Standard RAM
T}
T{
$100000-$1FFFFF
T}@T{
1024k
T}@T{
Expanded RAM
T}
.TE
.PP
Normal RAM is divided into 8k pages or 16k banks which may be mapped
into the 64k memory space by the memory management hardware of the Next.
Some of these pages have special properties.
.PP
Pages 10, 11 and 14 are used by Layer 1/0 (ULA) video modes with 10 used
by standard Spectrum ULA video, 10 and 11 used by Timex Hi-res and
Hi-colour modes, 11 used by Timex alternate video and page 14 used by
the ULA shadow mode.
Pages 10 an 11 are usable by Layer 3 (Tilemap) video.
.SS Z80 Visible Memory Map
.SH zxnDMA
.PP
February 25, 2019 Phoebus Dokos Off Hardware, Resources,
.PP
The ZX Spectrum Next DMA (zxnDMA)
.SS Overview
.PP
The ZX Spectrum Next DMA (zxnDMA) is a single channel dma device that
implements a subset of the Z80 DMA functionality.
The subset is large enough to be compatible with common uses of the
similar Datagear interface available for standard ZX Spectrum computers
and compatibles.
It also adds a burst mode capability that can deliver audio at
programmable sample rates to the DAC device.
.SS Accessing the zxnDMA
.PP
The zxnDMA is mapped to a single Read/Write IO Port 0x6B which is the
same one used by the Datagear but unlike the Datagear it doesn\[cq]t
also map itself to a second port 0x0B similar to the MB-02 interface.
.IP
.nf
\f[C]
PORT $6b: zxnDMA
\f[R]
.fi
.SS Description
.PP
The normal Z80 DMA (Z8410) chip is a pipelined device and because of
that it has numerous off-by-one idiosyncrasies and requirements on the
order that certain commands should be carried out.
These issues are not duplicated in the zxnDMA.
You can continue to program the zxnDMA as if it is were a Z8410 DMA
device but it can also be programmed in a simpler manner.
.PP
The single channel of the zxnDMA chip consists of two ports named A and
B.
Transfers can occur in either direction between ports A and B, each port
can describe a target in memory or IO, and each can be configured to
autoincrement, autodecrement or stay fixed after a byte is transferred.
.PP
A special feature of the zxnDMA can force each byte transfer to take a
fixed amount of time so that the zxnDMA can be used to deliver sampled
audio.
.SS Modes of Operation
.PP
The zxnDMA can operate in a z80-dma compatibility mode.
.PP
The z80-dma compatibility mode is selected by setting bit 6 of nextreg
$06.
In this mode, all transfers involve length+1 bytes which is the same
behaviour as the z80-dma chip.
In zxn-dma mode, the transfer length is exactly the number of bytes
programmed.
This mode is mainly present to accommodate existing spectrum software
that uses the z80-dma and for cp/m programs that may have a z80-dma
option.
.PP
The zxnDMA can also operate in either burst or continuous modes.
.PP
Continuous mode means the DMA chip runs to completion without allowing
the CPU to run.
When the CPU starts the DMA, the DMA operation will complete before the
CPU executes its next instruction.
.PP
Burst mode nominally means the DMA lets the CPU run if either port is
not ready.
This condition can\[cq]t happen in the zxnDMA chip except when operated
in the special fixed time transfer mode.
In this mode, the zxnDMA will let the CPU run while it waits for the
fixed time to expire between bytes transferred.
.PP
Note that there is no byte transfer mode as in the Z80 DMA.
.SS Programming the zxnDMA
.PP
Like the Z80 DMA chip, the zxnDMA has seven write registers named
WR0-WR6 that control the device.
Each register WR0-WR6 can have zero or more parameters associated with
it.
.PP
In a first write to the zxnDMA port, the write value is compared against
a bitmask to determine which of the WR0-WR6 is the target.
Remaining bits in the written value can contain data as well as a list
of associated parameter bits.
The parameter bits determine if further writes are expected to deliver
parameter values.
If there are multiple parameter bits set, the expected order of
parameter values written is determined by parameter bit position from
right to left (bit 0 through bit 7).
Once all parameters are written, the zxnDMA again expects a regular
register write selecting WR0-WR6.
.PP
The table X.Y describes the registers and the bitmask required to select
them on the zxnDMA.
.SS zxnDMA Registers
.PP
These are described below following the same convention used by Zilog
for its DMA chip:
.SS WR0 \[en] Write Register Group 0
.IP
.nf
\f[C]
D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
 0   |   |   |   |   |   |   |
     |   |   |   |   |   0   0  Do not use
     |   |   |   |   |   0   1  Transfer (Prefer this for Z80 DMA compatibility)
     |   |   |   |   |   1   0  Do not use (Behaves like Transfer, Search on Z80
     |   |   |   |   |                       DMA)
     |   |   |   |   |   1   1  Do not use (Behaves like Transfer, Search/Trans-
     |   |   |   |   |                      fer on Z80 DMA)
     |   |   |   |   0 = Port B -> Port A (Byte transfer direction)
     |   |   |   |   1 = Port A -> Port B
     |   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  PORT A STARTING ADDRESS (LOW BYTE)
     |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  PORT A STARTING ADDRESS (HIGH BYTE)
     |   V
D7  D6  D5  D4  D3  D2  D1  D0  BLOCK LENGTH (LOW BYTE)
     V
D7  D6  D5  D4  D3  D2  D1  D0  BLOCK LENGTH (HIGH BYTE)
\f[R]
.fi
.PP
Several registers are accessible from WR0.
The first write to WR0 is to the base register byte.
Bits D6:D3 are optionally set to indicate that associated registers in
this group will be written next.
The order the writes come in are from D3 to D6 (right to left).
For example, if bits D6 and D3 are set, the next two writes will be
directed to PORT A STARTING ADDRESS LOW followed by BLOCK LENGTH HIGH.
.SS WR1 \[en] Write Register Group 1
.IP
.nf
\f[C]
D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
 0   |   |   |   |   1   0   0
     |   |   |   |
     |   |   |   0 = Port A is memory
     |   |   |   1 = Port A is IO
     |   |   |
     |   0   0 = Port A address decrements
     |   0   1 = Port A address increments
     |   1   0 = Port A address is fixed
     |   1   1 = Port A address is fixed
     |
     V
D7  D6  D5  D4  D3  D2  D1  D0  PORT A VARIABLE TIMING BYTE
 0   0   0   0   0   0   |   |
                         0   0 = Cycle Length = 4
                         0   1 = Cycle Length = 3
                         1   0 = Cycle Length = 2
                         1   1 = Do not use
\f[R]
.fi
.PP
The cycle length is the number of cycles used in a read or write
operation.
The first cycle asserts signals and the last cycle releases them.
There is no half cycle timing for the control signals.
.SS WR2 \[en] Write Register Group 2
.IP
.nf
\f[C]
D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
 0   |   |   |   |   0   0   0
     |   |   |   |
     |   |   |   0 = Port B is memory
     |   |   |   1 = Port B is IO
     |   |   |
     |   0   0 = Port B address decrements
     |   0   1 = Port B address increments
     |   1   0 = Port B address is fixed
     |   1   1 = Port B address is fixed
     |
     V
D7  D6  D5  D4  D3  D2  D1  D0  PORT B VARIABLE TIMING BYTE
 0   0   |   0   0   0   |   |
         |               0   0 = Cycle Length = 4
         |               0   1 = Cycle Length = 3
         |               1   0 = Cycle Length = 2
         |               1   1 = Do not use
         |
         V
D7  D6  D5  D4  D3  D2  D1  D0  ZXN PRESCALAR (FIXED TIME TRANSFER)
\f[R]
.fi
.PP
The ZXN PRESCALAR is a feature of the zxnDMA implementation.
If non-zero, a delay will be inserted after each byte is transferred
such that the total time needed for each transfer is determined by the
prescalar.
This works in both the continuous mode and the burst mode.
If the DMA is operated in burst mode, the DMA will give up any waiting
time to the CPU so that the CPU can run while the DMA is idle.
.PP
The rate of transfer is given by the formula \[lq]Frate = 875kHz /
prescalar\[rq] or, rearranged, \[lq]prescalar = 875kHz / Frate\[rq].
The formula is framed in terms of a sample rate (Frate) but Frate can be
inverted to set a transfer time for each byte instead.
The 875kHz constant is a nominal value assuming a 28MHz system clock;
the system clock actually varies from this depending on the video timing
selected by the user (HDMI, VGA0-6) so for complete accuracy the
constant should be prorated according to documentation for nextreg $11.
.PP
In a DMA audio setting, selecting a sample rate of 16kHz would mean
setting the prescalar value to 55.
This sample period is constant across changes in CPU speed.
.SS WR3 \[en] Write Register Group 3
.IP
.nf
\f[C]
D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
 1   |   0   0   0   0   0   0
     |
     1 = DMA Enable
\f[R]
.fi
.PP
The Z80 DMA defines more fields but they are ignored by the zxnDMA.
.PP
The two other registers defined by the Z80 DMA in this group on D4 and
D3 are implemented by the zxnDMA but they do nothing.
.PP
It is preferred to start the DMA by writing an Enable DMA command to
WR6.
.SS WR4 \[en] Write Register Group 4
.IP
.nf
\f[C]
D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
 1   |   |   0   |   |   0   1
     |   |       |   |
     0   0 = Do not use (Behaves like Continuous mode, Byte mode on Z80 DMA)
     0   1 = Continuous mode
     1   0 = Burst mode
     1   1 = Do not use
                 |   |
                 |   V
D7  D6  D5  D4  D3  D2  D1  D0  PORT B STARTING ADDRESS (LOW BYTE)
                 |
                 V
D7  D6  D5  D4  D3  D2  D1  D0  PORT B STARTING ADDRESS (HIGH BYTE)
\f[R]
.fi
.PP
The Z80 DMA defines three more registers in this group through D4 that
define interrupt behaviour.
Interrups and pulse generation are not implemented in the zxnDMA nor are
these registers available for writing.
.SS WR5 \[en] Write Register Group 5
.IP
.nf
\f[C]
D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
 1   0   |   |   0   0   1   0
         |   |
         |   0 = /ce only
         |   1 = /ce & /wait multiplexed
         |
         0 = Stop on end of block
         1 = Auto restart on end of block
\f[R]
.fi
.PP
The /ce & /wait mode is implemented in the zxnDMA but is not currently
used.
This mode has an external device using the DMA\[cq]s /ce pin to insert
wait states during the DMA\[cq]s transfer.
.PP
The auto restart feature causes the DMA to automatically reload its
source and destination addresses and reset its byte counter to zero to
repeat the last transfer when a previous one is finished.
.SS WR6 \[en] Command Register
.IP
.nf
\f[C]
D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
 1   ?   ?   ?   ?   ?   1   1
     |   |   |   |   |
     1   0   0   0   0 = \[rs]$C3 = Reset
     1   0   0   0   1 = \[rs]$C7 = Reset Port A Timing
     1   0   0   1   0 = \[rs]$CB = Reset Port B Timing
     0   1   1   1   1 = \[rs]$BF = Read Status Byte
     0   0   0   1   0 = \[rs]$8B = Reinitialize Status Byte
     0   1   0   0   1 = \[rs]$A7 = Initialize Read Sequence
     1   0   0   1   1 = \[rs]$CF = Load
     1   0   1   0   0 = \[rs]$D3 = Continue
     0   0   0   0   1 = \[rs]$87 = Enable DMA
     0   0   0   0   0 = \[rs]$83 = Disable DMA
 +-- 0   1   1   1   0 = \[rs]$BB = Read Mask Follows
 |
D7  D6  D5  D4  D3  D2  D1  D0  READ MASK
 0   |   |   |   |   |   |   |
     |   |   |   |   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Status Byte
     |   |   |   |   |   |
     |   |   |   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Byte Counter Low
     |   |   |   |   |
     |   |   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Byte Counter High
     |   |   |   |
     |   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Port A Address Low
     |   |   |
     |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Port A Address High
     |   |
     |   V
D7  D6  D5  D4  D3  D2  D1  D0  Port B Address Low
     |
     V
D7  D6  D5  D4  D3  D2  D1  D0  Port B Address High
\f[R]
.fi
.PP
Unimplemented Z80 DMA commands are ignored.
.PP
Prior to starting the DMA, a LOAD command must be issued to copy the
Port A and Port B addresses into the DMA\[cq]s internal pointers.
Then an \[`i]Enable DMA\[^i] command is issued to start the DMA.
.PP
The \[`i]Continue\[^i] command resets the DMA\[cq]s byte counter so that
a following \[`i]Enable DMA\[^i] allows the DMA to repeat the last
transfer but using the current internal address pointers.
I.e.
it continues from where the last copy operation left off.
.PP
Registers can be read via an IO read from the DMA port after setting the
read mask.
(At power up the read mask is set to $7f).
Register values are the current internal dma counter values.
So \[`i]Port Address A Low\[^i] is the lower 8-bits of Port A\[cq]s next
transfer address.
Once the end of the read mask is reached, further reads loop around to
the first one.
.PP
The format of the DMA status byte is as follows:
.PP
00E1101T
.PP
E is set to 0 if the total block length has been transferred at least
once.
.PP
T is set to 1 if at least one byte has been transferred.
.SS Operating speed
.PP
The zxnDMA operates at the same speed as the CPU, that is 3.5MHz, 7MHz
or 14MHz.
This is a contended clock that is modified by the ULA and the
auto-slowdown by Layer2.
.PP
Auto-slowdown occurs without user intervention if speed exceeds 7Mhz and
the active Layer2 display is being generated (higher speed operation
resumes when the active Layer2 display is not generated).
Programmers do NOT need to account for speed differences regarding DMA
transfers as this happens automatically.
.PP
Because of this, the cycle lengths for Ports A and B can be set to their
minimum values without ill effects.
The cycle lengths specified for Ports A and B are intended to
selectively slow down read or write cycles for hardware that cannot
operate at the DMA\[cq]s full speed.
.SS The DMA and Interrupts
.PP
The zxnDMA cannot currently generate interrupts.
.PP
The other side of this is that while the DMA controls the bus, the Z80
cannot respond to interrupts.
On the Z80, the nmi interrupt is edge triggered so if an nmi occurs the
fact that it occurred is stored internally in the Z80 so that it will
respond when it is woken up.
On the other hand, maskable interrupts are level triggered.
That is, the Z80 must be active to regularly sample the /INT line to
determine if a maskable interrupt is occurring.
On the Spectrum and the ZX Next, the ULA (and line interrupt) are only
asserted for a fixed amount of time \ 30 cycles at 3.5MHz.
If the DMA is executing a transfer while the interrupt is asserted, the
CPU will not be able to see this and it will most likely miss the
interrupt.
In burst mode, the CPU will never miss these interrupts, although this
may change if multiple channels are implemented.
.SS Programming examples
.PP
A simple way to program the DMA is to walk down the list of registers
WR0-WR5, sending desired settings to each.
Then start the DMA by sending a LOAD command followed by an ENABLE_DMA
command to WR6.
Once more familiar with the DMA, you will discover that the amount of
information sent can be reduced to what changes between transfers.
.IP "1." 3
Assembly
.RS 4
.PP
Short example program to DMA memory to the screen then DMA a sprite
image from memory to sprite RAM, and then showing said sprite scroll
across the screen.
.IP
.nf
\f[C]
;------------------------------------------------------------------------------
device zxspectrum48
;------------------------------------------------------------------------------
; DEFINE testing
;------------------------------------------------------------------------------
; DMA (Register 6)
;
;------------------------------------------------------------------------------
;zxnDMA programming example
;------------------------------------------------------------------------------
;(c) Jim Bagley
;------------------------------------------------------------------------------
DMA_RESET equ $c3
DMA_RESET_PORT_A_TIMING equ $c7
DMA_RESET_PORT_B_TIMING equ $cb
DMA_LOAD equ $cf ; %11001111
DMA_CONTINUE equ $d3
DMA_DISABLE_INTERUPTS equ $af
DMA_ENABLE_INTERUPTS equ $ab
DMA_RESET_DISABLE_INTERUPTS equ $a3
DMA_ENABLE_AFTER_RETI equ $b7
DMA_READ_STATUS_BYTE equ $bf
DMA_REINIT_STATUS_BYTE equ $8b
DMA_START_READ_SEQUENCE equ $a7
DMA_FORCE_READY equ $b3
DMA_DISABLE equ $83
DMA_ENABLE equ $87
DMA_WRITE_REGISTER_COMMAND equ $bb
DMA_BURST equ %11001101
DMA_CONTINUOUS equ %10101101
ZXN_DMA_PORT equ $6b
SPRITE_STATUS_SLOT_SELECT equ $303B
SPRITE_IMAGE_PORT equ $5b
SPRITE_INFO_PORT equ $57
;------------------------------------------------------------------------------

IFDEF testing
org $6000
ELSE
org $2000
ENDIF

start
ld hl,$0000
ld de,$4000
ld bc,$800
call TransferDMA ; copy some random data to the screen pointing
; to ROM for now, for the purpose of showing
; how to do a DMA copy.
ld a,0 ; sprite image number we want to update
ld bc,SPRITE_STATUS_SLOT_SELECT
out (c),a ; set the sprite image number
ld bc,1*256 ; number to transfer (1)
ld hl,testsprite ; from
call TransferDMASprite ; transfer to sprite ram

nextreg 21,1 ; turn sprite on. for more info on this check
; out https://www.specnext.com/tbblue-io-port-system/
ld de,0
ld (xpos),de ; set initial X position ( doesn\[aq]t need it for
; this demo, but if you run the .loop again it
; will continue from where it was
ld a,$20
ld (ypos),a ; set initial Y position

\&.loop
ld a,0 ; sprite number we want to position
ld bc,SPRITE_STATUS_SLOT_SELECT
out (c),a
ld de,(xpos)
ld hl,(ypos) ; ignores H so doing this rather than
; ld a,(ypos):ld l,a
ld bc,(image) ; not flipped or palette shifted
call SetSprite

halt

ld de,(xpos)
inc de
ld (xpos),de
ld a,d
cp $01
jr nz,.loop ; if high byte of xpos is not 1 (right of
; screen )
ld a,e
cp $20+1
jr nz,.loop ; if low byte is not $21 just off the right of
; the screen, $20 is off screen but as the
; INC DE is just above and not updated sprite
; after it, it needs to be $21
xor a
ret ; return back to basic with OK

xpos dw 0 ; x position
ypos db 0 ; y position
; these next two BITS and IMAGE are swapped
; as bits needs to go into B register image
; db 0+$80 ; use image 0 (for the image we
; transfered)+$80 to set the sprite to active
bits db 0 ; not flipped or palette shifted

c1 = %11100000
c2 = %11000000
c3 = %10100000
c4 = %10000000
c5 = %01100000
c6 = %01000000
c7 = %00100000
c8 = %00000000

testsprite
db c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1
db c1,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c1
db c1,c2,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c2,c1
db c1,c2,c3,c4,c4,c4,c4,c4,c4,c4,c4,c4,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c5,c5,c5,c5,c5,c5,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c6,c6,c6,c6,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c7,c7,c7,c7,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c7,c8,c8,c7,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c7,c8,c8,c7,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c7,c7,c7,c7,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c6,c6,c6,c6,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c5,c5,c5,c5,c5,c5,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c4,c4,c4,c4,c4,c4,c4,c4,c4,c3,c2,c1
db c1,c2,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c2,c1
db c1,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c1
db c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1

;-------------------------------------------------
; de = X
; l = Y
; b = bits
; c = sprite image
SetSprite
push bc
ld bc,SPRITE_INFO_PORT
out (c),e ; Xpos
out (c),l ; Ypos
pop hl
ld a,d
and 1
or h
out (c),a
ld a,l:or $80
out (c),a ; image
ret

;--------------------------------
; hl = source
; de = destination
; bc = length
;--------------------------------
TransferDMA
di
ld (DMASource),hl
ld (DMADest),de
ld (DMALength),bc
ld hl,DMACode
ld b,DMACode_Len
ld c,ZXN_DMA_PORT
otir
ei
ret

DMACode db DMA_DISABLE
db %01111101 ; R0-Transfer mode, A -> B, write adress
; + block length
DMASource dw 0 ; R0-Port A, Start address
; (source address)
DMALength dw 0 ; R0-Block length (length in bytes)
db %01010100 ; R1-write A time byte, increment, to
; memory, bitmask
db %00000010 ; 2t
db %01010000 ; R2-write B time byte, increment, to
; memory, bitmask
db %00000010 ; R2-Cycle length port B
db DMA_CONTINUOUS ; R4-Continuous mode (use this for block
; transfer), write dest adress
DMADest dw 0 ; R4-Dest address (destination address)
db %10000010 ; R5-Restart on end of block, RDY active
; LOW
db DMA_LOAD ; R6-Load
db DMA_ENABLE ; R6-Enable DMA

DMACode_Len equ $-DMACode

;------------------------------------------------------------------------------
; hl = source
; bc = length
; set port to write to with TBBLUE_REGISTER_SELECT
; prior to call
;------------------------------------------------------------------------------
TransferDMAPort
di
ld (DMASourceP),hl
ld (DMALengthP),bc
ld hl,DMACodeP
ld b,DMACode_LenP
ld c,ZXN_DMA_PORT
otir
ei
ret

DMACodeP db DMA_DISABLE
db %01111101 ; R0-Transfer mode, A -> B, write adress
; + block length
DMASourceP dw 0 ; R0-Port A, Start address (source address)
DMALengthP dw 0 ; R0-Block length (length in bytes)
db %01010100 ; R1-read A time byte, increment, to
; memory, bitmask
db %00000010 ; R1-Cycle length port A
db %01101000 ; R2-write B time byte, increment, to
; memory, bitmask
db %00000010 ; R2-Cycle length port B
db %10101101 ; R4-Continuous mode (use this for block
; transfer), write dest adress
dw $253b ; R4-Dest address (destination address)
db %10000010 ; R5-Restart on end of block, RDY active
; LOW
db DMA_LOAD ; R6-Load
db DMA_ENABLE ; R6-Enable DMA

DMACode_LenP equ $-DMACodeP
;------------------------------------------------------------------------------
; hl = source
; bc = length
;------------------------------------------------------------------------------
TransferDMASprite
di
ld (DMASourceS),hl
ld (DMALengthS),bc
ld hl,DMACodeS
ld b,DMACode_LenS
ld c,ZXN_DMA_PORT
otir
ei
ret

DMACodeS db DMA_DISABLE
db %01111101 ; R0-Transfer mode, A -> B, write adress
; + block length
DMASourceS dw 0 ; R0-Port A, Start address (source address)
DMALengthS dw 0 ; R0-Block length (length in bytes)
db %01010100 ; R1-read A time byte, increment, to
; memory, bitmask
db %00000010 ; R1-Cycle length port A
db %01101000 ; R2-write B time byte, increment, to
; memory, bitmask
db %00000010 ; R2-Cycle length port B
db %10101101 ; R4-Continuous mode (use this for block
; transfer), write dest adress
dw SPRITE_IMAGE_PORT ; R4-Dest address (destination address)
db %10000010 ; R5-Restart on end of block, RDY active
; LOW
db DMA_LOAD ; R6-Load
db DMA_ENABLE ; R6-Enable DMA
DMACode_LenS equ $-DMACodeS
;------------------------------------------------------------------------------
; de = dest, a = fill value, bc = lenth
;------------------------------------------------------------------------------
DMAFill
di
ld (FillValue),a
ld (DMACDest),de
ld (DMACLength),bc
ld hl,DMACCode
ld b,DMACCode_Len
ld c,ZXN_DMA_PORT
otir
ei
ret

FillValue db 22
DMACCode db DMA_DISABLE
db %01111101
DMACSource dw FillValue
DMACLength dw 0
db %00100100,%00010000,%10101101
DMACDest dw 0
db DMA_LOAD,DMA_ENABLE
DMACCode_Len equ $-DMACCode

;------------------------------------------------------------------------------
; End of file
;------------------------------------------------------------------------------

IFDEF testing
savesna \[dq]dmatest.sna\[dq],start
ELSE
fin
savebin \[dq]DMATEST\[dq],start,fin-start
ENDIF
\f[R]
.fi
.RE
.SH Copper and Display Timing
.PP
From: KevB (aka 9bitcolour)
.SS Introduction
.PP
The ZX Spectrum Next includes a co-processor named \[lq]COPPER\[rq].
It functions in a similar way to the Copper found in the Commodore Amiga
Agnus custom chip.
It\[cq]s role is to free the Z80 of tasks that require the writing of
hardware registers at precise pixel co-ordinates.
.SS Overview
.PP
The ZX Spectrum Next COPPER has three instructions: NOOP, MOVE, WAIT.
.PP
NOOP is used to fine tune timing.
MOVE writes data to a specific range of hardware registers.
WAIT waits for a pixel position on the video display.
.PP
These instructions are stored in 2k (2048 BYTES) of dedicated write-only
program RAM also known as a \[lq]Copper list\[rq].
.PP
Each instruction is 16 bits (WORD) in size allowing for a maximum of
1024 instructions to be stored in the program RAM.
The COPPER uses an internal 10 bit program counter (PC) which wraps to
zero at the end of the list.
The PC can be reset to zero, this is the default value after a hard/soft
reset.
.PP
The instructions are stored in big endian format and transferred to the
2k program RAM using the Z80 or DMA (bits 15..8 followed by bits 7..0).
.PP
Three write-only hardware registers control access to the program RAM as
well as the operating modes.
.PP
System performance is not affected when the COPPER is executing
instructions.
.PP
The hardware registers and COPPER program RAM are not connected to the
main memory BUS.
The overall design of this system together with the use of alternate
clock edges means that contention between the COPPER, Z80 and DMA has
been eliminated.
.PP
The COPPER has a base clock speed of 13.5Mhz for HDMI and 14Mhz for VGA.
.PP
The bandwidth is around 14 million single cycle NOOP/WAIT instructions
and 7 million two cycle MOVE instructions per second.
.SS Timing
.PP
To fully understand the COPPER, you must first understand the display
timing for each of the machines and video modes found in the ZX Spectrum
Next.
.PP
There are several display timing configurations due to the four machine
types, two refresh rates, two video systems (VGA/HDMI) and Timex HIRES
mode.
.PP
Details of these timings are outlined in this chapter.
.SS Machines
.PP
The ZX Spectrum Next has four machine types (48k, 128k, Pentagon, and
HDMI).
The machine timing and HDMI determine the number of T-states per line
which determines the base dot clock frequency and Z80/DMA clock speed.
.PP
This guide groups machine types by their timing for convenience.
The HDMI video mode overrides the default machine timing so it is
included as an extra machine type which does not exist in the official
documentation.
.SS Display
.PP
The ZX Spectrum Next doesn\[cq]t have video modes based on resolution
that you would expect to find on graphics card based hardware.
There is one fixed resolution of 256\[u2005]\[tmu]\[u2005]192 which can
be doubled to 512\[u2005]\[tmu]\[u2005]192 in Timex HIRES mode.
What it does have is the ability to set the refresh rate from 50Hz to
60Hz and horizontal dot clock.
This in turn together with the VGA and HDMI timing affects the vertical
line count giving several combinations in total.
.PP
VGA modes 0..6 are included as one single VGA mode as the internal
machine timing is constant across those seven refresh rate steps.
.PP
More details can be found in Video modes.
.SS Resolution
.PP
There are two main horizontal resolutions: standard
256\[u2005]\[tmu]\[u2005]192 and Timex HIRES
512\[u2005]\[tmu]\[u2005]192.
Details of LORES 128\[u2005]\[tmu]\[u2005]96 are not included to
simplify this guide.
.PP
The frame buffer height is fixed at 192 pixels and surrounded by a large
border and overscan as well as horizontal and vertical blanking periods.
.PP
There are five vertical line counts: 261, 262, 311, 312, 320.
Several pixels are hidden in the overscan and blanking periods beyond
the visible border.
.PP
The result is 256\[u2005]\[tmu]\[u2005]192 and
512\[u2005]\[tmu]\[u2005]192 pixel resolutions with a large border.
.PP
The colour of the visible border beyond the frame buffer can be
manipulated.
Visual changes will not show during the overscan and blanking periods.
.SS Dot Clock
.PP
The dot clock on the ZX Spectrum Next runs at 13.5Mhz for HDMI and
around 14Mhz for VGA.
The COPPER clock runs at the same frequency as the dot clock.
For v3.00 the copper runs at twice the frequency of the dot clock.
.PP
The number of dot clocks per line is calculated by multiplying the
number of 3.5Mhz Z80 T-states per line by four.
Example: 228Ts * 4 = 912 dot clocks.
.PP
The number of dot clocks per second is calculated by the following:
.PP
T-states per line * 4 * line count * refresh rate
.PP
In standard 256\[u2005]\[tmu]\[u2005]192 resolution the duration of one
pixel is two dot clocks.
In Timex HIRES 512\[u2005]\[tmu]\[u2005]192 resolution the duration of
one pixel is one dot clock.
.PP
Details of the dot clock counts can be found in tables 5.1 and 5.2.
.SS Coordinates
.PP
The top left pixel of the frame buffer is line 0 and horizontal dot
clock 0.
This is also known as \[lq]0,0\[rq].
.PP
The bottom right pixel of the frame buffer in standard
256\[u2005]\[tmu]\[u2005]192 resolution is line 191 and horizontal dot
clocks 510+511.
.PP
The bottom right pixel of the frame buffer in Timex HIRES
512\[u2005]\[tmu]\[u2005]192 resolution is line 191 and horizontal dot
clock 511.
.PP
The line one pixel above the frame buffer is the last line of the video
frame and equal to the total line count minus one (312-1 for example).
.PP
The line one pixel below the frame buffer is line 192.
.PP
The COPPER horizontal dot clock compare is locked to every eight pixels
in standard 256\[u2005]\[tmu]\[u2005]192 resolution and every sixteen
pixels in Timex HIRES 512\[u2005]\[tmu]\[u2005]192 resolution.
The NOOP instruction can be used to fine tune timing in single dot clock
steps.
.SS Compare
.PP
The COPPER uses a 9 bit vertical line compare allowing it to handle the
various line counts.
.PP
The COPPER horizontal compare is 6 bits meaning that it can wait for 64
positions across each line.
The range of this value is limited by the machine timing as that
determines the number of dot clocks per line.
.PP
Each horizontal compare is in steps of 16 dot clocks to cover the full
range across a raster line.
.PP
16 dot clocks = 4 pixels in lo 128\[u2005]\[tmu]\[u2005]96 resolution
.PP
16 dot clocks = 8 pixels in standard 256\[u2005]\[tmu]\[u2005]192
resolution
.PP
16 dot clocks = 16 pixels in high 512\[u2005]\[tmu]\[u2005]192
resolution
.PP
There is some slack to consider after the maximum horizontal compare
value.
The slack is calculated using the following:
.PP
dot clocks per line - maximum horizontal compare * 16
.PP
Table 5.5 provides details of the horizontal display, left/right border,
blanking and COPPER dot clock/pixel position compare values:
.PP
\[en] Dot clock compare is out of range.
.PP
Table 5.6 provides a detailed list of vertical display, top/bottom
border and blanking as well as maximum COPPER line compare.
It also provides the ULA VBLANK interrupt line number.
.PP
\[en] Line compare is out of range
.PP
* ULA VBLANK interrupt.
.PP
Note: The HDMI overscan and blanking period is larger than that of a VGA
monitor which can auto-adjust alignment.
The following data is based on visible results from various monitors
thus subject to refinement.
.PP
Pixels are visible during DISPLAY/BORDER and hidden during BLANKING.
.SS Overscan
.PP
The visible area of the display can extend to resolutions exceeding
256\[u2005]\[tmu]\[u2005]192.
.PP
The 50/60 Hz refresh rate mode dictates the vertical limit.
.PP
VGA and HDMI differ with VGA providing more visible pixels beyond the
range of HDMI.
Table 5.7 provides ideal extended pixel resolutions:
.PP
Maximum Extended VGA Resolutions
.PP
50Hz = 352\[u2005]\[tmu]\[u2005]288 (standard 256 resolution)
.PP
60Hz = 352\[u2005]\[tmu]\[u2005]240 (standard 256 resolution)
.PP
Table 5.8 provides COPPER horizontal position and vertical line compare
parameters for ideal extended resolutions:
.PP
TOP: Initial line of the extended top border area - see notes below*
.PP
BOT: Last line of the extended bottom border area - see notes below*
.PP
LEFT: First pixel of the extended left border area - see notes below**
.PP
RIGHT: Last pixel of the extended right border area - see notes below**
.PP
* Line compare value for MOVE (bits 8..0).
.PP
** The integer part is the horizontal value for MOVE (bits 14..9).
.PP
** The fractional part is specified in dot clocks (NOOP instructions).
.SS Instructions
.PP
This section describes the behaviour of the COPPER instructions as well
as the bit definitions and execution time.
.PP
The three 16 bit COPPER instructions are comprised of the following bit
definitions:
.PP
H 6 bit horizontal dot clock compare
.PP
V 9 bit vertical line compare
.PP
R 7 bit Next register 0x00..0x7F
.PP
D 8 bit data
.SS NOOP
.PP
NOOP (no-operation) executes in one dot clock.
It is useful for fine tuning timing, initialising COPPER RAM and
\[cq]NOP\[cq] out COPPER program instructions.
.PP
It can be used to align colour and display changes to half pixel
positions in standard 256\[u2005]\[tmu]\[u2005]192 resolution.
Its duration is equal to one Timex HIRES pixel.
.PP
This guide uses the name \[cq]NOOP\[cq] to avoid confusion with the Z80
opcode NOP.
.SS MOVE
.PP
MOVE executes in two dot clocks.
It moves 8 bits of data into any of the Next hardware registers in the
range $00 (0) ..
$7F (127).
.PP
The WORD value $0000 is reserved for the NOOP instruction so no register
access is carried out for that special case.
Register $00 is read-only so not affected by the restriction of not
being able to write zero to it.
.PP
This instruction can perform 7 million register writes per second for
VGA and 6.75 million register writes per second for HDMI.
.SS WAIT
.PP
WAIT executes in one dot clock.
It performs a compare with the current vertical line number and the
current horizontal dot clock.
.PP
WAIT will hold until the current raster line matches the 9 bit value
stored in bits 8..0.
When the line compare matches, WAIT will still hold if the current
horizontal dot clock is less than the value in bits 14..9.
.PP
This compare logic means that out of order vertical line compares will
cause the COPPER to wait until the next video frame as the test is for
an exact match of the line number.
The COPPER will continue to the next instruction after an out of order
horizontal pixel position compare as the test checks for the current dot
clock being greater than or equal to the compare value.
.PP
WAIT will stop the COPPER when a compare is made against an out of range
vertical line or horizontal dot clock position as they will never occur
.PP
A standard way to terminate a COPPER program is to wait for line 511 and
horizontal position 63.
This encodes into the instruction WORD $FFFF.
.PP
The horizontal dot clock position compare includes an adjustment meaning
that the compare completes three dot clocks early in standard
256\[u2005]\[tmu]\[u2005]192 resolution and two dot clocks early in
Timex HIRES 512\[u2005]\[tmu]\[u2005]192 resolution.
In practice, a pixel position can be specified with clocks to spare to
write a register value before the pixel is displayed.
This saves software having to auto-adjust positions to arrive early.
It also means that a wait for 0,0 can affect the first pixel of the
frame buffer before it is displayed and set the scroll registers without
visual artefacts.
.SS Example
.PP
The following example provides a simple COPPER program to move data to a
hardware register at two specific pixel positions.
The BYTES for the program are listed in the left column:
.IP
.nf
\f[C]
         PAL8 equ   0x41           ; 8 bit palette hardware register

$80,$00       WAIT  0,0            ; wait for pixel position 0,0 (H,V)
$00,$00       NOOP                 ; fine tune timing by one dot clock
$41,$E0       MOVE  PAL8,11100000b ; write RED to palette register

$C0,$BF       WAIT  32,191         ; wait for pixel position 256,191
$00,$00       NOOP                 ; fine tune timing by one dot clock
$41,$00       MOVE  PAL8,00000000b ; write BLACK to palette register

$FF,$FF       WAIT  63,511         ; wait for an out of range position
\f[R]
.fi
.SS Control
.PP
The COPPER is controlled by the following three write-only registers:
.IP \[bu] 2
$60 (96) Copper data
.IP \[bu] 2
$61 (97) Copper control LO BYTE
.IP \[bu] 2
$62 (98) Copper control HI BYTE
.PP
The COPPER instructions are written one BYTE at a time to the program
RAM using register $60 (Copper data).
.PP
An index system is used to select the destination write address within
the 2K program RAM.
Eleven bits are needed to represent the index.
Registers $61 and $62 hold this 11 bit index.
.PP
The index increments each time one BYTE is written to register $60.
The index wraps to zero when the last BYTE of program RAM is written.
.PP
The instruction data is normally written in big endian format although
there is no rule stating that partial instruction BYTES cannot be
written.
It is safe to write to the COPPER program RAM while the COPPER is
executing as long the instruction data written does not create a mall
formed instruction which comprises of one half of the current executing
instruction and one half the new instruction - this could result in
unexpected behaviour.
.PP
The Z80 and DMA can be used to write the instruction data.
.PP
Writing to program RAM while the COPPER is running has no impact on
system performance as the RAM is contention free.
COPPER timing is not affected by the Z80 or DMA writing to the program
RAM.
Program RAM is write-only.
.PP
The contents of the 2k program RAM are preserved during a hard/soft
reset.
.PP
Register $61 holds the lower 8 bits of the index.
Register $62 holds the upper 3 bits of the index as well as two control
bits which set the COPPER operating mode.
.PP
D 8 bit data
.PP
I 11 bit index
.PP
C 2 bit control
.PP
The COPPER has an internal 10 bit program counter (PC).
Each instruction advances the program counter by one after completion.
The program counter wraps to zero after the last instruction at location
1023.
This causes the copper list to loop.
.PP
The program counter defaults to zero during a hard/soft reset.
.PP
The control bits require a change to update the operating mode.
This feature preserves COPPER operation when setting the program RAM
index address.
.PP
The program counter is preserved when stopping the COPPER.
Two of the four control settings reset the internal PC to zero.
.PP
Table 5.11 describes the control bits:
.PP
The control mode names used in this guide differ from the official
names.
.PP
Here is a detailed description of the control bits:
.SS STOP
.PP
This is the default operating mode set during a hard/soft reset.
The COPPER is idle in this state and will STOP if currently executing
when entering this mode.
It is safe to write to any location within the 2K program RAM when the
COPPER is stopped.
.PP
Entering STOP mode preserves the internal program counter so that the
COPPER may continue when restarted.
.SS RESET
.PP
The program counter is RESET to zero when entering this mode.
The COPPER is started if idle otherwise entering this mode acts as a
jump to location zero when the COPPER is running.
.SS START
.PP
Entering this mode causes an idle COPPER to start executing instructions
from the current program counter.
Entering this mode while the COPPER is running has no effect other than
to disable FRAME mode if active.
.SS FRAME
.PP
The program counter is RESET to zero when entering this mode.
The COPPER is started if idle otherwise entering this mode acts as a
jump to location zero when the COPPER is running.
.PP
Entering this state enables FRAME mode.
The program counter will be reset to zero each frame at 0,0.
.SS Configuration
.PP
Hardware registers provide timing and configuration data allowing
software to build and configure COPPER programs that function correctly
across the various video modes and machine types.
It is not essential to detect the machine type but it should be noted
that software should not assume that it is running on a specific machine
as the COPPER hardware is available across all four machine types.
.PP
Three registers can be read to determine the machine configuration for
Ts per line, dot clocks, refresh rate, line count and maximum horizontal
dot clock/pixel position compare.
.SS Refresh Rate
.PP
The refresh rate must be taken into account and can change real-time so
should be monitored and auto-configured when the COPPER is active as the
line count will change with the refresh rate.
This could lead to the COPPER waiting for lines that never occur.
.PP
Register (R/W) $05 () \[rA] Peripheral 1 Settings
.IP \[bu] 2
bits 7-6 = joystick 1 mode (MSB)
.IP \[bu] 2
bits 5-4 = joystick 2 mode (MSB)
.IP \[bu] 2
bit 3 = joystick 1 mode (LSB)
.IP \[bu] 2
bit 2 = 50/60 Hz mode (0 = 50Hz, 1 = 60Hz)
.IP \[bu] 2
bit 1 = joystick 2 mode (LSB)
.IP \[bu] 2
bit 0 = Enable Scandoubler
.PP
Joystick modes
.IP \[bu] 2
000 = Sinclair 2 (67890)
.IP \[bu] 2
001 = Kempston 2 (port $37)
.IP \[bu] 2
010 = Kempston 1 (port $1F)
.IP \[bu] 2
011 = Megadrive 1 (port $1F)
.IP \[bu] 2
100 = Cursor
.IP \[bu] 2
101 = Megadrive 2 (port $37)
.IP \[bu] 2
110 = Sinclair 1 (12345)
.IP \[bu] 2
111 = I/O Mode (3.01.04) Both joysticks are places in I/O Mode if either
is set to I/O Mode.
The underlying joystick type is not changed and reads of this register
will continue to return the last joystick type.
Ehether the joystick is in io mode or not is invisible but this state
can be cleared either through reset or by re-writing the gegister with
joystick type not equal to 111.
Recovery time for a normal joystick read after leaving I/O Mode is at
most 64 scan lines.
.SS Video Modes
.PP
The video mode can only be changed during the boot process so one
initial read is required of this register during software start up
phase.
.PP
The machine timing is identical for the seven VGA modes although the
physical refresh rate of the video output speeds up for each mode in
turn by roughly 1Hz.
The internal timing of the machine remains constant and as close to the
original hardware as possible.
VGA is a perfect Amstrad ZX Spectrum 128k +3 for example as far as
timing is concerned across the seven VGA modes.
.PP
The effect of this speed up means that mode 0 will execute in one second
of time whereas mode 6 will execute in a shorter time period.
Mode 0 is as close to 50/60 Hz as possible where mode 6 is closer to
60/70 Hz.
That would mean that one second of machine time for mode 6 will execute
in 0.83 seconds of human time when running 50 frames per second at 60Hz.
.PP
The eighth mode (mode 7) is used for HDMI timing.
Machine configuration is forced for this mode.
Line counts, Ts and various other settings are set to meet the rigid
HDMI timing specification.
For mode 7, 50/60 Hz are rock solid but the original hardware timing
loses Ts across all machines to meet HDMI display requirements.
.PP
Software that was previously written for specific hardware with
hard-coded software timing loops may fail.
This is one of the risks of coding timing loops counting Ts.
We saw evidence of this with the release of the 1985 Sinclair ZX
Spectrum 128k+ and the later Amstrad models as previous software written
for the ZX Spectrum 48k/48k+ would fail when trying to display colour
attribute and border effects as the number of Ts per line was changed
from 224Ts (1982 original 48k) to 228Ts (128k models).
The ZX Spectrum Next runs slower in HDMI mode.
Demos may fail to display correctly and games may slow down although
setting the Z80 to 7Mhz can solve the game slow down, demos should be
run in VGA mode for maximum compatibility.
.PP
Video timing also affects audio output as the sample rate can vary
depending on the output timing method.
.PP
The following register allows software to read the video timing mode:
.PP
Register (R/W) $11 () \[rA] Video Timing (writable in config mode only)
.IP \[bu] 2
bits 7-3 = Reserved, must be 0
.IP \[bu] 2
bits 2-0 = Mode (VGA = 0..6, HDMI = 7)
.RS 2
.IP \[bu] 2
000 = Base VGA timing, clk28 = 28000000
.IP \[bu] 2
001 = VGA setting 1, clk28 = 28571429
.IP \[bu] 2
010 = VGA setting 2, clk28 = 29464286
.IP \[bu] 2
011 = VGA setting 3, clk28 = 30000000
.IP \[bu] 2
100 = VGA setting 4, clk28 = 31000000
.IP \[bu] 2
101 = VGA setting 5, clk28 = 32000000
.IP \[bu] 2
110 = VGA setting 6, clk28 = 33000000
.IP \[bu] 2
111 = HDMI, clk28 = 27000000
.RE
.IP \[bu] 2
50/60Hz selection depends on bit 2 of register $05
.IP \[bu] 2
Only writable in config mode
.SS Machine Type
.PP
The machine type register can be used to provide the number of Ts per
line, line count, dot clock and maximum horizontal COPPER wait.
.PP
The dot clock (DC) is the number of Ts per line * 4.
.PP
The maximum horizontal COPPER wait (H) is in multiples of 16 clocks.
.PP
Video mode 7 (HMDI) overrides the timing.
.PP
The following list shows the various parameters that can be gained from
reading the machine register combined with the refresh register and
video mode bits:
.PP
Register (R/W) $03 () \[rA] Machine Type
.PD 0
.P
.PD
A write to this register disables the boot rom in config mode
.PD 0
.P
.PD
bits 2-0 select machine type when in config mode
.IP \[bu] 2
bit 7 = (W) Display Timing change enable (allow changes to bits 6-4) (0
on hard reset)
.IP \[bu] 2
bits 6-4 = Display Timing
.IP \[bu] 2
bit 3 = Display Timing user lock control
.IP \[bu] 2
Read
.RS 2
.IP \[bu] 2
0 = No user lock on display timing
.IP \[bu] 2
1 = User lock on display timing
.RE
.IP \[bu] 2
Write
.RS 2
.IP \[bu] 2
1 = Apply user lock on display timing (0 on hard reset)
.RE
.IP \[bu] 2
bits 2-0 = Machine Type (config mode only)
.PD 0
.P
.PD
determines roms loaded
.IP \[bu] 2
Machine Types/Display Timings
.RS 2
.IP \[bu] 2
000 or 001 = ZX 48K
.IP \[bu] 2
010 = ZX 128K/+2 (Grey)
.IP \[bu] 2
011 = ZX +2A-B/+3e/Next Native
.IP \[bu] 2
100 = Pentagon 128K
.RE
.SS Summary
.PP
Table 5.13 provides a full list of video timing configuration data:
.SH Interrupts
.SS Interrupt Types
.PP
The Z80 has three different hardware interrupt signals:
$\[rs]overline{\[rs]hbox{RESET}}$, $\[rs]overline{\[rs]hbox{NMI}}$, and
$\[rs]overline{\[rs]hbox{INT}}$.
.SS $\[rs]overline{\[rs]hbox{RESET}}$
.PP
$\[rs]overline{\[rs]hbox{RESET}}$ is used to return the CPU to a known
state.
When the $\[rs]overline{\[rs]hbox{RESET}}$ line is pulled low, a
$\[rs]overline{\[rs]hbox{RESET}}$ is generated.
The CPU then does several things.
I, and R are set to $00.
PC is set to $0000.
SP becomes $FFFF.
A and F are set to $FF.
The interrupt mode is set to 0.
And (maskable) interrupts are disabled by clearing IFF1 and IFF2.
.SS $\[rs]overline{\[rs]hbox{NMI}}$
.PP
$\[rs]overline{\[rs]hbox{NMI}}$ is the non-maskable interrupt.
Upon receiving a non-maskable interrupt ($\[rs]overline{\[rs]hbox{NMI}}$
being pulled low) one of two sequences occur depending on the calue of
bit 3 of the interrupt control register (nextreg $C0).
.PP
Register (R/W) $C0 () \[rA] Interrupt Control (3.01.09)
.PD 0
.P
.PD
($00 on reset)
.IP \[bu] 2
bits 7-5 = Programmable portion of IM2 vector *
.IP \[bu] 2
bit 4 = Reserved, must be 0
.IP \[bu] 2
bit 3 = Enable stackless $\[rs]overline{\[rs]hbox{NMI}}$ response
.IP \[bu] 2
bits 2-1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = Maskable interrupt mode
.RS 2
.IP \[bu] 2
0 - pulse
.IP \[bu] 2
1 - IM2
.RE
.PP
* In IM2 mode vector generated is:
.IP \[bu] 2
bits 7-5 = nextreg $C0 bits 7-5
.IP \[bu] 2
bits 4-1 = Interrupt source
.RS 2
.IP \[bu] 2
0 - line interrupt (highest priority)
.IP \[bu] 2
1 - UART 0 Rx
.IP \[bu] 2
2 - UART 1 Rx
.IP \[bu] 2
3\[en]10 - CTC channels 0-7
.IP \[bu] 2
11 - ULA
.IP \[bu] 2
12 - UART 0 Tx
.IP \[bu] 2
13 - UART 1 Tx (lowest priority)
.RE
.IP \[bu] 2
bit 0 = 0
.PP
If bit 3 is clear (0) PC is pushed on the stack, IFF1 is copied to IFF2,
IFF1 is cleared (inhibiting maskable interrupts).
The $\[rs]overline{\[rs]hbox{NMI}}$ should end with RETN which copies
the contents of IFF2 to IFF1 (returning the interrupt state to what it
was before the $\[rs]overline{\[rs]hbox{NMI}}$) and PC is popped off the
stack.
.PP
If bit 3 is set (1) PC is stored in the $\[rs]overline{\[rs]hbox{NMI}}$
return address registers (nextregs $C2 and $C3), IFF1 is copied to IFF2,
IFF1 is cleared (inhibiting maskable interrupts).
The $\[rs]overline{\[rs]hbox{NMI}}$ should end with RETN which copies
the contents of IFF2 to IFF1 (returning the interrupt state to what it
was before the $\[rs]overline{\[rs]hbox{NMI}}$) and PC is compied from
the $\[rs]overline{\[rs]hbox{NMI}}$ return address registers.
.PP
Register (R/W) $C2 () \[rA] $\[rs]overline{\[rs]hbox{NMI}}$ Return
Address LSB (3.01.09)
.PD 0
.P
.PD
($00 on reset)
.PP
Register (R/W) $C3 () \[rA] $\[rs]overline{\[rs]hbox{NMI}}$ Return
Address MSB (3.01.09)
.PD 0
.P
.PD
($00 on reset)
.SS $\[rs]overline{\[rs]hbox{INT}}$
.PP
The interrupt generally of most interest to programmers is
$\[rs]overline{\[rs]hbox{INT}}$.
So much so that if programmers talk about interrupts on the Z80, they
are probebly only talking about $\[rs]overline{\[rs]hbox{INT}}$.
The processing of $\[rs]overline{\[rs]hbox{INT}}$ is controlled by IFF1
and IFF2 which are set using EI to enable interrupts and reset using DI
to disable interrupts.
Interrupts can happen at any time and should preserve register contents.
If none of your code uses the alternate registers the EXX and EX
AF,AF\[cq] instructions can make this faster and easier.
Interrupt routined should end with EI and RETI to reenable interrupts,
potentially inform the interrupting device that its interrupt has been
serviced, and return from the interrupt routine.
In general the Spectrum machines do not make any distingtion between RET
and RETI, but future developments in the ZX Spectrum Next may make the
distinction important.
.PP
The ZX Spectrum Next has 14 internal sources for
$\[rs]overline{\[rs]hbox{INT}}$ signals.
This can be enabled and disabled using nextregs $C4 \[en] $C6.
Which signals have been received can be read/cleared using nexregs $C8
\[en] $CA.
.PP
Interrupt Enable
.PP
Register (R/W) $C4 () \[rA] Interrupt Enable 0 (3.01.08)
.PD 0
.P
.PD
($83 on reset)
.IP \[bu] 2
bit 7 = Expansion bus $\[rs]overline{\[rs]hbox{INT}}$
.IP \[bu] 2
bits 6-2 = Reserved must be zero
.IP \[bu] 2
bit 1 = Line
.IP \[bu] 2
bit 0 = ULA
.PP
Register (R/W) $C5 () \[rA] Interrupt Enable 1 (3.01.08)
.PD 0
.P
.PD
($00 on reset)
.IP \[bu] 2
bit 7 = ctc channel 7 zc/to
.IP \[bu] 2
bit 6 = ctc channel 6 zc/to
.IP \[bu] 2
bit 5 = ctc channel 5 zc/to
.IP \[bu] 2
bit 4 = ctc channel 4 zc/to
.IP \[bu] 2
bit 3 = ctc channel 3 zc/to
.IP \[bu] 2
bit 2 = ctc channel 2 zc/to
.IP \[bu] 2
bit 1 = ctc channel 1 zc/to
.IP \[bu] 2
bit 0 = ctc channel 0 zc/to
.PP
Register (W) $C6 () \[rA] Interrupt Enable 2 (3.01.08)
.PD 0
.P
.PD
($00 on reset)
.IP \[bu] 2
bit 7 = Reserved, must be 0
.IP \[bu] 2
bit 6 = UART1 Tx empty
.IP \[bu] 2
bit 5 = UART1 Rx half full *
.IP \[bu] 2
bit 4 = UART1 Rx available *
.IP \[bu] 2
bit 3 = Reserved, must be 0
.IP \[bu] 2
bit 2 = UART0 Tx empty
.IP \[bu] 2
bit 1 = UART0 Rx half full *
.IP \[bu] 2
bit 0 = UART0 Rx available *
.PP
* For each UART, Rx half full and Rx available are shared interrupts
.PP
Interupt Status
.PP
Register (R/W) $C8 () \[rA] Interrupt Status 0 (3.01.09)
.PD 0
.P
.PD
($00 on reset)
.IP \[bu] 2
bits 7-2 = Reserved, must be zero
.IP \[bu] 2
bit 1 = Line
.IP \[bu] 2
bit 0 = ULA
.PP
* Set bits indicate the device generated an interrupt in the past *
Writes clear bits where bits are set except in IM2 mode
.PP
Register (R/W) $C9 () \[rA] Interrupt Status 1 (3.01.09)
.IP \[bu] 2
bit 7 = ctc channel 7 zc/to
.IP \[bu] 2
bit 6 = ctc channel 6 zc/to
.IP \[bu] 2
bit 5 = ctc channel 5 zc/to
.IP \[bu] 2
bit 4 = ctc channel 4 zc/to
.IP \[bu] 2
bit 3 = ctc channel 3 zc/to
.IP \[bu] 2
bit 2 = ctc channel 2 zc/to
.IP \[bu] 2
bit 1 = ctc channel 1 zc/to
.IP \[bu] 2
bit 0 = ctc channel 0 zc/to
.PP
* Set bits indicate the device generated an interrupt in the past *
Writes clear bits where bits are set except in IM2 mode
.PP
Register (R/W) $CA () \[rA] Interrupt Status 2 (3.01.09) ($00 on reset)
.IP \[bu] 2
bit 7 = Reserved, must be zero
.IP \[bu] 2
bit 6 = UART1 Tx empty
.IP \[bu] 2
bit 5 = UART1 Rx almost full *
.IP \[bu] 2
bit 4 = UART1 Rx available *
.IP \[bu] 2
bit 3 = Reserved must be zero
.IP \[bu] 2
bit 2 = UART0 Tx empty
.IP \[bu] 2
bit 1 = UART0 Rx almost full *
.IP \[bu] 2
bit 0 = UART0 Rx available *
.PP
* For each UART Rx half full and Rx available are shared interrupts **
Set bits indicate the device generated an interrupt in the past **
Writes clear bits where bits are set except in IM2 mode
.PP
Internal Interrupt Sources
.IP \[bu] 2
0 = Line (highest priority)
.IP \[bu] 2
1 = UART 0 Rx
.IP \[bu] 2
2 = UART 1 Rx
.IP \[bu] 2
3-10 = CTC channels 0-7
.IP \[bu] 2
11 = ULA
.IP \[bu] 2
12 = UART 0 Tx
.IP \[bu] 2
13 = UART 1 Tx (lowest priority)
.SS Interrupt Modes
.SS IM0
.PP
When an interrupt is received by the CPU it disables interrupts and
executes the instruction placed on the bus by the interrupting device
and (no known use on the Next) It is enabled with the IM0 instruction
and enabling interrupts (EI).
.SS IM1
.PP
When an interrupt is received, the CPU disables interrupts and jumps to
an interrupt handler at $0038 (normally in ROM).
The ROM interrupt handler updates the frame counter and scans the
keyboard.
This is the default interrupt handling method for the ZX Spectrum and is
probably the method to use if you don\[cq]t need the ROMs for anything.
It is enabled using the IM1 instruction and enabling interrupts.
.SS IM2
.PP
The ZX Spectrum Next has both a legacy method for handling IM2 and an
updated one which makes better use of the capabilities of IM2 which was
added in Core 3.01.09.
.PP
The ZX Spectrum Next has 14 interrupt devices which can all be given
independent interrupt vectors when using IM2.
These interrupts are controlled by nextregs $C0 \[en] $CF.
The address of the vector for a given interrupt is created by composing
the I register (bits 15-0), nextreg $C0 bits 7-5 (bits 7-5) and the
interrupt number of the interrupt device (bits 4-1).
This means that even if you use all 14 internal interrupt sources, your
interrupt vector table is no more than 28 bytes which can be at any 32
byte boundry.
It also means that far less processing has to be done on interrupts
which are received.
External interrupts are a little different.
If no vector is supplied by a device the implied LSB will be $FF.
.PP
While in IM2 mode, it is possible for interrupts to interrupt DMA
transfers.
This capability is controlled by The DMA Interrupt enable registers
(nextregs $CC \[en] $CE).
When DMA is interrupted, one instruction of the main program will be
processed, then the interrupt will be taken.
On return, DMA will continue.
.PP
Register (R/W) $CC () \[rA] DMA Interrupt Enable 0 (3.01.09) ($00 on
reset)
.IP \[bu] 2
bits 7-2 = Reserved, must be 0
.IP \[bu] 2
bit 1 = Line
.IP \[bu] 2
bit 0 = ULA
.PP
* Set bits indicate the specified interrupt will interrupt a DMA
operation when in IM2 mode
.PP
Register (R/W) $CD () \[rA] DMA Interrupt Enable 1 (3.01.09) ($00 on
reset)
.IP \[bu] 2
bit 7 = CTC channel 7 zc/to
.IP \[bu] 2
bit 6 = CTC channel 6 zc/to
.IP \[bu] 2
bit 5 = CTC channel 5 zc/to
.IP \[bu] 2
bit 4 = CTC channel 4 zc/to
.IP \[bu] 2
bit 3 = CTC channel 3 zc/to
.IP \[bu] 2
bit 2 = CTC channel 2 zc/to
.IP \[bu] 2
bit 1 = CTC channel 1 zc/to
.IP \[bu] 2
bit 0 = CTC channel 0 zc/to
.PP
* Set bits indicate the corresponding interrupt will interrupt a DMA
operation when in IM2 mode
.PP
Register (R/W) $CE () \[rA] DMA Interrupt Enable 2 (3.01.09) ($00 on
reset)
.IP \[bu] 2
bit 7 = Reserved, must be 0
.IP \[bu] 2
bit 6 = UART1 Tx empty
.IP \[bu] 2
bit 5 = UART1 Rx half full
.IP \[bu] 2
bit 4 = UART1 Rx available
.IP \[bu] 2
bit 3 = Reserved, must be 0
.IP \[bu] 2
bit 2 = UART0 Tx empty
.IP \[bu] 2
bit 1 = UART0 Tx half full
.IP \[bu] 2
bit 0 = UART0 Tx available
.PP
* Set bits indicate the corresponding interrupt will interrupt a DMA
operation when in IM2 mode.
.PP
In legacy mode, when the CPU receives an interrupt it disables
interrupts and jumps to an interrupt routine starting at the contents of
the jump table at I.
The start of the interrupt routine is the contents of I*$100+bus and
I*$100+bus+1.
Most devices that can supply interrupts on the ZX Spectrum leave the
data bus in a floating state.
As a result the interpreted state of the data bus while generally $FF is
not entirely predictable.
The solution to place your interrupt routine at an address where the MSB
and LSB are the same ($0101, $0202, \&... $FFFF) then place 257 copies
of that value in a block starting at I*$100 (you can set the value of
the I register).
.PP
Code:
.IP
.nf
\f[C]
;; my program
org $8000
;; enable interrupt mode im2
ld i,$fe
im2
ei
;; program body
;; interrupt routine
handler:
;; preserve registers used
;; handle interrupt
;; restore registers
ei
reti
;; jump to interrupt routine
org $fdfd
jp handler
;; im2 jump table
org $fe00 ; not actually legal
defs $101,$fd
\f[R]
.fi
.SS Z80 CTC
.PP
(3.01.08) Untested, assuming it acts like two Z80 CTCs.
.PP
Eight independent CTC channels are available on ports $183B through
$1F3B.
These perform counter/timer functions that can be used to generate timer
interrupts or to generate interrupts from physical signals.
.PP
The CTC is a standard Zilog part.
Its datasheet can be found at http://www.zilog.com/docs/z80/ps0181.pdf .
The Zilog documentation is ambiguous around how soft resets are treated
so the following clarifies some points in the Next\[cq]s implementation.
.IP "1." 3
Hard reset requires both a control word and a time constant to be
written to a channel even if bit 2 = 0 in the first control word.
.IP "2." 3
Soft reset with bit 2 = 0 causes the entire control register to be
modified.
Soft reset with bit 2 = 1 does not change the control register contents.
In both cases a time constant must follow to resume operation.
.IP "3." 3
Changing the trigger edge selection in bit 4 while the channel is in
operation counts as a clock edge.
A pending timer trigger will be fired and, in counter mode, an edge will
be received.
.IP "4." 3
ZC/TO is asserted for one clock cycle and not for the entire duration
that the count is at zero.
.PP
At the moment, any interrupt generated by the CTC will assert the
z80\[cq]s /INT line for 32 cpu cycles.
This is the same way that the ULA and line interrupts operate.
.PP
At the moment, the ZC/TO output of each channel is fed into the CLK/TRG
input of the succeeding channel so that time and count periods can be
cascaded.
.SS Programming
.PP
Initial values are set by a write of a channel control word followed by
a time constant.
In timer mode, the counter decrements every time it is triggered.
In counter mode it decrements every time the prescaler counter reaches
zero.
.PP
Channel Control Word
.IP \[bu] 2
bit 7 = Enable Interrupt
.IP \[bu] 2
bit 6 = Mode
.RS 2
.IP \[bu] 2
0 = Timer mode
.IP \[bu] 2
1 = Counter mode
.RE
.IP \[bu] 2
bit 5 = Prescalar value (Timer mode only)
.RS 2
.IP \[bu] 2
0 = 16
.IP \[bu] 2
1 = 256
.RE
.IP \[bu] 2
bit 4 = CLK/TRG edge selection
.RS 2
.IP \[bu] 2
0 = Falling Edge
.IP \[bu] 2
1 = Rising Edge
.RE
.IP \[bu] 2
bit 3 = Timer Trigger (Timer mode only)
.RS 2
.IP \[bu] 2
0 = Starts on loading of time constant
.IP \[bu] 2
1 = Starts on CLK/TRG
.RE
.IP \[bu] 2
bit 2 = Time constant follows
.IP \[bu] 2
bit 1 = Software reset
.IP \[bu] 2
bit 0 = 0 (Control Word)
.PP
If we are running at 28MHz (Mode 0) and wish to trigger an interrupt
every 1 sec, that is 28 million T-States/cycles we could program CTC 5
as a counter with a prescalar of 16 and a period of 175, CTC 6 as a
counter with a prescalar of 16 and a period of 125, and CTC 7 as a timer
with a period of 5.
.PP
CTC 5 triggers ZC5 every 280 cycles or 10 usec.
.PP
CTC 6 triggers ZC6 every 560,000 cycles or 20 msec.
.PP
CTC 7 triggers ZC7 and an interrupt every 28,000,000 cycles or 1 sec.
.IP
.nf
\f[C]
di
; set up interrupt routine
im 2
ld bc,$183B     ; CTC 0
ld hl,$FFFA     ; address pointing to start of interrupt routine
ld de,interrupt ; start of interrupt routine
ld (hl),de
ld i,$FF
ld a,l          ; Vector to address at on this interrupt
out (c),a
; set up CTC 5
ld b,$1D        ; CTC 5
ld a,$87
out (c),a       ; Interrupt mode, timer mode, time constant, soft, control
ld a,$05
out (c),a       ; once every 5 times 
; set up CTC 6
inc b           ; CTC 6
ld a,$47
out (c),a       ; 16x, counter mode, time constant, soft, control
ld a,$7D        ; 125 = once every 2000 times
out (c),a
; set up CTC 7
inc b           ; CTC 7
ld a,$47
out (c),a       ; 16x, counter mode, time constant, soft, control
ld a,$AF        ; 175 = once every 2800 times
ei
\f[R]
.fi
.SH Serial Communication
.PP
The Spectrum Next has two independent fully featured UARTs.
The UARTS share I/O ports so it is important to select the correct one
before communicating with it.
Each has its own 64 byte Tx buffer and 512 byte Rx buffer.
One UART can be connected to either the ESP of joystick port while the
other can be connected to the Raspberry Pi accelerator or joystick port.
The UARTS are controlled using ports $37, $133B, $143B, $153B, and
$163B.
The UARTs are connected to the IM2 interrupt system.
Nextreg $c6 allows interrupts to be enabled for the status of each UART.
UART interrupts correspond to interrupts 1, 2, 12, and 13 (see
Interrupts).
.PP
Port $37 () Kempston/Mega Drive Joystick 2
.PD 0
.P
.PD
Read
.IP \[bu] 2
bit 7 = \[rq]start\[rq] button
.IP \[bu] 2
bit 6 = A/X button
.IP \[bu] 2
bit 5 = C/Z button
.IP \[bu] 2
bit 4 = Fire/C/Y button
.IP \[bu] 2
bit 3 = Up
.IP \[bu] 2
bit 2 = Down
.IP \[bu] 2
bit 1 = Left
.IP \[bu] 2
bit 0 = Right
.PP
Disable with Nextreg $05
.PD 0
.P
.PD
Write ($00 on reset, 3.01.04)
.IP \[bu] 2
bits 7-6 = Select I/O Mode
.RS 2
.IP \[bu] 2
00 = Bit Bang
.IP \[bu] 2
01 = Clock
.IP \[bu] 2
10 = UART
.IP \[bu] 2
11 = Reserved (don\[cq]t use)
.RE
.IP \[bu] 2
bit 5 = Reserved, must be 0
.IP \[bu] 2
bit 4 = Select Joystick Port for Read
.RS 2
.IP \[bu] 2
0 = Left
.IP \[bu] 2
1 = Right
.RE
.IP \[bu] 2
bits 3-1 = Reserved, must be $00
.IP \[bu] 2
bit 0 = Pin 7 state (both ports)
.RS 2
.IP \[bu] 2
Bit Bang - bit 0 on pin 7
.IP \[bu] 2
Clock - clock on pin 7
.PD 0
.P
.PD
0 = Slow clock (Fsys/2048 = 12.672 kHz)
.PD 0
.P
.PD
1 = Fast clock (Fsys/8 = 3.5 MHz)
.IP \[bu] 2
UART - Pin 7 = TX, Pin 9 = RX 0 = ESP
.PD 0
.P
.PD
1 = Pi
.RE
.PP
** A Runt clock may appear in the first cycle
.PD 0
.P
.PD
The I/O mode should be set by writing this port first followed by
enabling io mo de on the joysticks with a write to nextreg 0x05.
.PP
Port $133B () UART tx
.PD 0
.P
.PD
Read: UART Status
.PD 0
.P
.PD
.IP \[bu] 2
bits 7-4 = Reserved (0)
.IP \[bu] 2
bit 3 = UART at least half full (3.01.09)
.IP \[bu] 2
bit 2 = UART full
.IP \[bu] 2
bit 1 = UART transmit busy
.IP \[bu] 2
bit 0 = UART receive has data
.PP
Write: UART Transmit
.PP
Port $143B () UART rx
.PD 0
.P
.PD
Read: UART Receive
.PD 0
.P
.PD
Write: UART Prescalar
.IP \[bu] 2
bit 7 = select prescalar part
.RS 2
.IP \[bu] 2
0 = Bits 6-0 of prescalar
.IP \[bu] 2
1 = Bits 13-7 of prescalar
.RE
.IP \[bu] 2
bits 6-0 = Prescalar bits
.PP
Port $153B () UART select
.IP \[bu] 2
bit 7 = Reserved (0)
.IP \[bu] 2
bit 6 = UART select (0 on soft reset) **
.RS 2
.IP \[bu] 2
0 = ESP
.IP \[bu] 2
1 = Pi *
.RE
.IP \[bu] 2
bit 5 = Reserved (0)
.IP \[bu] 2
bit 4 = Prescalar valid in this write
.IP \[bu] 2
bit 3 = Reserved (0)
.IP \[bu] 2
bits 2-0 = Bits 16-14 of prescalar (0 on hard reset)
.PP
* Pi GPIO must be configured for UART, see nextreg $A0
.PD 0
.P
.PD
** Either UART can be redirected to the joystick ports, see port $037
.PP
Port $153B () UART frame (upcoming)
.PD 0
.P
.PD
($18 on hard reset)
.IP \[bu] 2
bit 7 = Immediately reset Rx and Tx to idle and empty FIFOs
.IP \[bu] 2
bit 6 = Assert break (Tx=0) when Tx reaches idle
.IP \[bu] 2
bit 5 = Enable hardware flow control *
.IP \[bu] 2
bits 4-3 = Number of bits in a frame
.RS 2
.IP \[bu] 2
00 = 5 bits
.IP \[bu] 2
01 = 6 bits
.IP \[bu] 2
10 = 7 bits
.IP \[bu] 2
11 = 8 bits
.RE
.IP \[bu] 2
bit 2 = Enable parity
.IP \[bu] 2
bit 1 = Parity
.RS 2
.IP \[bu] 2
0 = Even parity
.IP \[bu] 2
1 = Odd parity
.RE
.IP \[bu] 2
bit 0 = Number of stop bits
.RS 2
.IP \[bu] 2
0 = 1 stop bit
.IP \[bu] 2
1 = 2 stop bits
.RE
.PP
Register (R/W) $C0 () \[rA] Interrupt Control (3.01.09)
.PD 0
.P
.PD
($00 on reset)
.IP \[bu] 2
bits 7-5 = Programmable portion of IM2 vector *
.IP \[bu] 2
bit 4 = Reserved, must be 0
.IP \[bu] 2
bit 3 = Enable stackless $\[rs]overline{\[rs]hbox{NMI}}$ response
.IP \[bu] 2
bits 2-1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = Maskable interrupt mode
.RS 2
.IP \[bu] 2
0 - pulse
.IP \[bu] 2
1 - IM2
.RE
.PP
* In IM2 mode vector generated is:
.IP \[bu] 2
bits 7-5 = nextreg $C0 bits 7-5
.IP \[bu] 2
bits 4-1 = Interrupt source
.RS 2
.IP \[bu] 2
0 - line interrupt (highest priority)
.IP \[bu] 2
1 - UART 0 Rx
.IP \[bu] 2
2 - UART 1 Rx
.IP \[bu] 2
3\[en]10 - CTC channels 0-7
.IP \[bu] 2
11 - ULA
.IP \[bu] 2
12 - UART 0 Tx
.IP \[bu] 2
13 - UART 1 Tx (lowest priority)
.RE
.IP \[bu] 2
bit 0 = 0
.PP
Register (W) $C6 () \[rA] Interrupt Enable 2 (3.01.08)
.PD 0
.P
.PD
($00 on reset)
.IP \[bu] 2
bit 7 = Reserved, must be 0
.IP \[bu] 2
bit 6 = UART1 Tx empty
.IP \[bu] 2
bit 5 = UART1 Rx half full *
.IP \[bu] 2
bit 4 = UART1 Rx available *
.IP \[bu] 2
bit 3 = Reserved, must be 0
.IP \[bu] 2
bit 2 = UART0 Tx empty
.IP \[bu] 2
bit 1 = UART0 Rx half full *
.IP \[bu] 2
bit 0 = UART0 Rx available *
.PP
* For each UART, Rx half full and Rx available are shared interrupts
.SH Raspberry Pi0 Acceleration
.PP
The Spectrum Next has a header (with male pins) which can be attached to
a Raspberry Pi Zero.
There is a modified version of DietPi called NextPi which is the
standard distro for the Raspberry Pi0 accelerator.
Software for the general public should be written assuming that it will
be interfacing with a Pi0 running this distro.
.PP
If you are more adventurous, you may choose to use another distro, or
even another accelerator that uses the Raspberry Pi style (40 pin)
expansion bus.
Chief concers when doing this is that you have a console presented on
the UART that defaults to 115,200 bps, you don\[cq]t need to login, the
machine is configured with a driver to treat the I^2^S interface as a
sound card, and the presence of the nextpi scripts.
.PP
The Raspberry Pi 0 has a Broadcom BCM2835 SoC with an ARMv6 core, a
Videocore 4 GPU, and its own 512 MB memory and HDMI output.
It has its own SD card from which it boots.
For this application the Pi 0 ships with a 1GB microSD card containing
NextPi a customized version of DietPi.
.PP
The Pi Zero, if installed, is a smart peripheral for the ZX Spectrum
Next.
Available interfaces are: low level access to the GPIO pins, higher
level access to standardized I/O interfaces, and use of the Pi Zero as a
sound card.
.PP
When using the low level GPIO interface Pi Zero GPIO pins 2-27 can be
configured as either inputs or outputs using nextregs $90-$93.
If they are outputs, the output state can be set by writing to nextregs
$98-$9b.
The current status of the GPIO pins can be read from nextregs $98-$9b
whether it is the state driven by the ZX Spectrum Next or the state
drive by some other peripherial attached to the bus (normally the
Raspberry Pi Zero).
.PP
Register (R/W) $90 () \[rA] Pi GPIO output enable 1/4
.IP \[bu] 2
bit 7 = Enable Pin 7 (0 on reset)
.IP \[bu] 2
bit 6 = Enable Pin 6 (0 on reset)
.IP \[bu] 2
bit 5 = Enable Pin 5 (0 on reset)
.IP \[bu] 2
bit 4 = Enable Pin 4 (0 on reset)
.IP \[bu] 2
bit 3 = Enable Pin 3 (0 on reset)
.IP \[bu] 2
bit 2 = Enable Pin 2 (0 on reset)
.IP \[bu] 2
bit 1 = Enable Pin 1 (cannot be enabled) (0 on reset)
.IP \[bu] 2
bit 0 = Enable Pin 0 (cannot be enabled) (0 on reset)
.PP
Register (R/W) $91 () \[rA] Pi GPIO output enable 2/4
.IP \[bu] 2
bit 7 = Enable Pin 15 (0 on reset)
.IP \[bu] 2
bit 6 = Enable Pin 14 (0 on reset)
.IP \[bu] 2
bit 5 = Enable Pin 13 (0 on reset)
.IP \[bu] 2
bit 4 = Enable Pin 12 (0 on reset)
.IP \[bu] 2
bit 3 = Enable Pin 11 (0 on reset)
.IP \[bu] 2
bit 2 = Enable Pin 10 (0 on reset)
.IP \[bu] 2
bit 1 = Enable Pin 9 (0 on reset)
.IP \[bu] 2
bit 0 = Enable Pin 8 (0 on reset)
.PP
Register (R/W) $92 () \[rA] Pi GPIO output enable 3/4
.IP \[bu] 2
bit 7 = Enable Pin 23 (0 on reset)
.IP \[bu] 2
bit 6 = Enable Pin 22 (0 on reset)
.IP \[bu] 2
bit 5 = Enable Pin 21 (0 on reset)
.IP \[bu] 2
bit 4 = Enable Pin 20 (0 on reset)
.IP \[bu] 2
bit 3 = Enable Pin 19 (0 on reset)
.IP \[bu] 2
bit 2 = Enable Pin 18 (0 on reset)
.IP \[bu] 2
bit 1 = Enable Pin 17 (0 on reset)
.IP \[bu] 2
bit 0 = Enable Pin 16 (0 on reset)
.PP
Register (R/W) $93 () \[rA] Pi GPIO output enable 4/4
.IP \[bu] 2
bits 7-4 = Reserved
.IP \[bu] 2
bit 3 = Enable Pin 27 (0 on reset)
.IP \[bu] 2
bit 2 = Enable Pin 26 (0 on reset)
.IP \[bu] 2
bit 1 = Enable Pin 25 (0 on reset)
.IP \[bu] 2
bit 0 = Enable Pin 24 (0 on reset)
.PP
Register (R/W) $98 () \[rA] Pi GPIO Pin State 1/4
.IP \[bu] 2
bit 7 = Pin 7 Data (1 on reset)
.IP \[bu] 2
bit 6 = Pin 6 Data (1 on reset)
.IP \[bu] 2
bit 5 = Pin 5 Data (1 on reset)
.IP \[bu] 2
bit 4 = Pin 4 Data (1 on reset)
.IP \[bu] 2
bit 3 = Pin 3 Data (1 on reset)
.IP \[bu] 2
bit 2 = Pin 2 Data (1 on reset)
.IP \[bu] 2
bit 1 = Pin 1 Data (1 on reset)
.IP \[bu] 2
bit 0 = Pin 0 Data (1 on reset)
.PP
Register (R/W) $99 () \[rA] Pi GPIO Pin State 2/4
.IP \[bu] 2
bit 7 = Pin 15 Data (1 on reset)
.IP \[bu] 2
bit 6 = Pin 14 Data (1 on reset)
.IP \[bu] 2
bit 5 = Pin 13 Data (1 on reset)
.IP \[bu] 2
bit 4 = Pin 12 Data (1 on reset)
.IP \[bu] 2
bit 3 = Pin 11 Data (1 on reset)
.IP \[bu] 2
bit 2 = Pin 10 Data (1 on reset)
.IP \[bu] 2
bit 1 = Pin 9 Data (1 on reset)
.IP \[bu] 2
bit 0 = Pin 8 Data (1 on reset)
.PP
Register (R/W) $9A () \[rA] Pi GPIO Pin State 3/4
.IP \[bu] 2
bit 7 = Pin 23 Data (1 on reset)
.IP \[bu] 2
bit 6 = Pin 22 Data (1 on reset)
.IP \[bu] 2
bit 5 = Pin 21 Data (1 on reset)
.IP \[bu] 2
bit 4 = Pin 20 Data (1 on reset)
.IP \[bu] 2
bit 3 = Pin 19 Data (1 on reset)
.IP \[bu] 2
bit 2 = Pin 18 Data (1 on reset)
.IP \[bu] 2
bit 1 = Pin 17 Data (1 on reset)
.IP \[bu] 2
bit 0 = Pin 16 Data (1 on reset)
.PP
Register (R/W) $9B () \[rA] Pi GPIO Pin State 4/4
.IP \[bu] 2
bits 7-4 = Reserved
.IP \[bu] 2
bit 3 = Pin 27 Data (1 on reset)
.IP \[bu] 2
bit 2 = Pin 26 Data (1 on reset)
.IP \[bu] 2
bit 1 = Pin 25 Data (1 on reset)
.IP \[bu] 2
bit 0 = Pin 24 Data (1 on reset)
.PP
Standardized I/O access with the Pi Zero can use the I^2^C , SPI, or
UART interfaces and is configured using nextreg $a0.
Any enabled port will disable low level (write) access to the
corresponding GPIO pins.
.PP
Register (R/W) $A0 () \[rA] Pi Peripheral Enable
.IP \[bu] 2
bits 7-6 = Reserved, must be 0
.IP \[bu] 2
bit 5 = Enable UART on GPIO 14, 15 (0 on reset)*
.IP \[bu] 2
bit 4 = Communication Type (0 on reset)
.RS 2
.IP \[bu] 2
0 = Rx to GPIO 15, Tx to GPIO 14 (Pi)
.IP \[bu] 2
1 = Rx to GPIO 14, Tx to GPIO 15 (Pi Hats)
.RE
.IP \[bu] 2
bit 3 = Enable I^2^C on GPIO 2, 3 (0 on reset)*
.IP \[bu] 2
bits 2-1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = Enable SPI on GPIO 7, 8, 9, 10, 11 (0 on reset)*
.PP
*Overrides GPIO Enables
.PP
The I^2^C interface is controlled using ports $103b (SCL) and $113b
(SDA).
This is the same I^2^C interface that is used for the optional Real Time
Clock.
Interfacing with the Pi Zero over I^2^C is complicated by the fact that
it is a master/slave interface, but both the ZX Spectrum Next and Pi
Zero are configured to be bus masters.
.PP
Port $103B () I^2^C SCL (rtc, rpi)
.PP
Port $113B () I^2^C SDA (rtc, rpi)
.PP
The SPI interface is controlled using ports $e7 (/CS) and $eb (/DATA).
The SPI interface is shared between the SD card(s), the flash memory,
and the Pi Zero.
Interfacing with the Pi Zero over SPI is complicated by the fact it is a
master/slave interface and both the ZX Spectrum Next and Pi Zero are
configured to be bus masters.
.PP
Port $E7 () SPI $\[rs]overline{\[rs]hbox{CS}}$ (SD card, flash, rpi)
.PD 0
.P
.PD
Disable with bit 2 of Nextreg $09
.PP
Port $EB () SPI $\[rs]overline{\[rs]hbox{DATA}}$ (SD card, flash, rpi)
.PD 0
.P
.PD
Disable with bit 2 of Nextreg $09
.PP
The default means of communication between the ZX Next and the Pi is
through the UART interface (see serial communications chapter).
In order to communicate withe the Pi the Pi UART must be connected to
the Pi by setting nextreg $a0 bits 5 and 4 to 1, selecting the Pi UART
by setting port $153b bit 6 to 1 and ensuring that both ends are using
matching communication protocols (by default 115,200 bps, 8N1 and no
flow control).
On the Pi end the UART is connected to the serial console.
.IP
.nf
\f[C]
;; enable UART connection with Pi Zero
   ld c,$3b
   ld b,$15 ; UART control
;; select Pi on UART control
   in a,(c)
   or $40
   out (c),a
   ld b,$24 ; Next Register Select
   ld a,$a0
   out (c),a
   inc b ; Next Register Data
;; Enable UART on GPIO and select Pi
   in a,(c)
   or $30
   out (c),a
\f[R]
.fi
.PP
The I^2^S sound interface between the ZX Spectrum Next and the Pi Zero
is controlled by nextregs $a2 and $a3.
Normally, one would control the Pi through some other channel such as
the UART recieve audio from the Pi to either use as a fulloy
programmable sound card or to allow loading of tape files on the ZX
Spectrum Next.
.PP
Register (R/W) $A2 () \[rA] Pi I^2^S Audio Control
.IP \[bu] 2
bits 7-6 = I^2^S State ($00 on reset)
.RS 2
.IP \[bu] 2
00 = I^2^S Disabled
.IP \[bu] 2
01 = I^2^S is mono, source R
.IP \[bu] 2
10 = I^2^S is mono, source L
.IP \[bu] 2
11 = I^2^S is stereo
.RE
.IP \[bu] 2
bit 5 = Reserved, must be 0
.IP \[bu] 2
bit 4 = Audio Flow Direction (0 on reset)
.RS 2
.IP \[bu] 2
0 = PCM_DOUT to Pi, PCM_DIN from Pi (Hats)
.IP \[bu] 2
1 = PCM_DOUT from Pi, PCM_DIN to Pi (Pi)
.RE
.IP \[bu] 2
bit 3 = Mute left (0 on reset)
.IP \[bu] 2
bit 2 = Mute right (0 on reset)
.IP \[bu] 2
bit 1 = Slave mode, Reserved must be 1 (remove in 3.01.05)
.IP \[bu] 2
bit 0 = Direct I^2^S audio to EAR on port $FE (0 on reset)
.PP
Register (R/W) $A3 () \[rA] Pi I^2^S Clock Divide (Master Mode) (removed
in 3.01.05)
.IP \[bu] 2
bits 7-0 = Clock divide value ($0B on reset)
.PP
$\[rs]hbox{Divider}=\[rs]frac{538461}{\[rs]hbox{Rate}}-1$ or
$\[rs]hbox{Rate}=\[rs]frac{538461}{\[rs]hbox{Divider}+1}$
.SH System Software
.SS CP/M
.PP
The ZX Spextrum Next has support for CP/M+ 3.0.
CP/M was the most popular microcomputer coperating system prior to the
advent of MS-DOS.
.SS Utilities
.PP
From the Digital Research: CP/M 3 Command Reference Manual 1984
.PP
This section documents all standard CP/M+ 3 commands plus those extras
included with the ZX Spectrum Next CP/M system.
.PP
\f[B]COLOURS\f[R]
.PP
Parameters:\f[B]Syntax:\f[R] \f[B]COLOURS [RGB] \f[BI]paper\f[B]
\f[BI]ink\f[B]\f[R]
.PP
\f[B]Function:\f[R] Sets the screen colours
.PP
\f[B]Parameters:\f[R]
.PP
Parameters\f[I]paper\f[R] Paper (background) colour
.PP
Parameters:\f[I]ink\f[R] Ink (foreground) colour
.PP
\f[B]Options:\f[R]
.PP
Parameters:RGB Causes ink and paper colours to be interpreted as 9-bit
octal RGB numbers
.PP
\f[B]Notes:\f[R] Sets the screen colours using standard ZX colours or
octal 9-bit RGB numbers.
.PP
\f[B]Examples:\f[R]
.PP
colours 1 6
.PP
colours rgb 000 750
.PP
\f[B]COPYSYS\f[R]
.PP
Parameters:\f[B]Syntax:\f[R] \f[B]COPYSYS\f[R]
.PP
\f[B]Function:\f[R] Copy CP/M system
.PP
\f[B]Notes:\f[R] COPYSYS copies the CP/M Plus system from a CP/M Plus
system diskette to another diskette.
The new diskette must have the same format as the original system
diskette.
.PP
\f[B]DATE\f[R]
.PP
Parameters:\f[B]Syntax:\f[R] \f[B]DATE\f[R]
.PD 0
.P
.PD
\f[B]DATE C\f[R]
.PD 0
.P
.PD
\f[B]DATE CONTINUOUS\f[R]
.PD 0
.P
.PD
\f[B]DATE \f[BI]time-specification\f[B]\f[R]
.PD 0
.P
.PD
\f[B]DATE SET\f[R]
.PP
\f[B]Function:\f[R] The DATE command lets you display and set the date
and time of day.
.PP
\f[B]Parameters:\f[R]
.PP
Parameters\f[I]time-specification\f[R] Time/date in the format MM/DD/YY
HH:MM:SS
.PP
\f[B]Options:\f[R]
.PP
Parameters:C Continuously show the date and time until a key is pressed
.PP
Parameters:CONTINUOUS Continuously show the date and time until a key is
pressed
.PP
Parameters:SET Prompt the user for the current date and time
.PP
\f[B]Notes:\f[R] The DATE command is a transient utility that lets you
display and set the date and time of day.
When you start CP/M 3, the date and time are set to the creation date of
your CP/M 3 system.
Use DATE to change this initial value to the current date and time.
.PP
\f[B]Examples:\f[R]
.PP
DATE
.PP
DATE C
.PP
DATE CONTINUOUS
.PP
DATE 08/13/82 09:15:37
.PP
DATE SET
.PP
\f[B]DEVICE\f[R]
.PP
Syntax:
.PD 0
.P
.PD
DEVICE
.PD 0
.P
.PD
DEVICE NAMES
.PD 0
.P
.PD
DEVICE VALUES
.PD 0
.P
.PD
DEVICE logical-dev {XON|NOXON|baud-rate},
.PD 0
.P
.PD
DEVICE physical-dev {XON|NOXON|baud-rate}
.PD 0
.P
.PD
DEVICE logical-dev=physical-dev {option} {,physical-dev {option},...}
.PD 0
.P
.PD
DEVICE logical-dev = NULL
.PD 0
.P
.PD
DEVICE CONSOLE {PAGE}
.PD 0
.P
.PD
DEVICE CONSOLE {COLUMNS=n, LINES=n}
.PD 0
.P
.PD
DEVICE displays current logical device assignments and physical device
names.
.PP
\f[B]DIR\f[R] (built-in)
.PP
Syntax:
.PD 0
.P
.PD
DIR
.PD 0
.P
.PD
DIR d:
.PD 0
.P
.PD
DIR filespec
.PD 0
.P
.PD
DIR d: options
.PD 0
.P
.PD
DIR filespec,...
filespec options
.PP
The DIR command displays the names of files catalogued in the directory
of an online disk that belong to current user number and have the
Directory (DIR) attribute.
DIR accepts the * and ?
wildcards in the file specification.
.PP
The DIR command with options displays the names of files and the
characteristics associated with the files.
DIR is a built-in utility.
DIR with options is a transient utility and must be loaded into memory
from the disk.
.PP
\f[B]DIRSYS/DIRS\f[R] (built-in)
.PP
Syntax:
.PD 0
.P
.PD
DIRSYS
.PD 0
.P
.PD
DIRSYS d:
.PD 0
.P
.PD
DIRSYS filespec
.PP
The DIRSYS command lists the names of files in the current directory
that have the system (SYS) attribute.
DIRSYS accept the * and ?
wildcards in the file specification.
DIRSYS is a built-in utility.
.PP
\f[B]DUMP\f[R]
.PP
Syntax:
.PD 0
.P
.PD
DUMP filespec
.PP
DUMP displays the contents of a file in and ASCII format.
.PP
\f[B]ECHO\f[R] (ZX Spectrum Next)
.PP
Syntax:
.PD 0
.P
.PD
ECHO string
.PP
Echo characters to the terminal
.PP
The following special character sequences may be used
.IP \[bu] 2
\[rs]a alert (bell) (ASCII 7)
.IP \[bu] 2
\[rs]b backspace (ASCII 8)
.IP \[bu] 2
\[rs]e escape (ASCII 27)
.IP \[bu] 2
\[rs]n line feed (ASCII 10)
.IP \[bu] 2
\[rs]r carriage return (ASCII 13)
.IP \[bu] 2
\[rs]l interpret further characters as lower-case
.IP \[bu] 2
\[rs]u interpret further characters as upper-case
.IP \[bu] 2
\[rs]\[rs]backslash (\[cq]\[rs]\[cq])
.PP
Note that CP/M converts all your typed characters to upper-case before
providing them to ECHO.COM.
Therefore you will need to use \[rs]l and \[rs]u to specify the case of
characters if it is important (in ESCape sequences, for example).
.PP
\f[B]ED\f[R]
.PP
Syntax:
.PD 0
.P
.PD
ED
.PD 0
.P
.PD
ED input-filespec
.PD 0
.P
.PD
ED input-filespec {d: | output-filespec}
.PP
Character file editor.
To redirect or rename the new version of the file specify the
destination drive or destination filespec.
.PP
\f[B]ERASE/ERA\f[R] (built-in)
.PP
Syntax:
.PD 0
.P
.PD
ERASE
.PD 0
.P
.PD
ERASE filespec
.PD 0
.P
.PD
ERASE filespec [CONFIRM]
.PP
The ERASE command removes one or more files from the directory of a
disk.
Wildcard characters are accepted in the filespec.
Directory and data space are automatically reclaimed for later use by
another file.
The ERASE command can be abbreviated to ERA.
.PP
[CONFIRM] option informs the system to prompt for verification before
erasing each file that matches the filespec.
CONFIRM can be abbreviated to C.
.PP
\f[B]EXIT\f[R] (ZX Spectrum Next)
.PP
Syntax:
.PD 0
.P
.PD
EXIT
.PP
The EXIT command leaves CP/M (rebooting the ZX Spectrum Next)
.PP
\f[B]EXPORT\f[R] (ZX Spectrum Next)
.PP
Syntax:
.PD 0
.P
.PD
EXPORT cpm-filespec nextzxos-filespec
.PP
NextZXOS file export utility
.PP
Export file to a NextZXOS drive.
.PP
\f[B]GENCOM\f[R]
.PP
Syntax:
.PD 0
.P
.PD
GENCOM COM-Eilespec RSX-filespec...
RSX-Eilespec {[LOADER | SCB=(Offset,value)]}
.PD 0
.P
.PD
GENCOM RSX-filespec ...
RSX-filespec {[NULL | SCB=(Offset,value)l}
.PD 0
.P
.PD
GENCOM filename
.PD 0
.P
.PD
GENCOM filename [SCB=(offset,value)]
.PP
The GENCOM command attaches RSX files to a COM file, or creates a dummy
COM file containing only RSXS.
It can also restore a previously GENCOMed file to the original COM file
without the header and RSXS, add or replace RSXs in already GENCOMed
files, and attach header records to COM files without RSXS.
.PP
\f[B]GENCPM\f[R]
.PP
Syntax:
.PD 0
.P
.PD
GENCPM {AUTO|AUTO DISPLAY}
.PP
GENCPM creates a memory image CPM3.SYS file, containing the CP/M 3 BDOS
and customized BIOS.
The GENCPM utility performs late resolution of intermodule references
between system modules.
GENCPM can accept its command input interactively from the console or
from a file GENCPM.DAT.
.PP
In the nonbanked system, GENCPM creates a CPM3.SYS file from the
BDOS3.SPR and BIOS3.SPR files.
In the banked system, GENCPM creates the CPM3.SYS file from the
RESBDOS3.SPR, the BNKBDOS3.SPR and the BNKBIOS3.SPR files.
Remember to back up your CPM3.SYS file before executing GENCPM, because
GENCPM deletes any existing CPM3.SYS file before it generates a new
system.
.PP
\f[B]GET\f[R]
.PP
Syntax:
.PD 0
.P
.PD
GET {CONSOLE INPUT FROM} FILE filespec options
.PD 0
.P
.PD
GET {CONSOLE INPUT FROM} CONSOLE
.PP
GET directs the system to take console input from a file for the next
system comand or user program entered at the console.
.PP
Console input is taken from a file until the program terminates.
If the file is exhausted before program input is terminated, the program
looks for subsequent input from the console.
If the program terminates before exhausting all its input, the system
reverts back to the console for console input.
.PP
\f[B]HELP\f[R]
.PP
Syntax:
.PD 0
.P
.PD
HELP
.PD 0
.P
.PD
HELP topic
.PD 0
.P
.PD
HELP topic subtopic
.PD 0
.P
.PD
HELP topic [NOPAGE]
.PD 0
.P
.PD
HELP topic subtopic1...subtopic8
.PD 0
.P
.PD
HELP>topic
.PD 0
.P
.PD
HELP>.subtopic
.PP
HELP displays a list of topics and provides summarized information for
CP/M Plus commands.
.PP
Typing HELP topic displays information about that topic.
Typing HELP topic subtopic displays information about that subtopics One
or two letters is enough to identify the topics.
After HELP displays information for your topic, it displays the special
prompt HELP> on your screen, followed by a list of subtopics.
.IP \[bu] 2
Enter ?
to display list of main topics.
.IP \[bu] 2
Enter a period and subtopic name to access subtopics.
.IP \[bu] 2
Enter a period to redisplay what you just read.
.IP \[bu] 2
Press RETURN to return to the CP/M Plus system prompt.
.IP \[bu] 2
[NOPAGE] option disables the 24 lines per page console display.
.IP \[bu] 2
Press any key to exit a display and return to the HELP> prompt.
.PP
\f[B]HEXCOM\f[R]
.PP
Syntax:
.PD 0
.P
.PD
HEXCOM filename
.PP
The HEXCOM Command generates a command file (filetype COM) from a HEX
input file.
it names the output tile with the same filename as the input file but
with filetype COM.
HEXCOM always looks for a file with filetype HEX.
.PP
\f[B]IMPORT\f[R] (ZX Spectrum Next)
.PP
Syntax:
.PD 0
.P
.PD
IMPORT nextzxos-filespec
.PD 0
.P
.PD
IMPORT nextzxos-filespec cpm-filespec
.PP
NextZXOS file import utility
.PP
List or import files from a NextZXOS drive.
.PP
\f[B]INITDIR\f[R] (Not included)
.PP
Syntax:
.PD 0
.P
.PD
INITDIR d:
.PP
The INITDIR command initializes a disk directory to allow date and time
stamping of files on that disk.
INITDIR can also recover time/date directory space.
.PP
\f[B]NEXTREG\f[R] (ZX Spectrum Next)
.PP
Syntax:
.PD 0
.P
.PD
NEXTREG register {value}
.PP
NextReg Utility
.PP
Show or change a NextReg register (use at your own risk!)
.PP
\f[B]LIB\f[R] (Not included)
.PP
Syntax:
.PD 0
.P
.PD
LIB filespec options
.PD 0
.P
.PD
LIB filespec options=filespec <modifier> f,filespec<modifier>
.PP
A library is a file that contains a collection of object modules.
.PP
Use the LIB utility to create libraries, and to append, replace, select,
or delete modules from an existing library.
Use LIB to obtain information about the contents of library files.
LIB creates and maintains library files that contain object modules in
Microsoft REL file format.
These modules are produced by the Digital Research relocatable
macro-assembler program, RMAC, or other language translator that
produces modules in Microsoft REL file format.
.PP
You can use LINK-80 to link the object modules contained in a library to
other object files.
LINK-80 automatically selects from the library only those modules needed
by the program being linked, and then forms an executable file with a
filetype of Com.
.PP
\f[B]LINK\f[R] (Not included)
.PP
Syntax:
.PD 0
.P
.PD
LINK filespec [options]
.PD 0
.P
.PD
LINK filespec [options],...filespec [options]
.PD 0
.P
.PD
LINK filespec [options]=filespec [options],...
.PD 0
.P
.PD
LINK combines relocatable object modules such as those produced by RMAC
and PL/I- 80 into a COM file ready for execution.
Relocatable files can contain external references and publics.
Relocatable files can reference modules in library files.
LINK searches the library files and includes the referenced modules in
the output file.
See the Programmer\[cq]s Utilities Guide for the CP/M Family of
Operating Systems for a complete description of LINK-80.
.PP
Use LINK option switches to control execution parameters.
Link options follow the file specifications and are enclosed within
square brackets.
Multiple switches are separated by commas.
.PP
\f[B]MAC\f[R] (Not included)
.PP
Syntax:
.PD 0
.P
.PD
MAC filename [$options]
.PP
MAC, the CP/M Plus macro assembler, reads assembly language statements
from a file of type ASM, assembles the statements, and produces three
output files with the input filename and filetypes of HEX, PRN, and SYM.
Filename.HEX contains Intel hexadecimal format object code.
Filename.PRN contains an annotated source listing that you can print or
examine at the console.
Filename.SYM contains a sorted list of symbols defined in the program.
.PP
Use options to direct the input and output of MAC.
Use a letter with the option to indicate the source and destination
drives, and console, printer, or zero output.
Valid drive names are A through 0.
X, P, and Z specify console, printer, and zero output, respectively.
.PP
\f[B]PATCH\f[R]
.PP
Syntax:
.PD 0
.P
.PD
PATCH filename.typ n
.PP
The PATCH command displays or installs patch number n to the CP/M Plus
system or command files.
The patch number n must be between 1 and 32 inclusive.
.PP
\f[B]PIP\f[R]
.PP
Syntax:
.PD 0
.P
.PD
PIP Destination = Source
.PD 0
.P
.PD
PIP d:[Gn]=filespec [options]
.PD 0
.P
.PD
PIP filespec[Gn]=filespec [options]
.PD 0
.P
.PD
PIP filespec[Gn]device=filespec [options] device
.PP
The file copy program PIP copies files, combines files, and transfers
files between disks, printers, consoles, or other devices attached to
your computer.
The first filespec is the destination.
The second filespec is the source.
Use two or more source filespecs separated by commas to combine two or
more files into one file.
[options] is any combination of the available options.
The [Gn] option in the destination filespec tells PIP to copy your file
to that user number.
PIP with no command tail displays an * prompt and awaits your series of
commands, entered and processed one line at a time.
The source or destination can optionally be any CP/M Plus logical
device.
.PP
\f[B]PUT\f[R]
.PP
Syntax:
.PD 0
.P
.PD
PUT CONSOLE {OUTPUT TO} FILE filespec {option}
.PD 0
.P
.PD
PUT PRINTER {OUTPUT TO} FILE filespec {option}
.PD 0
.P
.PD
PUT CONSOLE {OUTPUT TO} CONSOLE
.PD 0
.P
.PD
PUT PRINTER {OUTPUT TO} PRINTER
.PP
PUT puts console or printer output to a file for the next command
entered at the console, until the program terminates.
Then console output reverts to the console.
Printer output is directed to a file until the program terminates.
Then printer output is put back to the printer.
.PP
PUT with the SYSTEM option directs all subsequent console/printer output
to the specified file.
This option terminates when you enter the PUT CONSOLE or PUT PRINTER
command.
.PP
\f[B]RENAME/REN\f[R] (built-in)
.PP
Syntax:
.PD 0
.P
.PD
RENAME
.PD 0
.P
.PD
RENAME new-filespec=old-filespec
.PP
RENAME lets you change the name of a file in the directory of a disk.
To change several filenames in one command use the * or ?
wildcards in the file specifications.
You can abbreviate the RENAME command to REN.
REN prompts you for input.
.PP
\f[B]RMAC\f[R] (Not included)
.PP
Syntax:
.PD 0
.P
.PD
RMAC filespec options
.PP
RMAC, a relocatable macro assembler, assembles ASM files into REL files
that you can link to create COM files.
.PP
RMAC options specify the destination of the output files.
Replace d with the destination drive letter for the output files.
.PP
\f[B]SAVE\f[R]
.PP
Syntax:
.PD 0
.P
.PD
SAVE
.PP
SAVE copies the contents of memory to a file.
To use SAVE, first issue the SAVE command, then run your program which
reads a file into memory.
Your program exits to the SAVE utility which prompts you for a filespec
to which it copies the contents of memory, and the beginning and ending
address of the memory to be SAVED.
.PP
\f[B]SET\f[R]
.PP
Syntax:
.PD 0
.P
.PD
SET [options]
.PD 0
.P
.PD
SET d: [options]
.PD 0
.P
.PD
SET filespec [options]
.PD 0
.P
.PD
SET [option = modifier]
.PD 0
.P
.PD
SET filespec [option = modifier]
.PP
SET initiates password protection and time stamping of files.
It also sets the file and drive attributes Read/Write, Read/Only, DIR
and SYS.
It lets you label a disk and passord protect the label.
To enable time stamping of files, you must first run INITDIR to format
the disk directory.
.PP
\f[B]SET Default password operation:\f[R]
.PP
Syntax:
.PD 0
.P
.PD
SET [DEFAULT=password]
.PP
Instructs the system to use a default password if you do not enter a
password for a password-protected file.
.PP
\f[B]SET Time-stamp operations:\f[R]
.PP
Syntax:
.PD 0
.P
.PD
SET d: [CREATE=ON|OFF]
.PD 0
.P
.PD
SET d: [ACCESS=ON|OFF]
.PD 0
.P
.PD
SET d: [UPDATE=ON|OFF]
.PP
The above set commands allw YOU to keep a record of the time and date of
file creation and update or of the last access update of your files.
.PP
\f[B]SET Drive operations:\f[R]
.PP
Syntax:
.PD 0
.P
.PD
SET d: [RO]
.PD 0
.P
.PD
SET d: [RW]
.PP
Adds or removes write protection from a drive.
.PP
\f[B]SETDEF\f[R]
.PP
Syntax:
.PD 0
.P
.PD
SETDEF
.PD 0
.P
.PD
SETDEF [TEMPORARY=d:]
.PD 0
.P
.PD
SETDEF d:i,d:i,d:i,d:i
.PD 0
.P
.PD
SETDEF [ORDER= (typ1, typn)]
.PD 0
.P
.PD
SETDEF [DISPLAY | NO DISPLAY)
.PD 0
.P
.PD
SETDEF [PAGE | NOPAGE]
.PP
SETDEF allows the user to display or define up to four drives for the
program search order, the drive for temporary files, and the filetype
search order.
The SETDEF definitions affect only the loading of programs and/or
execution of SUBMIT (SUB) files.
SETDEF turns on/off the system Display and Console Page modes.
When on, the system displays the location and name of programs loaded or
SUBmit files executed, and stops after displaying one full console
screen of information.
.PP
\f[B]SHOW\f[R]
.PP
Syntax:
.PD 0
.P
.PD
SHOW
.PD 0
.P
.PD
SHOW d:
.PD 0
.P
.PD
SHOW d: [SPACE]
.PD 0
.P
.PD
SHOW d: [LABEL]
.PD 0
.P
.PD
SHOW d: [USERS]
.PD 0
.P
.PD
SHOW d: [DIR]
.PD 0
.P
.PD
SHOW d: [DRIVE]
.PP
The SHOW command displays the following disk drive information:
.IP \[bu] 2
access mode and the amount of free disk space
.IP \[bu] 2
disk label
.IP \[bu] 2
current user number
.IP \[bu] 2
number of files for each user number on the disk
.IP \[bu] 2
number of free directory entries for the disk
.IP \[bu] 2
drive characteristics
.PP
\f[B]SID\f[R]
.PP
Syntax:
.PD 0
.P
.PD
SID [pgm-filespec],{sym-filespec}
.PP
The SID symbolic debugger allows you to monitor and test programs
developed for the 8080 microprocessor.
SID supports real-time breakpoints, fully monitored execution, symbolic
disassembly, assembly, and memory display and fill functions.
SID can dynamically load SID utility programs to provide traceback and
histogram facilities.
.PP
\f[B]SUBMIT\f[R]
.PP
Syntax:
.PD 0
.P
.PD
SUBMIT
.PD 0
.P
.PD
SUBMIT filespec
.PD 0
.P
.PD
SUBMIT filespec argument ...
argument
.PP
The SUBMIT command lets you execute a group (batch) of commands from a
SUBmit file (a file with filetype of SUB).
.PP
SUB files:
.PP
The SUB file can contain the following types of lines:
.IP \[bu] 2
any valid CP/M Plus command
.IP \[bu] 2
any valid CP/M Plus command with SUBMIT parameters ($0-$9)
.IP \[bu] 2
any data input line
.IP \[bu] 2
any program input line with parameters ($0 to $9)
.PP
The command line cannot exceed 135 characters.
.PP
\f[B]TERMINFO\f[R] (ZX Spectrum Next)
.PP
Syntax:
.PD 0
.P
.PD
TERMINFO
.PP
This program provides information on the terminal facilities provided by
the BIOS on the ZX Spectrum Next.
.PP
\f[B]TERMSIZE\f[R] (ZX Spectrum Next)
.PP
Syntax:
.PD 0
.P
.PD
TERMSIZE top left height width
.PP
Terminal resize utility
.PP
Size can be up to 32x80 (defaults to 24x80, suitable for many programs).
If setting a reduced size, the top and left parameters can be used to
make the image more centered on your screen.
.PP
\f[B]TYPE/TYP\f[R] (built-in)
.PP
Syntax:
.PD 0
.P
.PD
TYPE
.PD 0
.P
.PD
TYPE filespec
.PD 0
.P
.PD
TYPE filespec [PAGE]
.PD 0
.P
.PD
TYPE filespec [NOPAGE]
.PP
The TYPE command displays the contents of an ASCII character file on
your screen.
.PP
\f[B]UPGRADE\f[R] (ZX Spectrum Next)
.PP
Syntax:
.PD 0
.P
.PD
UPGRADE
.PP
UPGRADE CP/M from C:/NEXTZXOS/CPMBASE.P3D
.PP
\f[B]USER/USE\f[R] (built-in)
.PP
Syntax:
.PD 0
.P
.PD
USER
.PD 0
.P
.PD
USER n
.PP
The USER command sets the current user number.
The disk directory can be divided into distinct groups according to a
User Number.
User numbers range from 0 through 15.
.PP
\f[B]XREF\f[R] (Not included)
.PP
Syntax:
.PD 0
.P
.PD
XREF {d:} filename {$P}
.PP
XREF provides a cross-reference summary of variable usage in a program.
XREF requires the PRN and SYM files produced by MAC or RMAC for input to
the program.
The SYM and PRN files must have the same filename as the filename in the
XREF command tail.
XREF outputs a file of type XRF.
.SS BDOS
.PP
From the CP/M 3 Programmers\[cq] Guide 1984
.PP
This section documents all BDOS system calls to include the parameters
that must be passes to them and the values that are returned to the
calling program.
.PP
BDOS function 0: \f[B]SYSTEM RESET\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $00
.PP
The System Reset function terminates the calling program and returns
control to the CCP via a warm start sequence.
Calling this function has the same effect as a jump to location $0000 of
Page Zero.
.PP
Note that the disk subsystem is not reset by System Reset under CP/M 3.
The calling program can pass a return code to the CCP by calling
Function 108, Get/Set Program Return Code, prior to making a System
Reset call or jumping to location $0000.
.PP
BDOS function 1: \f[B]CONSOLE INPUT\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $01
.PP
Returned Value:
.IP \[bu] 2
A: ASCII Character
.PP
The Console Input function reads the next character from the logical
console, CONIN:, to register A.
Graphic characters, along with carriage return, line-feed, and
backspace, CTRL-H, are echoed to the console.
Tab characters, CTR-L-1, are expanded in columns of 8 characters.
CTRL-S, CTRL-Q, and CTRL-P are normally intercepted as described below.
All other non-graphic characters are returned in register A but are not
echoed to the console.
.PP
When the Console Mode is in the default state Function 1 intercepts the
stop scroll, CTRL-S, start scroll, CTRL-Q, and start/stop printer echo,
CTRL-P, characters.
Any characters that are typed following a CTRL-S and preceding a CTRL-Q
are also intercepted.
However, if start/stop scroll has been disabled by the Console Mode, the
CTRL-S, CTRL-Q, and CTRL-P characters are not intercepted.
Instead, they are returned in register A, but are not echoed to the
console.
.PP
If printer echo has been invoked, all characters that are echoed to the
console are also sent to the list device, LST:.
Function 1 does not return control to the calling program until a
non-intercepted character is typed, thus suspending execution if a
character is not ready.
.PP
BDOS function 2: \f[B]CONSOLE OUTPUT\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $02
.IP \[bu] 2
E: ASCII Character
.PP
The Console Output function sends the ASCII character from register E to
the logical console device, CONOUT:.
When the Console Mode is in the default state (see Section 2.2.1),
Function 2 expands tab characters, CTRL-1, in columns of 8 characters,
checks for stop scroll, CTRL-S, start scroll, CTRL-Q, and echoes
characters to the logical list device, LST:, if printer echo, CTRL-P,
has been invoked.
.PP
BDOS function 3: \f[B]AUXILIARY INPUT\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $03
.PP
Returned Value:
.IP \[bu] 2
A: ASCII Character
.PP
The Auxiliary Input function reads the next character from the logical
auxiliary input device, AUXIN:, into register A.
Control does not return to the calling program \[cq]I the character is
read.
unti
.PP
BDOS function 4: \f[B]AUXILIARY OUTPUT\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $04
.IP \[bu] 2
E: ASCII Character
.PP
The Auxiliary Output function sends the ASCII character from register E
to the logical auxiliary output device, AUXOUT:.
.PP
BDOS function 5: \f[B]LIST OUTPUT\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $05
.IP \[bu] 2
E: ASCII Character
.PP
The List Output function sends the ASCII character in register E to the
logical list device, LST:.
.PP
BDOS function 6: \f[B]DIRECT CONSOLE I/O\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $06
.IP \[bu] 2
E: function/data (see description)
.PP
Returned Value:
.IP \[bu] 2
A: char/status/no value (see description)
.PP
CP/M 3 supports direct I/O to the logical console, CONIN:, for those
specialized applications where unadorned console input and output is
required.
Use Direct Console I/O carefully because it bypasses all the normal
control character functions.
Programs that perform direct I/O through the BIOS under previous
releases of CP/M should be changed to use direct I/O so that they can be
fully supported under future releases of MP/M and CP/M.
.PP
A program calls Function 6 by passing one of four different values in
register E.
.IP \[bu] 2
$FF Console input/status command returns an input character; if no
character is ready, a value of zero is returned.
.IP \[bu] 2
$FE Console status command (On return, register A contains 00 if no
character is ready; otherwise it contains $FF.)
.IP \[bu] 2
$FD Console input command, returns an input character; this function
will suspend the calling process until a character is ready.
.IP \[bu] 2
ASCII Function 6 assumes that register E contains a valid ASCII
chararacter and sends it to the console.
.PP
BDOS function 7: \f[B]AUXILIARY INPUT STATUS\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $07
.PP
Returned Value:
.IP \[bu] 2
A: Auxiliary Input Status
.PP
The Auxiliary Input Status function returns the value $FF in register A
if a character is ready for input from the logical auxiliary input
device, AUXIN:.
If no character is ready for input, the value $00 is returned.
.PP
BDOS function 8: \f[B]AUXILIARY OUTPUT STATUS\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $08
.PP
Returned Value:
.IP \[bu] 2
A: Auxiliary Output Status
.PP
The Auxiliary Output Status function returns the value $FF in register A
if the logical auxiliary output device, AUXOUT:, is ready to accept a
character for output.
If the device is not ready for output, the value $00 is returned.
.PP
BDOS function 9: \f[B]PRINT STRING\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $09
.IP \[bu] 2
DE: String Address
.PP
The Print String function sends the character string addressed by
register pair DE to the logical console, CONOUT:, until it encounters a
delimiter in the string.
Usually the delimiter is a dollar sign, $, but it can be changed to any
other value by Function 110, Get/Set Output Delimiter.
If the Console Mode is in the default state, Function 9 expands tab
characters, CTRL-I, in columns of 8 characters.
It also checks for stop scroll, CTRL-S, start scroll, CTRL-Q, and echoes
to the logical list device, LST:, if printer echo, CTRL-P, has been
invoked.
.PP
BDOS function 10: \f[B]READ CONSOLE BUFFER\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $0A
.IP \[bu] 2
DE: Buffer Address
.PP
Returned Value:
.IP \[bu] 2
Console Characters in Buffer
.PP
The Read Console Buffer function reads a line of edited console input
from the logical console, CONIN:, to a buffer that register pair DE
addresses.
It terminates input and returns to the calling program when it
encounters a return, CTRL-M, or a line feed, CTRL-J, character.
Function 10 also discards all input characters after the input buffer is
filled.
In addition, it outputs a bell character, CTRL-G, to the console when it
discards a character to signal the user that the buffer is full.
The input buffer addressed by DE has the following format:
.PP
where mx is the maximum number of characters which the buffer holds, and
nc is the number of characters placed in the buffer.
The characters entered by the operator follow the nc value.
The value mx must be set prior to making a Function 10 call and may
range in value from 1 to 255.
Setting mx to zero is equivalent to setting mx to one.
The value nc is returned to the calling program and may range from zero
to mx.
If nc < mx, then uninitialized positions follow the last character,
denoted by ??
in the figure.
Note that a terminating return or line feed character is not placed in
the buffer and not included in the count nc.
.PP
If register pair DE is set to zero, Function 10 assumes that an
initialized input buffer is located at the current DMA address (see
Function 26, Set DMA Address).
This allows a program to put a string on the screen for the user to
edit.
To initialize the input buffer, set characters c1 through cn to the
initial value followed by a binary zero terminator.
.PP
When a program calls Function 10 with an initialized buffer, Function 10
operates as if the user had typed in the string.
When Function 10 encounters the binary zero terminator, it accepts input
from the console.
At this point, the user can edit the initialized string or accept it as
it is by pressing the RETURN key.
However, if the initialized string contains a return, CTRL-M, or a
linefeed, CTRL-J, character, Function 10 returns to the calling program
without giving the user the opportunity to edit the string.
.PP
The level of console editing supported by Function 10 differs for the
banked and nonbanked versions of CP/M 3.
Refer to the CPIM Plus (CPIM Version 3) Operating System User\[cq]s
Guide for a detailed description of console editing.
In the nonbanked version, Function 10 recognizes the following edit
control characters.
.PP
Nonbanked CP/M 3
.IP \[bu] 2
rub/del Removes and echoes the last character; GENCPM can change this
function to CTRL-H
.IP \[bu] 2
CTRL-C Reboots when at the beginning of line; the Console Mode can
disable this function
.IP \[bu] 2
CTRL-E Causes physical end of line
.IP \[bu] 2
CTRL-H Backspaces one character position; GENCPM can change this
function to rub/del
.IP \[bu] 2
CTRL-J (Line-feed) terminates input line
.IP \[bu] 2
CTRL-M (Return) terminates input line
.IP \[bu] 2
CTRL-P Echoes console output to the list device
.IP \[bu] 2
CTRL-R Retypes the current line after new line
.IP \[bu] 2
CTRL-U Removes current line after new line
.IP \[bu] 2
CTRL-X Backspaces to beginning of current line
.PP
The banked version of CP/M 3 expands upon the editing provided in the
non-banked version.
The functionality of the two versions is similar when the cursor is
positioned at the end of the line.
However, in the banked version, the user can move the cursor anywhere in
the current line, insert characters, delete characters, and perform
other editing functions.
In addition, the banked version saves the previous command line; it can
be recalled when the current line is empty.
In the banked version, Function 10 recognizes the following edit control
characters.
.PP
Banked CP/M 3
.IP \[bu] 2
rub/del Removes and echoes the last character if at the end of the line;
otherwise deletes the character to the left of the current cursor
position; GENCPM can change this function to CTRL-H.
.IP \[bu] 2
CTRL-A Moves cursor one character to the left.
.IP \[bu] 2
CTRL-B Moves cursor to the beginning of the line when not at the
beginning; otherwise moves cursor to the end of the line.
.IP \[bu] 2
CTRL-C Reboots when at the beginning of line; the Console Mode can
disable this function.
.IP \[bu] 2
CTRL-E Causes physical end-of-line; if the cursor is positioned in the
middle of a line, the characters at and to the right of the cursor are
displayed on the next line.
.IP \[bu] 2
CTRL-F Moves cursor one character to the right.
.IP \[bu] 2
CTRL-G Deletes the character at the current cursor position when in the
middle of the line; has no effect when the cursor is at the end of the
line.
.IP \[bu] 2
CTRL-H Backspaces one character position when positioned at the end of
the line,; otherwise deletes the character to the left of the cursor;
GENCPM can change this function to rub/del.
.IP \[bu] 2
CTRL-J (Line-feed) terminates input; the cursor can be positioned
anywhere in the line; the entire input line is accepted; sets the
previous line buffer to the input line.
.IP \[bu] 2
CTRL-K Deletes all characters to the right of the cursor along with the
character at the cursor.
.IP \[bu] 2
CTRL-M (Return) terminates input; the cursor can be positioned anywhere
in the line; the entire input line is accepted; sets the previous line
buffer to the input line.
.IP \[bu] 2
CTRL-P Echoes console output to the list device.
.IP \[bu] 2
CTRL-R Retypes the characters to the left of the cursor on the new line.
.IP \[bu] 2
CTRL-U Updates the previous line buffer to contain the characters to the
left of the cursor; deletes current line, and advances to new line.
.IP \[bu] 2
CTRL-W Recalls previous line if current line is empty; otherwise moves
cursor to end-of-line.
.IP \[bu] 2
CTRL-X Deletes all characters to the left of the cursor.
.PP
For banked systems, Function 10 uses the console width field defined in
the System Control Block.
If the console width is exceeded when the cursor is positioned at the
end of the line, Function 10 automatically advances to the next line.
The beginning of the line can be edited by entering a CTRL-R.
.PP
When a character is typed while the cursor is positioned in the middle
of the line, the typed character is inserted into the line.
Characters at and to the right of the cursor are shifted to the right.
If the console width is exceeded, the characters disappear off the right
of the screen.
However, these characters are not lost.
They reappear if characters are deleted out of the line, or if a CTRL-E
is typed.
.PP
BDOS function 11: \f[B]GET CONSOLE STATUS\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $0B
.PP
Returned Value:
.IP \[bu] 2
A: Console Status
.PP
The Get Console Status function checks to see if a character has been
typed at the logical console, CONIN:.
If the Console Mode is in the default state, Function 11 returns the
value $01 in register A when a character is ready.
If a character is not ready, it returns a value of $00.
.PP
If the Console Mode is in CTRL-C Only Status mode, Function 11 returns
the value $01 in register A only if a CTRL-C has been typed at the
console.
.PP
BDOS function 12: \f[B]RETURN VERSION NUMBER\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $0C
.PP
Returned Value:
.IP \[bu] 2
HL: Version Number
.PP
The Return Version Number function provides information that allows
version independent programming.
It returns a two-byte value in register pair HL: H contains $00 for CP/M
and L contains $31, the BDOS file system version number.
Function 12 is useful for writing applications programs that must run on
multiple versions of CP/M and MP/M.
.PP
BDOS function 13: \f[B]RESET DISK SYSTEM\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $0D
.PP
The Reset Disk System function restores the file system to a reset state
where all the disk drives are set to read-write (see Functions 28 and
29), the default disk is set to drive A, and the default DMA address is
reset to $0080.
This function can be used, for example, by an application program that
requires disk changes during operation.
Function 37, Reset Drive, can also be used for this purpose.
.PP
BDOS function 14: \f[B]SELECT DISK\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $0E
.IP \[bu] 2
E: Selected Disk
.PP
Returned Value:
.IP \[bu] 2
A: Error Flag
.IP \[bu] 2
H: Physical Error
.PP
The Select Disk function designates the disk drive named in register E
as the default disk for subsequent BDOS file operations.
Register E is set to 0 for drive A, 1 for drive B, and so on through 15
for drive P in a full 16-drive system.
In addition, Function 14 logs in the designated drive if it is currently
in the reset state.
Logging-in a drive activates the drive\[cq]s directory until the next
disk system reset or drive reset operation.
.PP
FCBs that specify drive code zero (dr = $00) automatically reference the
currently selected default drive.
FCBs with drive code values between 1 and 16, however, gnore the
selected default drive and directly reference drives A through P.
.PP
Upon return, register A contains a zero if the select operation was
successful.
If a physical error was encountered, the select function performs
different actions depending on the BDOS error mode (see Function 45).
If the BDOS error mode is in the default mode, a message identifying the
error is displayed at the console, and the calling program is
terminated.
Otherwise, the select function returns to the calling program with
register A set to $FF and register H set to one of the following
.PP
physical error codes:
.IP \[bu] 2
01 Disk I/O Error
.IP \[bu] 2
04 Invalid drive
.PP
BDOS function 15: \f[B]OPEN FILE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $0F
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Directory Code
.IP \[bu] 2
H: Physical or Extended Error
.PP
The Open File function activates the FCB for a file that exists in the
disk directory under the currently active user number or user zero.
The calling program passes the address of the FCB in register pair DE,
with byte 0 of the FCB specifying the drive, bytes 1 through 11
specifying the filename and filetype, and byte 12 specifying the extent.
Usually, byte 12 of the FCB is initialized to zero.
.PP
If the file is password protected in Read mode, the correct password
must be placed in the first eight bytes of the current DMA, or have been
previously established as the default password (see Function 106).
If the current record field of the FCB, cr, is set to $FF, Function 15
returns the byte count of the last record of the file in the cr field.
You can set the last record byte count for a file with Function 30, Set
File Attributes.
Note that the current record field of the FCB, cr, must be zeroed by the
calling program before beginning read or write operations if the file is
to be accessed sequentially from the first record.
.PP
If the current user is non-zero, and the file to be opened does not
exist under the current user number, the open function searches user
zero for the file.
If the file exists under user zero, and has the system attribute,
t2\[cq], set, the file is opened under user zero.
Write operations are not supported for a file that is opened under user
zero in this manner.
.PP
If the open operation is successful, the user\[cq]s FCB is activated for
read and write operations.
The relevant directory information is copied from the matching directory
FCB into bytes d0 through dn of the FCB.
If the file is opened under user zero when the current user number is
not zero, interface attribute f8\[cq] is set to one in the user\[cq]s
FCB.
In addition, if the referenced file is password protected in Write mode,
and the correct password was not passed in the DMA, or did not match the
default password, interface attribute f7\[cq] is set to one.
Write operations are not supported for an activated FCB if interface
attribute f7\[cq] or f8\[cq] is true.
.PP
When the open operation is successful, the open function also makes an
Access date and time stamp for the opened file when the following
conditions are satisfied: the referenced drive has a directory label
that requests Access date and time stamping, and the FCB extent number
field is zero.
.PP
Upon return, the Open File function returns a directory code in register
A with the value $00 if the open was successful, or $FF, 255 decimal, if
the file was not found.
Register H is set to zero in both of these cases.
If a physical or extended error was encountered, the Open File function
performs different actions depending on the BDOS error mode (see
Function 45).
If the BDOS error mode is in the default mode, a message identifying the
error is displayed at the console and the program is terminated.
Otherwise, the Open File function returns to the calling program with
register A set to $FF, and register H set to one of the following
physical or extended error codes:
.IP \[bu] 2
01 : Disk I/O Error
.IP \[bu] 2
04 : Invalid drive error
.IP \[bu] 2
07 : File password error
.IP \[bu] 2
09 : ?
in the FCB filename or filetype field
.PP
BDOS function 16: \f[B]CLOSE FILE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $10
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Directory Code
.IP \[bu] 2
H: Physical or Extended Error
.PP
The Close File function performs the inverse of the Open File function.
The calling program passes the address of an FCB in register pair DE.
The referenced FCB must have been previously activated by a successful
Open or Make function call (see Functions 15 and 22).
Interface attribute f5\[cq] specifies how the file is to be closed as
shown below:
.IP \[bu] 2
f5\[cq] = 0 - Permanent close (default mode)
.IP \[bu] 2
f5\[cq] = 1 - Partial close
.PP
A permanent close operation indicates that the program has completed
file operations on the file.
A partial close operation updates the directory, but indicates that the
file is to be maintained in the open state.
.PP
If the referenced FCB contains new information because of write
operations to the FCB, the close function permanently records the new
information in the referenced disk directory.
Note that the FCB does not contain new information, and the directory
update step is bypassed if only read or update operations have been made
to the referenced FCB.
.PP
Upon return, the close function returns a directory code in register A
with the value $00 if the close was successful,, or $FF, 255 Decimal, if
the file was not found.
Register H is set to zero in both of these cases.
If a physical or extended error is encountered, the close function
performs different actions depending on the BDOS error mode (see
Function 45).
If the BDOS error mode is in the default mode, a message identifying the
error is displayed at the console, and the calling program is
terminated.
Otherwise, the close function returns to the calling program with
register A set to $FF and register H set to one of the following
physical error codes:
.IP \[bu] 2
01 Disk I/O error
.IP \[bu] 2
02 Read/only disk
.IP \[bu] 2
04 Invalid drive error
.PP
BDOS function 17: \f[B]SEARCH FOR FIRST\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $11
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Directory Code
.IP \[bu] 2
H: Physical Error
.PP
The Search For First function scans the directory for a match with the
FCB addressed by register pair DE.
Two types of searches can be performed.
For standard searches, the calling program initializes bytes 0 through
12 of the referenced FCB, with byte 0 specifying the drive directory to
be searched, bytes 1 through 11 specifying the file or files to be
searched for,, and byte 12 specifying the extent.
Usually byte 12 is set to zero.
An ASCII question mark, 63 decimal, 3F hex, in any of the bytes 1
through 12 matches all entries on the directory in the corresponding
position.
This facility, called ambiguous reference, can be used to search for
multiple files on the directory.
When called in the standard mode, the Search function scans for the
first file entry in the specified directory that matches the FCB, and
belongs to the current user number.
.PP
The Search For First function also initializes the Search For Next
function.
After the Search function has located the first directory entry matching
the referenced FCB, the Search For Next function can be called
repeatedly to locate all remaining matching entries.
In terms of execution sequence, however, the Search For Next call must
either follow a Search For First or Search For Next call with no other
intervening BDOS disk-related function calls.
.PP
If byte 0 of the referenced FCB is set to a question mark, the Search
function ignores the remainder of the referenced FCB, and locates the
first directory entry residing on the current default drive.
All remaining directory entries can be located by making multiple Search
For Next calls.
This type of search operation is not usually made by application
programs, but it does provide complete flexibility to scan all current
directory values.
Note that this type of search operation must be performed to access a
drive\[cq]s directory label.
.PP
Upon return, the Search function returns a Directory Code in register A
with the value 0 to 3 if the search is successful, or $FF, 255 Decimal,
if a matching directory entry is not found.
Register H is set to zero in both of these cases.
For successful searches, the current DMA is also filled with the
directory record containing the matching entry, and the relative
starting position is A * 32 (that is, rotate the A register left 5 bits,
or ADD A five times).
Although it is not usually required for application programs, the
directory information can be extracted from the buffer at this position.
.PP
If the directory has been initialized for date and time stamping by
INITDIR, then an SFCB resides in every fourth directory entry, and
successful Directory Codes are restricted to the values 0 to 2.
For successful searches, if the matching directory record is an extent
zero entry, and if an SFCB resides at offset 96 within the current DMA,
contents of (DMA Address + 96) = $21, the SFCB contains the date and
time stamp information, and password mode for the file.
This information is located at the relative starting position of 97 + (A
* 10) within the current DMA in the following format:
.IP \[bu] 2
0 - 3 Create or Access Date and Time Stamp Field
.IP \[bu] 2
4 - 7 Update Date and Time Stamp Field
.IP \[bu] 2
8 : Password Mode Field
.PP
If a physical error is encountered, the Search function performs
different actions depending on the BDOS error mode (see Function 45).
If the BDOS error mode is in the default mode, a message identifying the
error is displayed at the console, and the calling program is
terminated.
Otherwise, the Search function returns to the calling program with
register A set to $FF, and register H set to one of the following
physical error codes:
.IP \[bu] 2
01 Disk I/O error
.IP \[bu] 2
04 Invalid drive error
.PP
BDOS function 18: \f[B]SEARCH FOR NEXT\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $12
.PP
Returned Value:
.IP \[bu] 2
A: Directory Code
.IP \[bu] 2
H: Physical Error
.PP
The Search For Next function is identical to the Search For First
function, except that the directory scan continues from the last entry
that was matched.
Function 18 returns a Directory code in register A, analogous to
Function 17.
.PP
Note: in execution sequence, a Function 18 call must follow either a
Function 17 or another Function 18 call with no other intervening BDOS
disk-related function calls.
.PP
BDOS function 19: \f[B]DELETE FILE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $13
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Directory Code
.IP \[bu] 2
H: Extended or Physical Error
.PP
The Delete File function removes files or XFCBs that match the FCB
addressed in register pair DE.
The filename and filetype can contain ambiguous references, that is,
question marks in bytes f1\[cq] through t3\[cq], but the dr byte cannot
be ambiguous, as it can in the Search and Search Next functions.
Interface attribute f5\[cq] specifies the type of delete operation that
is performed.
.IP \[bu] 2
f5\[cq] = 0 - Standard Delete (default mode)
.IP \[bu] 2
f5\[cq] = 1 - Delete only XFCBs
.PP
If any of the files that the referenced FCB specify are password
protected, the correct password must be placed in the first eight bytes
of the current DMA buffer, or have been previously established as the
default password (see Function 106).
.PP
For standard delete operations, the Delete function removes all
directory entries belonging to files that match the referenced FCB.
All disk directory and data space owned by the deleted files is returned
to free space, and becomes available for allocation to other files.
Directory XFCBs that were owned by the deleted files are also removed
from the directory.
If interface attribute f5\[cq] of the FCB is set to 1, Function 19
deletes only the directory XFCBs that match the referenced FCB.
.PP
Note: if any of the files that match the input FCB specification fall
the password check, or are Read-Only, then the Delete function does not
delete any files or XFCBS.
This applies to both types of delete operations.
.PP
In nonbanked systems, file passwords and XFCBs are not supported.
Thus, if the Delete function is called with interface attribute f5\[cq]
set to true, the Delete function performs no action but returns with
register A set to zero.
.PP
Upon return, the Delete function returns a Directory Code in register A
with the value 0 if the delete is successful, or $FF, 255 Decimal, if no
file that matches the referenced FCB is found.
Register H is set to zero in both of these cases.
If a physical, or extended error is encountered, the Delete function
performs different actions depending on the BDOS error mode (see
Function 45).
If the BDOS error mode is the default mode, a message identifying the
error is displayed at the console and the calling program is terminated.
Otherwise, the Delete function returns to the calling program with
register A set to $FF and register H set to one of the following
physical or extended error codes:
.IP \[bu] 2
01 : Disk I/O error
.IP \[bu] 2
02 : Read-Only disk
.IP \[bu] 2
03 : Read-Only file
.IP \[bu] 2
04 : Invalid drive error
.IP \[bu] 2
07 : File password error
.PP
BDOS function 20: \f[B]READ SEQUENTIAL\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $14
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Error Code
.IP \[bu] 2
H: Physical Error
.PP
The Read Sequential function reads the next 1 to 128 128-byte records
from a file into memory beginning at the current DMA address.
The BDOS Multi-Sector Count (see Function 44) determines the number of
records to be read.
The default is one record.
The FCB addressed by register pair DE must have been previously
activated by an Open or Make function call.
.PP
Function 20 reads each record from byte cr of the extent, then
automatically increments the cr field to the next record position.
If the cr field overflows, then the function automatically opens the
next logical extent and resets the cr field to 0 in preparation for the
next read operation.
The calling program must set the cr field to 0 following the Open call
if the intent is to read sequentially from the beginning of the file.
Upon return, the Read Sequential function sets register A to zero if the
read operation is successful.
Otherwise, register A contains an error code identifying the error as
shown below:
.IP \[bu] 2
01 Reading unwritten data (end-of-file)
.IP \[bu] 2
09 Invalid FCB
.IP \[bu] 2
10 Media change occurred
.IP \[bu] 2
255 Physical Error; refer to register H
.PP
Error Code 01 is returned if no data exists at the next record position
of the file.
Usually, the no data situation is encountered at the end of a file.
However, it can also occur if an attempt is made to read a data block
that has not been previously written, or an extent which has not been
created.
These situations are usually restricted to files created or appended
with the BDOS random write functions (see Functions 34 and 40).
.PP
Error Code 09 is returned if the FCB is invalidated by a previous BDOS
close call that returns an error.
.PP
Error Code 10 is returned if a media change occurs on the drive after
the referenced FCB is activated by a BDOS Open, or Make Call.
.PP
Error Code 255 is returned if a physical error is encountered and the
BDOS error mode is Return Error mode, or Return and Display Error mode
(see Function 45).
If the error mode is the default mode, a message identifying the
physical error is displayed at the console, and the calling program is
terminated.
When a physical error is returned to the calling program, register H
contains one of the following error codes:
.IP \[bu] 2
01 Disk I/O error
.IP \[bu] 2
04 Invalid drive error
.PP
On all error returns except for physical error returns, A = 255,
Function 20 sets register H to the number of records successfully read
before the error is encountered.
This value can range from 0 to 127 depending on the current BDOS
Multi-Sector Count.
It is always set to zero when the Multi-Sector Count is equal to one.
.PP
BDOS function 21: \f[B]WRITE SEQUENTIAL\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $15
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Error Code
.IP \[bu] 2
H: Physical Error
.PP
The Write Sequential function writes 1 to 128 128-byte data records,
beginning at the current DMA address into the file named by the FCB
addressed in register pair DE.
The BDOS Multi-Sector Count (see Function 44) determines the number of
128 byte records that are written.
The default is one record.
The referenced FCB must have been previously activated by a BDOS Open or
Make function call.
.PP
Function 21 places the record into the file at the position indicated by
the cr byte of the FCB, and then automatically increments the cr byte to
the next record position.
If the cr field overflows, the function automatically opens, or creates
the next logical extent, and resets the cr field to 0 in preparation for
the next write operation.
If Function 21 is used to write to an existing file, then the newly
written records overlay those already existing in the file.
The calling program must set the cr field to 0 following an Open or Make
call if the intent is to write sequentially from the beginning of the
file.
.PP
Function 21 makes an Update date and time for the file if the following
conditions are satisfied: the referenced drive has a directory label
that requests date and time stamping, and the file has not already been
stamped for update by a previous Make or Write function call.
.PP
Upon return, the Write Sequential function sets register A to zero if
the write operation is successful.
Otherwise, register A contains an error code identifying the error as
shown below:
.IP \[bu] 2
01 No available directory space
.IP \[bu] 2
02 No available data block
.IP \[bu] 2
09 Invalid FCB
.IP \[bu] 2
10 Media change occurred
.IP \[bu] 2
255 Physical Error : refer to register H
.PP
Error Code 01 is returned when the write function attempts to create a
new extent that requires a new directory entry, and no available
directory entries exist on the selected disk drive.
.PP
Error Code 02 is returned when the write command attempts to allocate a
new data block to the file, and no unallocated data blocks exist on the
selected disk drive.
.PP
Error Code 09 is returned if the FCB is invalidated by a previous BDOS
close call that returns an error.
.PP
Error Code 10 is returned if a media change occurs on the drive after
the referenced FCB is activated by a BDOS Open or Make call.
.PP
Error Code 255 is returned if a physical error is encountered and the
BDOS error mode is Return Error mode, or Return and Display Error mode
(see Function 45).
If the error mode is the default mode, a message identifying the
physical error is displayed at the console, and the calling program is
terminated.
When a physical error is returned to the calling program, register H
contains one of the following error codes:
.IP \[bu] 2
01 Disk I/O error
.IP \[bu] 2
02 Read-Only disk
.IP \[bu] 2
03 Read-Only file or File open from user 0 when the current user number
is non-zero or File password protected in Write mode
.IP \[bu] 2
04 Invalid drive error
.PP
On all error returns, except for physical error returns, A = 255,
Function 21 sets register H to the number of records successfully
written before the error was encountered.
This value can range from 0 to 127 depending on the current BDOS
Multi-Sector Count.
It is always set to zero when the Multi-Sector Count is set to one.
.PP
BDOS function 22: \f[B]MAKE FILE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $16
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Directory Code
.IP \[bu] 2
H: Physical or Extended Error
.PP
The Make File function creates a new directory entry for a file under
the current user number.
It also creates an XFCB for the file if the referenced drive has a
directory label that enables password protection on the drive, and the
calling program assigns a password to the file.
.PP
The calling program passes the address of the FCB in register pair DE,
with byte 0 of the FCB specifying the drive, bytes 1 through 11
specifying the filename and filctype, and byte 12 set to the extent
number.
Usually, byte 12 is set to zero.
Byte 32 of the FCB, the cr field, must be initialized to zero, before or
after the Make call, if the intent is to write sequentially from the
beginning of the file.
.PP
Interface attribute f6\[cq] specifies whether a password is to be
assigned to the created file.
.IP \[bu] 2
f6\[cq] = 0 - Do not assign password (default)
.IP \[bu] 2
f6\[cq] = 1 - Assign password to created file
.PP
When attribute f6\[cq] is set to 1, the calling program must place the
password in the first 8 bytes of the current DMA buffer, and set byte 9
of the DMA buffer to the password mode (see Function 102).
Note that the Make function only interrogates interface attribute
f6\[cq] if passwords are activated on the referenced drive.
In nonbanked systems, file passwords are not supported, and attribute
f6\[cq] is never interrogated.
.PP
The Make function returns with an error if the referenced FCB names a
file that currently exists in the directory under the current user
number.
.PP
If the Make function is successful, it activates the referenced FCB for
file operations by opening the FCB, and initializes both the directory
entry and the referenced FCB to an empty file.
It also initializes all file attributes to zero.
In addition, Function 22 makes a Creation date and time stamp for the
file if the following conditions are satisfied: the referenced drive has
a directory label that requests Creation date and time stamping and the
FCB extent number field is equal to zero.
Function 22 also makes an Update stamp if the directory label requests
update stamping and the FCB extent field is equal to zero.
.PP
If the referenced drive contains a directory label that enables password
protection, and if interface attribute f6\[cq] has been set to 1, the
Make function creates an XFCB for the file.
In addition, Function 22 also assigns the password, and password mode
placed in the first nine bytes of the DMA, to the XFCB.
.PP
Upon return, the Make function returns a directory code in register A
with the value 0 if the make operation is successful, or $FF, 255
decimal, if no directory space is available.
Register H is set to zero in both of these cases.
If a physical or extended error is encountered, the Make function
performs different actions depending on the BDOS error mode (see
Function 45).
If the BDOS error mode is the default mode, a message identifying the
error is displayed at the console, and the calling program is
terminated.
Otherwise, the Make function returns to the calling program with
register A set to $FF, and register H set to one of the following
physical or extended error codes:
.IP \[bu] 2
01 : Disk I/O error
.IP \[bu] 2
02 : Read-Only disk
.IP \[bu] 2
04 : Invalid drive error
.IP \[bu] 2
08 : File already exists
.IP \[bu] 2
09 : ?
in filename or filetype field
.PP
BDOS function 23: \f[B]RENAME FILE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $17
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Directory Code
.IP \[bu] 2
H: Physical or Extended Error
.PP
The Rename function uses the FCB, addressed by register pair DE, to
change all directory entries of the file specified by the filename in
the first 16 bytes of the FCB to the filename in the second 16 bytes.
If the file specified by the first filename is password protected, the
correct password must be placed in the first eight bytes of the current
DMA buffer, or have been previously established as the default password
(see Function 106).
The calling program must also ensure that the filenames specified in the
FCB are valid and unambiguous, and that the new filename does not
already exist on the drive.
Function 23 uses the dr code at byte 0 of the FCB to select the drive.
The drive code at byte 16 of the FCB is ignored.
.PP
Upon return, the Rename function returns a Directory Code in register A
with the value 0 if the rename is successful, or $0FF, 255 Decimal, if
the file named by the first filename in the FCB is not found.
Register H is set to zero in both of these cases.
If a physical or extended error is encountered, the Rename function
performs different actions depending on the BDOS error mode (see
Function 45).
If the BDOS error mode is the default mode, a message identifying the
error is displayed at the console and the program is terminated.
Otherwise, the Rename function returns to the calling program with
register A set to $0FF and register H set to one of the following
physical or extended error codes:
.IP \[bu] 2
01 Disk I/O error
.IP \[bu] 2
02 Read-Only disk
.IP \[bu] 2
03 Read-Only file
.IP \[bu] 2
04 Invalid drive error
.IP \[bu] 2
07 File password error
.IP \[bu] 2
08 File already exists
.IP \[bu] 2
09 ?
in filename or filetype field
.PP
BDOS function 24: \f[B]RETURN LOGIN VECTOR\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $18
.PP
Returned Value:
.IP \[bu] 2
HL: Login Vector
.PP
Function 24 returns the login vector in register pair HL.
The login vector is a 16-bit value with the least significant bit of L
corresponding to drive A, and the highorder bit of H corresponding to
the 16th drive, labelled P.
A 0 bit indicates that the drive is not on-line, while a 1 bit indicates
the drive is active.
A drive is made active by either an explicit BDOS Select Disk call,
number 14, or an implicit selection when a BDOS file operation specifies
a non-zero dr byte in the FCB.
Function 24 maintains compatibilty with earlier releases since registers
A and L contain the same values upon return.
.PP
BDOS function 25: \f[B]RETURN CURRENT DISK\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $19
.PP
Returned Value:
.IP \[bu] 2
A: Current Disk
.PP
Function 25 returns the currently selected default disk number in
register A.
The disk numbers range from 0 through 15 corresponding to drives A
through P.
.PP
BDOS function 26: \f[B]SET DMA ADDRESS\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $1A
.IP \[bu] 2
DE: DMA Address
.PP
DMA is an acronym for Direct Memory Address, which is often used in
connection with disk controllers that directly access the memory of the
computer to transfer data to and from the disk subsystem.
Under CP/M 3, the current DMA is usually defined as the buffer in memory
where a record resides before a disk write, and after a disk read
operation.
If the BDOS Multi-Sector Count is equal to one (see Function 44), the
size of the buffer is 128 bytes.
However, if the BDOS Multi-Sector Count is greater than one, the size of
the buffer must equal N * 128, where N equals the Multi-Sector Count.
.PP
Some BDOS functions also use the current DMA to pass parameters, and to
return values.
For example, BDOS functions that check and assign file passwords require
that the password be placed in the current DMA.
As another example, Function 46, Get Disk Free Space, returns its
results in the first 3 bytes of the current DMA.
When the current DMA is used in this context, the size of the buffer in
memory is determined by the specific requirements of the called
function.
.PP
When a transient program is initiated by the CCP, its DMA address is set
to $0080.
The BDOS Reset Disk System function, Function 13, also sets the DMA
address to $0080.
The Set DMA function can change this default value to another memory
address.
The DMA address is set to the value passed in the register pair DE.
The DMA address remains at this value until it is changed by another Set
DMA Address, or Reset Disk System call.
.PP
BDOS function 27: \f[B]GET ADDR(ALLOC)\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $1B
.PP
Returned Value:
.IP \[bu] 2
HL: ALLOC Address
.PP
CP/M 3 maintains an allocation vector in main memory for each active
disk drive.
Some programs use the information provided by the allocation vector to
determine the amount of free data space on a drive.
Note, however, that the allocation information might be inaccurate if
the drive has been marked Read-Only.
.PP
Function 27 returns in register pair HL, the base address of the
allocation vector for the currently selected drive.
If a physical error is encountered when the BDOS error mode is one of
the return modes (see Function 45), Function 27 returns the value $FFFF
in the register pair HL.
.PP
In banked CP/M 3 systems, the allocation vector can be placed in bank
zero.
In this case, a transient program cannot access the allocation vector.
However, the BDOS function, Get Disk Free Space (Function 46), can be
used to directly return the number of free 128-byte records on a drive.
The CP/M 3 utilities that display a drive\[cq]s free space, DIR and
SHOW, use Function 46 for that purpose.
.PP
BDOS function 28: \f[B]WRITE PROTECT DISK\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $1C
.PP
The Write Protect Disk function provides temporary write protection for
the currently selected disk by marking the drive as Read-Only, No
program can write to a disk that is in the Read-Only state.
A drive reset operation must be performed for a Read-Only drive to
restore it to the Read-Write state (see Functions 13 and 37).
.PP
BDOS function 29: \f[B]GET READ-ONLY VECTOR\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: l$D
.PP
Returned Value:
.IP \[bu] 2
HL: R/O Vector Value
.PP
Function 29 returns a bit vector in register pair HL that indicates
which drives have the temporary Read-Only bit set.
The Read-Only bit can be set only by a BDOS Write Protect Disk call.
.PP
The format of the bit vector is analogous to that of the login vector
returned by Function 24.
The least significant bit corresponds to drive A, while the most
significant bit corresponds to drive P.
.PP
BDOS function 30: \f[B]SET FILE ATTRIBUTES\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $1E
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Directory Code
.IP \[bu] 2
H: Physical or Extended error
.PP
By calling the Set File Attributes function, a program can modify a
file\[cq]s attributes and set its last record byte count.
Other BDOS functions can be called to interrogate these file parameters,
but only Function 30 can change them.
The file attributes that can be set or reset by Function 30 are fl\[cq]
through f4\[cq], Read-Only, t1\[cq], System, t2\[cq], and Archive,
t3\[cq].
The register pair DE addresses an FCB containing a filename with the
appropriate attributes set or reset.
The calling program must ensure that it does not specify an ambiguous
filename.
In addition, if the specified file is password totected, the correct
password must be placed in the first eight bytes of the current DMA
buffer or have been previously established as the default password (see
Function 106).
.PP
Interface attribute f6\[cq] specifies whether the last record byte count
of the specified file is to be set:
.IP \[bu] 2
f6\[cq] = 0 - Do not set byte count (default mode)
.IP \[bu] 2
f6\[cq] = 1 - Set byte count
.PP
If interface attribute f6\[cq] is set, the calling program must set the
cr field of the referenced FCB to the byte count value.
A program can access a file\[cq]s byte count value with the BDOS Open,
Search, or Search Next functions.
.PP
Function 30 searches the referenced directory for entries belonging to
the current user number that matches the FCB specified name and type
fields.
The function then updates the directory to contain the selected
indicators, and if interface attribute f6\[cq] is set, the specified
byte count value.
Note that the last record byte count is maintained in byte 13 of a
file\[cq]s directory FCBS.
.PP
File attributes t1\[cq], t2\[cq], and t3\[cq] are defined by CP/M 3.
(They are described in Section 2.3.4.) Attributes fl\[cq] through
f4\[cq] are not presently used, but can be useful for application
programs, because they are not involved in the matching program used by
the BDOS during Open File and Close File operations.
Indicators f5\[cq] through f8\[cq] are reserved for use as interface
attributes.
.PP
Upon return, Function 30 returns a Directory Code in register A with the
value 0 if the function is successful, or $FF, 255 Decimal, if the file
specified by the referenced FCB is not found.
Register H is set to zero in both of these cases.
If a physical or extended error is encountered\[cq], the Set File
Attributes function performs different actions depending on the BDOS
error mode (see Function 45).
If the BDOS error mode is the default mode, a message identifying the
error is displayed at the console, and the program is terminated.
Otherwise, Function 30 returns to the calling program with
reg\[cq]ls-Ler A set to $FF, and register H set to one of the following
physical or extended error codes:
.IP \[bu] 2
01 Disk I/O error
.IP \[bu] 2
02 Read-Only disk
.IP \[bu] 2
04 Select error
.IP \[bu] 2
07 File password error
.IP \[bu] 2
09 ?
in filename or filetype field
.PP
BDOS function 31: \f[B]GET ADDR(DPB PARMS)\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $1F
.PP
Returned Value:
.IP \[bu] 2
HL: DPB Address
.PP
Function 31 returns in register pair HL the address of the BIOS-resident
Disk Parameter Block, DPB, for the currently selected drive.
(Refer to the CP/M Plus (CP/M Version 3) Operating System System Guide
for the format of the DPB).
The calling program can use this address to extract the disk parameter
values.
.PP
If a physical error is encountered when the BDOS error mode is one of
the return modes (see Function 45), Function 31 returns the value $FFFF
in the register pair HL.
.PP
BDOS function 32: \f[B]SET/GET USER CODE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $20
.PP
Returned Value:
.IP \[bu] 2
E: $FF (get) or User Code (set)
.IP \[bu] 2
A: Current Code or (no value)
.PP
A program can change, or interrogate the currently active user number by
calling Function 32.
If register E = $FF, then the value of the current user number is
returned in register A, where the value is in the range of 0 to 15.
If register E is not $FF, then the current user number is changed to the
value of E, modulo 16.
.PP
BDOS function 33: \f[B]READ RANDOM\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $21
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Error Code
.IP \[bu] 2
H: Physical Error
.PP
The Read Random function is similar to the Read Sequential function
except that the read operation takes place at a particular random record
number, selected by the 24-bit value constructed from the three byte,
r0, r1, r2, field beginning at position 33 of the FCB.
Note that the sequence of 24 bits is stored with the least significant
byte first, rO, the middle byte next, rl, and the high byte last, r2.
The random record number can range from 0 to 262,143.
This corresponds to a maximum value of 3 in byte r2.
.PP
To read a file with Function 33, the calling program must first open the
base extent, extent 0.
This ensures that the FCB is properly initialized for subsequent random
access operations.
The base extent may or may not contain any allocated data.
Function 33 reads the record specified by the random record field into
the current DMA address.
The function automatically sets the logical extent and current record
values, but unlike the Read Sequential function, it does not advance the
current record number.
Thus, a subsequent Read Random call rereads the same record.
After a random read operation, a file can be accessed sequentially,
starting from the current randomly accessed position.
However, the last randomly accessed record is reread or rewritten when
switching from random to sequential mode.
.PP
If the BDOS Multi-Sector Count is greater than one (see Function 44),
the Read Random function reads multiple consecutive records into memory
beginning at the current DMA.
The rO, rl, and r2 field of the FCB is automatically incremented to read
each record.
However, the FCBs random record number is restored to the first
record\[cq]s value upon return to the calling program.
.PP
Upon return, the Read Random function sets register A to zero if the
read operation was successful.
Otherwise, register A contains one of the following error codes:
.IP \[bu] 2
01 Reading unwritten data (end-of-file)
.IP \[bu] 2
03 Cannot close current extent
.IP \[bu] 2
04 Seek to unwritten extent
.IP \[bu] 2
06 Random record number out of range
.IP \[bu] 2
10 Media change occurred
.IP \[bu] 2
255 Physical Error : refer to register H
.PP
Error Code 01 is returned if no data exists at the next record position
of the file.
Usually, the no data situation is encountered at the end of a file.
However, it can also occur if an attempt is made to read a data block
that has not been previously written.
.PP
Error Code 03 is returned when the Read Random function cannot close the
current extent prior to moving to a new extent.
.PP
Error Code 04 is returned when a read random operation accesses an
extent that has not been created.
.PP
Error Code 06 is returned when byte 35, r2, of the referenced FCB is
greater than 3.
.PP
Error Code 10 is returned if a media change occurs on the drive after
the referenced FCB is activated by a BDOS Open or Make Call.
.PP
Error Code 255 is returned if a physical error is encountered, and the
BDOS error mode is one of the return modes (see Function 45).
If the error mode is the default mode, a message identifying the
physical error is displayed at the console, and the calling program is
terminated.
When a physical error is returned to the calling program, register H
contains one of the following error codes:
.IP \[bu] 2
01 Disk I/O error
.IP \[bu] 2
04 Invalid drive error
.PP
On all error returns except for physical errors, A = 255, the Read
Random function sets register H to the number of records successfully
read before the error is encountered.
This value can range from 0 to 127 depending on the current BDOS
Multi-Sector Count.
It is always set to zero when the Multi-Sector Count is equal to one.
.PP
BDOS function 34: \f[B]WRITE RANDOM\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $22
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Error Code
.IP \[bu] 2
H: Physical Error
.PP
The Write Random function is analogous to the Read Random function,
except that data is written to the disk from the current DMA address.
If the disk extent or data block where the data is to be written is not
already allocated, the BDOS automatically performs the allocation before
the write operation continues.
.PP
To write to a file using the Write Random function, the calling program
must first open the base extent, extent 0.
This ensures that the FCB is properly initialized for subsequent random
access operations.
If the file is empty, the calling program must create the base extent
with the Make File function before calling Function 34.
The base extent might or might not contain any allocated data, but it
does record the file in the directory, so that the file can be displayed
by the DIR utility.
.PP
The Write Random function sets the logical extent and current record
positions to correspond with the random record being written, but does
not change the random record number.
Thus, sequential read or write operations can follow a random write,
with the current record being reread or rewritten as the calling program
switches from random to sequential mode.
.PP
Function 34 makes an Update date and time stamp for the file if the
following conditions are satisfied: the referenced drive has a directory
label that requests Update date and time stamping if the file has not
already been stamped for update by a previous BDOS Make or Write call.
.PP
If the BDOS Multi-Sector Count is greater than one (see Function 44),
the Write Random function reads multiple consecutive records into memory
beginning at the current DMA.
The rO, rl, and r2 field of the FCB is automatically incremented to
write each record.
However, the FCB\[cq]s random record number is restored to the first
record\[cq]s value when it returns to the calling program.
Upon return, the Write Random function sets register A to zero if the
write operation is successful.
Otherwise, register A contains one of the following error codes:
.IP \[bu] 2
02 No available data block
.IP \[bu] 2
03 Cannot Close current extent
.IP \[bu] 2
05 No available directory space
.IP \[bu] 2
06 Random record number out of range
.IP \[bu] 2
10 Media change occurred
.IP \[bu] 2
255 Physical Error : refer to register H
.PP
Error Code 02 is returned when the write command attempts to allocate a
new data block to the file and no unallocated data blocks exist on the
selected disk drive.
.PP
Error Code 03 is returned when the Write Random function cannot close
the current extent prior to moving to a new extent.
.PP
Error Code 05 is returned when the write function attempts to create a
new extent that requires a new directory entry and no available
directory entries exist on the selected disk drive.
.PP
Error Code 06 is returned when byte 35, r2, of the referenced FCB is
greater than 3.
.PP
Error Code 10 is returned if a media change occurs on the drive after
the referenced FCB is activated by a BDOS Open or Make Call.
.PP
Error Code 255 is returned if a physical error is encountered and the
BDOS error mode is one of the return modes (see Function 45).
If the error mode is the default mode, a message identifying the
physical error is displayed at the console, and the calling program is
terminated.
When a physical error is returned to the calling program, it is
identified by register H as shown below:
.IP \[bu] 2
01 Disk I/O error
.IP \[bu] 2
02 Read-Only disk
.IP \[bu] 2
03 Read-Only file or File open from user 0 when the current user number
is nonzero or File password protected in Write mode
.IP \[bu] 2
04 Invalid drive error
.PP
On all error returns, except for physical errors, A = 255, the Write
Random function sets register H to the number of records successfully
written before the error is encountered.
This value can range from 0 to 127 depending on the current BDOS
Multi-Sector Count.
It is always set to zero when the Multi-Sector Count is equal to one.
.PP
BDOS function 35: \f[B]COMPUTE FILE SIZE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $23
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Error Flag
.IP \[bu] 2
H: Physical or Extended error
.IP \[bu] 2
Random Record Field Set
.PP
The Compute File Size function determines the virtual file size, which
is, in effect, the address of the record immediately following the end
of the file.
The virtual size of a file corresponds to the physical size if the file
is written sequentially.
If the file is written in random mode, gaps might exist in the
allocation, and the file might contain fewer records than the indicated
size.
For example, if a single record with record number 262,143, the CP/M 3
maximum is written to a file using the Write Random function, then the
virtual size of the file is 262,144 records even though only 1 data
block \[cq]is actually allocated.
.PP
To compute file size, the calling program passes in register pair DE the
address of an FCB in random mode format, bytes rO, rl and r2 present.
Note that the FCB must contain an unambiguous filename and filetype.
Function 35 sets the random record field of the FCB to the random record
number + 1 of the last record in the file.
If the r2 byte is set to 04, then the file contains the maximum record
count 262,144.
.PP
A program can append data to the end of an existing file by calling
Function 35 to set the random record position to the end of file, and
then performing a sequence of random writes starting at the preset
record address.
.PP
Note: the BDOS does not require that the file be open to use Function
35.
However, if the file has been written to, it must be closed before
calling Function 35.
Otherwise, an incorrect file size might be returned.
.PP
Upon return, Function 35 returns a zero in register A if the file
specified by the referenced FCB is found, or an $FF in register A if the
file is not found.
Register H is set to zero in both of these cases.
If a physical error is encountered, Function 35 performs different
actions depending on the BDOS error mode (see Function 45).
If the BDOS error mode is the default mode, a message identifying the
error is displayed at the console and the program is terminated.
Otherwise, Function 35 returns to the calling program with register A
set to $FF, and register H set to one of the following physical errors:
.IP \[bu] 2
01 Disk I/O error
.IP \[bu] 2
04 Invalid drive error
.PP
BDOS function 36: \f[B]SET RANDOM RECORD\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $24
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
Random Record Field Set
.PP
The Set Random Record function returns the random record number of the
next record to be accessed from a file that has been read or written
sequentially to a particular point.
This value is returned in the random record field, bytes rO, rl, and r2,
of the FCB addressed by the register pair DE.
Function 36 can be useful in two ways,
.PP
First, it is often necessary to initially read and scan a sequential
file to extract the positions of various key fields.
As each key is encountered, Function 36 is called to compute the random
record position for the data corresponding to this key.
If the data unit size is 128 bytes, the resulting record number minus
one is placed into a table with the key for later retrieval.
After scanning the entire file and tabularizing the keys and their
record numbers, you can move directly to a particular record by
performing a random read using the corresponding random record number
that you saved earlier.
The scheme is easily generalized when variable record lengths are
involved, because the program need only store the buffer-relative byte
position along with the key and record number to find the exact starting
position of the keyed data at a later time.
.PP
A second use of Function 36 occurs when switching from a sequential read
or write over to random read or write.
A file is sequentially accessed to a particular point in the file, then
Function 36 is called to set the record number, and subsequent random
read and write operations continue from the next record in the file.
.PP
BDOS function 37: \f[B]RESET DRIVE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $25
.IP \[bu] 2
DE: Drive Vector
.PP
Returned Value:
.IP \[bu] 2
A: $00
.PP
The Reset Drive function programmatically restores specified drives to
the reset state.
A reset drive is not logged-in and is in Read-Write status.
The passed parameter in register pair DE is a 16-bit vector of drives to
be reset, where the least significant bit corresponds to the first drive
A, and the high-order bit corresponds to the sixteenth drive, labelled
P.
Bit values of 1 indicate that the specified drive is to be reset.
.PP
BDOS function 38: \f[B]ACCESS DRIVE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $26
.PP
This is an MP/M function that is not supported under CP/M 3.
If called, the file system returns a zero In register A indicating that
the access request is successful.
.PP
BDOS function 39: \f[B]FREE DRIVE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $27
.PP
This is an MP/M function that is not supported under CP/M 3.
If called, the file system returns a zero In register A indicating that
the free request is successful.
.PP
BDOS function 40: \f[B]WRITE RANDOM WITH ZERO FILL\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $28
.IP \[bu] 2
DE: FCB address
.PP
Returned Value:
.IP \[bu] 2
A: Error Code
.IP \[bu] 2
H: Physical Error
.PP
The Write Random With Zero Fill function is identical to the Write
Random function (Function 34) with the exception that a previously
unallocated data block is filled with zeros before the record is
written.
If this function has been used to create a file, records accessed by a
read random operation that contain all zeros identify unwritten random
record numbers.
Unwritten random records in allocated data blocks of files created using
the Write Random function (Function 34) contain uninitialized data.
.PP
BDOS function 41: \f[B]TEST AND WRITE RECORD\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $29
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Error Code
.IP \[bu] 2
H: Physical Error
.PP
The Test and Write Record function is an MP/M function that is not
supported under CP/M 3.
If called, Function 41 returns with register A set to $FF and register H
set to zero.
.PP
BDOS function 42: \f[B]LOCK RECORD\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $2A
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: $00
.PP
The Lock Record function is an MP/M II function that is supported under
CP/M 3 only to provide compatibility between CP/M 3 and MP/M.
It is intended for use in situations where more than one running program
has Read-Write access to a common file.
Because CP/M 3 is a single-user operating system in which only one
program can run at a time, this situation cannot occur.
Thus, under CP/M 3, Function 42 performs no action except to return the
value $00 in register A indicating that the record lock operation is
successful.
.PP
BDOS function 43: \f[B]UNLOCK RECORD\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $2B
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: $00
.PP
The Unlock Record function is an MP/M II function that is supported
under CP/M 3 only to provide compatibility between CP/M 3 and MP/M.
It is intended for use in situations where more than one running program
has Read-Write access to a common file.
Because CP/M 3 is a single-user operating system in which only one
program can run at a time, this situation cannot occur.
Thus, under CP/M 3, Function 43 performs no action except to return the
value $00 in register A indicating that the record unlock operation is
successful.
.PP
BDOS function 44: \f[B]SET MULTI-SECTOR COUNT\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $2C
.IP \[bu] 2
E: Number of Sectors
.PP
Returned Value:
.IP \[bu] 2
A: Return Code
.PP
The Set Multi-Sector Count function provides logical record blocking
under CP/M 3.
It enables a program to read and write from 1 to 128 records of 128
bytes at a time during subsequent BDOS Read and Write functions.
.PP
Function 44 sets the Multi-Sector Count value for the calling program to
the value passed in register E.
Once set, the specified Multi-Sector Count remains in effect until the
calling program makes another Set Multi-Sector Count function call and
changes the value.
Note that the CCP sets the Multi-Sector Count to one when it initiates a
transient program.
.PP
The Multi-Sector Count affects BDOS error reporting for the BDOS Read
and Write functions.
If an error interrupts these functions when the Multi-Sector is greater
than one, they return the number of records successfully read or written
in register H for all errors except for physical errors (A = 255).
.PP
Upon return, register A is set to zero if the specified value is in the
range of 1 to 128.
Otherwise, register A is set to $FF.
.PP
BDOS function 45: \f[B]SET BDOS ERROR MODE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $2D
.IP \[bu] 2
E: BDOS Error Mode
.PP
Returned Value:
.IP \[bu] 2
None
.PP
Function 45 sets the BDOS error mode for the calling program to the mode
specified in register E.
If register E is set to $FF, 255 decimal, the error mode is set to
Return Error mode.
If register E is set to $FE, 254 decimal, the error mode is set to
Return and Display mode.
If register E is set to any other value, the error mode is set to the
default mode.
.PP
The SET BDOS Error Mode function determines how physical and extended
errors (see Section 2.2.13) are handled for a program.
The Error Mode can exist in three modes: the default mode, Return Error
mode, and Return and Display Error mode.
In the default mode, the BDOS displays a system message at the console
that identifies the error and terminates the calling program.
In the return modes, the BDOS sets register A to $FF, 255 decimal,
places an error code that identifies the physical or extended error in
register H and returns to the calling program.
In Return and Display mode, the BDOS displays the system message before
returning to the calling program.
No system messages are displayed, however, when the BDOS is in Return
Error mode.
.PP
BDOS function 46: \f[B]GET DISK FREE SPACE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $2E
.IP \[bu] 2
E: Drive
.PP
Returned Value:
.IP \[bu] 2
First 3 bytes of current DMA buffer
.IP \[bu] 2
A: Error Flag
.IP \[bu] 2
H: Physical Error
.PP
The Get Disk Free Space function determines the number of free sectors,
128 byte records, on the specified drive.
The calling program passes the drive number in register E, with 0 for
drive A, 1 for B, and so on, through 15 for drive P in a full 16drive
system.
Function 46 returns a binary number in the first 3 bytes of the current
DMA buffer.
This number is returned in the following format:
.PP
fso fsl fs2
.PP
Disk Free Space Field Format
.PP
fso = low byte
.PD 0
.P
.PD
fsl = middle byte
.PD 0
.P
.PD
fs2 = high byte
.PD 0
.P
.PD
Note that the returned free space value might be inaccurate if the drive
has been marked Read-Only.
.PP
Upon return, register A is set to zero if the function is successful.
However, if the BDOS Error Mode is one of the return modes (see Function
45), and a physical error is encountered, register A is set to $FF, 255
decimal, and register H is set to one of the following values:
.IP \[bu] 2
01 - Disk I/O error
.IP \[bu] 2
04 - Invalid drive error
.PP
BDOS function 47: \f[B]CHAIN TO PROGRAM\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $2F
.IP \[bu] 2
E: Chain Flag
.PP
The Chain To Program function provides a means of chaining from one
program to the next without operator intervention.
The calling program must place a command line terminated by a null byte,
OOH, in the default DMA buffer.
If register E is set to $FF, the CCP initializes the default drive and
user number to the current program values when it passes control to the
specified transient program.
Otherwise, these parameters are set to the default CCP values.
Note that Function 108, Get/Set Program Return Code, can be used to pass
a two byte value to the chained program.
.PP
Function 47 does not return any values to the calling program and any
encountered errors are handled by the CCP.
.PP
BDOS function 48: \f[B]FLUSH BUFFERS\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $30
.PP
Returned Value:
.IP \[bu] 2
A: Error Flag
.IP \[bu] 2
H: Physical Error
.PP
E: Purge Flag
.PP
The Flush Buffers function forces the write of any write-pending records
contained in internal blocking/deblocking buffers.
If register E is set to $FF, this function also purges all active data
buffers.
Programs that provide write with read verify support need to purge
internal buffers to ensure that verifying reads actually access the disk
instead of returning data that is resident in internal data buffers.
The CP/M 3 PIP utility is an example of such a program.
.PP
Upon return, register A is set to zero if the flush operation is
successful.
If a physical error is encountered, the Flush Buffers function performs
different actions depending on the BDOS error mode (see Function 45).
If the BDOS error mode is in the default mode,, a message identifying
the error is displayed at the console and the calling program is
terminated.
Otherwise, the Flush Buffers function returns to the calling program
with register A set to $FF and register H set to the following physical
error code:
.IP \[bu] 2
0 1 Disk I/O error
.IP \[bu] 2
02 Read/only disk
.IP \[bu] 2
04 Invalid drive error
.PP
BDOS function 49: \f[B]GET/SET SYSTEM CONTROL BLOCK\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $31
.IP \[bu] 2
DE: SCB PB Address
.PP
Returned Value:
.IP \[bu] 2
A: Returned Byte
.IP \[bu] 2
HL: Returned Word
.PP
Function 49 allows access to parameters located in the CP/M 3 System
Control Block (SCB).
The SCB is a 100-byte data structure residing within the BDOS that
contains flags and data used by the BDOS, CCP and other system
components.
Note that Function 49 is a CP/M 3 specific function.
Programs intended for both MP/M 11 and CP/M 3 should either avoid the
use of this function or isolate calls to this function in CP/M 3
version-dependent sections.
.PP
To use Function 49, the calling program passes the address of a data
structure called the SCB parameter block in register pair DE.
This data structure identifies the byte or word of the SCB to be updated
or returned.
The SCB parameter block is defined as:
.IP
.nf
\f[C]
SCBPB: DB OFFSET ; Offset within SCB
       DB SET ; 0FFH if setting a byte
       ; 0FEH if setting a word
       ; 001H - 0FDH are reserved
       ; 000H if a get operation
       DW VALUE ; Byte or word value to be set
\f[R]
.fi
.PP
The OFFSET parameter identifies the offset of the field within the SCB
to be updated or accessed.
The SET parameter determines whether Function 49 is to set a byte or
word value in the SCB or if it is to return a byte from the SCB.
The VALUE parameter is used only in set calls.
In addition, only the first byte of VALUE is referenced in set byte
calls.
.PP
Use caution when you set SCB fields.
Some of these parameters reflect the current state of the operating
system.
If they are set to invalid values, software errors can result.
In general, do not use Function 49 to set a system parameter if another
BDOS function can achieve the same result.
For example, Function 49 can be called to update the Current DMA Address
field within the SCB.
This is not equivalent to making a Function 26, Set DMA Address call,
and updating the SCB Current DMA field in this way would result in
system errors.
However, you can use Function 49 to return the Current DMA address.
The System Control Block is summarized in [table:91].
.PP
If Function 49 is called with the OFFSET parameter of the SCB parameter
block greater than $63, the function performs no action but returns with
registers A and HL set to zero.
.PP
BDOS function 50: \f[B]DIRECT BIOS CALLS\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $32
.IP \[bu] 2
DE: BIOS PB Address
.PP
Returned Value:
.IP \[bu] 2
BIOS RETURN
.PP
Function 50 provides a direct BIOS call through the BDOS to the BIOS.
The calling program passes the address of a data structure called the
BIOS Parameter Block (BIOSPB) in register pair DE.
The BIOSPB contains the BIOS function number and register contents as
shown below:
.IP
.nf
\f[C]
BIOSPB: db FUNC ; BIOS function no.
        db AREG ; A register contents
        dw BCREG ; BC register contents
        dw DEREG ; DE register contents
        dw HLREG ; HL register contents
\f[R]
.fi
.PP
System Reset (Function 0) is equivalent to Function 50 with a BIOS
function number of 1.
.PP
Note that the register pair BIOSPB fields (BCREG, DEREG, HLREG) arc
defined in low byte, high byte order.
For example, in the BCREG field, the first byte contains the C register
value, the second byte contains the B register value.
Under CP/M 3, direct BIOS calls via the BIOS jump vector are only
supported for the BIOS Console I/O and List functions.
You must use Function 50 to call any other
.PP
BIOS functions.
In addition, Function 50 intercepts BIOS Function 27 (Select Memory)
calls and returns with register A set to zero.
Refer to the CPIM Plus (CP/M Version 3) Operating System System Guide
for the definition of the BIOS functions and their register passing and
return conventions.
.PP
BDOS function 59: \f[B]LOAD OVERLAY\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $3B
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Error Code
.IP \[bu] 2
H: Physical Error
.PP
Only transient programs with an RSX header can use the Load Overlay
function because BDOS Function 59 is supported by the LOADER module.
The calling program must have a header to force the LOADER to remain
resident after the program is loaded (see Section 1.3).
.PP
Function 59 loads either an absolute or relocatable module.
Relocatable modules are identified by a filetype of PRL.
Function 59 does not call the loaded module.
.PP
The referenced FCB must be successfully opened before Function 59 is
called.
The load address is specified in the first two random record bytes of
the FCB, rO and rl.
The LOADER returns an error if the load address is less than $100, or if
performing the requested load operation would overlay the LOADER, or any
other Resident System Extensions that have been previously loaded.
.PP
When loading relocatable files, the LOADER requires enough room at the
load address for the complete PRL file including the header and bit map
(see Appendix B).
Otherwise an error is returned.
Function 59 also returns an error on PRL file load requests if the
specified load address is not on a page boundary.
.PP
Upon return, Function 59 sets register A to zero if the load operation
is successful.
If the LOADER RSX is not resident in memory because the calling program
did not have a RSX header, the BDOS returns with register A set to $FF
and register H set to zero.
If the LOADER detects an invalid load address, or if insufficient memory
is available to load the overlay, Function 59 returns with register A
set to $FE.
All other error returns are consistent with the error codes returned by
BDOS Function 20, Read Sequential.
.PP
BDOS function 60: \f[B]CALL RESIDENT SYSTEM EXTENSION\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $3C
.IP \[bu] 2
DE: RSX PB Address
.PP
Returned Value:
.IP \[bu] 2
A: Error Code
.IP \[bu] 2
H: Physical Error
.PP
Function 60 is a special BDOS function that you use when you call
Resident System Extensions.
The RSX subfunction is specified in a structure called the RSX Parameter
Block, defined as follows:
.IP
.nf
\f[C]
RSXPB: db FUNC ; RSX Function number
       db NUMPARMS ; Number of word Parameters
       dw PARMETER1 ; Parameter I
       dw PARMETER2 ; Parameter 2
       . . .
       dw PARMETERN ; Parameter n
\f[R]
.fi
.PP
RSX modules filter all BDOS calls and capture RSX function calls that
they can handle.
If there is no RSX module present in memory that can handle a specific
RSX function call, the call is not trapped, and the BDOS returns $FF in
registers A and L.
RSX function numbers from 0 to 127 are available for CP/M 3 compatible
software use.
RSX function numbers 128 to 255 are reserved for system use.
.PP
BDOS function 98: \f[B]FREE BLOCKS\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $62
.PP
Returned Value:
.IP \[bu] 2
A: Error Flag
.IP \[bu] 2
H: Physical Error
.PP
The Free Blocks function scans all the currently logged-in drives, and
for each drive returns to free space all temporarily-allocated data
blocks.
A temporarily-allocated data block is a block that has been allocated to
a file by a BDOS write operation but has not been permanently recorded
in the directory by a BDOS close operation.
The CCP calls Function 98 when it receives control following a system
warm start.
Be sure to close your file, particularly any file you have written to,
prior to calling Function 98.
.PP
In the nonbanked version of CP/M 3, Function 98 frees only temporarily
allocated blocks for systems that request double allocation vectors in
GENCPM.
.PP
Upon return, register A is set to zero if Function 98 is successful.
If a physical error is encountered, the Free Blocks function performs
different actions depending on the BDOS error mode (see Function 45).
If the BDOS error mode is in the default mode, a message identifying the
error is displayed at the console and the calling program is terminated.
Otherwise, the Free Blocks function returns to the calling program with
register A set to $FF and register H set to the following physical error
code:
.IP \[bu] 2
04 : Invalid drive error
.PP
BDOS function 99: \f[B]TRUNCATE FILE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $63
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Directory Code
.IP \[bu] 2
H: Extended or Physical Error
.PP
The Truncate File function sets the last record of a file to the random
record number contained in the referenced FCB.
The calling program passes the address of the FCB in register pair DE,
with byte 0 of the FCB specifying the drive, bytes 1 through 11
specifying the filename and filetype, and bytes 33 through 35, rO, rl,
and r2, specifying the last record number of the file.
The last record number is a 24 bit value, stored with the least
significant byte first, rO, the middle byte next, rl, and the high byte
last, r2.
This value can range from 0 to 262,143, which corresponds to a maximum
value of 3 in byte r2.
.PP
If the file specified by the referenced FCB is password protected, the
correct password must be placed in the first eight bytes of the current
DMA buffer, or have been previously established as the default password
(see Function 106).
.PP
Function 99 requires that the file specified by the FCB not be open,
particularly if the file has been written to.
In addition, any activated FCBs naming the file are not valid after
Function 99 is called.
Close your file before calling Function 99, and then reopen it after the
call to continue processing on the file.
.PP
Function 99 also requires that the random record number field of the
referenced FCB specify a value less than the current file size.
In addition, if the file is sparse, the random record field must specify
a record in a region of the file where data exists.
.PP
Upon return, the Truncate function returns a Directory Code in register
A with the value 0 if the Truncate function is successful, or $FF, 255
decimal, if the file is not found or the record number is invalid.
Register H is set to zero in both of these cases.
If a physical or extended error is encountered, the Truncate function
performs different actions depending on the BDOS error mode (see
Function 45).
If the BDOS error mode is in the default mode, a message identifying the
error is displayed at the console and the program is terminated.
Otherwise, the Truncate function returns to the calling program with
register A set to $FF and register H set to one of the following
physical or extended error codes:
.IP \[bu] 2
01 Disk I/O error
.IP \[bu] 2
02 Read-Only disk
.IP \[bu] 2
03 Read-Only file
.IP \[bu] 2
04 Invalid drive error
.IP \[bu] 2
07 File password error
.IP \[bu] 2
09 ?
in filename or filetype field
.PP
BDOS function 100: \f[B]SET DIRECTORY LABEL\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $64
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Directory Code
.IP \[bu] 2
H: Physical or Extended Error
.PP
The Set Directory Label function creates a directory label, or updates
the existing directory label for the specified drive.
The calling program passes in register pair DE the address of an FCB
containing the name, type, and extent fields to be assigned to the
directory label.
The name and type fields of the referenced FCB are not used to locate
the directory label in the directory; they are simply copied into the
updated or created directory label.
The extent field of the FCB, byte 12, contains the user\[cq]s
specificat-on of the directory label data byte.
The definition of the directory label data byte is:
.IP \[bu] 2
7 - Require passwords for password-protected files (Not supported in
nonbanked CP/M 3 systems)
.IP \[bu] 2
6 - Perform access date and time stamping
.IP \[bu] 2
5 - Perform update date and time stamping
.IP \[bu] 2
4 - Perform create date and time stamping
.IP \[bu] 2
0 - Assign a new password to the directory label
.PP
If the current directory label is password protected, the correct
password must be placed in the first eight bytes of the current DMA, or
have been previously established as the default password (see Function
106).
If bit 0, the low-order bit, of byte 12 of the FCB is set to 1, it
indicates that a new password for the directory label has been placed in
the second eight bytes of the current DMA.
.PP
Note that Function 100 is implemented as an RSX, DIRLBL.RSX, in
nonbanked CP/M 3 systems.
If Function 100 is called in nonbanked systems when the DIRLBL.RSX is
not resident an error code of $0FF is returned.
.PP
Function 100 also requires that the referenced directory contain SFCBs
to activate date and time stamping on the drive.
If an attempt is made to activate date and time stamping when no SFCBs
exist, Function 100 returns an error code of $FF in register A and
performs no action.
The CP/M 3 INITDIR utility initializes a directory for date and time
stamping by placing an SFCB record in every fourth entry of the
directory.
.PP
Function 100 returns a Directory Code in register A with the value 0 if
the directory label create or update is successful, or $FF, 255 decimal,
if no space exists in the referenced directory to create a directory
label, or if date and time stamping was requested and the referenced
directory did not contain SFCBS.
Register H is set to zero in both of these cases.
If a physical error or extended error is encountered, Function 100
performs different actions depending on the BDOS error mode (see
Function 45).
If the BDOS error mode is the default mode, a message identifying the
error is displayed at the console and the calling program is terminated.
Otherwise, Function 100 returns to the calling program with register A
set to $FF and register H set to one of the following physical or
extended error codes:
.IP \[bu] 2
01 Disk I/O error
.IP \[bu] 2
02 Read-Only disk
.IP \[bu] 2
04 Invalid drive error
.IP \[bu] 2
07 File password error
.PP
BDOS function 101: \f[B]RETURN DIRECTORY LABEL DATA\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $65
.IP \[bu] 2
E: Drive
.PP
Returned Value:
.IP \[bu] 2
A: Directory Label Data Byte
.IP \[bu] 2
H: Physical Error
.PP
The Return Directory Label Data function returns the data byte of the
directory label for the specified drive.
The calling program passes the drive number in register E with 0 for
drive A, 1 for drive B, and so on through 15 for drive P in a full
sixteen drive system.
The format of the directory label data byte is shown below:
.IP \[bu] 2
7 - Require passwords for password protected files
.IP \[bu] 2
6 - Perform access date and time stamping
.IP \[bu] 2
5 - Perform update date and time stamping
.IP \[bu] 2
4 - Perform create date and time stamping
.IP \[bu] 2
0 - Directory label exists on drive
.PP
Function 101 returns the directory label data byte to the calling
program in register A.
Register A equal to zero indicates that no directory label exists on the
specified drive.
If a physical error is encountered by Function 101 when the BDOS Error
mode is in one of the return modes (see Function 45), this function
returns with register A set to $FF, 25S decimal, and register H set to
one of the following:
.IP \[bu] 2
01 Disk I/O error
.IP \[bu] 2
04 Invalid drive error
.PP
BDOS function 102: \f[B]READ FILE DATE STAMPS AND PASSWORD MODE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $66
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Directory Code
.IP \[bu] 2
H: Physical Error
.PP
Function 102 returns the date and time stamp information and password
mode for the specified file in byte 12 and bytes 24 through 32 of the
specified FCB.
The calling program passes in register pair DE, the address of an FCB in
which the drive, filename, and filetype fields have been defined.
.PP
If Function 102 is successful, it sets the following fields in the
referenced FCB:
.IP \[bu] 2
byte 12 : Password mode field
.RS 2
.IP \[bu] 2
7 - Read mode
.IP \[bu] 2
6 - Write mode
.IP \[bu] 2
4 - Delete mode
.RE
.PP
Byte 12 equal to zero indicates the file has not been assigned a
password.
In nonbanked systems, byte 12 is always set to zero.
.IP \[bu] 2
byte 24 - 27 Create or Access time stamp field
.IP \[bu] 2
byte 28 - 31 Update time stamp field
.PP
The date stamp fields are set to binary zeros if a stamp has not been
made.
The format of the time stamp fields is the same as the format of the
date and time structure described in Function 104.
.PP
Upon return, Function 102 returns a Directory Code in register A with
the value zero if the function is successful, or $FF, 255 decimal, if
the specified file is not found.
Register H is set to zero in both of these cases.
If a physical or extended error is encountered, Function 102 performs
different actions depending on the BDOS error mode (see Function 45).
If the BDOS error mode is in the default mode, a message identifying the
error is displayed at the console and the calling program is terminated.
Otherwise, Function 102 returns to the calling program with register A
set to $FF and register H set to one of the following physical or
extended error codes:
.IP \[bu] 2
01 Disk I/O error
.IP \[bu] 2
04 Invalid drive error
.IP \[bu] 2
09 ?
in filename or filetype field
.PP
BDOS function 103: \f[B]WRITE FILE XFCB\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $67
.IP \[bu] 2
DE: FCB Address
.PP
Returned Value:
.IP \[bu] 2
A: Directory Code
.IP \[bu] 2
H: Physical Error
.PP
The Write File XFCB function creates a new XFCB or updates the existing
XFCB for the specified file.
The calling program passes in register pair DE the address of an FCB in
which the drive, name, type, and extent fields have been defined.
The extent field specifies the password mode and whether a new password
is to be assigned to the file.
The format of the extent byte is shown below:
.PP
FCB byte 12 (ex) : XFCB password mode
.IP \[bu] 2
7 - Read mode
.IP \[bu] 2
6 - Write mode
.IP \[bu] 2
5 - Delete mode
.IP \[bu] 2
0 - Assign new password to the file
.PP
If the specified file is currently password protected, the correct
password must reside in the first eight bytes of the current DMA, or
have been previously established as the default password (see Function
106).
If bit 0 is set to 1, the new password must reside in the second eight
bytes of the current DMA.
.PP
Upon return, Function 103 returns a Directory Code in register A with
the value zero if the XFCB create or update is successful, or $FF, 255
decimal, if no directory label exists on the specified drive, or the
file named in the FCB is not found, or no space exists in the directory
to create an XFCB.
Function 103 also returns with $FF in register A if passwords are not
enabled by the referenced directory\[cq]s label.
On nonbanked systems, this function always returns with register A = $FF
because passwords are not supported.
Register H is set to zero in all of these cases.
If a physical or extended error is encountered, Function 103 performs
different actions depending on the BDOS error mode (see Function 45).
If the BDOS error mode is the default mode, a message identifying the
error is displayed at the console and the calling program is terminated.
Otherwise, Function 103 returns to the calling program with register A
set to $FF and register H set to one of the following physical or
extended error codes:
.IP \[bu] 2
01 Disk I/O error
.IP \[bu] 2
02 Read-Only disk
.IP \[bu] 2
04 Invalid drive error
.IP \[bu] 2
07 File password error
.IP \[bu] 2
09 ?
in filename or filetype field
.PP
BDOS function 104: \f[B]SET DATE AND TIME\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $68
.IP \[bu] 2
DE: DAT Address
.PP
Returned Value:
.IP \[bu] 2
none
.PP
The Set Date and Time function sets the system internal date and time.
The calling program passes the address of a 4-byte structure containing
the date and time specification in the register pair DE.
The format of the date and time (DAT) data structure is:
.IP \[bu] 2
0 - 1 Date field
.IP \[bu] 2
2 Hour field
.IP \[bu] 2
3 Minute field
.PP
The date is represented as a 16-bit integer with day 1 corresponding to
January 1, 1978.
The time is represented as two bytes: hours and minutes are stored as
two BCD digits.
.PP
This function also sets the seconds field of the system date and time to
zero.
.PP
BDOS function 105: \f[B]GET DATE AND TIME\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $69
.IP \[bu] 2
DE: DAT Address
.PP
Returned Value:
.IP \[bu] 2
A: seconds
.IP \[bu] 2
DAT set
.PP
The Get Date and Time function obtains the system internal date and
time.
The calling program passes in register pair DE, the address of a 4-byte
data structure which receives the date and time values.
The format of the date and time, DAT, data structure is the same as the
format described in Function 104.
Function 105 also returns the seconds field of the system date and time
in register A as a two digit BCD value.
.PP
BDOS function 106: \f[B]SET DEFAULT PASSWORD\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $6A
.IP \[bu] 2
DE: Password Address
.PP
Returned Value:
.IP \[bu] 2
none
.PP
The Set Default Password function allows a program to specify a password
value before a file protected by the password is accessed.
When the file system accesses a password-protected file, it checks the
current DMA, and the default password for the correct value.
If either value matches the file\[cq]s password, full access to the file
is allowed.
Note that this function performs no action in nonbanked CP/M 3 systems
because file passwords are not supported.
.PP
To make a Function 106 call, the calling program sets register pair DE
to the address of an 8-byte field containing the password.
.PP
BDOS function 107: \f[B]RETURN SERIAL NUMBER\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $6B
.IP \[bu] 2
DE: Serial Number Field
.PP
Returned Value:
.IP \[bu] 2
Serial number field set
.PP
Function 107 returns the CP/M 3 serial number to the 6-byte field
addressed by register pair DE.
.PP
BDOS function 108: \f[B]GET/SET PROGRAM RETURN CODE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $6C
.IP \[bu] 2
DE: $0FFFF (Get) or Program Return Code (Set)
.PP
Returned Value:
.IP \[bu] 2
HL: Program Return Code or (no value)
.PP
CP/M 3 allows programs to set a return code before terminating.
This provides a mechanism for programs to pass an error code or value to
a following job step in batch environments.
For example, Program Return Codes are used by the CCP in CP/M 3\[cq]s
conditional command line batch facility.
Conditional command lines are command lines that begin with a colon, :.
The execution of a conditional command depends on the successful
execution of the preceding command.
The CCP tests the return code of a terminating program to determine
whether it successfully completed or terminated in error.
Program return codes can also be used by programs to pass an error code
or value to a chained program (see Function 47, Chain To Program).
.PP
A program can set or interrogate the Program Return Code by calling
Function 108.
If re \[cq]ster pair DE = $FFFF, then the current Program Return Code is
returned in register pair HL.
Otherwise, Function 108 sets the Program Return Code to the \[cq]value
contained in register pair DE.
Program Return Codes are defined in [table:92]
.PP
BDOS function 109: \f[B]GET/SET CONSOLE MODE\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $6D
.IP \[bu] 2
DE: $FFFF (Get) or Console Mode (Set)
.PP
Returned Value:
.IP \[bu] 2
HL: Console Mode or (no value)
.PP
A program can set or interrogate the Console Mode by calling Function
109.
If register pair DE = $FFFF, then the current Console Mode is returned
in register HL.
Otherwise, Function 109 sets the Console Mode to the value contained in
register pair DE.
.PP
The Console Mode is a 16-bit system parameter that determines the action
of certain BDOS Console I/O functions.
The definition of the Console Mode is:
.IP \[bu] 2
= 1 - CTRL-C only status for Function 1 1.
.PD 0
.P
.PD
= 0 - Normal status for Function 1 1.
.IP \[bu] 2
= 1- Disable stop scroll, CTRL-S, start scroll, CTRL-Q, support.
.PD 0
.P
.PD
= 0-Enable stop scroll, start scroll support.
.IP \[bu] 2
= 1- Raw console output mode.
Disables tab expansion for Functions 2, 9 and 111.
Also disables printer echo, CTIRL-P, support.
.PD 0
.P
.PD
= 0 - Normal console output mode.
.IP \[bu] 2
= 1 - Disable CTRL-C program termination
.PD 0
.P
.PD
= 0 - Enable CTRL-C program termination
.IP \[bu] 2
-Console status mode for RSXs that perform console input redirection
from a file.
These bits determine how the RSX responds to console status requests.
.RS 2
.IP \[bu] 2
bit 8 = 0, bit 9 = 0 - conditional status
.IP \[bu] 2
bit 8 = 0, bit 9 = 1 - false status
.IP \[bu] 2
bit 8 = 1, bit 9 = 0 - true status
.IP \[bu] 2
bit 8 = 1, bit 9 = 1 - bypass redirection
.RE
.PP
Note that the Console Mode bits are numbered from right to left.
.PP
The CCP initializes the Console Mode to zero when it loads a program
unless the program has an RSX that overrides the default value.
Refer to Section 2.2.1 for detailed information on Console Mode.
.PP
BDOS function 110: \f[B]GET/SET OUTPUT DELIMITER\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $6E
.IP \[bu] 2
DE: $FFFF (Get) or
.IP \[bu] 2
E: Output Delimiter (Set)
.PP
Returned Value:
.IP \[bu] 2
A: Output Delimiter or (no value)
.PP
A program can set or interrogate the current Output Delimiter by calling
Function 110.
If register pair DE = $FFFF, then the current Output Delimiter is
returned in register A.
Otherwise, Function 110 sets the Output Delimiter to the value contained
in register E.
.PP
Function 110 sets the string delimiter for Function 9, Print String.
The default delimiter value is a dollar sign, $.
The CCP restores the Output Delimiter to the default value when a
transient program is loaded.
.PP
BDOS function 111: \f[B]PRINT BLOCK\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $6F
.IP \[bu] 2
DE: CCB Address
.PP
Returned Value:
.IP \[bu] 2
none
.PP
The Print Block function sends the character string located by the
Character Control Block, CCB, addressed in register pair DE, to the
logical console, CONOUT:.
If the Console Mode is in the default state (see Section 2.2.1),
Function 111 expands tab characters, CTRL-I, in columns of eight
characters.
It also checks for stop scroll, CTRL-S, start scroll, CTRL-Q, and echoes
to the logical list device, LST:, if printer echo, CTRL-P, has been
invoked.
.PP
The CCB format is:
.IP \[bu] 2
0 - 1 Address of character string (word value)
.IP \[bu] 2
2 - 3 Length of character string (word value)
.PP
BDOS function 112: \f[B]LIST BLOCK\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $70
.IP \[bu] 2
DE: CCB Address
.PP
Returned Value:
.IP \[bu] 2
none
.PP
The List Block function sends the character string located by the
Character Control Block, CCB, addressed in register pair DE, to the
logical list device, LST:.
.PP
The CCB format is:
.IP \[bu] 2
0 - 1 Address of character string (word value)
.IP \[bu] 2
2 - 3 Length of character string (word value)
.PP
BDOS function 152: \f[B]PARSE FILENAME\f[R]
.PP
Entry Parameters:
.IP \[bu] 2
C: $98
.IP \[bu] 2
DE: PFCB Address
.PP
Returned Value:
.IP \[bu] 2
HL: Return code
.IP \[bu] 2
Parsed file control block
.PP
The Parse Filename function parses an ASCII file specification and
prepares a File Control Block, FCB.
The calling program passes the address of a data structure called the
Parse Filename Control Block, PFCB, in register pair DE.
The PFCB contains the address of the input ASCII filename string
followed by the address of the target FCB as shown below:
.IP
.nf
\f[C]
 PFCB: DW INPUT ; Address of input ASCII string
       DW FCB ; Address of target FCB
\f[R]
.fi
.PP
The maximum length of the input ASCII string to be parsed is 128 bytes.
The target FCB must be 36 bytes in length.
.PP
Function 152 assumes the input string contains file specifications in
the following form:
.PP
{d:}filename{.typ}{;password}
.PP
where items enclosed in curly brackets are optional.
Function 152 also accepts isolated drive specifications d: in the input
string.
When it encounters one, it sets the filename, filetype, and password
fields in the FCB to blank.
.PP
The Parse Filename function parses the first file specification it finds
in the input string.
The function first eliminates leading blanks and tabs.
The function then assumes that the file specification ends on the first
delimiter it encounters that is out of context with the specific field
it is parsing.
For instance, if it finds a colon, and it is not the second character of
the file specification, the colon delimits the entire file
specification.
.PP
Function 152 recognizes the following characters as detimiters:
.IP \[bu] 2
space
.IP \[bu] 2
tab
.IP \[bu] 2
return
.IP \[bu] 2
nut]
.IP \[bu] 2
; (semicolon) - except before password field
.IP \[bu] 2
= (equal)
.IP \[bu] 2
< (less than)
.IP \[bu] 2
> (greater than)
.IP \[bu] 2
\&.
(period) - except after filename and before filetype
.IP \[bu] 2
: (colon) - except before filename and after drive
.IP \[bu] 2
, (comma)
.IP \[bu] 2
| (vertical bar)
.IP \[bu] 2
] (right square bracket)
.PP
If Function 152 encounters a non-graphic character in the range 1
through 31 not listed above, it treats the character as an error.
The Parse Filename function initializes the specified FCB shown in
[table:93].
.PP
If an error occurs, Function 152 returns an $FFFF in register pair HL.
.PP
On a successful parse, the Parse Filename function checks the next item
in the input string.
It skips over trailing blanks and tabs and looks at the next character.
If the character is a null or carriage return, it returns a 0 indicating
the end of the input string.
If the character is a delimiter, it returns the address of the
delimiter.
If the character is not a delimiter, it returns the address of the first
trailing blank or tab.
.PP
If the first non-blank or non-tab character in the input string is a
null, 0, or carriage return, the Parse Filename function returns a zero
indicating the end of string.
.PP
If the Parse Filename function is to be used to parse a subsequent file
specification in the input string, the returned address must be advanced
over the delimiter before placing it in the PFCB.
.SS BIOS
.SS System Initialization Functions
.PP
This section defines the BIOS system initialization routines BOOT,
WBOOT, DEVTBL, DEVINI, and DRVTBL.
.PP
BIOS Function 0: BOOT
.PP
Get Control from Cold Start Loader and Initialize System
.PD 0
.P
.PD
Entry Parameters: None
.PD 0
.P
.PD
Returned Values: None
.PP
The BOOT entry point gets control from the Cold Start Loader in Bank 0
and is responsible for basic system initialization.
Any remaining hardware initialization that is not done by the boot ROMS,
the Cold Boot Loader, or the LDRBIOS should be performed by the BOOT
routine.
.PP
BIOS Function 1: WBOOT
.PP
Get Control When a Warm Start Occurs
.PD 0
.P
.PD
Entry Parameters: None
.PD 0
.P
.PD
Returned Values: None
.PP
The WBOOT entry point is entered when a warm start occurs.
A warm start is performed whenever a user program branches to location
0000H or attempts to return to the CCP.
.PP
BIOS Function 20: DEVTBL
.PP
Return Address of Character I/O Table
.PD 0
.P
.PD
Entry Parameters: None
.PD 0
.P
.PD
Returned Values: HL=address of Chrtbl
.PP
The DEVTBL and DEVINI entry points allow you to support device
assignment with a flexible, yet completely optional system.
It replaces the IOBYTE facility of CP/M 2.2.
.PP
BIOS Function 21: DEVINI
.PP
Initialize Character I/O Device
.PD 0
.P
.PD
Entry Parameters: C=device number, 0-15
.PD 0
.P
.PD
Returned Values: None
.PP
The DEVINI routine initializes the physical character device specified
in register C to the baud rate contained in the appropriate entry of the
CHRTBL.
.PP
BIOS Function 22: DRVTBL
.PP
Return Address of Disk Drive Table
.PD 0
.P
.PD
Entry Parameters: None
.PD 0
.P
.PD
Returned Values:
.IP \[bu] 2
HL=Address of Drive Table of Disk Parameter Headers (DPH); Hashing can
utilized if specified by the DPHs Referenced by this DRVTBL.
.IP \[bu] 2
HL=$ffff if no Drive Table; GENCPM does not set up buffers.
Hashing is supported.
.IP \[bu] 2
HL=$fffe if no Drive Table; GENCPM does not set up buffers.
Hashing is not supported.
.PP
The first instruction of this subroutine must be an LXI H,<address>
where <address> is one of the above returned values.
The GENCPM utility accesses the address in this instruction to locate
the drive table and the disk parameter data structures to determine
which system configuration to use.
.SS Character I/O Functions
.PP
This section defines the CP/M 3 character I/O routines CONST, CONIN,
CONOUT, LIST, AUXOUT, AUXIN, LISTST, CONOST, AUXIST, and AUXOST.
CP/M 3 assumes all simple character I/O operations are performed in
eight-bit ASCII, upper and lowercase, with no parity.
An ASCII CTRL-Z ($1a) denotes an end-of-file condition for an input
device.
.PP
In CP/M 3, you can direct each of the five logical character devices to
any combination of up to twelve physical devices.
Each of the five logical devices has a 16-bit vector in the System
Control Block (SCB) .
Each bit of the vector represents a physical device where bit 15
corresponds to device zero, and bit 4 is device eleven.
Bits 0 through 3 are reserved for future system use.
.PP
BIOS Function 2: CONST
.PP
Sample the Status of the Console Input Device
.PD 0
.P
.PD
Entry Parameters: None
.PD 0
.P
.PD
Returned value:
.IP \[bu] 2
A=$ff if a console character is ready to read
.IP \[bu] 2
A=$00 if no console character is ready to read
.PP
Read the status of the currently assigned console device and return $ff
in register A if a character is ready to read, and $ff in register A if
no console characters are ready.
.PP
BIOS Function 3: CONIN
.PP
Read a Character from the Console
.PD 0
.P
.PD
Entry Parameters: None
.PD 0
.P
.PD
Returned Values: A=Console Character
.PP
Read the next console character into register A with no parity.
If no console character is ready, wait until a character is available
before returning.
.PP
BIOS Function 4: CONOUT
.PP
Output Character to Console
.PD 0
.P
.PD
Entry Parameters: C=Console Character
.PD 0
.P
.PD
Returned Values: None
.PP
Send the character in register C to the console output device.
The character is in ASCII with no parity.
.PP
BIOS Function 5: LIST
.PP
Output Character to List Device
.PD 0
.P
.PD
Entry Parameters: C=Character
.PD 0
.P
.PD
Returned Values: None
.PP
Send the character from register C to the listing device.
The character is in ASCII with no parity.
.PP
BIOS Function 6: AUXOUT
.PP
Output a Character to the Auxiliary Output Device
.PD 0
.P
.PD
Entry Parameters: C=Character
.PD 0
.P
.PD
Returned Values: None
.PP
Send the character from register C to the currently assigned AUXOUT
device.
The character is in ASCII with no parity.
.PP
BIOS Function 7: AUXIN
.PP
Read a Character from the Auxiliary Input Device
.PD 0
.P
.PD
Entry Parameters: None
.PD 0
.P
.PD
Returned Values: A=Character
.PP
Read the next character from the currently assigned AUXIN device into
register A with no parity.
A returned ASCII CTRL-Z ($1a) reports an end-of-file.
.PP
BIOS Function 15: LISTST
.PP
Return the Ready Status of the List Device
.PD 0
.P
.PD
Entry Parameters: None
.PD 0
.P
.PD
Returned Values:
.IP \[bu] 2
A=$00 if list device is not ready to accept a character
.IP \[bu] 2
A=$ff if list device is ready to accept a character
.PP
BIOS Function 17: CONOST
.PP
Return Output Status of Console
.PD 0
.P
.PD
Entry Parameters: None
.PD 0
.P
.PD
Returned Values:
.IP \[bu] 2
A=$ff if ready
.IP \[bu] 2
A=$00 if not ready
.PP
The CONOST routine checks the status of the console.
CONOST returns an $ff if the console is ready to display another
character.
This entry point allows for full polled handshaking communications
support.
.PP
BIOS Function 18: AUXIST
.PP
Return Input Status of Auxiliary Port
.PD 0
.P
.PD
Entry Parameters: None
.PD 0
.P
.PD
Returned Values:
.IP \[bu] 2
A=$ff if ready
.IP \[bu] 2
A=$00 if not ready
.PP
The AUXIST routine checks the input status of the auxiliary port.
This entry point allows full polled handshaking for communications
support using an auxiliary port.
.PP
BIOS Function 19: AUXOST
.PP
Return Output Status of Auxiliary Port
.PD 0
.P
.PD
Entry Parameters: None
.PD 0
.P
.PD
Returned Values:
.IP \[bu] 2
A=$ff if ready
.IP \[bu] 2
A=$00 if not ready
.PP
The AUXOST routine checks the output status of the auxiliary port.
This routine allows full polled handshaking for communications support
using an auxiliary port.
.SS Disk I/O Functions
.PP
This section defines the CP/M 3 BIOS disk I/O routines HOME, SELDSK,
SETTRK, SETSEC, SETDMA, READ, WRITE, SECTRN, MULTIO, and FLUSH.
.PP
BIOS Function 8: HOME
.PP
Select Track 00 of the Specified Drive
.PD 0
.P
.PD
Entry Parameters: None
.PD 0
.P
.PD
Returned Values: None
.PP
Return the disk head of the currently selected disk to the track 00
position.
Usually, you can translate the HOME call into a call on SETTRK with a
parameter of 0.
.PP
BIOS Function 9: SELDSK
.PP
Select the Specified Disk Drive
.PD 0
.P
.PD
Entry Parameters:
.IP \[bu] 2
C=Disk Drive (0-15)
.IP \[bu] 2
E=Initial Select Flag
.PP
Returned Values:
.IP \[bu] 2
HL=Address of Disk Parameter Header (DPH) if drive exists
.IP \[bu] 2
HL=0000H if drive does not exist
.PP
Select the disk drive specified in register C for further operations,
where register C contains 0 for drive A, 1 for drive B, and so on to 15
for drive P.
On each disk select, SELDSK must return in HL the base address of a
25-byte area called the Disk Parameter Header.
If there is an attempt to select a nonexistent drive, SELDSK returns
HL=$0000 as an error indicator.
On entry to SELDSK, you can determine if it is the first time the
specified disk is selected.
Bit 0, the least significant bit in register E, is set to 0 if the drive
has not been previously selected.
This information is of interest in systems that read configuration
information from the disk to set up a dynamic disk definition table.
.PP
BIOS Function 10: SETTRK
.PP
Set Specified Track Number
.PD 0
.P
.PD
Entry Parameters: BC=Track Number
.PD 0
.P
.PD
Returned Values: None
.PP
Register BC contains the track number for a subsequent disk access on
the currently selected drive.
Normally, the track number is saved until the next READ or WRITE occurs.
.PP
BIOS Function 11: SETSEC
.PP
Set Specified Sector Number
.PD 0
.P
.PD
Entry Parameters: BC=Sector Number
.PD 0
.P
.PD
Returned Values: None
.PP
Register BC contains the sector number for the subsequent disk access on
the currently selected drive.
This number is the value returned by SECTRN.
Usually, you delay actual sector selection until a READ or WRITE
operation occurs.
.PP
BIOS Function 12: SETDMA
.PP
Set Address for Subsequent Disk I/O
.PD 0
.P
.PD
Entry Parameters: BC=Direct Memory Access Address
.PD 0
.P
.PD
Returned Values: None
.PP
Register BC contains the DMA (Direct Memory Access) address for the
subsequent READ or WRITE operation.
For example, if B = $00 and C = $80 when the BDOS calls SETDMA, then the
subsequent read operation reads its data starting at $80, or the
subsequent write operation gets its data from 80H, until the next call
to SETDMA occurs.
.PP
BIOS Function 13: READ
.PP
Read a Sector from the Specified Drive
.PD 0
.P
.PD
Entry Parameters: None
.PD 0
.P
.PD
Returned Values:
.IP \[bu] 2
A=$00 if no errors occurred
.IP \[bu] 2
A=$01 if nonrecoverable error condition occurred
.IP \[bu] 2
A=$ff if media has changed
.PP
Assume the BDOS has selected the drive, set the track, set the sector,
and specified the DMA address.
The READ subroutine attempts to read one sector based upon these
parameters, then returns one of the error codes in register A as
described above.
.PP
If the value in register A is $00, then CP/M 3 assumes that the disk
operation completed properly.
If an error occurs, the BIOS should attempt several retries to see if
the error is recoverable before returning the error code.
.PP
If an error occurs in a system that supports automatic density
selection, the system should verify the density of the drive.
If the density has changed, return a $ff in the accumulator.
This causes the BDOS to terminate the current operation and relog in the
disk.
.PP
BIOS Function 14: WRITE
.PP
Write a Sector to the Specified Disk
.PD 0
.P
.PD
Entry Parameters: C=Deblocking Codes
.PD 0
.P
.PD
Returned Values:
.IP \[bu] 2
A=$00 if no error occurred
.IP \[bu] 2
A=$01 if physical error occurred
.IP \[bu] 2
A=$02 if disk is Read-Only
.IP \[bu] 2
A=$ff if media has changed
.PP
Write the data from the currently selected DMA address to the currently
selected drive, track, and sector.
Upon each call to WRITE, the BDOS provides the following information in
register C:
.IP \[bu] 2
0 = deferred write
.IP \[bu] 2
1 = nondeferred write
.IP \[bu] 2
2 = deferred write to the first sector of a new data block
.PP
This information is provided for those BIOS implementations that do
blocking/deblocking in the BIOS instead of the BDOS.
.PP
BIOS Function 16: SECTRN
.PP
Translate Sector Number Given Translate Table Entry Parameters:
.IP \[bu] 2
BC=Logical Sector Number
.IP \[bu] 2
DE=Translate Table Address
.PP
Returned Values: HL=Physical Sector Number
.PP
SECTRN performs logical sequential sector address to physical sector
translation to improve the overall response of CP/M 3.
.PP
BIOS Function 23: MULTIO
.PP
Set Count of Consecutive Sectors for READ or WRITE
.PD 0
.P
.PD
Entry Parameters: C=Multisector Count
.PD 0
.P
.PD
Returned Values: None
.PP
To transfer logically consecutive disk sectors to or from contiguous
memory locations, the BDOS issues a MULTIO call, followed by a series of
READ or WRITE calls.
This allows the BIOS to transfer multiple sectors in a single disk
operation.
The maximum value of the sector count is dependent on the physical
sector size, ranging from 128 with 128-byte sectors, to 4 with 4096-byte
sectors.
Thus, the BIOS can transfer up to 16K directly to or from the TPA with a
single operation.
.PP
BIOS Function 24: FLUSH
.PP
Force Physical Buffer Flushing for User-supported Deblocking
.PD 0
.P
.PD
Entry Parameters: None
.PD 0
.P
.PD
Returned Values:
.IP \[bu] 2
A=$00 if no error occurred
.IP \[bu] 2
A=$001 if physical error occurred
.IP \[bu] 2
A=$002 if disk is Read-Only
.PP
The flush buffers entry point allows the system to force physical sector
buffer flushing when your BIOS is performing its own record blocking and
deblocking.
The BDOS calls the FLUSH routine to ensure that no dirty buffers remain
in memory.
.SS Memory Select and Move Functions
.PP
This section defines the memory management functions MOVE, XMOVE,
SELMEM, and SETBNK.
.PP
BIOS Function 25: MOVE
.PP
Memory-to-Memory Block Move
.PD 0
.P
.PD
Entry Parameters:
.IP \[bu] 2
HL=Destination address
.IP \[bu] 2
DE=Source address
.IP \[bu] 2
BC=Count
.PP
Returned Values: HL and DE must point to next bytes following move
operation
.PP
The BDOS calls the MOVE routine to perform memory to memory block moves
to allow use of the Z80 LDIR instruction or special DMA hardware, if
available.
Note that the arguments in HL and DE are reversed from the Z8O machine
instruction, necessitating the use of XCHG instructions on either side
of the LDIR.
The BDOS uses this routine for all large memory copy operations.
On return, the HL and DE registers are expected to point to the next
bytes following the move.
.PP
Usually, the BDOS expects MOVE to transfer data within the currently
selected bank or common memory.
However, if the BDOS calls the XMOVE entry point before calling MOVE,
the MOVE routine must perform an interbank transfer.
.PP
BIOS Function 27: SELMEM
.PP
Select Memory Bank
.PD 0
.P
.PD
Entry Parameters: A=Memory Bank
.PD 0
.P
.PD
Returned Values; None
.PP
The SELMEM entry point is only present in banked systems.
The banked version of the CP/M 3 BDOS calls SELMEM to select the current
memory bank for further instruction execution or buffer references.
You must preserve or restore all registers other than the accumulator,
A, upon exit.
.PP
BIOS Function 28: SETBNK
.PP
Specify Bank for DMA Operation
.PD 0
.P
.PD
Entry Parameters: A=Memory Bank
.PD 0
.P
.PD
Returned Values: None
.PP
SETBNK only occurs in the banked version of CP/M 3.
SETBNK specifies the bank that the subsequent disk READ or WRITE routine
must use for memory transfers.
The BDOS always makes a call to SETBNK to identify the DMA bank before
performing a READ or WRITE call.
Note that the BDOS does not reference banks other than 0 or 1 unless
another bank is specified by the BANK field of a Data Buffer Control
Block (BCB).
.PP
BIOS Function 29: XMOVE
.PP
Set Banks for Following MOVE
.PD 0
.P
.PD
Entry Parameters:
.IP \[bu] 2
B=destination bank
.IP \[bu] 2
C=source bank
.PP
Returned Values: None
.PP
XMOVE is provided for banked systems that support memory-to- memory DMA
transfers over the entire extended address range.
Systems with this feature can have their data buffers located in an
alternate bank instead of in common memory, as is usually required.
An XMOVE call affects only the following MOVE call.
All subsequent MOVE calls apply to the memory selected by the latest
call to SELMEM.
After a call to the XMOVE function, the following call to the MOVE
function is not more than 128 bytes of data.
.SS Clock Support Function
.PP
This section defines the clock support function TIME.
.PP
BIOS Function 26: TIME
.PP
Get and Set Time
.PD 0
.P
.PD
Entry Parameters: C=Time Get/Set Flag
.PD 0
.P
.PD
Returned values: None
.PP
The BDOS calls the TIME function to indicate to the BIOS whether it has
just set the Time and Date fields in the SCB, or whether the BDOS is
about to get the Time and Date from the SCB.
On entry to the TIME function, a zero in register C indicates that the
BIOS should update the Time and Date fields in the SCB.
A $ff in register C indicates that the BDOS has just set the Time and
Date in the SCB and the BIOS should update its clock.
Upon exit, you must restore register pairs HL and DE to their entry
values.
.SS NextZXOS
.SS NextZXOS
.PP
A ZX Spectrum I/O system supported by the ZX Spectrum Next.
This Documentation is largely from Garry Lancaster\[cq]s DOCs at
https://gitlab.com/thesmog358/tbblue/blob/master/docs/nextzxos/NextZXOS_and_esxDOS_APIs.pdf.
Before making any calls disable writes to Layer 2 in the $0000-$3fff
area with port $123b.
.SS +3DOS compatible API
.PP
Generally to make these calls, you need to set up: place ROM 2 at
$0000-$3fff, RAM bank 7 at $c000-$ffff, stack below $bfe0, and set up
the parameters for the call in the indicated registers.
Call the function at its address.
Then, restore your system to its previous configuration.
In general the carry bit of F is cleared on error with the error code in
A.
Calls generally affect the contnts of AF, BC, DE, HL, and IX leaving
AF\[cq], BC\[cq], DE\[cq], HL\[cq], IY, and SP intact.
To simplify, descriptions will assume this is true and only indicate
exceptions to the rule.
.PP
$0056 \f[B]IDE_STREAM_OPEN\f[R]
.PP
Open stream to a channel
.PP
$0059 \f[B]IDE_STREAM_CLOSE\f[R]
.PP
Close stream and attached channel
.PP
$005c \f[B]IDE_STREAM_IN\f[R]
.PP
Get byte from current stream
.PP
$005f \f[B]IDE_STREAM_OUT\f[R]
.PP
Write byte to current stream
.PP
$0062 \f[B]IDE_STREAM_PTR\f[R]
.PP
Get or set pointer information for current stream
.PP
$00A0 \f[B]IDE_VERSION\f[R]
.PP
Get IDEDOS version number
.PP
$00A3 \f[B]IDE_INTERFACE\f[R]
.PP
Initialise card interfaces
.PP
$00A6 \f[B]IDE_INIT\f[R]
.PP
Initialise IDEDOS
.PP
$00A9 \f[B]IDE_DRIVE\f[R]
.PP
Get unit handle
.PP
$00AC \f[B]IDE_SECTOR_READ\f[R]
.PP
Low-level sector read
.PP
$00AF \f[B]IDE_SECTOR_WRITE\f[R]
.PP
Low-level sector write
.PP
$00B2 \f[B]IDE_FORMAT\f[R]
.PP
Format a partition
.PP
$00B5 \f[B]IDE_PARTITION_FIND\f[R]
.PP
Find named partition
.PP
$00B8 \f[B]IDE_PARTITION_NEW\f[R]
.PP
Create partition
.PP
$00BB \f[B]IDE_PARTITION_INIT\f[R]
.PP
Initialise partition
.PP
$00BE \f[B]IDE_PARTITION_ERASE\f[R]
.PP
Delete a partition
.PP
$00C1 \f[B]IDE_PARTITION_RENAME\f[R]
.PP
Rename a partition
.PP
$00C4 \f[B]IDE_PARTITON_READ\f[R]
.PP
Read a partition entry
.PP
$00C7 \f[B]IDE_PARTITION_WRITE\f[R]
.PP
Write a partition entry
.PP
$00CA \f[B]IDE_PARTITION_WINFO\f[R]
.PP
Write type-specific partition information
.PP
$00CD \f[B]IDE_PARTITION_OPEN\f[R]
.PP
Open a partition
.PP
$00D0 \f[B]IDE_PARTITION_CLOSE\f[R]
.PP
Close a partition
.PP
$00D3 \f[B]IDE_PARTITION_GETINFO\f[R]
.PP
Get byte from type-specific partition information
.PP
$00D6 \f[B]IDE_PARTITION_SETINFO\f[R]
.PP
Set byte in type-specific partition information
.PP
$00D9 (217) \f[B]IDE_SWAP_OPEN\f[R]
.PP
Open a swap partition (file)
.PP
$00DC \f[B]IDE_SWAP_CLOSE\f[R]
.PP
Close a swap partition
.PP
$00DF \f[B]IDE_SWAP_OUT\f[R]
.PP
Write block to swap partition
.PP
$00E2 \f[B]IDE_SWAP_IN\f[R]
.PP
Read block from swap partition
.PP
$00E5 (231) \f[B]IDE_SWAP_EX\f[R]
.PP
Exchange block with swap partition
.PP
Deprecated, use IDE_SWAP_IN and IDE_SWAP_OUT
.PP
$00E8 \f[B]IDE_SWAP_POS\f[R]
.PP
Get current block number in swap partition
.PP
$00EB \f[B]IDE_SWAP_MOVE\f[R]
.PP
Set current block number in swap partition
.PP
$00EE \f[B]IDE_SWAP_RESIZE\f[R]
.PP
Change block size of swap partition
.PP
$00F1 (241) \f[B]IDE_DOS_MAP\f[R]
.PP
Map drive to partition or physical device
.PP
$00F4 (244) \f[B]IDE_DOS_UNMAP\f[R]
.PP
Unmap drive
.PP
$00F7 (247) \f[B]IDE_DOS_MAPPING\f[R]
.PP
Get drive mapping
.PP
$00FA \f[B]IDE_DOS_UNPERMANENT\f[R]
.PP
Remove permanent drive mapping
.PP
$00FD (253) \f[B]IDE_SNAPLOAD\f[R]
.PP
Load a snapshot
.PP
$0100 \f[B]DOS_INITIALISE\f[R]
.PP
Initialise +3DOS
.PP
$0103 \f[B]DOS_VERSION\f[R]
.PP
Get +3DOS issue and version numbers
.PP
$0106 (262) \f[B]DOS_OPEN\f[R]
.PP
Create and/or open a file
.PP
$0109 \f[B]DOS_CLOSE\f[R]
.PP
Close a file
.PP
$010C \f[B]DOS_ABANDON\f[R]
.PP
Abandon a file
.PP
$010F \f[B]DOS_REF_HEAD\f[R]
.PP
Point at the header data for this file
.PP
$0112 \f[B]DOS_READ\f[R]
.PP
Read bytes into memory
.PP
$0115 \f[B]DOS_WRITE\f[R]
.PP
Write bytes from memory
.PP
$0118 \f[B]DOS_BYTE_READ\f[R]
.PP
Read a byte
.PP
$011B \f[B]DOS_BYTE_WRITE\f[R]
.PP
Write a byte
.PP
$011E (286) \f[B]DOS_CATALOG\f[R]
.PP
Catalog disk directory
.PP
$0121 (289) \f[B]DOS_FREE_SPACE\f[R]
.PP
Free space on disk
.PP
$0124 \f[B]DOS_DELETE\f[R]
.PP
Delete a file
.PP
$0127 \f[B]DOS_RENAME\f[R]
.PP
Rename a file
.PP
$012A \f[B]DOS_BOOT\f[R]
.PP
Boot an operating system or other program
.PP
$012D \f[B]DOS_SET_DRIVE\f[R]
.PP
Set/get default drive
.PP
$0130 \f[B]DOS_SET_USER\f[R]
.PP
Set/get default user number
.PP
$0133 (307) \f[B]DOS_GET_POSITION\f[R]
.PP
Get file pointer for random access
.PP
$0136 \f[B]DOS_SET_POSITION\f[R]
.PP
Set file pointer for random access
.PP
$0139 (313) \f[B]DOS_GET_EOF\f[R]
.PP
Get end of file position for random access
.PP
$013C \f[B]DOS_GET_1346\f[R]
.PP
Get memory usage in pages 1\[u2006] 3\[u2006] 4\[u2006] 6
.PP
$013F \f[B]DOS_SET_1346\f[R]
.PP
Re-allocate memory usage in pages 1\[u2006] 3\[u2006] 4\[u2006] 6
.PP
$0142 \f[B]DOS_FLUSH\f[R]
.PP
Bring disk up to date
.PP
$0145 \f[B]DOS_SET_ACCESS\f[R]
.PP
Change open file\[cq]s access mode
.PP
$0148 \f[B]DOS_SET_ATTRIBUTES\f[R]
.PP
Change a file\[cq]s attributes
.PP
$014B \f[B]DOS_OPEN_DRIVE\f[R]
.PP
Open a drive as a single file
.PP
$014E \f[B]DOS_SET_MESSAGE\f[R]
.PP
Enable/disable error messages
.PP
$0151 \f[B]DOS_REF_XDPB\f[R]
.PP
Point at XDPB for low level disk access
.PP
$0154 \f[B]DOS_MAP_B\f[R]
.PP
Map B: onto unit 0 or 1
.PP
$0157 \f[B]DD_INTERFACE\f[R]
.PP
Is the floppy disk driver interface present?
.PP
$015A \f[B]DD_INIT\f[R]
.PP
Initialise disk driver
.PP
$015D \f[B]DD_SETUP\f[R]
.PP
Specify drive parameters
.PP
$0160 \f[B]DD_SET_RETRY\f[R]
.PP
Set try/retry count
.PP
$0163 \f[B]DD_READ_SECTOR\f[R]
.PP
Read a sector
.PP
$0166 \f[B]DD_WRITE_SECTOR\f[R]
.PP
Write a sector
.PP
$0169 \f[B]DD_CHECK_SECTOR\f[R]
.PP
Check a sector
.PP
$016C \f[B]DD_FORMAT\f[R]
.PP
Format a track
.PP
$016F \f[B]DD_READ_ID\f[R]
.PP
Read a sector identifier
.PP
$0172 \f[B]DD_TEST_UNSUITABLE\f[R]
.PP
Test media suitability
.PP
$0175 \f[B]DD_LOGIN\f[R]
.PP
Log in disk, initialise XDPB
.PP
$0178 \f[B]DD_SEL_FORMAT\f[R]
.PP
Pre-initialise XDPB for DD FORMAT
.PP
$017B \f[B]DD_ASK_1\f[R]
.PP
Is unit 1 (external drive) present?
.PP
$017E \f[B]DD_DRIVE_STATUS\f[R]
.PP
Fetch drive status
.PP
$0181 \f[B]DD_EQUIPMENT\f[R]
.PP
What type of drive?
.PP
$0184 \f[B]DD_ENCODE\f[R]
.PP
Set intercept routine for copy protection
.PP
$0187 \f[B]DD_L_XDPB\f[R]
.PP
Initialise an XDPB from a disk specification
.PP
$018A \f[B]DD_L_DPB\f[R]
.PP
Initialise a DPB from a disk specification
.PP
$018D \f[B]DD_L_SEEK\f[R]
.PP
uPD765A seek driver
.PP
$0190 \f[B]DD_L_READ\f[R]
.PP
uPD765A read driver
.PP
$0193 \f[B]DD_L_WRITE\f[R]
.PP
uPD765A write driver
.PP
$0196 \f[B]DD_L_ON_MOTOR\f[R]
.PP
Motor on, wait for motor-on time
.PP
$0199 \f[B]DD_L_T_OFF_MOTOR\f[R]
.PP
Start the motor-off ticker
.PP
$019C \f[B]DD_L_OFF_MOTOR\f[R]
.PP
Turn the motor off
.PP
$01a2 \f[B]IDE_IDENTIFY\f[R]
.PP
Return IDE drive identity information
.PP
$01a5 \f[B]IDE_PARTITIONS\f[R]
.PP
Get number of open partitions
.PP
$01b1 (433) \f[B]IDE_PATH\f[R]
.PP
Create, delete, change or get directory
.PP
$01b4 (436) \f[B]IDE_CAPACITY\f[R]
.PP
Get card capacity
.PP
$01b7 (439) \f[B]IDE_GET_LFN\f[R]
.PP
Get long filename
.PP
Obtain a long file name and other file information.
.PP
$01ba (442) \f[B]IDE_BROWSER\f[R]
.PP
File browser
.PP
$01bd (445) \f[B]IDE_BANK\f[R]
.PP
Allocate or free 8K pages in ZX or DivMMC memory
.PP
$01c0 \f[B]IDE_BASIC\f[R]
.PP
Execute a BASIC command line
.PP
$01c3 \f[B]IDE_WINDOW_LINEIN\f[R]
.PP
Input line from current window stream
.PP
$01c6 \f[B]IDE_WINDOW_STRING\f[R]
.PP
Output string to current window stream
.PP
$01c9 \f[B]IDE_INTEGER_VAR\f[R]
.PP
Get or set NextBASIC integer variable
.PP
$01cc \f[B]IDE_RTC\f[R]
.PP
Query the real-time-clock module
.PP
$01cf \f[B]IDE_DRIVER\f[R]
.PP
Access the driver API
.PP
$01d2 \f[B]IDE_MOUNT\f[R]
.PP
Unmount/remount SD cards
.PP
$01d2 \f[B]IDE_MOUNT\f[R]
.PP
Unmount/remount SD cards
.PP
$01d5 \f[B]IDE_MODE\f[R]
.PP
Query NextBASIC display mode info, or change mode
.PP
$01d8 \f[B]IDE_TOKENISER\f[R]
.PP
Convert BASIC between plain text & tokenised forms
.SS esxDOS compatible API
.SS Next Extensions
.PP
$0085 \f[B]DISK_FILEMAP\f[R]
.IP
.nf
\f[C]
unsigned char esx_disk_filemap(uint8_t handle,struct esx_filemap *fmap)
\f[R]
.fi
.PP
Obtain a map of card addresses describing the space occupies by the
file.
Can be called multiple times if the buffer is filled, continuing from
previous.
.PP
\f[B]DISK_STREAM_BYTES\f[R]
.IP
.nf
\f[C]
void *esx_disk_stream_bytes(void *dst,uint16_t len)
\f[R]
.fi
.PP
$0087 \f[B]DISK_STREAM_END\f[R]
.IP
.nf
\f[C]
unsigned char esx_disk_stream_end(void)
\f[R]
.fi
.PP
Stop current streaming operation.
.PP
\f[B]DISK_STREAM_SECTORS\f[R]
.IP
.nf
\f[C]
void *esx_disk_stream_sectors(void *dst,uint8_t sectors)
\f[R]
.fi
.PP
$0086 \f[B]DISK_STREAM_START\f[R]
.IP
.nf
\f[C]
unsigned char esx_disk_stream_start(struct esx_filemap_entry *entry)
\f[R]
.fi
.PP
Start reading from the card in streaming mode.
.PP
\f[B]DOS_CATALOG\f[R]
.IP
.nf
\f[C]
unsigned char esx_dos_catalog(struct esx_cat *cat)
\f[R]
.fi
.PP
\f[B]DOS_CATALOG_NEXT\f[R]
.IP
.nf
\f[C]
unsigned char esx_dos_catalog_next(struct esx_cat *cat)
\f[R]
.fi
.PP
\f[B]DOS_GETSET_DRIVE\f[R]
.IP
.nf
\f[C]
unsigned char esx_dos_get_drive(void)
unsigned char esx_dos_set_drive(unsigned char drive)
\f[R]
.fi
.SS esxDOS compatible API
.PP
The esxDOS-compatible API is a bit simpler to use than the
+3DOS-compatible API.
.PP
To make a call, you only need to set up the entry parameters as
indicated and perform a RST $08; DEFB hook_code.
On return, registers AF,BC,DE,HL will all be changed.
IX,IY and the alternate registers are never changed (except for
M_P3DOS).
.PP
(Note that the standard 48K BASIC ROM must be paged in to the bottom of
memory, but this is the usual situation after starting a machine code
program with a USR function call).
.PP
Notice that error codes are different from those returned by +3DOS
calls, and also the carry flag is SET for an error condition when
returning from an esxDOS call (instead of RESET, as is the case for
+3DOS).
.PP
If desired, you can use the M_GETERR hook to generate a BASIC error
report for any error returned, or even use it to generate your own
custom BASIC error report.
.PP
All of the calls where a filename is specified will accept long
filenames (LFNs) and most will accept wildcards (for an operation such
as F_OPEN where a single file is always used, the first matching
filename will be used).
.PP
$00A9 \f[B]F_CHDIR\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_chdir(unsigned char *pathname)
\f[R]
.fi
.PP
Change directory.
.PP
$00AF \f[B]F_CHMOD\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_chmod(unsigned char *filename, uint8_t attr_mask, uint8_t attr)
\f[R]
.fi
.PP
Modify file attributes.
.PP
$009B\f[B]F_CLOSE\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_close(unsigned char handle)
\f[R]
.fi
.PP
Close a file or directory.
.PP
\f[B]F_CLOSEDIR\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_closedir(unsigned char handle)
\f[R]
.fi
.PP
$00A0 \f[B]F_FGETPOS\f[R]
.IP
.nf
\f[C]
uint32_t esx_f_fgetpos(unsigned char handle)
\f[R]
.fi
.PP
Get current file position.
.PP
$00A1 \f[B]F_FSTAT\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_fstat(unsigned char handle, struct esx_stat *es)
\f[R]
.fi
.PP
Get file information/status.
.PP
$00A2 \f[B]F_FTRUNC\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_ftrunc(unsigned char handle, uint32_t size)
\f[R]
.fi
.PP
Truncate/extend file.
.PP
\f[B]F_GET_CANONICAL_PATH\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_get_canonical_path(char *pathname, char *canonical)
\f[R]
.fi
.PP
$00A8 \f[B]F_GETCWD\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_getcwd(unsigned char *buf)
\f[R]
.fi
.PP
Get current working directory.
.PP
\f[B]F_GETCWD_DRIVE\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_getcwd_drive(unsigned char drive, char *buf)
\f[R]
.fi
.PP
$00B1 \f[B]F_GETFREE\f[R]
.IP
.nf
\f[C]
uint32_t esx_f_getfree(void)
\f[R]
.fi
.PP
Gets free space on drive.
.PP
$00AA \f[B]F_MKDIR\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_mkdir(unsigned char *pathname)
\f[R]
.fi
.PP
Create directory.
.PP
$009A \f[B]F_OPEN\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_open(unsigned char *filename,unsigned char mode)
\f[R]
.fi
.PP
Open a file.
.PP
$00A3 \f[B]F_OPENDIR\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_opendir(unsigned char *dirname)
unsigned char esx_f_opendir_ex(unsigned char *dirname,uint8_t mode)
\f[R]
.fi
.PP
Open directory.
.PP
$009A \f[B]F_OPEN\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_open_p3(unsigned char *filename,unsigned char mode,struct esx_p3_hdr *h)
\f[R]
.fi
.PP
Open a file.
.PP
$009D \f[B]F_READ\f[R]
.IP
.nf
\f[C]
uint16_t esx_f_read(unsigned char handle, void *dst, size_t nbytes)
\f[R]
.fi
.PP
Read bytes from file.
.PP
$00A4 \f[B]F_READDIR\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_readdir(unsigned char handle,struct esx_dirent *dirent)
\f[R]
.fi
.PP
Read next directory entry.
.PP
$00B0 \f[B]F_RENAME\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_rename(unsigned char *old, unsigned char *new)
\f[R]
.fi
.PP
Rename or move a file.
.PP
$00A7 \f[B]F_REWINDDIR\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_rewinddir(unsigned char handle)
\f[R]
.fi
.PP
Rewind directory position to the start of the directory.
.PP
$00AB \f[B]F_RMDIR\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_rmdir(unsigned char *pathname)
\f[R]
.fi
.PP
Remove directory.
.PP
$009F \f[B]F_SEEK\f[R]
.IP
.nf
\f[C]
uint32_t esx_f_seek(unsigned char handle, uint32_t distance, unsigned char whence)
\f[R]
.fi
.PP
Seek to position in file.
.PP
$00A6 \f[B]F_SEEKDIR\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_seekdir(unsigned char handle,uint32_t pos)
\f[R]
.fi
.PP
Set current directory position.
.PP
$00AC \f[B]F_STAT\f[R]
.PP
Get unopened file information/status.
.PP
$009C \f[B]F_SYNC\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_sync(unsigned char handle)
\f[R]
.fi
.PP
Sync file changes to disk.
.PP
$00A5 \f[B]F_TELLDIR\f[R]
.IP
.nf
\f[C]
uint32_t esx_f_telldir(unsigned char handle)
\f[R]
.fi
.PP
Get current directory position.
.PP
$00AE \f[B]F_TRUNC\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_trunc(unsigned char *filename,uint32_t size)
\f[R]
.fi
.PP
Truncate/extend unopened file.
.PP
$00AD \f[B]F_UNLINK\f[R]
.IP
.nf
\f[C]
unsigned char esx_f_unlink(unsigned char *filename)
\f[R]
.fi
.PP
Delete file.
.PP
$009E \f[B]F_WRITE\f[R]
.IP
.nf
\f[C]
uint16_t esx_f_write(unsigned char handle, void *src, size_t nbytes)
\f[R]
.fi
.PP
Write bytes to file.
.PP
\f[B]IDE_BANK_ALLOC\f[R]
.IP
.nf
\f[C]
unsigned char esx_ide_bank_alloc(unsigned char banktype)
\f[R]
.fi
.PP
\f[B]IDE_BANK_AVAIL\f[R]
.IP
.nf
\f[C]
unsigned char esx_ide_bank_avail(unsigned char banktype)
\f[R]
.fi
.PP
\f[B]IDE_BANK_FREE\f[R]
.IP
.nf
\f[C]
unsigned char esx_ide_bank_free(unsigned char banktype, unsigned char page)
\f[R]
.fi
.PP
\f[B]IDE_BANK_RESERVE\f[R]
.IP
.nf
\f[C]
unsigned char esx_ide_bank_reserve(unsigned char banktype,unsigned char page)
\f[R]
.fi
.PP
\f[B]IDE_BANK_TOTAL\f[R]
.IP
.nf
\f[C]
unsigned char esx_ide_bank_total(unsigned char banktype)
\f[R]
.fi
.PP
\f[B]IDE_BROWSER\f[R]
.IP
.nf
\f[C]
unsigned char esx_ide_browser(uint8_t browsercaps, void *filetypes, char *help,char *dst_sfn, char *dst_lfn)
\f[R]
.fi
.PP
\f[B]IDE_GET_LFN\f[R]
.IP
.nf
\f[C]
unsigned char esx_ide_get_lfn(struct esx_lfn *dir, struct esx_cat_entry *query)
\f[R]
.fi
.PP
\f[B]IDE_MODE_GET\f[R]
.IP
.nf
\f[C]
unsigned char esx_ide_mode_get(struct esx_mode *mode)
\f[R]
.fi
.PP
\f[B]IDE_MODE_SET\f[R]
.IP
.nf
\f[C]
unsigned char esx_ide_mode_set(struct esx_mode *mode)
\f[R]
.fi
.PP
$0088 \f[B]M_DOSVER\f[R]
.PP
Get API version/mode information.
.PP
$0092 \f[B]M_DRVAPI\f[R]
.IP
.nf
\f[C]
unsigned char esx_m_drvapi(struct esx_drvapi *)
\f[R]
.fi
.PP
Access API for installable drivers.
.PP
$0095 \f[B]M_ERRH\f[R]
.IP
.nf
\f[C]
void esx_m_errh(void (*handler)(uint8_t error))
\f[R]
.fi
.PP
Install error handler for dot command.
.PD 0
.P
.PD
$008F \f[B]M_EXECCMD\f[R]
.IP
.nf
\f[C]
uint16_t esx_m_execcmd(unsigned char *cmdline)
\f[R]
.fi
.PP
Execute a dot command.
.PP
$008E \f[B]M_GETDATE\f[R]
.IP
.nf
\f[C]
unsigned char esx_m_getdate(struct dos_tm *)
\f[R]
.fi
.PP
Get the current date/time.
.PP
$0093 \f[B]M_GETERR\f[R]
.IP
.nf
\f[C]
void esx_m_geterr(uint16_t error,unsigned char *msg)
\f[R]
.fi
.PP
$008D \f[B]M_GETHANDLE\f[R]
.IP
.nf
\f[C]
unsigned char esx_m_gethandle(void)
\f[R]
.fi
.PP
Get the file handle of the currently running dot command
.PP
$0089 \f[B]M_GETSETDRV\f[R]
.IP
.nf
\f[C]
unsigned char esx_m_getdrv(void)
unsigned char esx_m_setdrv(unsigned char drive)
\f[R]
.fi
.PP
Get or set the default drive.
.PP
$0091 \f[B]M_SETCAPS\f[R]
.IP
.nf
\f[C]
unsigned char esx_m_setcaps(unsigned char caps)
\f[R]
.fi
.PP
$008B \f[B]M_TAPEIN\f[R]
.IP
.nf
\f[C]
unsigned char esx_m_tapein_close(void)
unsigned char esx_m_tapein_flags(uint8_t flags)
uint16_t esx_m_tapein_getpos(void)
unsigned char esx_m_tapein_info(uint8_t *drive,unsigned char *filename)
unsigned char esx_m_tapein_open(unsigned char *filename)
unsigned char esx_m_tapein_setpos(uint16_t block)
unsigned char esx_m_tapein_toggle_pause(void)
\f[R]
.fi
.PP
Tape input redirection control.
.PP
$008C \f[B]M_TAPEOUT\f[R]
.IP
.nf
\f[C]
unsigned char esx_m_tapeout_close(void)
unsigned char esx_m_tapeout_info(uint8_t *drive,unsigned char *filename)
unsigned char esx_m_tapeout_open(unsigned char *appendname)
unsigned char esx_m_tapeout_trunc(unsigned char *filename)
\f[R]
.fi
.PP
Tape output redirection control.
.PP
\f[B]SLICE_DIRENT\f[R]
.IP
.nf
\f[C]
struct esx_dirent_slice *esx_slice_dirent(struct esx_dirent *)
\f[R]
.fi
.PP
\f[B]EXTENDED_SNA_LOAD\f[R]
.IP
.nf
\f[C]
unsigned char extended_sna_load(unsigned char handle)
\f[R]
.fi
.PP
\f[B]P3DOS_COPY_CSTR_TO_PSTR\f[R]
.IP
.nf
\f[C]
unsigned char *p3dos_copy_cstr_to_pstr(char *pdst, const char *csrc)
\f[R]
.fi
.PP
\f[B]P3DOS_COPY_PSTR_TO_CSTR\f[R]
.IP
.nf
\f[C]
unsigned char *p3dos_copy_pstr_to_cstr(char *cdst, const char *psrc)
\f[R]
.fi
.PP
\f[B]P3DOS_CSTR_TO_PSTR\f[R]
.IP
.nf
\f[C]
unsigned char *p3dos_cstr_to_pstr(unsigned char *s)
\f[R]
.fi
.PP
\f[B]P3DOS_DOSNAME_FROM_CATNAME\f[R]
.IP
.nf
\f[C]
char *p3dos_dosname_from_catname(char *dosname, char *catname)
\f[R]
.fi
.PP
\f[B]P3DOS_EDRV_FROM_PDRV\f[R]
.IP
.nf
\f[C]
unsigned char p3dos_edrv_from_pdrv(unsigned char pdrv)
\f[R]
.fi
.PP
\f[B]P3DOS_PDRV_FROM_EDRV\f[R]
.IP
.nf
\f[C]
unsigned char p3dos_pdrv_from_edrv(unsigned char edrv)
\f[R]
.fi
.PP
\f[B]P3DOS_PSTR_TO_CSTR\f[R]
.IP
.nf
\f[C]
unsigned char *p3dos_pstr_to_cstr(unsigned char *s)
\f[R]
.fi
.SH Ports
.SS 8-bit
.PP
Port $6B () DMA Control (Z80 Mode, 3.01.02)
.PP
Port $0F () DAC B
.IP \[bu] 2
bits 7-0 = DAC Value
.PP
Disable with bit 3 of Nextreg $08
.PP
Port $1F () Kempston/Mega Drive Joystick 1/DAC A
.PD 0
.P
.PD
Read
.IP \[bu] 2
bit 7 = \[rq]start\[rq] button
.IP \[bu] 2
bit 6 = A/X button
.IP \[bu] 2
bit 5 = C/Z button
.IP \[bu] 2
bit 4 = Fire/C/Y button
.IP \[bu] 2
bit 3 = Up
.IP \[bu] 2
bit 2 = Down
.IP \[bu] 2
bit 1 = Left
.IP \[bu] 2
bit 0 = Right
.PP
Disable with Nextreg $05
.PD 0
.P
.PD
Write
.IP \[bu] 2
bits 7-0 = DAC Value
.PP
Disable with bit 3 of Nextreg $08
.PP
Port $37 () Kempston/Mega Drive Joystick 2
.PD 0
.P
.PD
Read
.IP \[bu] 2
bit 7 = \[rq]start\[rq] button
.IP \[bu] 2
bit 6 = A/X button
.IP \[bu] 2
bit 5 = C/Z button
.IP \[bu] 2
bit 4 = Fire/C/Y button
.IP \[bu] 2
bit 3 = Up
.IP \[bu] 2
bit 2 = Down
.IP \[bu] 2
bit 1 = Left
.IP \[bu] 2
bit 0 = Right
.PP
Disable with Nextreg $05
.PD 0
.P
.PD
Write ($00 on reset, 3.01.04)
.IP \[bu] 2
bits 7-6 = Select I/O Mode
.RS 2
.IP \[bu] 2
00 = Bit Bang
.IP \[bu] 2
01 = Clock
.IP \[bu] 2
10 = UART
.IP \[bu] 2
11 = Reserved (don\[cq]t use)
.RE
.IP \[bu] 2
bit 5 = Reserved, must be 0
.IP \[bu] 2
bit 4 = Select Joystick Port for Read
.RS 2
.IP \[bu] 2
0 = Left
.IP \[bu] 2
1 = Right
.RE
.IP \[bu] 2
bits 3-1 = Reserved, must be $00
.IP \[bu] 2
bit 0 = Pin 7 state (both ports)
.RS 2
.IP \[bu] 2
Bit Bang - bit 0 on pin 7
.IP \[bu] 2
Clock - clock on pin 7
.PD 0
.P
.PD
0 = Slow clock (Fsys/2048 = 12.672 kHz)
.PD 0
.P
.PD
1 = Fast clock (Fsys/8 = 3.5 MHz)
.IP \[bu] 2
UART - Pin 7 = TX, Pin 9 = RX 0 = ESP
.PD 0
.P
.PD
1 = Pi
.RE
.PP
** A Runt clock may appear in the first cycle
.PD 0
.P
.PD
The I/O mode should be set by writing this port first followed by
enabling io mo de on the joysticks with a write to nextreg 0x05.
.PP
Port $3F () DAC A
.IP \[bu] 2
bits 7-0 = DAC Value
.PP
Disable with bit 3 of Nextreg $08
.PP
Port $4F () DAC C
.IP \[bu] 2
bits 7-0 = DAC Value
.PP
Disable with bit 3 of Nextreg $08
.PP
Port $57 () Sprite Attributes
.PD 0
.P
.PD
Byte 1
.IP \[bu] 2
bits 7-0 = LSB of X coordinate (bit 8 is in byte 3)
.PP
Byte 2
.IP \[bu] 2
bits 7-0 = LSB of Y coordinate (bit 8 is in byte 5)
.PP
Byte 3
.IP \[bu] 2
bits 7-4 = Palette Offset
.IP \[bu] 2
bit 3 = Enable X Mirror
.IP \[bu] 2
bit 2 = Enable Y Mirror
.IP \[bu] 2
bit 1 = Enable Roration
.IP \[bu] 2
bit 0 = By Sprite Type
.RS 2
.IP \[bu] 2
Anchor = MSB of X coordinate
.IP \[bu] 2
Relative = Enable relative palette offset
.RE
.PP
Byte 4
.IP \[bu] 2
bit 7 = Enable visibility
.IP \[bu] 2
bit 6 = Enable Byte 5
.IP \[bu] 2
bit 5-0 = Pattern Index (\[lq]name\[rq])
.PP
Byte 5 (optional)
.PD 0
.P
.PD
Anchor
.IP \[bu] 2
bit 7-6 = type and pattern
.RS 2
.IP \[bu] 2
00 = 8-bit color
.IP \[bu] 2
01 = relative
.IP \[bu] 2
10 = 4-bit color, lower half of pattern (bytes 0-127)
.IP \[bu] 2
11 = 4-bit color, upper half of pattern (byets 128-255)
.RE
.IP \[bu] 2
bit 5 = Attached relative sprite type
.RS 2
.IP \[bu] 2
0 = composite
.IP \[bu] 2
1 = big sprite
.RE
.IP \[bu] 2
bit 4-3 = X-axis scale factor
.RS 2
.IP \[bu] 2
00 = 1\[tmu]
.IP \[bu] 2
01 = 2\[tmu]
.IP \[bu] 2
10 = 4\[tmu]
.IP \[bu] 2
11 = 8\[tmu]
.RE
.IP \[bu] 2
bit 2-1 = Y-axis scale factor
.IP \[bu] 2
bit 0 = MSB of Y coordinate
.PP
Composite Relative
.IP \[bu] 2
bits 7-6 = 01
.IP \[bu] 2
bit 5 = N6
.PD 0
.P
.PD
8-bit
.RS 2
.IP \[bu] 2
Reserved, must be 0
.PP
4-bit
.IP \[bu] 2
0 = lower half of pattern (bytes 0-127)
.IP \[bu] 2
1 = upper half of pattern (bytes 128-255)
.RE
.IP \[bu] 2
bit 4-3 = X-axis scale factor
.IP \[bu] 2
bit 2-1 = Y-axis scale factor
.IP \[bu] 2
bit 0 = Enable relative pattern offset
.PP
Big-sprite Relative
.IP \[bu] 2
bits 7-6 = 01
.IP \[bu] 2
bit 5 = N6
.PD 0
.P
.PD
8-bit
.RS 2
.IP \[bu] 2
Reserved, must be 0
.PP
4-bit
.IP \[bu] 2
0 = lower half of pattern (bytes 0-127)
.IP \[bu] 2
1 = upper half of pattern (bytes 128-255)
.RE
.IP \[bu] 2
bit 4-1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = Enable relative pattern offset
.PP
Port $5B () Sprite Pattern
.PD 0
.P
.PD
Load data into sprite pattern memory auto-incrementing.
Port $303B can be used to set the starting sprite pattern number.
.PP
Port $5F () DAC D
.IP \[bu] 2
bits 7-0 = DAC Value
.PP
Disable with bit 3 of Nextreg $08
.PP
Port $6B () DMA Control (Next Mode, 3.01.02)
.PP
Port $DF () DAC A,D
.IP \[bu] 2
bits 7-0 = DAC Value
.PP
Disable with bit 3 of Nextreg $08
.PP
Port $E3 () divMMC Control
.PD 0
.P
.PD
Disable with bit 2 of Nextreg $09
.IP \[bu] 2
bit 7 = conmem, enable divMMC memory
.IP \[bu] 2
bit 6 = mapram, enable divMMC allRAM mode
.IP \[bu] 2
bits 3-0 = bank, selected divMMC ram bank for $2000-$3FFF region
.IP \[bu] 2
conmem can be used to manually control divMMC mapping.
When enabled
.PD 0
.P
.PD
$0000-$1FFF contains esxDOS ROM or esxDOS page 3
.PD 0
.P
.PD
$2000-$3FFF contains esxDOS RAM page selected by bits 3-0
.IP \[bu] 2
divMMC automatically maps itself in when instruction fetches hit
specific addresses in the ROM.
When this happens, the esxDOS ROM (or divMMC bank 3 if mapram is set)
appears in $0000-$1FFF and the selected divMMC bank appears as RAM in
$2000-$3FFF
.IP \[bu] 2
bit 6 can only be set, once set only a power cycle can reset it.
nextreg $09 bit 3 can be set to reset this bit.
.PP
divMMC automapping is normally disabled by NextZXOS see nextreg $06 bit
4.
.PD 0
.P
.PD
Port $E7 () SPI $\[rs]overline{\[rs]hbox{CS}}$ (SD card, flash, rpi)
.PD 0
.P
.PD
Disable with bit 2 of Nextreg $09
.PP
Port $EB () SPI $\[rs]overline{\[rs]hbox{DATA}}$ (SD card, flash, rpi)
.PD 0
.P
.PD
Disable with bit 2 of Nextreg $09
.PP
Port $F1 () DAC A (precedence over $xxFD)
.IP \[bu] 2
bits 7-0 = DAC Value
.PP
Disable with bit 3 of Nextreg $08
.PP
Port $F3 () DAC B
.IP \[bu] 2
bits 7-0 = DAC Value
.PP
Disable with bit 3 of Nextreg $08
.PP
Port $F9 () DAC C (precedence over $xxFD)
.IP \[bu] 2
bits 7-0 = DAC Value
.PP
Disable with bit 3 of Nextreg $08
.PP
Port $FB () DAC A,D
.IP \[bu] 2
bits 7-0 = DAC Value
.PP
Disable with bit 3 of Nextreg $08
.PP
Port $FE () ULA
.IP \[bu] 2
bits 7-5 = Unused
.IP \[bu] 2
bit 4 = enable ear output
.IP \[bu] 2
bit 3 = enable mic output
.IP \[bu] 2
bit 2-0 = border colour
.PP
Port $FF () Timex Sinclair/Floating Bus
.IP \[bu] 2
bit 7 = memory paging (not on ZX Next)
.IP \[bu] 2
bit 6 = Disable generation of interrupts
.IP \[bu] 2
bit 5-3 = Hi-res mode color combination
.RS 2
.IP \[bu] 2
000 = Black on white (indexes 0, 135)
.IP \[bu] 2
001 = Blue on Yellow (indexes 1, 134)
.IP \[bu] 2
010 = Green on Magenta (indexes 2, 133)
.IP \[bu] 2
011 = Cyan on Red (indexes 3, 132)
.IP \[bu] 2
100 = Red on Cyan (indexes 4, 131)
.IP \[bu] 2
101 = Magenta on Green (indexes 5, 130)
.IP \[bu] 2
110 = Yellow on Blue (indexes 6, 129)
.IP \[bu] 2
111 = White on Black (indexes 7, 128)
.RE
.IP \[bu] 2
bit 2-0 = ULA Mode
.RS 2
.IP \[bu] 2
000 = Normal ULA address
.IP \[bu] 2
001 = Alternate ULA address
.IP \[bu] 2
010 = Hi-color mode
.IP \[bu] 2
110 = Hi-res mode
.RE
.PP
Disable with bit 2 of Nextreg $08
.SS 16-bit
.PP
Port $103B () I^2^C SCL (rtc, rpi)
.PP
Port $113B () I^2^C SDA (rtc, rpi)
.PP
Port $123B () Layer 2
.PD 0
.P
.PD
Bit 4 = 0
.IP \[bu] 2
bits 7-6 = Video RAM bank select
.RS 2
.IP \[bu] 2
00 = first 16k
.IP \[bu] 2
01 = second 16k
.IP \[bu] 2
10 = third 16k
.IP \[bu] 2
11 = first 48k
.RE
.IP \[bu] 2
bit 5 = Reserved, must be 0
.IP \[bu] 2
bit 4 = 0
.IP \[bu] 2
bit 3 = Shadow layer 2 select
.IP \[bu] 2
bit 2 = Enable layer 2 read paging
.IP \[bu] 2
bit 1 = Layer 2 visible (mirrored in register $69)
.IP \[bu] 2
bit 0 = Enable layer 2 write paging
.PP
Bit 4 = 1
.IP \[bu] 2
bits 7-5 = Reserved, must be 0
.IP \[bu] 2
bit 4 = 1
.IP \[bu] 2
bit 3 = Reserved, must be 0
.IP \[bu] 2
bit 2-0 = 16k bank relative offset
.PP
Port $133B () UART tx
.PD 0
.P
.PD
Read: UART Status
.PD 0
.P
.PD
.IP \[bu] 2
bits 7-4 = Reserved (0)
.IP \[bu] 2
bit 3 = UART at least half full (3.01.09)
.IP \[bu] 2
bit 2 = UART full
.IP \[bu] 2
bit 1 = UART transmit busy
.IP \[bu] 2
bit 0 = UART receive has data
.PP
Write: UART Transmit
.PP
Port $143B () UART rx
.PD 0
.P
.PD
Read: UART Receive
.PD 0
.P
.PD
Write: UART Prescalar
.IP \[bu] 2
bit 7 = select prescalar part
.RS 2
.IP \[bu] 2
0 = Bits 6-0 of prescalar
.IP \[bu] 2
1 = Bits 13-7 of prescalar
.RE
.IP \[bu] 2
bits 6-0 = Prescalar bits
.PP
Port $153B () UART select
.IP \[bu] 2
bit 7 = Reserved (0)
.IP \[bu] 2
bit 6 = UART select (0 on soft reset) **
.RS 2
.IP \[bu] 2
0 = ESP
.IP \[bu] 2
1 = Pi *
.RE
.IP \[bu] 2
bit 5 = Reserved (0)
.IP \[bu] 2
bit 4 = Prescalar valid in this write
.IP \[bu] 2
bit 3 = Reserved (0)
.IP \[bu] 2
bits 2-0 = Bits 16-14 of prescalar (0 on hard reset)
.PP
* Pi GPIO must be configured for UART, see nextreg $A0
.PD 0
.P
.PD
** Either UART can be redirected to the joystick ports, see port $037
.PP
Port $153B () UART frame (upcoming)
.PD 0
.P
.PD
($18 on hard reset)
.IP \[bu] 2
bit 7 = Immediately reset Rx and Tx to idle and empty FIFOs
.IP \[bu] 2
bit 6 = Assert break (Tx=0) when Tx reaches idle
.IP \[bu] 2
bit 5 = Enable hardware flow control *
.IP \[bu] 2
bits 4-3 = Number of bits in a frame
.RS 2
.IP \[bu] 2
00 = 5 bits
.IP \[bu] 2
01 = 6 bits
.IP \[bu] 2
10 = 7 bits
.IP \[bu] 2
11 = 8 bits
.RE
.IP \[bu] 2
bit 2 = Enable parity
.IP \[bu] 2
bit 1 = Parity
.RS 2
.IP \[bu] 2
0 = Even parity
.IP \[bu] 2
1 = Odd parity
.RE
.IP \[bu] 2
bit 0 = Number of stop bits
.RS 2
.IP \[bu] 2
0 = 1 stop bit
.IP \[bu] 2
1 = 2 stop bits
.RE
.PP
Port $183B () CTC Channel 0
.PP
Port $193B () CTC Channel 1
.PP
Port $1A3B () CTC Channel 2
.PP
Port $1B3B () CTC Channel 3
.PP
Port $1C3B () CTC Channel 4
.PP
Port $1D3B () CTC Channel 5
.PP
Port $1E3B () CTC Channel 6
.PP
Port $183B () CTC Channel 7
.PP
Port $1FFD () Plus 3 Memory Paging Control
.IP \[bu] 2
bits 7-3 = Unused, nust be 0
.IP \[bu] 2
bit 2 = High bit of ROM selection (low bit is in Port $7FFD)
.RS 2
.IP \[bu] 2
00 = ROM0 = 128k editor and menu system
.IP \[bu] 2
01 = ROM1 = 128k syntax checker
.IP \[bu] 2
10 = ROM2 = +3DOS
.IP \[bu] 2
11 = ROM3 = 48k BASIC
.RE
.IP \[bu] 2
bit 1 = Special mode: Low bit of memory configuration number
.IP \[bu] 2
bit 0 = Paging mode
.RS 2
.IP \[bu] 2
0 = Normal
.IP \[bu] 2
1 = Special
.RE
.PP
You should echo writes to $5B67
.PP
Port $243B () Next Register Select
.PP
Port $253B () Next Register Data
.PP
Port $303B () Sprite Slot/Flags
.PD 0
.P
.PD
Write: Sprite Slot Select
.PD 0
.P
.PD
select sprite slot for Sprite Attribute and Sprite Pattern ports which
independently auto-increment
.PD 0
.P
.PD
Read: Sprite status
.IP \[bu] 2
bits 7-2 = reserved
.IP \[bu] 2
bit 1 = Max sprites per line
.IP \[bu] 2
bit 0 = Collision flag
.PP
Port $7FFD () Memory Paging Control
.IP \[bu] 2
bits 6-7 = reserved
.IP \[bu] 2
bit 5 = Lock memory paging
.IP \[bu] 2
bit 4 = low bit of ROM Select (high bit is in Port $1FFD)
.RS 2
.IP \[bu] 2
00 = ROM0 = 128k editor and menu system
.IP \[bu] 2
01 = ROM1 = 128k syntax checker
.IP \[bu] 2
10 = ROM2 = +3DOS
.IP \[bu] 2
11 = ROM3 = 48k BASIC
.RE
.IP \[bu] 2
bit 3 = Shadow screen toggle
.IP \[bu] 2
bits 2-0 = LSB of Bank number for slot 4 (MSB is in Port $DFFD)
.PP
Disable with bit 5 port $7FFD
.PP
Port $7FFE () Keyboard 8 (read only)
.IP \[bu] 2
bit 0: \[cq]B\[cq]
.IP \[bu] 2
bit 1: \[cq]N\[cq]
.IP \[bu] 2
bit 2: \[cq]M\[cq]
.IP \[bu] 2
bit 3: Symbol Shift
.IP \[bu] 2
bit 4: Space
.PP
Port $BF3B () ULAplus register
.IP \[bu] 2
bits 7-6 = Select register group
.RS 2
.IP \[bu] 2
00 = palette group
.IP \[bu] 2
01 = mode group
.RE
.IP \[bu] 2
bits 5-0 = data
.RS 2
.IP \[bu] 2
If palette group, selects index 0-63 in ULAplus palette
.IP \[bu] 2
If mode group, ignored
.RE
.PP
Port $BFF5 () AY Info (3.01.09
.PD 0
.P
.PD
(R)
.IP \[bu] 2
bits 7-6 = Active AY chip
.RS 2
.IP \[bu] 2
01 = AY 0 active
.IP \[bu] 2
10 = AY 1 active
.IP \[bu] 2
11 = AY 2 active
.RE
.IP \[bu] 2
bit 5 = Reserved
.IP \[bu] 2
bits 4-0 = currently selected AY register
.PP
Port $BFFD () AY Data
.PP
Port $BFFE () Keyboard 7 (read only)
.IP \[bu] 2
bit 0 = \[cq]H\[cq]
.IP \[bu] 2
bit 1 = \[cq]J\[cq]
.IP \[bu] 2
bit 2 = \[cq]K\[cq]
.IP \[bu] 2
bit 3 = \[cq]L\[cq]
.IP \[bu] 2
bit 4 = Enter
.PP
Port $DFFD () Next Memory Bank Select
.IP \[bu] 2
bits 7-4 = Reserved, must be 0
.IP \[bu] 2
bits 3-0 = MSB of bank number for slot 4 (LSB is in Port $7FFD)
.PP
Port $DFFE () Keyboard 6 (read only)
.IP \[bu] 2
bit 0 = \[cq]Y\[cq]
.IP \[bu] 2
bit 1 = \[cq]U\[cq]
.IP \[bu] 2
bit 2 = \[cq]I\[cq]
.IP \[bu] 2
bit 3 = \[cq]O\[cq]
.IP \[bu] 2
bit 4 = \[cq]P\[cq]
.PP
Port $EFF7 () Pentagon 1024 paging
.IP \[bu] 2
bit 3 = 1 to overlay the bottom 16k with ram from 16k bank 0
.IP \[bu] 2
bit 2 = 0 to enable Pentagon 1024 mapping and disable bit 5 port 0x7ffd
locking, 1 to select standard zx128 mapping **
.IP \[bu] 2
** Applies only when pentagon 1024 mapping mode is enabled via nextreg
0x8f.
.PP
Port $EFFE () Keyboard 5 (read only)
.IP \[bu] 2
bit 0 = `6'
.IP \[bu] 2
bit 1 = `7'
.IP \[bu] 2
bit 2 = `8'
.IP \[bu] 2
bit 3 = `9'
.IP \[bu] 2
bit 4 = `0'
.PP
Port $F7FE () Keyboard 4 (read only)
.IP \[bu] 2
bit 0 = `5'
.IP \[bu] 2
bit 1 = `4'
.IP \[bu] 2
bit 2 = `3'
.IP \[bu] 2
bit 3 = `2'
.IP \[bu] 2
bit 4 = `1'
.PP
Port $FADF () Kempston Mouse Buttons
.IP \[bu] 2
bits 7-4 = Wheel delta since last read
.IP \[bu] 2
bit 3 = fourth button
.IP \[bu] 2
bit 2 = middle button
.IP \[bu] 2
bit 1 = left button
.IP \[bu] 2
bit 0 = right button
.PP
Port $FBDF () Kempston Mouse X
.IP \[bu] 2
bits 7-0 = X coordinate of mouse
.PP
Port $FBFE () Keyboard 3 (read only)
.IP \[bu] 2
bit 0 = `T'
.IP \[bu] 2
bit 1 = `R'
.IP \[bu] 2
bit 2 = `E'
.IP \[bu] 2
bit 3 = `W'
.IP \[bu] 2
bit 4 = `Q'
.PP
Port $FDFE () Keyboard 2 (read only)
.IP \[bu] 2
bit 0 = `G'
.IP \[bu] 2
bit 1 = `F'
.IP \[bu] 2
bit 2 = `D'
.IP \[bu] 2
bit 3 = `S'
.IP \[bu] 2
bit 4 = `A'
.PP
Port $FEFE () Keyboard 1 (read only)
.IP \[bu] 2
bit 0 = `V'
.IP \[bu] 2
bit 1 = `C'
.IP \[bu] 2
bit 2 = `X'
.IP \[bu] 2
bit 3 = `Z'
.IP \[bu] 2
bit 4 = Caps Shift
.PP
Port $FF3B () ULAplus data
.IP \[bu] 2
If palette group, 8-bit (RRRGGGBB) value for current index
.IP \[bu] 2
If mode group, bit 1 = enable ULAplus
.PP
Port $FFDF () Kempston Mouse Y
.IP \[bu] 2
bits 7-0 = Y coordinate of mouse (0-192)
.PP
Port $FFFD () AY Control and AY register Select (3.01.09)
.PD 0
.P
.PD
Read
.IP \[bu] 2
bits 7-0 = data in selected register of active AY chip
.PP
Select Chip
.IP \[bu] 2
bit 7 = 1
.IP \[bu] 2
bit 6 = Enable left
.IP \[bu] 2
bit 5 = Enable Right
.IP \[bu] 2
bits 4-2 = Reserved, must be 1
.IP \[bu] 2
bits 1-0 = AY chip select
.RS 2
.IP \[bu] 2
00 = Unused
.IP \[bu] 2
01 = AY 2
.IP \[bu] 2
10 = AY 1
.IP \[bu] 2
11 = AY 0
.RE
.PP
Select Register
.IP \[bu] 2
bit 7 = 0
.IP \[bu] 2
bits 6-5 = Reserved, must be 0
.IP \[bu] 2
bits 4-0 = Register Number
.SH Registers
.SS ZX Spectrum Next Registers
.PP
The ZX Next stores configuration state in a field of registers.
These registers are accessible via two I/O ports or via the special
nextreg instructions.
.PP
Port $243B (9275) is used to set the register number, listed below.
.PP
Port $253B (9531) is used to access the register value.
.PP
Some registers are accessible only during the initialization process.
.PP
Register (R) $00 () \[rA] Machine ID
.IP \[bu] 2
00000001 = DE1A
.IP \[bu] 2
00000010 = DE2A
.IP \[bu] 2
00000101 = FBLABS
.IP \[bu] 2
00000110 = VTRUCCO
.IP \[bu] 2
00000111 = WXEDA
.IP \[bu] 2
00001000 = EMULATORS
.IP \[bu] 2
00001010 = ZX Spectrum Next
.IP \[bu] 2
00001011 = Multicore
.IP \[bu] 2
10101010 = ZX Spectrum Next Core on unAmiga
.IP \[bu] 2
10111010 = ZX Spectrum Next Core on SiDi
.IP \[bu] 2
11001010 = ZX Spectrum Next Core on MIST
.IP \[bu] 2
11011010 = ZX Spectrum Next Core on MiSTer
.IP \[bu] 2
11011010 = ZX Spectrum Next Core on unAmiga Reloaded
.IP \[bu] 2
11101010 = ZX Spectrum Next Core on ZX-DOS
.IP \[bu] 2
11111010 = ZX Spectrum Next Anti-brick
.PP
Register (R) $01 () \[rA] Core Version
.IP \[bu] 2
bits 7-4 = Major version number
.IP \[bu] 2
bits 3-0 = Minor version number
.IP \[bu] 2
See register $0E for sub minor version number
.PP
Register (R/W) $02 () \[rA] Reset
.PD 0
.P
.PD
Read
.IP \[bu] 2
bit 7 = Expansion bus $\[rs]overline{\[rs]hbox{RESET}}$ Asserted
.IP \[bu] 2
bits 6-4 = Reserved
.IP \[bu] 2
bit 3 = Indicates multiface NMI was generated by this nextreg (3.01.09)
.IP \[bu] 2
bit 2 = Indicates divmmc NMI was generated by this nextreg (3.01.09)
.IP \[bu] 2
bit 1 = Last reset was Hard reset
.IP \[bu] 2
bit 0 = Last reset was Soft reset
.PP
Write
.IP \[bu] 2
bit 7 = Hold Expansion bus and ESP $\[rs]overline{\[rs]hbox{RESET}}$
.IP \[bu] 2
bits 6-4 = Reserved, must be 0
.IP \[bu] 2
bit 3 = Generate multiface NMI (write zero to clear)(3.01.09)
.IP \[bu] 2
bit 2 = Generate divmmc NMI (write zero to clear)(3.01.09)
.IP \[bu] 2
bit 1 = generate Hard reset (reboot)
.IP \[bu] 2
bit 0 = generate Soft reset
.PP
Register (R/W) $03 () \[rA] Machine Type
.PD 0
.P
.PD
A write to this register disables the boot rom in config mode
.PD 0
.P
.PD
bits 2-0 select machine type when in config mode
.IP \[bu] 2
bit 7 = (W) Display Timing change enable (allow changes to bits 6-4) (0
on hard reset)
.IP \[bu] 2
bits 6-4 = Display Timing
.IP \[bu] 2
bit 3 = Display Timing user lock control
.IP \[bu] 2
Read
.RS 2
.IP \[bu] 2
0 = No user lock on display timing
.IP \[bu] 2
1 = User lock on display timing
.RE
.IP \[bu] 2
Write
.RS 2
.IP \[bu] 2
1 = Apply user lock on display timing (0 on hard reset)
.RE
.IP \[bu] 2
bits 2-0 = Machine Type (config mode only)
.PD 0
.P
.PD
determines roms loaded
.IP \[bu] 2
Machine Types/Display Timings
.RS 2
.IP \[bu] 2
000 or 001 = ZX 48K
.IP \[bu] 2
010 = ZX 128K/+2 (Grey)
.IP \[bu] 2
011 = ZX +2A-B/+3e/Next Native
.IP \[bu] 2
100 = Pentagon 128K
.RE
.PP
Register (W) $04 () \[rA] Configuration Mapping
.IP \[bu] 2
bits 7 = Reserved, must be 0
.IP \[bu] 2
bits 6-0 = 16k SRAM bank mapping* ($00 on hard reset)
.IP \[bu] 2
* Maps a 16k SRAM bank over the bottom 16k.
Applies only in config mode when the bootrom is disabled
.IP \[bu] 2
** Odd multiples of 256k are unreliable if storing data in sram for the
mext core started.
.IP \[bu] 2
*** number of useful bits changed from 5 to 7 in coure 3.01.06
.PP
Register (R/W) $05 () \[rA] Peripheral 1 Settings
.IP \[bu] 2
bits 7-6 = joystick 1 mode (MSB)
.IP \[bu] 2
bits 5-4 = joystick 2 mode (MSB)
.IP \[bu] 2
bit 3 = joystick 1 mode (LSB)
.IP \[bu] 2
bit 2 = 50/60 Hz mode (0 = 50Hz, 1 = 60Hz)
.IP \[bu] 2
bit 1 = joystick 2 mode (LSB)
.IP \[bu] 2
bit 0 = Enable Scandoubler
.PP
Joystick modes
.IP \[bu] 2
000 = Sinclair 2 (67890)
.IP \[bu] 2
001 = Kempston 2 (port $37)
.IP \[bu] 2
010 = Kempston 1 (port $1F)
.IP \[bu] 2
011 = Megadrive 1 (port $1F)
.IP \[bu] 2
100 = Cursor
.IP \[bu] 2
101 = Megadrive 2 (port $37)
.IP \[bu] 2
110 = Sinclair 1 (12345)
.IP \[bu] 2
111 = I/O Mode (3.01.04) Both joysticks are places in I/O Mode if either
is set to I/O Mode.
The underlying joystick type is not changed and reads of this register
will continue to return the last joystick type.
Ehether the joystick is in io mode or not is invisible but this state
can be cleared either through reset or by re-writing the gegister with
joystick type not equal to 111.
Recovery time for a normal joystick read after leaving I/O Mode is at
most 64 scan lines.
.PP
Register (R/W) $06 () \[rA] Peripheral 2 Settings
.IP \[bu] 2
bit 7 = F8 CPU Speed Hotkey Enable (1 on reset)
.IP \[bu] 2
bit 6 = Enable classic audio mode (beep and tape to internal speaker,
other audio to ear and HDMI, 3.01.02)
.IP \[bu] 2
bit 5 = F3 50Hz/60Hz Hotkey Enable (1 on reset)
.IP \[bu] 2
bit 4 = divMMC Automap/NMI Enable (0 on hard reset)
.IP \[bu] 2
bit 3 = NMI Button Enable (0 on hard reset)
.IP \[bu] 2
bit 2 = PS/2 Mode (0 = keyboard, 1 = mouse)
.IP \[bu] 2
bits 1-0 = PSG Mode (00 = YM, 01 = AY, 11 = hold all PSGs in Reset)
.PP
Register (R/W) $07 () \[rA] Turbo mode
.PD 0
.P
.PD
Read
.IP \[bu] 2
bits 7-6 = Reserved
.IP \[bu] 2
bits 5-4 = Current Actual CPU Speed
.IP \[bu] 2
bits 3-2 = Reserved
.IP \[bu] 2
bits 1-0 = Current Selected CPU Speed (00 on reset)
.PP
Write
.IP \[bu] 2
bits 7-2 = Reserved, must be 0
.IP \[bu] 2
bits 1-0 = Select CPU Speed
.PP
CPU Speeds
.IP \[bu] 2
00 = 3.5MHz
.IP \[bu] 2
01 = 7MHz
.IP \[bu] 2
10 = 14MHz
.IP \[bu] 2
11 = 28MHz
.PP
Register (R/W) $08 () \[rA] Peripheral 3 Settings
.IP \[bu] 2
bit 7 = 128K Banking Unlock (inverse of port $7FFD, bit 5) (0 on reset)
.IP \[bu] 2
bit 6 = Disable RAM and Port Contention (0 on reset)
.IP \[bu] 2
bit 5 = PSG Stereo Mode Control (0 = ABC, 1 = ACB) (0 on hard reset)
.IP \[bu] 2
bit 4 = Enable internal speaker (1 on hard reset)
.IP \[bu] 2
bit 3 = Enable DACs (0 on hard reset)
.IP \[bu] 2
bit 2 = Enable read of port $FF (Timex) (0 on hard reset)
.IP \[bu] 2
bit 1 = Enable Multiple PSGs (0 on hard reset)
.IP \[bu] 2
bit 0 = Enable Issue 2 Keyboard
.PP
Register (R/W) $09 () \[rA] Peripheral 4 setting:
.IP \[bu] 2
bit 7 = PSG 2 Mono Enable (0 on hard reset)
.IP \[bu] 2
bit 6 = PSG 1 Mono Enable (0 on hard reset)
.IP \[bu] 2
bit 5 = PSG 0 Mono Enable (0 on hard reset)
.IP \[bu] 2
bit 4 = Sprite ID lockstep enable (1 = Nextreg $34 and IO Port $303B are
in lockstep, 0 on reset)
.IP \[bu] 2
bit 3 = divMMC mapRAM bit Control (reset bit 7 of port $E3)
.IP \[bu] 2
bit 2 = HDMI audio mute (0 on hard reset)
.IP \[bu] 2
bits 1-0 = scanlines
.RS 2
.IP \[bu] 2
00 = scanlines off
.IP \[bu] 2
01 = scanlines 12.5%
.IP \[bu] 2
10 = scanlines 25%
.IP \[bu] 2
11 = scanlines 50%
.RE
.IP \[bu] 2
In Sprite lockstep, NextREG $34 and Port $303B are in lockstep
.PP
Register (R/W) $0A () \[rA] Peripheral 5 setting:
.IP \[bu] 2
bits 7-6 = Multiface type (00 on hard reset)
.RS 2
.IP \[bu] 2
00 = Multiface +3 (enable port 0x3F, disable port 0xBF)
.IP \[bu] 2
01 = Multiface 128 v87.2 (enable port 0xBF, disable port 0x3F)
.IP \[bu] 2
10 = Multiface 128 v87.12 (enable port 0x9F, disable port 0x1F)
.IP \[bu] 2
11 = Multiface 1 (enable port 0x9F, disable port 0x1F)
.RE
.IP \[bu] 2
bits 5-4 = Reserved, must be zero
.IP \[bu] 2
bit 3 = 1 to reverse left and right mouse buttons (3.01.07)
.IP \[bu] 2
bit 2 = Reserved, must be 0
.IP \[bu] 2
bits 1-0 = mouse dpi (00 on hard reset) (3.01.05)
.RS 2
.IP \[bu] 2
00 = low dpi
.IP \[bu] 2
01 = default
.IP \[bu] 2
10 = medium dpi
.IP \[bu] 2
11 = high dpi
.RE
.PP
Register (R) $0E () \[rA] Core Version (sub minor number)
.IP \[bu] 2
bits 7-0 = Core sub minor version number
.IP \[bu] 2
(see register $01 for the major and minor version number)
.PP
Register (R/W) $10 () \[rA] Core Boot
.PD 0
.P
.PD
Read
.IP \[bu] 2
bits 7-2 = Reserved
.IP \[bu] 2
bit 1 = Drive button pressed
.IP \[bu] 2
bit 0 = NMI button pressed
.PP
Write
.IP \[bu] 2
bit 7 = Reboot FPGA using selected core (0 on reset)
.IP \[bu] 2
bits 6-5 = Reserved, must be 0
.IP \[bu] 2
bits 4-0 = Core ID
.IP \[bu] 2
Core ID with bits 4-0 can only be set in configuration mode
.PP
Register (R/W) $11 () \[rA] Video Timing (writable in config mode only)
.IP \[bu] 2
bits 7-3 = Reserved, must be 0
.IP \[bu] 2
bits 2-0 = Mode (VGA = 0..6, HDMI = 7)
.RS 2
.IP \[bu] 2
000 = Base VGA timing, clk28 = 28000000
.IP \[bu] 2
001 = VGA setting 1, clk28 = 28571429
.IP \[bu] 2
010 = VGA setting 2, clk28 = 29464286
.IP \[bu] 2
011 = VGA setting 3, clk28 = 30000000
.IP \[bu] 2
100 = VGA setting 4, clk28 = 31000000
.IP \[bu] 2
101 = VGA setting 5, clk28 = 32000000
.IP \[bu] 2
110 = VGA setting 6, clk28 = 33000000
.IP \[bu] 2
111 = HDMI, clk28 = 27000000
.RE
.IP \[bu] 2
50/60Hz selection depends on bit 2 of register $05
.IP \[bu] 2
Only writable in config mode
.PP
Register (R/W) $12 () \[rA] Layer 2 Active RAM bank
.IP \[bu] 2
bits 7-6 = Reserved, must be 0
.IP \[bu] 2
bits 5-0 = RAM bank (point to bank 8 after a Reset, NextZXOS modifies to
9)
.PP
Register (R/W) $13 () \[rA] Layer 2 Shadow RAM bank
.IP \[bu] 2
bits 7-6 = Reserved, must be 0
.IP \[bu] 2
bits 5-0 = RAM bank (point to bank 11 after a Reset, NextZXOS modifies
to 12)
.PP
Register (R/W) $14 () \[rA] Global transparency color
.IP \[bu] 2
bits 7-0 = Transparency color value ($E3 after a reset)
.PP
(Note: this value is 8-bit, so the transparency is compared against only
by the MSB bits of the final 9-bit colour)
.PD 0
.P
.PD
(Note2: this only affects Layer 2, ULA and LoRes.
Sprites use register $4B for transparency and tilemap uses nextreg $4C)
.PP
Register (R/W) $15 () \[rA] Sprite and Layer System Setup
.IP \[bu] 2
bit 7 = LoRes mode (0 on reset)
.IP \[bu] 2
bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on top) (0
on reset)
.IP \[bu] 2
bit 5 = Enable sprite clipping in over border mode (0 on reset)
.IP \[bu] 2
bits 4-2 = set layers priorities (000 on reset)
.RS 2
.IP \[bu] 2
000 - S L U
.IP \[bu] 2
001 - L S U
.IP \[bu] 2
010 - S U L
.IP \[bu] 2
011 - L U S
.IP \[bu] 2
100 - U S L
.IP \[bu] 2
101 - U L S
.IP \[bu] 2
110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7
.IP \[bu] 2
111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]
.RE
.IP \[bu] 2
bit 1 = Enable Sprites Over border (0 on reset)
.IP \[bu] 2
bit 0 = Enable Sprites (0 on reset)
.PP
Register (R/W) $16 () \[rA] Layer 2 Horizontal Scroll Control
.IP \[bu] 2
bits 7-0 = X Offset (0-255)(0 on reset)
.PP
Register (R/W) $17 () \[rA] Layer 2 Vertical Scroll Control
.IP \[bu] 2
bits 7-0 = Y Offset (0-191)(0 on reset)
.PP
Register (R/W) $18 () \[rA] Layer 2 Clip Window Definition
.IP \[bu] 2
bits 7-0 = Coords of the clip window
.RS 2
.IP \[bu] 2
1st write - X1 position
.IP \[bu] 2
2nd write - X2 position
.IP \[bu] 2
3rd write - Y1 position
.IP \[bu] 2
4rd write - Y2 position
.RE
.PP
Reads do not advance the clip position
.PD 0
.P
.PD
The values are 0,255,0,191 after a Reset
.PP
Register (R/W) $19 () \[rA] Sprite Clip Window Definition
.IP \[bu] 2
bits 7-0 = Cood.
of the clip window
.RS 2
.IP \[bu] 2
1st write - X1 position
.IP \[bu] 2
2nd write - X2 position
.IP \[bu] 2
3rd write - Y1 position
.IP \[bu] 2
4rd write - Y2 position
.RE
.PP
The values are 0,255,0,191 after a Reset
.PD 0
.P
.PD
Reads do not advance the clip position
.PP
When the clip window is enabled for sprites in \[dq]over border\[dq]
mode, the X coords are internally doubled and the clip window origin is
moved to the sprite origin inside the border.
.PP
Register (R/W) $1A () \[rA] Layer 0 (ULA/LoRes) Clip Window Definition
.IP \[bu] 2
bits 7-0 = Coord.
of the clip window
.RS 2
.IP \[bu] 2
1st write = X1 position
.IP \[bu] 2
2nd write = X2 position
.IP \[bu] 2
3rd write = Y1 position
.IP \[bu] 2
4rd write = Y2 position
.RE
.PP
The values are 0,255,0,191 after a Reset
.PD 0
.P
.PD
Reads do not advance the clip position
.PP
Register (R/W) $1B () \[rA] Layer 3 (Tilemap) Clip Window Definition
.IP \[bu] 2
bits 7-0 = Coord.
of the clip window
.RS 2
.IP \[bu] 2
1st write = X1 position
.IP \[bu] 2
2nd write = X2 position
.IP \[bu] 2
3rd write = Y1 position
.IP \[bu] 2
4rd write = Y2 position
.RE
.PP
The values are 0,159,0,255 after a Reset
.PD 0
.P
.PD
Reads do not advance the clip position
.PD 0
.P
.PD
The X coords are internally doubled.
.PP
Register (R/W) $1C () \[rA] Clip Window Control
.PD 0
.P
.PD
Read
.IP \[bu] 2
bits 7-6 = Layer 3 Clip Index
.IP \[bu] 2
bits 5-4 = Layer 0/1 Clip Index
.IP \[bu] 2
bits 3-2 = Sprite clip index
.IP \[bu] 2
bits 1-0 = Layer 2 Clip Index
.PP
Write
.IP \[bu] 2
bits 7-4 = Reserved, must be 0
.IP \[bu] 2
bit 3 - reset Layer 3 clip index
.IP \[bu] 2
bit 2 - reset Layer 0/1 clip index
.IP \[bu] 2
bit 1 - reset sprite clip index.
.IP \[bu] 2
bit 0 - reset Layer 2 clip index.
.PP
Register (R) $1E () \[rA] Active video line (MSB)
.IP \[bu] 2
bits 7-1 = Reserved
.IP \[bu] 2
bit 0 = Active line MSB
.PP
Register (R) $1F () \[rA] Active video line (LSB)
.IP \[bu] 2
bits 7-0 = Active line LSB (0-255)
.PP
Register (R/W) $22 () \[rA] Line Interrupt control
.IP \[bu] 2
bit 7 = (R) ULA asserting interrupt
.IP \[bu] 2
bit 7 = (W) Reserved, must be 0
.IP \[bu] 2
bits 6-3 = Reserved, must be 0
.IP \[bu] 2
bit 2 = Disable ULA Interrupt (0 on reset)
.IP \[bu] 2
bit 1 = Enable Line Interrupt (0 on reset)
.IP \[bu] 2
bit 0 = MSB of Line Interrupt line value (0 on reset)
.PP
Register (R/W) $23 () \[rA] Line Interrupt value LSB
.IP \[bu] 2
bits 7-0 = Line Interrupt line value LSB (0-255)(0 on reset)
.PP
Register (R/W) $26 () \[rA] ULA Horizontal Scroll Control
.IP \[bu] 2
bits 7-0 = ULA X Offset (0-255) (0 on reset)
.PP
Register (R/W) $27 () \[rA] ULA Vertical Scroll Control
.IP \[bu] 2
bits 7-0 = ULA Y Offset (0-191) (0 on reset)
.PP
Register (R/W) $28 () \[rA] Stored Palette Value and PS/2 Keymap Address
MSB
.PD 0
.P
.PD
Read
.IP \[bu] 2
bits 7-0 = Stored palette value (see NextREG $44)
.PP
Write
.IP \[bu] 2
bits 7-1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = PS/2 Keymap Address MSB
.PP
Register (W) $29 () \[rA] PS/2 Keymap Address LSB
.IP \[bu] 2
bits 7-0 = PS/2 Keymap Address LSB
.PP
Register (W) $2A () \[rA] PS/2 Keymap Data MSB
.IP \[bu] 2
bits 7-1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = PS/2 Keymap Data MSB
.PP
Register (W) $2B () \[rA] PS/2 Keymap Data LSB
.IP \[bu] 2
bits 7-0 = PS/2 Keymap Data LSB
.PP
(writing this register auto-increments the address)
.PP
Register (R/W) $2C () \[rA] DAC B Mirror (Left)/ I^2^S Left Sample MSB
.PD 0
.P
.PD
Read
.IP \[bu] 2
bits 7-0 = I^2^S Left Sample MSB
.PP
Write
.IP \[bu] 2
bits 7-0 = 8-bit sample left DAC ($80 on reset)
.PP
Register (R/W) $2D () \[rA] DAC A+D Mirror (mono/ I^2^S Sample LSB
.PD 0
.P
.PD
Read
.IP \[bu] 2
bits 7-0 = I^2^S Last Sample LSB
.PP
Write
.IP \[bu] 2
bits 7-0 = 8-bit sample DACs A + D ($80 on reset)
.PP
Register (R/W) $2E () \[rA] DAC C Mirror (Right/ I^2^S Risht Sample MSB
.PD 0
.P
.PD
Read
.IP \[bu] 2
bits 7-0 = I^2^S Right Sameple MSB
.PP
Write
.IP \[bu] 2
bits 7-0 = 8-bit sample Right DACs C ($80 on reset)
.PP
Register (R/W) $2F () \[rA] Layer 3 (Tilemap) Horizontal Scroll Control
MSB
.IP \[bu] 2
bits 7-2 = Reserved, must be 0
.IP \[bu] 2
bits 1-0 = X Offset MSB ($00 on reset)
.PP
Meaningful Range is 0-319 in 40 char mode, 0-639 in 80 char mode
.PP
Register (R/W) $30 () \[rA] Layer 3 (Tilemap) Horizontal Scroll Control
LSB
.IP \[bu] 2
bits 7-0 = X Offset LSB ($00 on reset)
.PP
Meaningful range is 0-319 in 40 char mode, 0-639 in 80 char mode
.PP
Register (R/W) $31 () \[rA] Layer 3 (Tilemap) Vertical Scroll Control
.IP \[bu] 2
bits 7-0 = Y Offset (0-255) )$00 on reset)
.PP
Register (R/W) $32 () \[rA] Layer 1,0 (LoRes) Horizontal Scroll Control)
.IP \[bu] 2
bits 7-0 = X Offset (0-255) ($00 on reset)
.PP
Layer 1,0 (LoRes) scrolls in \[dq]half-pixels\[dq] at the same
resolution and smoothness as Layer 2.
.PP
Register (R/W) $33 () \[rA] Layer 1,0 (LoRes) Vertical Scroll Control)
.IP \[bu] 2
bits 7-0 = Y Offset (0-191) ($00 on reset)
.PP
Layer 1,0 (LoRes) scrolls in \[dq]half-pixels\[dq] at the same
resolution and smoothness as Layer 2.
.PP
Register (R/W) $34 () \[rA] Sprite Number
.PD 0
.P
.PD
Lockstep (NextReg $09 bit 4 set)
.IP \[bu] 2
bit 7 = Pattern address offset (Add 128 to pattern address)
.IP \[bu] 2
bits 6-0 = Sprite number 0-127, Pattern number 0-63
.IP \[bu] 2
effectively performs an out to port $303B
.PP
No Lockstep (NextReg $09 bit 4 clear)
.IP \[bu] 2
bit 7 = Reserved, must be 0
.IP \[bu] 2
bits 6-0 = Sprite number 0-127
.PP
This register selects which sprite has its attributes connected to the
sprite attribute registers
.PP
Register (W) $35 () \[rA] Sprite Attribute 0
.IP \[bu] 2
bits 7-0 = Sprite X coordinate LSB (MSB in NextReg $37)
.PP
Register (W) $36 () \[rA] Sprite Attribute 1
.IP \[bu] 2
bits 7-0 = Sprite Y coordinate LSB (MSB in NextReg $39)
.PP
Register (W) $37 () \[rA] Sprite Attribute 2
.IP \[bu] 2
bits 7-4 = 4-bit Palette offset
.IP \[bu] 2
bit 3 = Enable horizontal mirror (reverse)
.IP \[bu] 2
bit 2 = Enable vertical mirror (reverse)
.IP \[bu] 2
bit 1 = Enable 90^\f[I]O\f[R]^ Clockwise Rotation
.PP
Normal Sprites
.IP \[bu] 2
bit 0 = X coordinate MSB
.PP
Relative Sprites
.IP \[bu] 2
bit 0 = Palette offset is relative to anchor sprite
.PP
Rotation is applied before mirroring
.PP
Register (W) $38 () \[rA] Sprite Attribute 3
.IP \[bu] 2
bit 7 = Enable Visiblity
.IP \[bu] 2
bit 6 = Enable Attribute 4 (0 = Attribute 4 effectively $00)
.IP \[bu] 2
bits 5-0 = Sprite Pattern Number
.PP
Register (W) $39 () \[rA] Sprite Attribute 4
.PD 0
.P
.PD
Normal Sprites
.IP \[bu] 2
bit 7 = 4-bit pattern switch (0 = 8-bit sprite, 1 = 4-bit sprite)
.IP \[bu] 2
bit 6 = Pattern number bit-7 for 4-bit, 0 for 8-bit
.IP \[bu] 2
bit 5 = Type of attached relative sprites (0 = Composite, 1 = Unified)
.IP \[bu] 2
bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
.IP \[bu] 2
bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
.IP \[bu] 2
bit 0 = MSB of Y coordinate
.PP
Relative, Composite Sprites
.IP \[bu] 2
bit 7-6 = 01
.IP \[bu] 2
bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit
.IP \[bu] 2
bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
.IP \[bu] 2
bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)
.IP \[bu] 2
bit 0 = Pattern number is relative to anchor
.PP
Relative, Unified Sprites
.IP \[bu] 2
bit 7-6 = 01
.IP \[bu] 2
bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit
.IP \[bu] 2
bits 4-1 = 0000
.IP \[bu] 2
bit 0 = Pattern number is relative to anchor
.PP
Register (R/W) $40 () \[rA] Palette Index Select
.IP \[bu] 2
bits 7-0 = Palette Index Number
.PP
Selects the palette index to change the associated colour
.PP
For ULA only, INKs are mapped to indices 0 through 7, BRIGHT INKs to
indices 8 through 15, PAPERs to indices 16 through 23 and BRIGHT PAPERs
to indices 24 through 31.
In EnhancedULA mode, INKs come from a subset of indices from 0 through
127 and PAPERs from a subset of indices from 128 through 255.
.PP
The number of active indices depends on the number of attribute bits
assigned to INK and PAPER out of the attribute byte.
.PP
In ULAplus mode, the last 64 entries (indices 192 to 255) hold the
ULAplus palette.
The ULA always takes border colour from PAPER for standard ULA and
Enhanced ULA
.PP
Register (R/W) $41 () \[rA] 8-bit Palette Data
.IP \[bu] 2
bits 7-0 = Colour Entry in RRRGGGBB format
.PP
The lower blue bit of the 9-bit internal colour will be the logical or
of bits 0 and 1 of the 8-bit entry.
After each write, the palette index auto-increments if aut-increment has
been enabled (NextReg $43 bit 7), Reads do not auto-increment.
.PP
Register (R/W) $42 () \[rA] ULANext Attribute Byte Format
.IP \[bu] 2
bits 7-0 = Attribute byte\[cq]s INK representation mask (7 on reset)
.PP
The mask can only indicate a solid sequence of bits on the right side of
the attribute byte (1, 3, 7, 15, 31, 63, 127 or 255).
.PP
INKs are mapped to base index 0 in the palette and PAPERs and border are
mapped to base index 128 in the palette.
.PP
The 255 value enables the full ink colour mode making all the palette
entries INK.
PAPER and border both take on the fallback colour (nextreg $4A) in this
mode.
.PP
Register (R/W) $43 () \[rA] Palette Control
.IP \[bu] 2
bit 7 = Disable palette write auto-increment.
.IP \[bu] 2
bits 6-4 = Select palette for reading or writing:
.RS 2
.IP \[bu] 2
000 = ULA first palette
.IP \[bu] 2
100 = ULA second palette
.IP \[bu] 2
001 = Layer 2 first palette
.IP \[bu] 2
101 = Layer 2 second palette
.IP \[bu] 2
010 = Sprite first palette
.IP \[bu] 2
110 = Sprite second palette
.IP \[bu] 2
011 = Layer 3 first palette
.IP \[bu] 2
111 = Layer 3 second palette
.RE
.IP \[bu] 2
bit 3 = Select Sprite palette (0 = first palette, 1 = second palette)
.IP \[bu] 2
bit 2 = Select Layer 2 palette (0 = first palette, 1 = second palette)
.IP \[bu] 2
bit 1 = Select ULA palette (0 = first palette, 1 = second palette)
.IP \[bu] 2
bit 0 = Enable EnhancedULA mode if 1.
(0 after a reset)
.PP
Register (R/W) $44 () \[rA] 9-bit Palette Data
.PD 0
.P
.PD
Non Level 2
.IP \[bu] 2
1st write
.IP \[bu] 2
bits 7-0 = MSB (RRRGGGBB)
.IP \[bu] 2
2nd write
.IP \[bu] 2
bits 7-1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = LSB (B)
.PP
Level 2
.IP \[bu] 2
1st write
.IP \[bu] 2
bits 7-0 = MSB (RRRGGGBB)
.IP \[bu] 2
2nd write
.IP \[bu] 2
bit 7 = Priority
.IP \[bu] 2
bits 6-1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = LSB (B)
.PP
9-bit Palette Data is entered in two consecutive writes; the second
write autoincrements the palette index if auto-increment is enabled in
NextREG $43 bit 7
.PP
If writing an L2 palette, the second write\[cq]s D7 holds the L2
priority bit which if set (1) brings the colour defined at that index on
top of all other layers.
If you also need the same colour in regular priority (for example: for
enviromental masking) you will have to set it up again, this time with
no priority.
.PP
Reads return the second byte and do not autoincrement.
Writes to nextreg $40, $41, $41, or $43 reset to the first write.
.PP
Register (R/W) $4A () \[rA] Fallback Colour Value
.IP \[bu] 2
bits 7-0 = 8-bit colour if all layers are transparent ($E3 on reset)
.PP
(black on reset = 0)
.PP
Register (R/W) $4B () \[rA] Sprite Transparency Index
.IP \[bu] 2
bits 7-0 = Index value ($E3 if reset)
.PP
For 4-bit sprites only the bottom 4-bits are relevant.
.PP
Register (R/W) $4C () \[rA] Level 3 Transparency Index
.IP \[bu] 2
bits 7-4 = Reserved, must be 0
.IP \[bu] 2
bits 3-0 = Index value ($0F on reset)
.PP
Register (R/W) $50 () \[rA] MMU Slot 0 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $0000 to $1FFF ($ff on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PD 0
.P
.PD
A 255 value causes the ROM to become visible.
.PP
Register (R/W) $51 () \[rA] MMU Slot 1 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $2000 to $3FFF ($ff on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PD 0
.P
.PD
A 255 value causes the ROM to become visible.
.PP
Register (R/W) $52 () \[rA] MMU Slot 2 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $4000 to $5FFF ($0A on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PP
Register (R/W) $53 () \[rA] MMU Slot 3 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $6000 to $7FFF ($0B on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PP
Register (R/W) $54 () \[rA] MMU Slot 4 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $8000 to $9FFF ($04 on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PP
Register (R/W) $55 () \[rA] MMU Slot 5 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $A000 to $BFFF ($05 on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PP
Register (R/W) $56 () \[rA] MMU Slot 6 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $C000 to $DFFF ($00 on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PP
Register (R/W) $57 () \[rA] MMU Slot 7 Control
.IP \[bu] 2
bits 7-0 = 8k RAM page at position $E000 to $FFFF ($01 on reset)
.PP
Pages can be from 0 to 223 on a fully expanded Next.
.PP
Writing to ports $1FFD, $7FFD and $DFFD writes $FF to MMU0 and MMU1 and
writes appropriate values to MMU6 and MMU7 to map in the selected 16k
bank.
.PP
+3 special modes override the MMUs if used.
.PP
Register (W) $60 () \[rA] Copper Data 8-bit Write
.IP \[bu] 2
bits 7-0 = Byte to write to copper instruction memory
.PP
Note that each copper instruction is two bytes long, after a write, the
coppen address is auto-incremented to the next memory position.
.PP
After a write, the index is auto-incremented to the next memory
position.
.PP
Register (W) $61 () \[rA] Copper Address LSB
.IP \[bu] 2
bits 7-0 = Copper instruction memory address LSB (0 on reset)
.PP
Register (W) $62 () \[rA] Copper Control
.IP \[bu] 2
bits 7-6 = Start Control
.RS 2
.IP \[bu] 2
00 = Copper fully stopped
.IP \[bu] 2
01 = Copper start, execute the list from index 0, and loop to the start
.IP \[bu] 2
10 = Copper start, execute the list from last point, and loop to the
start
.IP \[bu] 2
11 = Copper start, execute the list from index 0, and restart the list
when the raster reaches position (0,0)
.RE
.IP \[bu] 2
bits 2-0 = Copper instruction memory address (MSB) (0 on reset)
.PP
Register (W) $63 () \[rA] Copper Data 16-bit Write
.IP \[bu] 2
bits 7-0 = Byte to write to copper instruction memory
.PP
The 16-bit value is written in pairs.
The first 8-bits are the MSB and are destined for an even copper
instruction address.
The sesond 8-bits are the LSB and are destined for an odd copper
instruction address.
.PP
After each write, the copper address is auto-incremented to the next
memory position.
.PP
After a write to an odd address, the all 16-bits are written to copper
memory at once.
.PP
Register (R/W) $64 () \[rA] Vertical Line Count Offset (3.01.05)
.IP \[bu] 2
bits 7-0 = Offset added to the vertical line counter
.IP \[bu] 2
affects copper, line interrupt and active line count.
.PD 0
.P
.PD
Normally the ula\[cq]s pixel row 0 aligns with vertical line count 0.
With a non-zero offset, the ula\[cq]s pixel row 0 will align with the
vertical line offset.
.PD 0
.P
.PD
Eg, if the offset is 32 then vertical line 32 will correspond to the
first pixel row in the ula and vertical line 0 will align with the first
pixel row of the tilemap and sprites.
.PP
* Since a change in offset takes effect when the ula reaches row 0, the
change can take up to one frame to occur.
.PP
Register (R/W) $68 () \[rA] ULA Control
.IP \[bu] 2
bit 7 = Disable ULA output (0 on reset)
.IP \[bu] 2
bit 6-5 = Color blending control for layering modes 6 & 7 (3.01.01)
.RS 2
.IP \[bu] 2
00 = ULA as blend colour
.IP \[bu] 2
01 = No blending
.IP \[bu] 2
10 = ULA/Tilemap mix result as blend colour
.IP \[bu] 2
11 = Tilemap as blend colour
.RE
.IP \[bu] 2
bit 4 = Cancel entries in 8x5 matrix for extended keys (3.01.04)
.IP \[bu] 2
bit 3 = Enable ULAplus (0 on reset)
.IP \[bu] 2
bit 2 = Enable ULA half pixel scroll (0 on reset)
.IP \[bu] 2
may change
.IP \[bu] 2
bit 1 = Reserved (must be 0)
.IP \[bu] 2
bit 0 = Enable stencil mode (0 on reset)
.IP \[bu] 2
When ULA and Layer 3 are enabled, if either are transparent, the result
is transparent, otherwise the result is the logical AND of both colours.
.PP
Register (R/W) $69 () \[rA] Display Control 1
.IP \[bu] 2
bit 7 = Layer 2 Enable (Port $123B bit 1 alias)
.IP \[bu] 2
bit 6 = ULA Shadow display enable (Port $7FFD bit 3 alias)
.IP \[bu] 2
bits 5-0 = Timex alias (Port $FF alias)
.PP
Register (R/W) $6A () \[rA] Layer 1,0 (LoRes) Control
.IP \[bu] 2
bits 7-6 = reserved, must be 0
.IP \[bu] 2
bit 5 = Enable Radistan (16-colour) (0 on reset)
.IP \[bu] 2
bit 4 = Radistan DFILE switch (xor with bit 0 of port $ff) (0 on reset)
.IP \[bu] 2
bits 3-0 = Radistsan palette offset (0 on reset)
.IP \[bu] 2
bits 1-0 = ULAplus palette offset (0 on reset)
.PP
Register (R/W) $6B () \[rA] Layer 3 (Tilemap) Control
.IP \[bu] 2
bit 7 = Layer 3 Enable (0 on reset)
.IP \[bu] 2
bit 6 = Layer 3 Size control (0 on reset)
.RS 2
.IP \[bu] 2
0 = 40x32
.IP \[bu] 2
1 = 80x32
.RE
.IP \[bu] 2
bit 5 = Disable Arrtibute Entry (0 on reset)
.IP \[bu] 2
bit 4 = palette select (0 on reset)
.IP \[bu] 2
bit 3 = Enable Text mode (1-bit tilemap) (0 on reset)
.IP \[bu] 2
bit 2 = Reserved, must be 0
.IP \[bu] 2
bit 1 = Activate 512 tile mode (0 on reset)
.IP \[bu] 2
bit 0 = Enable Layer 3 on top of ULA (0 on reset)
.PP
Register (R/W) $6C () \[rA] Default Layer 3 Attribute*
.IP \[bu] 2
bits 7-4 = Palette Offset ($00 on reset)
.IP \[bu] 2
bit 3 = X mirror (0 on reset)
.IP \[bu] 2
bit 2 = Y mirror (0 on reset)
.IP \[bu] 2
bit 1 = Rotate (0 on reset)
.IP \[bu] 2
bit 0 = Bit 8 of the tile number (512 tile mode) (0 on reset)
.IP \[bu] 2
bit 0 = ULA over tilemap (256 tile mode) (0 on reset)
.PP
*Active tile attribute if bit 5 of nextreg $6B is set.
.PP
Register (R/W) $6E () \[rA] Layer 3 Tilemap Base Address
.IP \[bu] 2
bit 7 = Bank Select (3.01.08)
.RS 2
.IP \[bu] 2
0 = Bank 5
.IP \[bu] 2
1 = Bank 7
.RE
.IP \[bu] 2
bit 6 = Reserved, must be 0
.IP \[bu] 2
bits 5-0 = MSB of address of the tilemap in Bank 5 (16k) or 7 (8k) ($2C
on reset)
.PP
Soft Reset default $2C - This is because the address is $6C00 so the MSB
is $6C.
But the stored value is only the lower 6 bits so it\[cq]s an offset into
the 16k Bank 5.
To calculate therefore subtract $40 leaving you with $2C.
.PP
The value written is an offset into the 16k Bank 5 or the 8k lower half
of Bank 7 allowinf the tilemap to be placed at any multiple of 256
bytes.
.PP
Register (R/W) $6F () \[rA] Layer 3 Tile Definitions Base Address
.IP \[bu] 2
bit 7 = Select bank (3.01.08)
.RS 2
.IP \[bu] 2
0 = Bank 5
.IP \[bu] 2
1 = Bank 7
.RE
.IP \[bu] 2
bit 6 = Reserved, must be 0
.IP \[bu] 2
bits 5-0 = MSB of address of the tile definitions in Bank 5 (16k) or 7
(8k) ($0C on reset)
.PP
Soft Reset default $0C - This is because the address is $4C00 so the MSB
is $4C.
But the stored value is only the lower 6 bits so it\[cq]s an offset into
the 16k Bank 5.
To calculate therefore subtract $40 leaving you with $0C.
.PP
The value written is an offset into the 16k Bank 5 or the 8k lower half
of Bank 7 allowing the tilemap to be placed at any multiple of 256
bytes.
.PP
Register (R/W) $70 () \[rA] Layer 2 Control
.IP \[bu] 2
bits 7-6 = Reserved, must be 0
.IP \[bu] 2
bits 5-4 = Resolution (00 on soft reset)
.RS 2
.IP \[bu] 2
00 = 256\[u2005]\[tmu]\[u2005]192\[u2005]\[tmu]\[u2005]256
.IP \[bu] 2
01 = 320\[u2005]\[tmu]\[u2005]256\[u2005]\[tmu]\[u2005]256
.IP \[bu] 2
10 = 640\[u2005]\[tmu]\[u2005]256\[u2005]\[tmu]\[u2005]16
.IP \[bu] 2
11 = Do not use
.RE
.IP \[bu] 2
bits 3-0 = Palette offset ($0 on soft reset)
.PP
Register (R/W) $71 () \[rA] Layer 2 X Scroll MSB
.IP \[bu] 2
bits 7-1 = Reserved, must be 0
.IP \[bu] 2
bits 0 = MSB of X Offset
.PP
Register (W) $75 () \[rA] Sprite Attribute 0 (Auto-incrementing)
.PD 0
.P
.PD
See nextreg $35
.PP
Register (W) $76 () \[rA] Sprite Attribute 1 (Auto-incrementing)
.PD 0
.P
.PD
See nextreg $36
.PP
Register (W) $77 () \[rA] Sprite Attribute 2 (Auto-incrementing)
.PD 0
.P
.PD
See nextreg $37
.PP
Register (W) $78 () \[rA] Sprite Attribute 3 (Auto-incrementing)
.PD 0
.P
.PD
See nextreg $38
.PP
Register (W) $79 () \[rA] Sprite Attribute 4 (Auto-incrementing)
.PD 0
.P
.PD
See nextreg $39
.PP
Register (R/W) $7F () \[rA] User Register 0
.IP \[bu] 2
bits 7-0 = User Register ($FF on hard reset)
.PP
Caution NextReg numbers above $7F are inaccessible to the Copper
.PP
Register (R/W) $80 () \[rA] Expansion Bus Enable
.PD 0
.P
.PD
Immediate
.IP \[bu] 2
bit 7 = Expansion Bus Enable (0 on hard reset)(3.01.07)
.IP \[bu] 2
bit 6 = Enable ROMCS ROM replacement from divmmc banks 14/15
(experimental, 3.01.03)
.IP \[bu] 2
bit 5 = I/O cycle Disable/Ignore $\[rs]overline{\[rs]hbox{IORQULA}}$ (0
on hard reset)
.IP \[bu] 2
bit 4 = Memory cycle Disable/Ignore $\[rs]overline{\[rs]hbox{ROMCS}}$ (0
on hard reset)
.PP
After Soft Reset (Copied into bits 7-4)
.IP \[bu] 2
bit 3 = Expansion Bus Enable (0 on hard reset)
.IP \[bu] 2
bit 2 = Enable ROMCS ROM replacement from divmmc banks 14/15
(experimental, 3.01.03)
.IP \[bu] 2
bit 1 = I/O cycle Disable/Ignore $\[rs]overline{\[rs]hbox{IORQULA}}$ (0
on hard reset)
.IP \[bu] 2
bit 0 = Memory cycle Disable/Ignore $\[rs]overline{\[rs]hbox{ROMCS}}$ (0
on hard reset)
.PP
Register (R/W) $81 () \[rA] Expansion Bus Control
.IP \[bu] 2
bit 7 = (R) Expansion bus $\[rs]overline{\[rs]hbox{ROMCS}}$ asserted
.IP \[bu] 2
bit 6 = Allow peripherials to override the ULA on some even port reads
($00-$0E)(Rotoronics Wafadrive)(3.01.07)
.IP \[bu] 2
bit 5 = Disable expansion bus NMI debounce (Opus Discovery)(3.01.07)
.IP \[bu] 2
bit 4 = (W) Propagate max CPU clock at all times (0 on hard reset)
.IP \[bu] 2
bits 3-2 = Reserved, must be 0
.IP \[bu] 2
bits 1-0 = Max CPU Speed when Expansion Bus is enabled ($00 on hard
reset, currently fixed at $00)
.RS 2
.IP \[bu] 2
00 = 3.5 MHz
.IP \[bu] 2
01 = 7 MHz
.IP \[bu] 2
10 = 14 MHz
.IP \[bu] 2
11 = 28 MHz
.RE
.PP
Register (R/W) $82 () \[rA] Internal Port decoding control 1/4
.IP \[bu] 2
bit 7 = Enable Kempston Port 2 (Port $37) (1 on reset)
.IP \[bu] 2
bit 6 = Enable Kempston Port 1 (Port $1F) (1 on reset)
.IP \[bu] 2
bit 5 = Enable DMA (Port $6B) (1 on reset)
.IP \[bu] 2
bit 4 = Enable +3 Floating Bus (1 on reset)
.IP \[bu] 2
bit 3 = Enable +3 Paging (Port $1FFD) (1 on reset)
.IP \[bu] 2
bit 2 = Enable Next Memory Paging (Port $DFFD) (1 on reset)
.IP \[bu] 2
bit 1 = Enable Paging (Port $7FFD) (1 on reset)
.IP \[bu] 2
bit 0 = Enable Timex (Port $FF) (1 on reset)
.PP
Register (R/W) $83 () \[rA] Internal Port decoding control 2/4
.IP \[bu] 2
bit 7 = Enable Layer 2 (Port $123B) (1 on reset)
.IP \[bu] 2
bit 6 = Enable Sprites (Ports $57, $5B, $303B) (1 on reset)
.IP \[bu] 2
bit 5 = Enable Kempston Mouse (Ports $FADF, $FBDF, $FFDF) (1 on reset)
.IP \[bu] 2
bit 4 = Enable UART (Ports $133B, $143B, $153B) (1 on reset)
.IP \[bu] 2
bit 3 = Enable SPI (Ports $E7, $EB) (1 on reset)
.IP \[bu] 2
bit 2 = Enable I^2^C (Ports $103B, $113B) (1 on reset)
.IP \[bu] 2
bit 1 = Enable Multiface (two variable ports) (1 on reset)
.IP \[bu] 2
bit 0 = Enable divMMC (Port $E3) (1 on reset)
.PP
Register (R/W) $84 () \[rA] Internal Port decoding control 3/4
.IP \[bu] 2
bit 7 = Enable SPECdrum Mono DAC (Port $DF) (1 on reset)
.IP \[bu] 2
bit 6 = Enable Covox/GS Mono DAC (Port $B3) (1 on reset)
.IP \[bu] 2
bit 5 = Enable Pentagon/ATM DAC (Port $FB) (1 on reset)
.IP \[bu] 2
bit 4 = Enable Covox Stereo DAC (Ports $0F, $4F) (1 on reset)
.IP \[bu] 2
bit 3 = Enable Profi/Covox Stereo DAC (Ports $3F, $5F) (1 on reset)
.IP \[bu] 2
bit 2 = Enable Soundrive DAC Mode 2 (Ports $F1, $F3, $F9, $FB) (1 on
reset)
.IP \[bu] 2
bit 1 = Enable Soundrive DAC Mode 1 (Ports $0F, $1F, $4F, $5F) (1 on
reset)
.IP \[bu] 2
bit 0 = Enable AY (Ports $FFFD, $BFFD) (1 on reset)
.PP
Register (R/W) $85 () \[rA] Internal Port decoding control 4/4
.IP \[bu] 2
bit 7 = Enable configuration of port decoding on soft reset (3.01.01)
.IP \[bu] 2
bits 6-4 = Reserved
.IP \[bu] 2
bit 3 = Enable Z80 CTC ports $183B, $193B, $1A3B, $1B3B, $1C3B, $1D3B,
$1E3B, and $1F3B
.IP \[bu] 2
bit 2 = Enable Pentagon 1024 memory port $EFF7
.IP \[bu] 2
bit 1 = Enable DMA port $0B (3.01.02)
.IP \[bu] 2
bit 0 = Enable ULAplus (Ports $BF3B, $FF3B) (1 on reset)
.PP
Register (R/W) $86 () \[rA] Expansion Port decoding control 1/4
.IP \[bu] 2
bit 7 = Enable Kempston Port 2 (Port $37) (1 on reset)
.IP \[bu] 2
bit 6 = Enable Kempston Port 1 (Port $1F) (1 on reset)
.IP \[bu] 2
bit 5 = Enable DMA (Port $6B) (1 on reset)
.IP \[bu] 2
bit 4 = Enable +3 Floating Bus (1 on reset)
.IP \[bu] 2
bit 3 = Enable +3 Paging (Port $1FFD) (1 on reset)
.IP \[bu] 2
bit 2 = Enable Next Memory Paging (Port $DFFD) (1 on reset)
.IP \[bu] 2
bit 1 = Enable Paging (Port $7FFD) (1 on reset)
.IP \[bu] 2
bit 0 = Enable Timex (Port $FF) (1 on reset)
.PP
Register (R/W) $87 () \[rA] Expansion Port decoding control 2/4
.IP \[bu] 2
bit 7 = Enable Layer 2 (Port $123B) (1 on reset)
.IP \[bu] 2
bit 6 = Enable Sprites (Ports $57, $5B, $303B) (1 on reset)
.IP \[bu] 2
bit 5 = Enable Kempston Mouse (Ports $FADF, $FBDF, $FFDF) (1 on reset)
.IP \[bu] 2
bit 4 = Enable UART (Ports $133B, $143B, $153B) (1 on reset)
.IP \[bu] 2
bit 3 = Enable SPI (Ports $E7, $EB) (1 on reset)
.IP \[bu] 2
bit 2 = Enable I^2^C (Ports $103B, $113B) (1 on reset)
.IP \[bu] 2
bit 1 = Enable Multiface (two variable ports) (1 on reset)
.IP \[bu] 2
bit 0 = Enable divMMC (Port $E3) (1 on reset)
.PP
Register (R/W) $88 () \[rA] Expansion Port decoding control 3/4
.IP \[bu] 2
bit 7 = Enable SPECdrum Mono DAC (Port $DF) (1 on reset)
.IP \[bu] 2
bit 6 = Enable Covox/GS Mono DAC (Port $B3) (1 on reset)
.IP \[bu] 2
bit 5 = Enable Pentagon/ATM DAC (Port $FB) (1 on reset)
.IP \[bu] 2
bit 4 = Enable Covox Stereo DAC (Ports $0F, $4F) (1 on reset)
.IP \[bu] 2
bit 3 = Enable Profi/Covox Stereo DAC (Ports $3F, $5F) (1 on reset)
.IP \[bu] 2
bit 2 = Enable Soundrive DAC Mode 2 (Ports $F1, $F3, $F9, $FB) (1 on
reset)
.IP \[bu] 2
bit 1 = Enable Soundrive DAC Mode 1 (Ports $0F, $1F, $4F, $5F) (1 on
reset)
.IP \[bu] 2
bit 0 = Enable AY (Ports $FFFD, $BFFD) (1 on reset)
.PP
Register (R/W) $89 () \[rA] Expansion Port decoding control 4/4
.IP \[bu] 2
bit 7 = Enable configuration of port decoding on soft reset (3.01.01)
.IP \[bu] 2
bits 6-4 = Reserved
.IP \[bu] 2
bit 3 = Enable Z80 CTC ports $183B, $193B, $1A3B, $1B3B, $1C3B, $1D3B,
$1E3B, and $1F3B
.IP \[bu] 2
bit 2 = Enable Pentagon 1024 memory port $EFF7
.IP \[bu] 2
bit 1 = Enable DMA port $0B (3.01.02)
.IP \[bu] 2
bit 0 = Enable ULAplus (Ports $BF3B, $FF3B) (1 on reset)
.PP
The Internal Port Decoding Enables always apply.
.PP
When the Expansion Bus is enabled, the Expansion Bus Port Decoding
Enables are logically ANDed with the Internal Enables.
A result of 0 for the corresponding bit indicates the internal device is
\f[I]disabled\f[R].
If the Expansion Bus is enabled, this allows I/O cycles for disabled
ports to propagate to the Expansion Bus, otherwise corresponding I/O
cycles to the Expansion Bus are filtered.
.PP
Register (R/W) $8A () \[rA] Expansion Bus I/O Propagate Control
.IP \[bu] 2
bits 7-3 = Reserved, must be 0
.IP \[bu] 2
bit 4 = Propagate port $FF I/O Cycles (0 on hard reset, 3.01.02)
.IP \[bu] 2
bit 3 = Propagate port $1FFD I/O Cycles (0 on hard reset)
.IP \[bu] 2
bit 2 = Propagate port $DFFD I/O Cycles (0 on hard reset)
.IP \[bu] 2
bit 1 = Propagate port $7FFD I/O Cycles (0 on hard reset)
.IP \[bu] 2
bit 0 = Propagate port $FE I/O Cycles (1 on hard reset, 3.01.03: 0 on
hard reset)
.PP
Register (R/W) $8C () \[rA] Alternate ROM
.PD 0
.P
.PD
Immediate
.IP \[bu] 2
bit 7 = Alt ROM Enable (0 on hard reset)
.IP \[bu] 2
bit 6 = Alt ROM visible ONLY during writes (0 on hard reset)
.IP \[bu] 2
bit 5 = Reserved, must be 0
.IP \[bu] 2
bit 4 = 48k ROM Lock (0 on hard reset)
.PP
After Soft Reset (copied into bits 7-4)
.IP \[bu] 2
bit 3 = Alt ROM Enable (0 on hard reset)
.IP \[bu] 2
bit 2 = Alt ROM visible ONLY during writes (0 on hard reset)
.IP \[bu] 2
bit 1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = 48k ROM Lock (0 on hard reset)
.PP
Register (R/W) $8E () \[rA] Spectrum 128k Memory Mapping (3.01.01)
.IP \[bu] 2
bit 7 = Bank number bit 3 (port $dffd bit 0)
.IP \[bu] 2
bit 6-4 = Bank number bits 2-0 (port $7ffd bits 2-0)
.IP \[bu] 2
bit 3 = Enable change ram page (read as 1)
.IP \[bu] 2
bit 2 = Paging mode (port $1ffd bit 0)
.RS 2
.IP \[bu] 2
0 = Normal paging mode
.IP \[bu] 2
1 = Special paging mode (lot bit of memory configuration)
.RE
.IP \[bu] 2
Normal Paging Mode
.IP \[bu] 2
bits 1-0 = ROM selection (port $1ffd bit 1 and $7ffd bit 4)
.IP \[bu] 2
Special (all RAM) Paging Mode
.IP \[bu] 2
bits 1-0 = RAM configuration selection (port $1ffd bits 2-1)
.PP
Writes can affect all ports $7ffd, $dffd, and $1ffd
.PD 0
.P
.PD
Writes can always change the ROM/allRAM mapping
.PD 0
.P
.PD
Writes immediately change the current MMU mapping as if by port write.
.PP
Register (R/W) $8F () \[rA] Memory Mapping Mode (3.01.06)
.IP \[bu] 2
bits 7-2 = Reserved, must be zero
.IP \[bu] 2
bits 1-0 = Mapping mode applied
.RS 2
.IP \[bu] 2
00 = Standard ZX 128k +3
.IP \[bu] 2
01 = Profi (removed in 3.01.09)
.IP \[bu] 2
10 = Pentagon 512k
.IP \[bu] 2
11 = Pentagon 1024k (limited to 768k on 1MB machines)
.RE
.PP
* Standard ZX 128k +3 = principally ports $7FFD, $DFFD, and $1FFD
.PD 0
.P
.PD
* Pentagon 512k = principally port $7FFD
.PD 0
.P
.PD
* Pentagon 1024k = principally ports $7FFD and $EFF7
.PD 0
.P
.PD
** The mapping modes affect how ports $7FFD, $DFFD, $1FFD, and $EFF7
carry out memory paging, see ports
.PP
Register (R/W) $90 () \[rA] Pi GPIO output enable 1/4
.IP \[bu] 2
bit 7 = Enable Pin 7 (0 on reset)
.IP \[bu] 2
bit 6 = Enable Pin 6 (0 on reset)
.IP \[bu] 2
bit 5 = Enable Pin 5 (0 on reset)
.IP \[bu] 2
bit 4 = Enable Pin 4 (0 on reset)
.IP \[bu] 2
bit 3 = Enable Pin 3 (0 on reset)
.IP \[bu] 2
bit 2 = Enable Pin 2 (0 on reset)
.IP \[bu] 2
bit 1 = Enable Pin 1 (cannot be enabled) (0 on reset)
.IP \[bu] 2
bit 0 = Enable Pin 0 (cannot be enabled) (0 on reset)
.PP
Register (R/W) $91 () \[rA] Pi GPIO output enable 2/4
.IP \[bu] 2
bit 7 = Enable Pin 15 (0 on reset)
.IP \[bu] 2
bit 6 = Enable Pin 14 (0 on reset)
.IP \[bu] 2
bit 5 = Enable Pin 13 (0 on reset)
.IP \[bu] 2
bit 4 = Enable Pin 12 (0 on reset)
.IP \[bu] 2
bit 3 = Enable Pin 11 (0 on reset)
.IP \[bu] 2
bit 2 = Enable Pin 10 (0 on reset)
.IP \[bu] 2
bit 1 = Enable Pin 9 (0 on reset)
.IP \[bu] 2
bit 0 = Enable Pin 8 (0 on reset)
.PP
Register (R/W) $92 () \[rA] Pi GPIO output enable 3/4
.IP \[bu] 2
bit 7 = Enable Pin 23 (0 on reset)
.IP \[bu] 2
bit 6 = Enable Pin 22 (0 on reset)
.IP \[bu] 2
bit 5 = Enable Pin 21 (0 on reset)
.IP \[bu] 2
bit 4 = Enable Pin 20 (0 on reset)
.IP \[bu] 2
bit 3 = Enable Pin 19 (0 on reset)
.IP \[bu] 2
bit 2 = Enable Pin 18 (0 on reset)
.IP \[bu] 2
bit 1 = Enable Pin 17 (0 on reset)
.IP \[bu] 2
bit 0 = Enable Pin 16 (0 on reset)
.PP
Register (R/W) $93 () \[rA] Pi GPIO output enable 4/4
.IP \[bu] 2
bits 7-4 = Reserved
.IP \[bu] 2
bit 3 = Enable Pin 27 (0 on reset)
.IP \[bu] 2
bit 2 = Enable Pin 26 (0 on reset)
.IP \[bu] 2
bit 1 = Enable Pin 25 (0 on reset)
.IP \[bu] 2
bit 0 = Enable Pin 24 (0 on reset)
.PP
Register (R/W) $98 () \[rA] Pi GPIO Pin State 1/4
.IP \[bu] 2
bit 7 = Pin 7 Data (1 on reset)
.IP \[bu] 2
bit 6 = Pin 6 Data (1 on reset)
.IP \[bu] 2
bit 5 = Pin 5 Data (1 on reset)
.IP \[bu] 2
bit 4 = Pin 4 Data (1 on reset)
.IP \[bu] 2
bit 3 = Pin 3 Data (1 on reset)
.IP \[bu] 2
bit 2 = Pin 2 Data (1 on reset)
.IP \[bu] 2
bit 1 = Pin 1 Data (1 on reset)
.IP \[bu] 2
bit 0 = Pin 0 Data (1 on reset)
.PP
Register (R/W) $99 () \[rA] Pi GPIO Pin State 2/4
.IP \[bu] 2
bit 7 = Pin 15 Data (1 on reset)
.IP \[bu] 2
bit 6 = Pin 14 Data (1 on reset)
.IP \[bu] 2
bit 5 = Pin 13 Data (1 on reset)
.IP \[bu] 2
bit 4 = Pin 12 Data (1 on reset)
.IP \[bu] 2
bit 3 = Pin 11 Data (1 on reset)
.IP \[bu] 2
bit 2 = Pin 10 Data (1 on reset)
.IP \[bu] 2
bit 1 = Pin 9 Data (1 on reset)
.IP \[bu] 2
bit 0 = Pin 8 Data (1 on reset)
.PP
Register (R/W) $9A () \[rA] Pi GPIO Pin State 3/4
.IP \[bu] 2
bit 7 = Pin 23 Data (1 on reset)
.IP \[bu] 2
bit 6 = Pin 22 Data (1 on reset)
.IP \[bu] 2
bit 5 = Pin 21 Data (1 on reset)
.IP \[bu] 2
bit 4 = Pin 20 Data (1 on reset)
.IP \[bu] 2
bit 3 = Pin 19 Data (1 on reset)
.IP \[bu] 2
bit 2 = Pin 18 Data (1 on reset)
.IP \[bu] 2
bit 1 = Pin 17 Data (1 on reset)
.IP \[bu] 2
bit 0 = Pin 16 Data (1 on reset)
.PP
Register (R/W) $9B () \[rA] Pi GPIO Pin State 4/4
.IP \[bu] 2
bits 7-4 = Reserved
.IP \[bu] 2
bit 3 = Pin 27 Data (1 on reset)
.IP \[bu] 2
bit 2 = Pin 26 Data (1 on reset)
.IP \[bu] 2
bit 1 = Pin 25 Data (1 on reset)
.IP \[bu] 2
bit 0 = Pin 24 Data (1 on reset)
.PP
Register (R/W) $A0 () \[rA] Pi Peripheral Enable
.IP \[bu] 2
bits 7-6 = Reserved, must be 0
.IP \[bu] 2
bit 5 = Enable UART on GPIO 14, 15 (0 on reset)*
.IP \[bu] 2
bit 4 = Communication Type (0 on reset)
.RS 2
.IP \[bu] 2
0 = Rx to GPIO 15, Tx to GPIO 14 (Pi)
.IP \[bu] 2
1 = Rx to GPIO 14, Tx to GPIO 15 (Pi Hats)
.RE
.IP \[bu] 2
bit 3 = Enable I^2^C on GPIO 2, 3 (0 on reset)*
.IP \[bu] 2
bits 2-1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = Enable SPI on GPIO 7, 8, 9, 10, 11 (0 on reset)*
.PP
*Overrides GPIO Enables
.PP
Register (R/W) $A2 () \[rA] Pi I^2^S Audio Control
.IP \[bu] 2
bits 7-6 = I^2^S State ($00 on reset)
.RS 2
.IP \[bu] 2
00 = I^2^S Disabled
.IP \[bu] 2
01 = I^2^S is mono, source R
.IP \[bu] 2
10 = I^2^S is mono, source L
.IP \[bu] 2
11 = I^2^S is stereo
.RE
.IP \[bu] 2
bit 5 = Reserved, must be 0
.IP \[bu] 2
bit 4 = Audio Flow Direction (0 on reset)
.RS 2
.IP \[bu] 2
0 = PCM_DOUT to Pi, PCM_DIN from Pi (Hats)
.IP \[bu] 2
1 = PCM_DOUT from Pi, PCM_DIN to Pi (Pi)
.RE
.IP \[bu] 2
bit 3 = Mute left (0 on reset)
.IP \[bu] 2
bit 2 = Mute right (0 on reset)
.IP \[bu] 2
bit 1 = Slave mode, Reserved must be 1 (remove in 3.01.05)
.IP \[bu] 2
bit 0 = Direct I^2^S audio to EAR on port $FE (0 on reset)
.PP
Register (R/W) $A3 () \[rA] Pi I^2^S Clock Divide (Master Mode) (removed
in 3.01.05)
.IP \[bu] 2
bits 7-0 = Clock divide value ($0B on reset)
.PP
$\[rs]hbox{Divider}=\[rs]frac{538461}{\[rs]hbox{Rate}}-1$ or
$\[rs]hbox{Rate}=\[rs]frac{538461}{\[rs]hbox{Divider}+1}$
.PP
Register (R/W) $A8 () \[rA] ESP WiFi GPIO Output Enable
.IP \[bu] 2
bits 7-3 = Reserved, must be sero
.IP \[bu] 2
bit 2 = GPIO2 output enable (fixed at 0, GPIO2 is read-only)
.IP \[bu] 2
bit 1 = Reserved, must be zero
.IP \[bu] 2
bit 0 = GPIO0 output enable (fixed at 0, GPIO2 is read-only)
.PP
Register (R/W) $A9 () \[rA] ESP WiFi GPIO
.IP \[bu] 2
bits 7-3 = Reserved, must be sero
.IP \[bu] 2
bit 2 = Read/Write GPIO2 (reset = 1)
.IP \[bu] 2
bit 1 = Reserved, must be zero
.IP \[bu] 2
bit 0 = Read/Write GPIO0 (reset = 1)
.PP
Register (R) $B0 () \[rA] Extended Keys 0 (3.01.04)
.IP \[bu] 2
bit 7 = 1 if ; pressed
.IP \[bu] 2
bit 6 = 1 if p\[u0308]ressed
.IP \[bu] 2
bit 5 = 1 if , pressed
.IP \[bu] 2
bit 4 = 1 if .
pressed
.IP \[bu] 2
bit 3 = 1 if UP pressed
.IP \[bu] 2
bit 2 = 1 if DOWN pressed
.IP \[bu] 2
bit 1 = 1 if LEFT pressed
.IP \[bu] 2
bit 0 = 1 if RIGHT pressed
.PP
Register (R) $B1 () \[rA] Extended Keys 1 (3.01.04)
.IP \[bu] 2
bit 7 = 1 if DELETE pressed
.IP \[bu] 2
bit 6 = 1 if EDIT pressed
.IP \[bu] 2
bit 5 = 1 if BREAK pressed
.IP \[bu] 2
bit 4 = 1 if INV VIDEO pressed
.IP \[bu] 2
bit 3 = 1 if TRUE VIDEO pressed
.IP \[bu] 2
bit 2 = 1 if GRAPH pressed
.IP \[bu] 2
bit 1 = 1 if CAPS LOCK pressed
.IP \[bu] 2
bit 0 = 1 if EXTEND pressed
.PP
Register (R/W) $C0 () \[rA] Interrupt Control (3.01.09)
.PD 0
.P
.PD
($00 on reset)
.IP \[bu] 2
bits 7-5 = Programmable portion of IM2 vector *
.IP \[bu] 2
bit 4 = Reserved, must be 0
.IP \[bu] 2
bit 3 = Enable stackless $\[rs]overline{\[rs]hbox{NMI}}$ response
.IP \[bu] 2
bits 2-1 = Reserved, must be 0
.IP \[bu] 2
bit 0 = Maskable interrupt mode
.RS 2
.IP \[bu] 2
0 - pulse
.IP \[bu] 2
1 - IM2
.RE
.PP
* In IM2 mode vector generated is:
.IP \[bu] 2
bits 7-5 = nextreg $C0 bits 7-5
.IP \[bu] 2
bits 4-1 = Interrupt source
.RS 2
.IP \[bu] 2
0 - line interrupt (highest priority)
.IP \[bu] 2
1 - UART 0 Rx
.IP \[bu] 2
2 - UART 1 Rx
.IP \[bu] 2
3\[en]10 - CTC channels 0-7
.IP \[bu] 2
11 - ULA
.IP \[bu] 2
12 - UART 0 Tx
.IP \[bu] 2
13 - UART 1 Tx (lowest priority)
.RE
.IP \[bu] 2
bit 0 = 0
.PP
Register (R/W) $C2 () \[rA] $\[rs]overline{\[rs]hbox{NMI}}$ Return
Address LSB (3.01.09)
.PD 0
.P
.PD
($00 on reset)
.PP
Register (R/W) $C3 () \[rA] $\[rs]overline{\[rs]hbox{NMI}}$ Return
Address MSB (3.01.09)
.PD 0
.P
.PD
($00 on reset)
.PP
Register (R/W) $C4 () \[rA] Interrupt Enable 0 (3.01.08)
.PD 0
.P
.PD
($83 on reset)
.IP \[bu] 2
bit 7 = Expansion bus $\[rs]overline{\[rs]hbox{INT}}$
.IP \[bu] 2
bits 6-2 = Reserved must be zero
.IP \[bu] 2
bit 1 = Line
.IP \[bu] 2
bit 0 = ULA
.PP
Register (R/W) $C5 () \[rA] Interrupt Enable 1 (3.01.08)
.PD 0
.P
.PD
($00 on reset)
.IP \[bu] 2
bit 7 = ctc channel 7 zc/to
.IP \[bu] 2
bit 6 = ctc channel 6 zc/to
.IP \[bu] 2
bit 5 = ctc channel 5 zc/to
.IP \[bu] 2
bit 4 = ctc channel 4 zc/to
.IP \[bu] 2
bit 3 = ctc channel 3 zc/to
.IP \[bu] 2
bit 2 = ctc channel 2 zc/to
.IP \[bu] 2
bit 1 = ctc channel 1 zc/to
.IP \[bu] 2
bit 0 = ctc channel 0 zc/to
.PP
Register (W) $C6 () \[rA] Interrupt Enable 2 (3.01.08)
.PD 0
.P
.PD
($00 on reset)
.IP \[bu] 2
bit 7 = Reserved, must be 0
.IP \[bu] 2
bit 6 = UART1 Tx empty
.IP \[bu] 2
bit 5 = UART1 Rx half full *
.IP \[bu] 2
bit 4 = UART1 Rx available *
.IP \[bu] 2
bit 3 = Reserved, must be 0
.IP \[bu] 2
bit 2 = UART0 Tx empty
.IP \[bu] 2
bit 1 = UART0 Rx half full *
.IP \[bu] 2
bit 0 = UART0 Rx available *
.PP
* For each UART, Rx half full and Rx available are shared interrupts
.PP
Register (W) $C7 () \[rA] Reserved (3.01.09)
.PP
Register (R/W) $C8 () \[rA] Interrupt Status 0 (3.01.09)
.PD 0
.P
.PD
($00 on reset)
.IP \[bu] 2
bits 7-2 = Reserved, must be zero
.IP \[bu] 2
bit 1 = Line
.IP \[bu] 2
bit 0 = ULA
.PP
* Set bits indicate the device generated an interrupt in the past *
Writes clear bits where bits are set except in IM2 mode
.PP
Register (R/W) $C9 () \[rA] Interrupt Status 1 (3.01.09)
.IP \[bu] 2
bit 7 = ctc channel 7 zc/to
.IP \[bu] 2
bit 6 = ctc channel 6 zc/to
.IP \[bu] 2
bit 5 = ctc channel 5 zc/to
.IP \[bu] 2
bit 4 = ctc channel 4 zc/to
.IP \[bu] 2
bit 3 = ctc channel 3 zc/to
.IP \[bu] 2
bit 2 = ctc channel 2 zc/to
.IP \[bu] 2
bit 1 = ctc channel 1 zc/to
.IP \[bu] 2
bit 0 = ctc channel 0 zc/to
.PP
* Set bits indicate the device generated an interrupt in the past *
Writes clear bits where bits are set except in IM2 mode
.PP
Register (R/W) $CA () \[rA] Interrupt Status 2 (3.01.09) ($00 on reset)
.IP \[bu] 2
bit 7 = Reserved, must be zero
.IP \[bu] 2
bit 6 = UART1 Tx empty
.IP \[bu] 2
bit 5 = UART1 Rx almost full *
.IP \[bu] 2
bit 4 = UART1 Rx available *
.IP \[bu] 2
bit 3 = Reserved must be zero
.IP \[bu] 2
bit 2 = UART0 Tx empty
.IP \[bu] 2
bit 1 = UART0 Rx almost full *
.IP \[bu] 2
bit 0 = UART0 Rx available *
.PP
* For each UART Rx half full and Rx available are shared interrupts **
Set bits indicate the device generated an interrupt in the past **
Writes clear bits where bits are set except in IM2 mode
.PP
Register (W) $CB () \[rA] Reserved (3.01.09)
.PP
Register (R/W) $CC () \[rA] DMA Interrupt Enable 0 (3.01.09) ($00 on
reset)
.IP \[bu] 2
bits 7-2 = Reserved, must be 0
.IP \[bu] 2
bit 1 = Line
.IP \[bu] 2
bit 0 = ULA
.PP
* Set bits indicate the specified interrupt will interrupt a DMA
operation when in IM2 mode
.PP
Register (R/W) $CD () \[rA] DMA Interrupt Enable 1 (3.01.09) ($00 on
reset)
.IP \[bu] 2
bit 7 = CTC channel 7 zc/to
.IP \[bu] 2
bit 6 = CTC channel 6 zc/to
.IP \[bu] 2
bit 5 = CTC channel 5 zc/to
.IP \[bu] 2
bit 4 = CTC channel 4 zc/to
.IP \[bu] 2
bit 3 = CTC channel 3 zc/to
.IP \[bu] 2
bit 2 = CTC channel 2 zc/to
.IP \[bu] 2
bit 1 = CTC channel 1 zc/to
.IP \[bu] 2
bit 0 = CTC channel 0 zc/to
.PP
* Set bits indicate the corresponding interrupt will interrupt a DMA
operation when in IM2 mode
.PP
Register (R/W) $CE () \[rA] DMA Interrupt Enable 2 (3.01.09) ($00 on
reset)
.IP \[bu] 2
bit 7 = Reserved, must be 0
.IP \[bu] 2
bit 6 = UART1 Tx empty
.IP \[bu] 2
bit 5 = UART1 Rx half full
.IP \[bu] 2
bit 4 = UART1 Rx available
.IP \[bu] 2
bit 3 = Reserved, must be 0
.IP \[bu] 2
bit 2 = UART0 Tx empty
.IP \[bu] 2
bit 1 = UART0 Tx half full
.IP \[bu] 2
bit 0 = UART0 Tx available
.PP
* Set bits indicate the corresponding interrupt will interrupt a DMA
operation when in IM2 mode.
.PP
Register (W) $CF () \[rA] Reserved (3.01.09)
.PP
Register (W) $FF () \[rA] Debug LEDs (DE-1, DE-2 am Multicore only)
.SS AY-3-8912
.PP
(R/W) $00 (0) \[rA] Channel A fine tune
.IP \[bu] 2
bits 7-0 = Channel A frequency bits 7-0
.PP
(R/W) $01 (1) \[rA] Channel A coarse tune
.IP \[bu] 2
bits 7-4 = Reserved
.IP \[bu] 2
bits 4-0 = Channel A frequency bits 11-8
.PP
(R/W) $02 (0) \[rA] Channel B fine tune
.IP \[bu] 2
bits 7-0 = Channel A frequency bits 7-0
.PP
(R/W) $03 (1) \[rA] Channel B coarse tune
.IP \[bu] 2
bits 7-4 = Reserved
.IP \[bu] 2
bits 4-0 = Channel A frequency bits 11-8
.PP
(R/W) $04 (0) \[rA] Channel C fine tune
.IP \[bu] 2
bits 7-0 = Channel A frequency bits 7-0
.PP
(R/W) $05 (1) \[rA] Channel C coarse tune
.IP \[bu] 2
bits 7-4 = Reserved
.IP \[bu] 2
bits 4-0 = Channel A frequency bits 11-8
.PP
(R/W) $06 (6) \[rA] Noise period
.IP \[bu] 2
bits 7-5 = Reserved
.IP \[bu] 2
bits 4-0 = Noise period to noise generator
.PP
(R/W) $07 (7) \[rA] Mixer control I/O Enable
.IP \[bu] 2
Active low (0=enable, 1= disable)
.IP \[bu] 2
bit 7-6: Reserved
.IP \[bu] 2
bit 5: Channel C noise enable
.IP \[bu] 2
bit 4: Channel B noise enable
.IP \[bu] 2
bit 3: Channel A noise enable
.IP \[bu] 2
bit 2: Channel C tone enable
.IP \[bu] 2
bit 1: Channel B tone enable
.IP \[bu] 2
bit 0: Channel A tone enable
.PP
(R/W) $0A (10) \[rA] Channel A amplitude
.IP \[bu] 2
bits 7-5 = Reserved
.IP \[bu] 2
bit 4 = Amplitude mode
.RS 2
.IP \[bu] 2
0=fixed amplitude
.IP \[bu] 2
1=use envelope generator (bits 0-3 ignored)
.RE
.IP \[bu] 2
bits 0-3 = value of fixed amplitude
.PP
(R/W) $0B (11) \[rA] Channel B amplitude
.IP \[bu] 2
like channel A amplitude
.PP
(R/W) $0C (12) \[rA] Channel C amplitude
.IP \[bu] 2
like channel A amplitude
.PP
(R/W) $0D (13) \[rA] Envelope period fine
.IP \[bu] 2
bits 7-0 = Envelop period LSB
.PP
(R/W) $0E (14) \[rA] Envelope period coarse
.IP \[bu] 2
bits 7-0 = Envelop period MSB
.PP
(R/W) $0F (15) \[rA] Envelope shape
.IP \[bu] 2
bits 7-4 = Reserved
.IP \[bu] 2
bit 3 = Continue
.RS 2
.IP \[bu] 2
0=drop to amplitude 0 after 1 cycle
.IP \[bu] 2
1=use `Hold' value
.RE
.IP \[bu] 2
bit 2 = Attack
.RS 2
.IP \[bu] 2
0=generator counts down
.IP \[bu] 2
1=generator counts up
.RE
.IP \[bu] 2
bit 1-0 = Alternate & Hold
.RS 2
.IP \[bu] 2
00=generator resets after each cycle
.IP \[bu] 2
01=hold final value
.IP \[bu] 2
10=generator reverses direction each cycle
.IP \[bu] 2
11=hold initial value
.RE
.SS zxDMA
.SH Extended Opcodes to Mnemonics
.SS Single Byte Opcodes
.PP
&&&&&&&&&
.PP
&&&&&&&&&
.PP
&&&&&&&&&
.PP
&&&&&&&&&
.PP
&&&&&&&&&
.PP
&&&&&&&&&
.PP
&&&&&&&&&
.PP
&&&&&&&&&
.SS $CBxx Bit Operations
.PP
&&&&&&&
.PP
&&&&&&&
.PP
&&&&&&&
.PP
&&&&&&&
.PP
&&&&&&&
.PP
&&&&&&&
.PP
&&&&&&&
.PP
&&&&&&&
.SS $DDxx IX
.PP
&&&&&&&
.PP
&&&&&&&
.PP
&&&&&&&
.SS $EDxx Block/Port
.PP
&&&&&&&
.PP
* ZX Spectrum Next extension
.PP
&&&&&&&
.PP
&&&&&&&
.PP
* ZX Spectrum Next extension
.SS $FDxx IY
.PP
&&&&&&&
.PP
&&&&&&&
.PP
&&&&&&&
.SS $DDCBxx IX Bit Operations
.PP
&&&&&&&
.SS $FDCBxx IY Bit Operations
.PP
&&&&&&&
.SH Mnemonics to Extended Opcodes
.SH File Formats
.SS AKY
.PP
Music file
.SS BAS
.PP
Basic file
.SS BMP
.PP
Windows bitmap.
On the ZX Spectrum next, these must be uncompressed and 8 bpp.
.SS DSK
.PP
Disk image
.SS ESP
.PP
Update file for Wi-Fi module
.SS GDE
.PP
ZX Spectrum Next Guide hypertext file
.SS MC
.PP
A Timex hi-color image.
Like .shc, but the bitmap and colour map are stored in display order.
.SS MLT
.PP
A Timex hi-color image.
Like .shc, but the colour map is stored in display order.
.SS MOD
.PP
Modtracker music file (requires Pi accelerator to play).
.SS NDR
.PP
Nexdaw music file
.SS NEX
.PP
ZX Spectrum Next executable file.
.SS NXI
.PP
A version of a 256x192x8 layer 2 image.
.IP \[bu] 2
bytes 0-511 - palette data
.IP \[bu] 2
bytes 512-49663 - image data
.SS O
.PP
ZX-80 executable file
.SS P3D
.PP
Disk image file
.SS PT3
.PP
Protracker 3 music file
.SS P
.PP
ZX-81 executable file
.SS SDH
.PP
Music file (requires Pi accelerator to play)
.SS SID
.PP
Commodore 64 SID music file (requires Pi accelerator to play)
.SS SCR
.PP
ZX Spectrum screen dump
.PP
In basic form a 6912 byte file containing the bitmap and colour map for
a standard spectrum image.
May have ULAPlus or ULANext color data appended.
.PP
ULAplus
.IP \[bu] 2
bytes 0-6143 - bitmap: memory order
.IP \[bu] 2
bytes 6144-6911 - colour map: memory order
.IP \[bu] 2
bytes 6912-6975 - ULAPlus palette data
.PP
ULANext
.IP \[bu] 2
bytes 0-6143 - bitmap: memory order
.IP \[bu] 2
bytes 6144-6911 - colour map: memory order
.IP \[bu] 2
byte 6912 - ULANext mode
.IP \[bu] 2
bytes 6913-between 6228 and 7426 - ULANext palette data, size is
dependent on specific ULANext mode and 8 or 9 bit palette entries.
.RS 2
.PP
.TS
tab(@);
l r r r r.
T{
mode
T}@T{
ink
T}@T{
paper
T}@T{
8-bit
T}@T{
9-bit
T}
T{
$01
T}@T{
2
T}@T{
128
T}@T{
130
T}@T{
260
T}
T{
$03
T}@T{
4
T}@T{
64
T}@T{
68
T}@T{
136
T}
T{
$07
T}@T{
8
T}@T{
32
T}@T{
40
T}@T{
80
T}
T{
$0F
T}@T{
16
T}@T{
16
T}@T{
32
T}@T{
64
T}
T{
$1F
T}@T{
32
T}@T{
8
T}@T{
40
T}@T{
80
T}
T{
$3F
T}@T{
64
T}@T{
4
T}@T{
68
T}@T{
136
T}
T{
$7F
T}@T{
128
T}@T{
2
T}@T{
130
T}@T{
260
T}
T{
$FF
T}@T{
256
T}@T{
1
T}@T{
257
T}@T{
514
T}
.TE
.RE
.SS SHC
.PP
Timex hi-color screen dump
.PP
In basic form the 12,288 byte file containing the bitmap and colour map
for a Timex hi-color image.
May have ULAPlus or ULANext color data appended.
.PP
ULAplus
.IP \[bu] 2
bytes 0-6143 - bitmap: memory order
.IP \[bu] 2
bytes 6144-12287 - colour map: memory order
.IP \[bu] 2
bytes 12288-12351 - ULAPlus palette data
.PP
ULANext
.IP \[bu] 2
bytes 0-6143 - bitmap: memory order
.IP \[bu] 2
bytes 6144-12287 - colour map: memory order
.IP \[bu] 2
byte 12288 - ULANext mode
.IP \[bu] 2
bytes 12289-between 12304 and 12802 - ULANext palette data, size is
dependent on specific ULANext mode and 8 or 9 bit palette entries.
.RS 2
.PP
.TS
tab(@);
l r r r r.
T{
mode
T}@T{
ink
T}@T{
paper
T}@T{
8-bit
T}@T{
9-bit
T}
T{
$01
T}@T{
2
T}@T{
128
T}@T{
130
T}@T{
260
T}
T{
$03
T}@T{
4
T}@T{
64
T}@T{
68
T}@T{
136
T}
T{
$07
T}@T{
8
T}@T{
32
T}@T{
40
T}@T{
80
T}
T{
$0F
T}@T{
16
T}@T{
16
T}@T{
32
T}@T{
64
T}
T{
$1F
T}@T{
32
T}@T{
8
T}@T{
40
T}@T{
80
T}
T{
$3F
T}@T{
64
T}@T{
4
T}@T{
68
T}@T{
136
T}
T{
$7F
T}@T{
128
T}@T{
2
T}@T{
130
T}@T{
260
T}
T{
$FF
T}@T{
256
T}@T{
1
T}@T{
257
T}@T{
514
T}
.TE
.RE
.SS SHR
.PP
Timex hi-resolution screen dump.
.PP
A 12,288 or 12,289 byte file containing a memory dump of the two 6k
screen areas used by Timex hi-resolution mode in memory order with an
optional byte indicating teh colours used.
.SS SL2
.PP
ZX Spectrum Next layer 2 screen dump
.PP
In its most basic standard form, this is a 49,152 byte file contaning
the memory for the image data.
.PP
256x192x8
.IP \[bu] 2
bytes 0-49151 - image data: row dominant
.IP \[bu] 2
optional bytes 49152-49407 or 49663 - palette data (256 bytes for 8-bit
entries, 512 bytes for 9-bit entries)
.PP
320x256x8
.IP \[bu] 2
bytes 0-81919 - image data: column dominant
.IP \[bu] 2
optional bytes 81920-82175 or 82431 - palette data (256 bytes for 8-bit
entries, 512 bytes for 9-bit entries)
.PP
640x256x4
.IP \[bu] 2
bytes 0-81919 - image data: column dominant, nybbles in adjacent columns
.IP \[bu] 2
optional bytes 81920-81935 or 81951 - palette data (16 bytes for 8-bit
entries, 32 bytes for 9-bit entries)
.SS SLR
.PP
ZX Spectrum Next low-resolution screen dump.
.PP
Basic standard form 12,288 byte file contaning the memory for the two 6k
areas for 128x96x8 image files
.PP
192x96x8
.IP \[bu] 2
bytes 0-12287 - image data: row dominant
.IP \[bu] 2
optional bytes 12288-12543 or 12799 - palette data (256 bytes for 8-bit
entries, 512 bytes for 9-bit entries)
.PP
192x96x4 (Radistan)
.IP \[bu] 2
bytes 0-6143 - image data: row dominant
.IP \[bu] 2
optional bytes 6144-6159 or 6175 - palette data (16 bytes for 8-bit
entries, 32 bytes for 9-bit entries)
.SS SNA
.PP
ZX Spectrum memory snapshot
.SS SND
.PP
Music file (requires Pi accelerator to play)
.SS SNX
.PP
Extended ZX Spectrum memory snapshot to be run in ZX Spectrum Next mode
.SS SPR
.PP
Sprite file
.SS TAP
.PP
ZX Spectrum tape image
.SS TXT,DOC,ASM,INI,CFG,MD
.PP
Text files
.SS TZX
.PP
ZX Spectrum tape image (able to handle custom tape formats).
Requires Pi accelerator to load.
.SS WAV
.PP
PCM audio file
.SS XM
.PP
XM tracker music file (requires Pi accelerator to play)
.SS Z3 to Z8
.PP
Inform interactive fiction files
.SS Z80
.PP
ZX Spectrum memory snapshot
.SS ZIP
.PP
Zip compressed file
.SH Call Tables
.SS BDOS Call Table
.SS BIOS Call Table
.SS NextZXOS Calls
.SS +3DOS Compatible Calls
.PP
\f[B]Filesystem Calls\f[R]
.PP
.TS
tab(@);
l l l.
T{
DOS_VERSION
T}@T{
$0103 ()
T}@T{
Get +3DOS issue and version numbers
T}
T{
*DOS_OPEN
T}@T{
$0106 ()
T}@T{
Create and/or open a file
T}
T{
DOS_CLOSE
T}@T{
$0109 ()
T}@T{
Close a file
T}
T{
DOS_ABANDON
T}@T{
$010C ()
T}@T{
Abandon a file
T}
T{
DOS_REF_HEAD
T}@T{
$010F ()
T}@T{
Point at the header data for this file
T}
T{
DOS_READ
T}@T{
$0112 ()
T}@T{
Read bytes into memory
T}
T{
DOS_WRITE
T}@T{
$0115 ()
T}@T{
Write bytes from memory
T}
T{
DOS_BYTE_READ
T}@T{
$0118 ()
T}@T{
Read a byte
T}
T{
DOS_BYTE_WRITE
T}@T{
$011B ()
T}@T{
Write a byte
T}
T{
*DOS_CATALOG
T}@T{
$011E ()
T}@T{
Catalog disk directory
T}
T{
*DOS_FREE_SPACE
T}@T{
$0121 ()
T}@T{
Free space on disk
T}
T{
DOS_DELETE
T}@T{
$0124 ()
T}@T{
Delete a file
T}
T{
DOS_RENAME
T}@T{
$0127 ()
T}@T{
Rename a file
T}
T{
DOS_BOOT
T}@T{
$012A ()
T}@T{
Boot an operating system or other program
T}
T{
DOS_SET_DRIVE
T}@T{
$012D ()
T}@T{
Set/get default drive
T}
T{
DOS_SET_USER
T}@T{
$0130 ()
T}@T{
Set/get default user number
T}
T{
*DOS_GET_POSITION
T}@T{
$0133 ()
T}@T{
Get file pointer for random access
T}
T{
DOS_SET_POSITION
T}@T{
$0136 ()
T}@T{
Set file pointer for random access
T}
T{
*DOS_GET_EOF
T}@T{
$0139 ()
T}@T{
Get end of file position for random access
T}
T{
DOS_GET_1346
T}@T{
$013C ()
T}@T{
Get memory usage in pages 1, 3, 4, 6
T}
T{
DOS_SET_1346
T}@T{
$013F ()
T}@T{
Re-allocate memory usage in pages 1, 3, 4, 6
T}
T{
DOS_FLUSH
T}@T{
$0142 ()
T}@T{
Bring disk up to date
T}
T{
DOS_SET_ACCESS
T}@T{
$0145 ()
T}@T{
Change open file\[cq]s access mode
T}
T{
DOS_SET_ATTRIBUTES
T}@T{
$0148 ()
T}@T{
Change a file\[cq]s attributes
T}
T{
DOS_SET_MESSAGE
T}@T{
$014E ()
T}@T{
Enable/disable error messages
T}
.TE
.PP
.TS
tab(@);
l l l.
T{
DD_L_XDPB
T}@T{
$0187 ()
T}@T{
Initialise an XDPB from a disk specification
T}
T{
DD_L_DPB
T}@T{
$018A ()
T}@T{
Initialise a DPB from a disk specification
T}
.TE
.PP
\f[B]System Calls\f[R]
.PP
.TS
tab(@);
l l l.
T{
DOS_INITIALISE
T}@T{
$0100 ()
T}@T{
Initialise +3DOS
T}
.TE
.PP
.TS
tab(@);
l l l.
T{
IDE_INTERFACE
T}@T{
$00A3 ()
T}@T{
Initialise card interfaces
T}
T{
IDE_INIT
T}@T{
$00A6 ()
T}@T{
Initialise IDEDOS
T}
T{
IDE_DRIVE
T}@T{
$00A9 ()
T}@T{
Get unit handle
T}
T{
*IDE_SECTOR_READ
T}@T{
$00AC ()
T}@T{
Low-level sector read
T}
T{
*IDE_SECTOR_WRITE
T}@T{
$00AF ()
T}@T{
Low-level sector write
T}
T{
IDE_PARTITON_READ
T}@T{
$00C4 ()
T}@T{
Read a partition entry
T}
T{
IDE_PARTITION_OPEN
T}@T{
$00CD ()
T}@T{
Open a partition
T}
T{
IDE_PARTITION_CLOSE
T}@T{
$00D0 ()
T}@T{
Close a partition
T}
T{
IDE_PARTITIONS
T}@T{
$01A5 ()
T}@T{
Get number of open partitions
T}
.TE
.PP
\f[B]Unimplemented Calls\f[R]
.PP
.TS
tab(@);
l l l.
T{
DOS_OPEN_DRIVE
T}@T{
$014B ()
T}@T{
Open a drive as a single file
T}
T{
DOS_MAP_B
T}@T{
$0154 ()
T}@T{
Map B: onto unit 0 or 1
T}
.TE
.PP
.TS
tab(@);
l l l.
T{
DD_INTERFACE
T}@T{
$0157 ()
T}@T{
Is the floppy disk driver interface present?
T}
T{
DD_INIT
T}@T{
$015A ()
T}@T{
Initialise disk driver
T}
T{
DD_SETUP
T}@T{
$015D ()
T}@T{
Specify drive parameters
T}
T{
DD_SET_RETRY
T}@T{
$0160 ()
T}@T{
Set try/retry count
T}
T{
DD_READ_SECTOR
T}@T{
$0163 ()
T}@T{
Read a sector
T}
T{
DD_WRITE_SECTOR
T}@T{
$0166 ()
T}@T{
Write a sector
T}
T{
DD_CHECK_SECTOR
T}@T{
$0169 ()
T}@T{
Check a sector
T}
T{
DD_FORMAT
T}@T{
$016C ()
T}@T{
Format a track
T}
T{
DD_READ_ID
T}@T{
$016F ()
T}@T{
Read a sector identifier
T}
T{
DD_TEST_UNSUITABLE
T}@T{
$0172 ()
T}@T{
Test media suitability
T}
T{
DD_LOGIN
T}@T{
$0175 ()
T}@T{
Log in disk, initialise XDPB
T}
T{
DD_SEL_FORMAT
T}@T{
$0178 ()
T}@T{
Pre-initialise XDPB for DD FORMAT
T}
T{
DD_ASK_1
T}@T{
$017B ()
T}@T{
Is unit 1 & external drive & present?
T}
T{
DD_DRIVE_STATUS
T}@T{
$017E ()
T}@T{
Fetch drive status
T}
T{
DD_EQUIPMENT
T}@T{
$0181 ()
T}@T{
What type of drive?
T}
T{
DD_ENCODE
T}@T{
$0184 ()
T}@T{
Set intercept routine for copy protection
T}
T{
DD_L_SEEK
T}@T{
$018D ()
T}@T{
uPD765A seek driver
T}
T{
DD_L_READ
T}@T{
$0190 ()
T}@T{
uPD765A read driver
T}
T{
DD_L_WRITE
T}@T{
$0193 ()
T}@T{
uPD765A write driver
T}
T{
DD_L_ON_MOTOR
T}@T{
$0196 ()
T}@T{
Motor on, wait for motor-on time
T}
T{
DD_L_T_OFF_MOTOR
T}@T{
$0199 ()
T}@T{
Start the motor-off ticker
T}
T{
DD_L_OFF_MOTOR
T}@T{
$019C ()
T}@T{
Turn the motor off
T}
.TE
.PP
.TS
tab(@);
l l l.
T{
IDE_FORMAT
T}@T{
$00B2 ()
T}@T{
Format a partition
T}
T{
IDE_PARTITION_NEW
T}@T{
$00B8 ()
T}@T{
Create partition
T}
T{
IDE_PARTITION_INIT
T}@T{
$00BB ()
T}@T{
Initialise partition
T}
T{
IDE_PARTITION_ERASE
T}@T{
$00BE ()
T}@T{
Delete a partition
T}
T{
IDE_PARTITION_RENAME
T}@T{
$00C1 ()
T}@T{
Rename a partition
T}
T{
IDE_PARTITION_WRITE
T}@T{
$00C7 ()
T}@T{
Write a partition entry
T}
T{
IDE_PARTITION_WINFO
T}@T{
$00CA ()
T}@T{
Write type-specific partition information
T}
T{
IDE_PARTITION_GETINFO
T}@T{
$00D3 ()
T}@T{
Get byte from type-specific partition information
T}
T{
IDE_PARTITION_SETINFO
T}@T{
$00D6 ()
T}@T{
Set byte in type-specific partition information
T}
T{
IDE_DOS_UNPERMANENT
T}@T{
$00FA ()
T}@T{
Remove permanent drive mapping
T}
T{
IDE_IDENTIFY
T}@T{
$01A2 ()
T}@T{
Return IDE drive identity information
T}
.TE
.SS +3DOS compatible error codes
.PP
\f[B]Recoverable disk errors\f[R]
.PP
.TS
tab(@);
l l l.
T{
0
T}@T{
rc_ready
T}@T{
Drive not ready
T}
T{
1
T}@T{
rc_wp
T}@T{
Disk is write protected
T}
T{
2
T}@T{
rc_seek
T}@T{
Seek fail
T}
T{
3
T}@T{
rc_crc
T}@T{
CRC data error
T}
T{
4
T}@T{
rc_nodata
T}@T{
No data
T}
T{
5
T}@T{
rc_mark
T}@T{
Missing address mark
T}
T{
6
T}@T{
rc_unrecog
T}@T{
Unrecognised disk format
T}
T{
7
T}@T{
rc_unknown
T}@T{
Unknown disk error
T}
T{
8
T}@T{
rc_diskchg
T}@T{
Disk changed whilst +3DOS was using it
T}
T{
9
T}@T{
rc_unsuit
T}@T{
Unsuitable media for drive
T}
.TE
.PP
\f[B]Non-recoverable errors\f[R]
.PP
.TS
tab(@);
l l l.
T{
20
T}@T{
rc_badname
T}@T{
Bad filename
T}
T{
21
T}@T{
rc_badparam
T}@T{
Bad parameter
T}
T{
22
T}@T{
rc_nodrive
T}@T{
Drive not found
T}
T{
23
T}@T{
rc_nofile
T}@T{
File not found
T}
T{
24
T}@T{
rc_exists
T}@T{
File already exists
T}
T{
25
T}@T{
rc_eof
T}@T{
End of file
T}
T{
26
T}@T{
rc_diskfull
T}@T{
Disk full
T}
T{
27
T}@T{
rc_dirfull
T}@T{
Directory full
T}
T{
28
T}@T{
rc_ro
T}@T{
Read-only file
T}
T{
29
T}@T{
rc_number
T}@T{
File number not open (or open with wrong access)
T}
T{
30
T}@T{
rc_denied
T}@T{
Access denied
T}
T{
31
T}@T{
rc_norename
T}@T{
Cannot rename between drives
T}
T{
32
T}@T{
rc_extent
T}@T{
Extent missing
T}
T{
33
T}@T{
rc_uncached
T}@T{
Uncached
T}
T{
34
T}@T{
rc_toobig
T}@T{
File too big
T}
T{
35
T}@T{
rc_notboot
T}@T{
Disk not bootable
T}
T{
36
T}@T{
rc_inuse
T}@T{
Drive in use
T}
.TE
.PP
.TS
tab(@);
l l l.
T{
56
T}@T{
rc_invpartition
T}@T{
Invalid partition
T}
T{
57
T}@T{
rc_partexist
T}@T{
Partition already exists
T}
T{
58
T}@T{
rc_notimp
T}@T{
Not implemented
T}
T{
59
T}@T{
rc_partopen
T}@T{
Partition open
T}
T{
60
T}@T{
rc_nohandle
T}@T{
Out of handles
T}
T{
61
T}@T{
rc_notswap
T}@T{
Not a swap partition
T}
T{
62
T}@T{
rc_mapped
T}@T{
Drive already mapped
T}
T{
63
T}@T{
rc_noxdpb
T}@T{
No XDPB
T}
T{
64
T}@T{
rc_noswap
T}@T{
No suitable swap partition
T}
T{
65
T}@T{
rc_invdevice
T}@T{
Invalid device
T}
T{
67
T}@T{
rc_cmdphase
T}@T{
Command phase error
T}
T{
68
T}@T{
rc_dataphase
T}@T{
Data phase error
T}
T{
69
T}@T{
rc_notdir
T}@T{
Not a directory
T}
T{
74
T}@T{
rc_fragmented
T}@T{
File is fragmented, use .DEFRAG
T}
.TE
.SS esxDOS Compatible Calls
.PP
\f[B]Low-level calls\f[R]
.PP
.TS
tab(@);
l l l.
T{
disk_filemap
T}@T{
$85 ()
T}@T{
obtain file allocation map
T}
T{
disk_strmstart
T}@T{
$86 ()
T}@T{
start streaming operation
T}
T{
disk_strmend
T}@T{
$87 ()
T}@T{
end streaming operation
T}
.TE
.PP
\f[B]Miscellaneous calls\f[R]
.PP
.TS
tab(@);
l l l.
T{
m_dosversion
T}@T{
$88 ()
T}@T{
get NextZXOS version/mode information
T}
T{
m_getsetdrv
T}@T{
$89 ()
T}@T{
get/set default drive
T}
T{
m_tapein
T}@T{
$8B ()
T}@T{
tape redirection control (input)
T}
T{
m_tapeout
T}@T{
$8C ()
T}@T{
tape redirection control (output)
T}
T{
m_gethandle
T}@T{
$8D ()
T}@T{
get handle for current dot command
T}
T{
m_getdate
T}@T{
$8E ()
T}@T{
get current date/time
T}
T{
m_execcmd
T}@T{
$8F ()
T}@T{
execute a dot command
T}
T{
m_setcaps
T}@T{
$91 ()
T}@T{
set additional capabilities
T}
T{
m_drvapi
T}@T{
$92 ()
T}@T{
access API for installable drivers
T}
T{
m_geterr
T}@T{
$93 ()
T}@T{
get or generate error message
T}
T{
m_p3dos
T}@T{
$94 ()
T}@T{
execute +3DOS/IDEDOS/NextZXOS call
T}
T{
m_errh
T}@T{
$95 ()
T}@T{
register dot command error handler
T}
.TE
.PP
\f[B]File calls\f[R]
.PP
.TS
tab(@);
l l l.
T{
f_open
T}@T{
$9A ()
T}@T{
open file
T}
T{
f_close
T}@T{
$9B ()
T}@T{
close file
T}
T{
f_sync
T}@T{
$9C ()
T}@T{
sync file changes to disk
T}
T{
f_read
T}@T{
$9D ()
T}@T{
read file
T}
T{
f_write
T}@T{
$9E ()
T}@T{
write file
T}
T{
f_seek
T}@T{
$9F ()
T}@T{
set file position
T}
T{
f_fgetpos
T}@T{
$A0 ()
T}@T{
get file position
T}
T{
f_fstat
T}@T{
$A1 ()
T}@T{
get open file information
T}
T{
f_ftruncate
T}@T{
$A2 ()
T}@T{
truncate/extend open file
T}
T{
f_opendir
T}@T{
$A3 ()
T}@T{
open directory for reading
T}
T{
f_readdir
T}@T{
$A4 ()
T}@T{
read directory entry
T}
T{
f_telldir
T}@T{
$A5 ()
T}@T{
get directory position
T}
T{
f_seekdir
T}@T{
$A6 ()
T}@T{
set directory position
T}
T{
f_rewinddir
T}@T{
$A7 ()
T}@T{
rewind to start of directory
T}
T{
f_getcwd
T}@T{
$A8 ()
T}@T{
get current working directory
T}
T{
f_chdir
T}@T{
$A9 ()
T}@T{
change directory
T}
T{
f_mkdir
T}@T{
$AA ()
T}@T{
make directory
T}
T{
f_rmdir
T}@T{
$AB ()
T}@T{
remove directory
T}
T{
f_stat
T}@T{
$AC ()
T}@T{
get unopen file information
T}
T{
f_unlink
T}@T{
$AD ()
T}@T{
delete file
T}
T{
f_truncate
T}@T{
$AE ()
T}@T{
truncate/extend unopen file
T}
T{
f_chmod
T}@T{
$AF ()
T}@T{
change file attributes
T}
T{
f_rename
T}@T{
$B0 ()
T}@T{
rename/move file
T}
T{
f_getfree
T}@T{
$B1 ()
T}@T{
get free space
T}
.TE
.SH AUTHORS
Theodore (Alex) Evans.
