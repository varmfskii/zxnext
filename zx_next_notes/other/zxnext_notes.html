<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Theodore (Alex) Evans" />
  <title>ZX Spectrum Next Programming Notes</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">ZX Spectrum Next Programming Notes</h1>
<p class="author">Theodore (Alex) Evans</p>
</header>
<h1 id="introduction">Introduction</h1>
<p>The ZX Spectrum Next is an extension of the original ZX Spectrum implemented in FPGA which implements many of the common additions to the system includin the characteristics of all of the original ZX Spectrum line, including the Timex/Sinclair 2068, along with a number of characteristics to modernize the design.</p>
<p>This document is an attempt to consolidate the programming interface for the ZX Spectrum Next into a single location. This document started when much of the documentation on the ZX Spectrum Next site (https://www.specnext.com/) was out of date and/or difficult to figure out. The way to figure out how things actually worked was to either dig through the forums and ask questions or find someones code that implemented a particular bit of functionality and reverse engineer it. The situation has greatly improved and this document may even be redundant at this point.</p>
<p>Description from http://www.specnext.com/about/:</p>
<p>The Spectrum Next is fully implemented with FPGA technology, ensuring it can be upgraded and enhanced while remaining truly compatible with the original hardware by using special memory chips and clever design. Here’s what under the hood of the machine:</p>
<ul>
<li><p>Processor: Z80n normal and turbo modes</p></li>
<li><p>Memory: 1024Kb RAM (expandable to 2048Kb on board)</p></li>
<li><p>Video: Multilayer video implementing classic ZX Spectrum, Timex Hi-Resolution, Timex Hi-Colour, LoRes, Layer 2, and Tilemap video modes with Hardware sprites</p></li>
<li><p>Video Output: RGB, VGA, HDMI</p></li>
<li><p>Storage: SD Card slot, with DivMMC-compatible protocol</p></li>
<li><p>Audio: ZX Spectrum 1-bit audio, Turbo Sound Next (3x AY-3-8912 audio chips with stereo output), stereo PCM audio, and ability to use Pi accelerator as a sound source</p></li>
<li><p>Joystick: DB9 compatible with Cursor, Kempston and Interface 2 protocols (selectable)</p></li>
<li><p>PS/2 port: Mouse with Kempston mode emulation and an external keyboard</p></li>
<li><p>Special: Multiface functionality for memory access, savegames, cheats etc.</p></li>
<li><p>Tape support: Mic and Ear ports for tape loading and saving</p></li>
<li><p>Expansion: Original external bus expansion port and accelerator expansion port</p></li>
<li><p>Accelerator board (optional): Pi Zero with GPU / 1Ghz CPU / 512Mb RAM</p></li>
<li><p>Network (optional): Wi Fi module</p></li>
<li><p>Extras: Real Time Clock (optional), internal speaker (optional)</p></li>
</ul>
<h1 id="video">Video</h1>
<p>ZX Spectrum Next video splits the display types into four categories (layer 1 (ULA/Timex/LoRes), layer 2, layer 3 (tilemap) and sprites) which have their own sets of controls for colour palettes, clipping, and scrolling. Some aspects of ULA and tilemap are tied together, but all the rest operate in a largely independent manner using a layering system. The ULA category has a number of separate video modes that it can use. One of these (LoRes) is incompatible with using tilemaps (This may have change in the most recent cores).</p>
<h2 id="general-features">General Features</h2>
<p>There are a number of control features for the various video modes that are done in a unified fashion. These features are layering and transparency, palettes, scrolling, and clipping. For the sake of convenience we will occasionally talk about a global coordinate system for graphics on the ZX Next. This coordinate system has (0, 0) at the upper left corner of the usable display area and (319, 255) at the lower right corner. Individual pixels generally correspond to integer locations in this grid, but some modes may either double or halve this grid. This will be discussed in the sections for each of the video layers.</p>
<h3 id="video-layering-and-transparency">Video Layering and Transparency</h3>
<p>Video for the ZX Next is composed of a number of features and layers each of which may have its own set of video modes. Not all of these features are mandatory.</p>
<p>By composing together the border colour and transparency fallback color, layer 1 (ULA, Timex modes, or LoRes), layer 2 (<span class="math inline">256 × 192 × 256</span>, <span class="math inline">320 × 256 × 256</span>, or <span class="math inline">640 × 256 × 16</span>), layer 3 (16 or 2 colour tiles), and sprites; we generate the full video display.</p>
<p>The border/transparency fallback is the bottom with the ordering of the layers controlled by a combination of the video layering register (Next register $15 (21) bits 4-2), the interaction of layers 1 and 3 (Next register $6B (107) bit 0), and whether or not a pixel in layer 2 is set as a priority colour.</p>
<p>Register (R/W) $15 () <span class="math inline">⇒</span> Sprite and Layer System Setup</p>
<ul>
<li><p>bit 7 = LoRes mode (0 on reset)</p></li>
<li><p>bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on top) (0 on reset)</p></li>
<li><p>bit 5 = Enable sprite clipping in over border mode (0 on reset)</p></li>
<li><p>bits 4-2 = set layers priorities (000 on reset)</p>
<ul>
<li><p>000 - S L U</p></li>
<li><p>001 - L S U</p></li>
<li><p>010 - S U L</p></li>
<li><p>011 - L U S</p></li>
<li><p>100 - U S L</p></li>
<li><p>101 - U L S</p></li>
<li><p>110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7</p></li>
<li><p>111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]</p></li>
</ul></li>
<li><p>bit 1 = Enable Sprites Over border (0 on reset)</p></li>
<li><p>bit 0 = Enable Sprites (0 on reset)</p></li>
</ul>
<p>Transparency for Layer 2, Layer 1, and 1-bit Tilemaps are controlled by Next register $14 (20) and defaults to $E3. Sprites and 4-bit Tilemaps have their own registers ($4B and $4C respectively) for setting their transparency index (not colour). This colour ignores the state of the least significant blue bit, so $E3 equates to both $1C6 and $1C7. For Sprites and Tilemaps transparency is determined by colour index. For Sprites this is controlled by register $4B (with only the least significant 4-bits being relevant for 16-colour Sprites). For Tilemaps, the transparency index is set by register $4C. If all layers are transparent, the transparency fallback colour is displayed. This is set by register $4A.</p>
<p>Register (R/W) $14 () <span class="math inline">⇒</span> Global transparency color</p>
<ul>
<li><p>bits 7-0 = Transparency color value ($E3 after a reset)</p></li>
</ul>
<p>(Note: this value is 8-bit, so the transparency is compared against only by the MSB bits of the final 9-bit colour)<br />
(Note2: this only affects Layer 2, ULA and LoRes. Sprites use register $4B for transparency and tilemap uses nextreg $4C)</p>
<p>Register (R/W) $4A () <span class="math inline">⇒</span> Fallback Colour Value</p>
<ul>
<li><p>bits 7-0 = 8-bit colour if all layers are transparent ($E3 on reset)</p></li>
</ul>
<p>(black on reset = 0)</p>
<p>Register (R/W) $4B () <span class="math inline">⇒</span> Sprite Transparency Index</p>
<ul>
<li><p>bits 7-0 = Index value ($E3 if reset)</p></li>
</ul>
<p>For 4-bit sprites only the bottom 4-bits are relevant.</p>
<p>Register (R/W) $4C () <span class="math inline">⇒</span> Level 3 Transparency Index</p>
<ul>
<li><p>bits 7-4 = Reserved, must be 0</p></li>
<li><p>bits 3-0 = Index value ($0F on reset)</p></li>
</ul>
<h3 id="palette">Palette</h3>
<h5 id="next-colour-palettes">Next Colour Palettes</h5>
<p>Each video mode group has a pair of palettes assigned to it a primary and an alternate palette. Each palette entry is actually a 9-bit value (RRRGGGBBB) and can be set by selecting a palette using nextreg $43 (palette control), the entry using nextreg $40 (palette index), then writing the value into nextreg $44 (palette value, 9-bit) using pairs of consecutive writes for each palette value or nextreg $41 (palette value, 8-bit). Once a palette index has been selected writes automatically increment the palette index number so it is possible to efficiently write the values for a collection of palette entries.</p>
<p>Register (R/W) $40 () <span class="math inline">⇒</span> Palette Index Select</p>
<ul>
<li><p>bits 7-0 = Palette Index Number</p></li>
</ul>
<p>Selects the palette index to change the associated colour</p>
<p>For ULA only, INKs are mapped to indices 0 through 7, BRIGHT INKs to indices 8 through 15, PAPERs to indices 16 through 23 and BRIGHT PAPERs to indices 24 through 31. In EnhancedULA mode, INKs come from a subset of indices from 0 through 127 and PAPERs from a subset of indices from 128 through 255.</p>
<p>The number of active indices depends on the number of attribute bits assigned to INK and PAPER out of the attribute byte.</p>
<p>In ULAplus mode, the last 64 entries (indices 192 to 255) hold the ULAplus palette. The ULA always takes border colour from PAPER for standard ULA and Enhanced ULA</p>
<p>Register (R/W) $41 () <span class="math inline">⇒</span> 8-bit Palette Data</p>
<ul>
<li><p>bits 7-0 = Colour Entry in RRRGGGBB format</p></li>
</ul>
<p>The lower blue bit of the 9-bit internal colour will be the logical or of bits 0 and 1 of the 8-bit entry. After each write, the palette index auto-increments if aut-increment has been enabled (NextReg $43 bit 7), Reads do not auto-increment.</p>
<p>Register (R/W) $43 () <span class="math inline">⇒</span> Palette Control</p>
<ul>
<li><p>bit 7 = Disable palette write auto-increment.</p></li>
<li><p>bits 6-4 = Select palette for reading or writing:</p>
<ul>
<li><p>000 = ULA first palette</p></li>
<li><p>100 = ULA second palette</p></li>
<li><p>001 = Layer 2 first palette</p></li>
<li><p>101 = Layer 2 second palette</p></li>
<li><p>010 = Sprite first palette</p></li>
<li><p>110 = Sprite second palette</p></li>
<li><p>011 = Layer 3 first palette</p></li>
<li><p>111 = Layer 3 second palette</p></li>
</ul></li>
<li><p>bit 3 = Select Sprite palette (0 = first palette, 1 = second palette)</p></li>
<li><p>bit 2 = Select Layer 2 palette (0 = first palette, 1 = second palette)</p></li>
<li><p>bit 1 = Select ULA palette (0 = first palette, 1 = second palette)</p></li>
<li><p>bit 0 = Enable EnhancedULA mode if 1. (0 after a reset)</p></li>
</ul>
<p>Register (R/W) $44 () <span class="math inline">⇒</span> 9-bit Palette Data<br />
Non Level 2</p>
<ul>
<li><p>1st write</p></li>
<li><p>bits 7-0 = MSB (RRRGGGBB)</p></li>
<li><p>2nd write</p></li>
<li><p>bits 7-1 = Reserved, must be 0</p></li>
<li><p>bit 0 = LSB (B)</p></li>
</ul>
<p>Level 2</p>
<ul>
<li><p>1st write</p></li>
<li><p>bits 7-0 = MSB (RRRGGGBB)</p></li>
<li><p>2nd write</p></li>
<li><p>bit 7 = Priority</p></li>
<li><p>bits 6-1 = Reserved, must be 0</p></li>
<li><p>bit 0 = LSB (B)</p></li>
</ul>
<p>9-bit Palette Data is entered in two consecutive writes; the second write autoincrements the palette index if auto-increment is enabled in NextREG $43 bit 7</p>
<p>If writing an L2 palette, the second write’s D7 holds the L2 priority bit which if set (1) brings the colour defined at that index on top of all other layers. If you also need the same colour in regular priority (for example: for enviromental masking) you will have to set it up again, this time with no priority.</p>
<p>Reads return the second byte and do not autoincrement. Writes to nextreg $40, $41, $41, or $43 reset to the first write.</p>
<h3 id="scrolling">Scrolling</h3>
<p>The ZX Spectrum Next has four sets of scrolling registers to independently contol the display offsets of various video modes (Layer2, ULA, Tilemap, and LoRes). When the video is offset, the portion that is pushed off the screen (to the left and or top) then becomes visible on the opposite side of the screen so that the video offset values are effectively the coordinates of the origin in a toroidal universe.</p>
<h3 id="clipping">Clipping</h3>
<p>The ZX Spectrum Next has four clipping registers create a window of the layer that is visible. Clipping is managed by a set of four successive writes to the clipping register applicable for the video mode. If a section is masked off by clipping, it is as if the area were the transparency colour and the video lyers behind it become visible.</p>
<h2 id="layer-1">Layer 1</h2>
<table>
<caption>Layer 1 Mode summary</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Mode</th>
<th style="text-align: center;">Resolution</th>
<th style="text-align: center;">Colour</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">ULA</td>
<td style="text-align: center;">256<span class="math inline">×</span>192</td>
<td style="text-align: center;">ULA 8<span class="math inline">×</span>8</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Timex Alt</td>
<td style="text-align: center;">256<span class="math inline">×</span>192</td>
<td style="text-align: center;">ULA 8<span class="math inline">×</span>8</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">HiCol</td>
<td style="text-align: center;">256<span class="math inline">×</span>192</td>
<td style="text-align: center;">ULA 8<span class="math inline">×</span>1</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">HiRes</td>
<td style="text-align: center;">512<span class="math inline">×</span>192</td>
<td style="text-align: center;">2 colours</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">128 Alt</td>
<td style="text-align: center;">256<span class="math inline">×</span>192</td>
<td style="text-align: center;">ULA 8<span class="math inline">×</span>8</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">LoRes</td>
<td style="text-align: center;">128<span class="math inline">×</span>96</td>
<td style="text-align: center;">256 colours</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Rad</td>
<td style="text-align: center;">128<span class="math inline">×</span>96</td>
<td style="text-align: center;">16 colours</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>The Layer 1 consists of ZX Spectrum ULA video, Timex video modes, and the Spectrum Next’s lores video modes all use 16k memory bank 5 or 7 with the data coming from some combination of addresses $0000-$17FF (bitmap 1), $1800-$1AFF (attribute 1), $2000-$37FF (bitmap 2), and $3800-$3AFF (attribute 2) within the selected bank. Assuming default memory mapping and the use of bank 5 this will be mapped as some combination of memory $4000-$57FF, $5800-$5AFF, $6000-$77FF, $780-$7AFF. All of the modes other than the lores mode can either use the default ZX Spectrum colours, ULANext mode, or an emulation of ULAplus. In the Spectrum and Timex modes all colours are either Paper (foreground), paper (background), or border colours.</p>
<table>
<caption>Layer 1 Memory Map</caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: center;">BM 1</th>
<th style="text-align: center;">Attr 1</th>
<th style="text-align: center;">BM 2</th>
<th style="text-align: center;">Attr 2</th>
<th style="text-align: center;">BM a</th>
<th style="text-align: center;">Attr a</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Bank</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">7</td>
</tr>
<tr class="even">
<td style="text-align: left;">start</td>
<td style="text-align: center;">$0000</td>
<td style="text-align: center;">$1800</td>
<td style="text-align: center;">$2000</td>
<td style="text-align: center;">$3800</td>
<td style="text-align: center;">$0000</td>
<td style="text-align: center;">$1800</td>
</tr>
<tr class="odd">
<td style="text-align: left;">end</td>
<td style="text-align: center;">$17FF</td>
<td style="text-align: center;">$1AFF</td>
<td style="text-align: center;">$37FF</td>
<td style="text-align: center;">$3AFF</td>
<td style="text-align: center;">$17FF</td>
<td style="text-align: center;">$1AFF</td>
</tr>
<tr class="even">
<td style="text-align: left;">ULA</td>
<td style="text-align: center;">*</td>
<td style="text-align: center;">*</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Timex Alt</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">*</td>
<td style="text-align: center;">*</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">HiCol</td>
<td style="text-align: center;">*</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">*</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">HiRes</td>
<td style="text-align: center;">*</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">*</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">128 Alt</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">*</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td style="text-align: left;">LoRes</td>
<td style="text-align: center;">*</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">*</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Rad</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">2</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h3 id="colour-attributes">Colour Attributes</h3>
<p>The ZX Spectrum Next has three major modes for colour attributes: the ZX Spectrum attribute mapping, which is augmented by using the ZX Spectrum Next’s palette; ULANext, which allows the user to how many foreground and how many background colous are to be selected by the attribute bytes; and an emulation of ULAplus.</p>
<h5 id="ula-colour">ULA Colour</h5>
<p>In ULA colour INKs are mapped to indices 0-7, Bright INKS to indices 8-15, PAPERs to indices 16-23 and Bright PAPERs to indices 24-31. This is the default state for interpreting ULA palettes.</p>
<h5 id="ulanext">ULANext</h5>
<p>The ULANext modes use a varying number of bits from the attribute byte to determine the ink colours as the palette index from the appropriate bits (all others being zero) and the paper colours coming from the indicated value+128 with palette format 255 being a special case where all the bits determine the ink colour while the paper is always palette index 128. The ULA always takes border colour from paper. ULANext is enabled using bit 0 of nextreg $43 (palette control) and controlled with nextreg $42 (ULA Next attribute byte format)</p>
<h5 id="ulaplus">ULAplus</h5>
<p>The ZX Next emulates ULAPlus using the last 64 (192-255) entries of the ULA palette. ULAplus is controlled using two ports: $BF3B (register port) and $FF3B (data port)</p>
<h6 id="io-ports">I/O ports</h6>
<p>ULAplus is controlled by two ports.</p>
<p>$BF3B is the register port (write only)</p>
<p>The byte output will be interpreted as follows:</p>
<ul>
<li><p>Bits 7-6: Select the register group. Two groups are currently available:</p>
<ul>
<li><p>00=palette group<br />
When this group is selected, the sub-group determines the entry in the palette table (0-63).</p></li>
<li><p>01=mode group<br />
The sub-group is (optionally) used to mirror the video functionality of Timex port $FF as follows:</p></li>
</ul></li>
<li><p>Bits 5-0: Select the register sub-group</p></li>
<li><p>Mode group</p></li>
<li><p>Bits 5-3: Sets the screen colour in hi-res mode.</p>
<ul>
<li><p>000=Black on White</p></li>
<li><p>001=Blue on Yellow</p></li>
<li><p>010=Red on Cyan</p></li>
<li><p>011=Magenta on Green</p></li>
<li><p>100=Green on Magenta</p></li>
<li><p>101=Cyan on Red</p></li>
<li><p>110=Yellow on Blue</p></li>
<li><p>111=White on Black</p></li>
</ul></li>
<li><p>Bits 2-0: Screen mode.</p>
<ul>
<li><p>000=screen 0 (bank 5)</p></li>
<li><p>001=screen 1 (bank 5)</p></li>
<li><p>010=hi-colour (bank 5)</p></li>
<li><p>100=screen 0 (bank 7)</p></li>
<li><p>101=screen 1 (bank 7)</p></li>
<li><p>110=hi-colour (bank 7)</p></li>
<li><p>110=hi-res (bank 5)</p></li>
<li><p>111=hi-res (bank 7)</p></li>
</ul></li>
</ul>
<p>$FF3B is the data port (read/write)</p>
<p>When the palette group is selected, the byte written will describe the color.</p>
<p>When the mode group is selected, the byte output will be interpreted as follows:</p>
<ul>
<li><p>Bit 0: ULAplus palette on (1) / off (0)</p></li>
<li><p>Bit 1: (optional) grayscale: on (1) / off (0) (same as turing the color off on the television)</p></li>
</ul>
<p>Implementations that support the Timex video modes use the $FF register as the primary means to set the video mode, as per the Timex machines. It is left to the individual implementations to determine if reading the port returns the previous write or the floating bus.</p>
<h6 id="grb-palette-entries">GRB palette entries</h6>
<p>G3R3B2 encoding<br />
For a device using the GRB colour space the palette entry is interpreted as follows</p>
<ul>
<li><p>Bits 7-5: Green intensity.</p></li>
<li><p>Bits 4-2: Red intensity.</p></li>
<li><p>Bits 1-0: Blue intensity.</p></li>
</ul>
<p>This colour space uses a sub-set of 9-bit GRB. The missing lowest blue bit is set to OR of the other two blue bits (Bb becomes 000 for 00, and Bb1 for anything else). This gives access to a fixed half the potential 512 colour palette. The reduces the jump in intensity in the lower range in the earlier version of the specification. It also means the standard palette can now be represented by the ULAplus palette.</p>
<h6 id="grayscale-palette-entries">Grayscale palette entries</h6>
<p>This is an optional ULAPlus feature that is not supported on the Next.</p>
<p>In grayscale mode, each palette entry describes an intensity from zero to 255. This can be achieved by simply removing the colour from the output signal.</p>
<h6 id="limitations">Limitations</h6>
<p>Although in theory 64 colours can be displayed at once, in practice this is usually not possible except when displaying colour bars, because the four CLUTs are mutually exclusive; it is not possible to mix colours from two CLUTs in the same cell. However, with software palette cycling it is possible to display all 256 colours on screen at once.</p>
<h6 id="emulation">Emulation</h6>
<p>The 64 colour mode lookup table is organized as 4 palettes of 16 colours.</p>
<p>Bits 7 and 6 of each Spectrum attribute byte (normally used for FLASH and BRIGHT) will be used as an index value (0-3) to select one of the four colour palettes.</p>
<p>Each colour palette has 16 entries (8 for INK, 8 for PAPER). Bits 0 to 2 (INK) and 3 to 5 (PAPER) of the attribute byte will be used as indexes to retrieve colour data from the selected palette.</p>
<p>With the standard Spectrum display, the BORDER colour is the same as the PAPER colour in the first CLUT. For example BORDER 0 would set the border to the same colour as PAPER 0 (with the BRIGHT and FLASH bits not set).</p>
<p>The complete index can be calculated as<br />
ink_colour = (FLASH * 2 + BRIGHT) * 16 + INK paper_colour = (FLASH * 2 + BRIGHT) * 16 + PAPER + 8</p>
<h6 id="palette-file-format">Palette file format</h6>
<p>The palette format doubles as the BASIC patch loader. This enables you to edit patches produced by other people.</p>
<pre><code>; 64 colour palette file format (internal) - version 1.0
; copyright (c) 2009 Andrew Owen
;
; The palette file is stored as a BASIC program with embedded machine code

header:

db 0x00 ; program file
db 0x14, 0x01, &quot;64colour&quot; ; file name
dw 0x0097 ; data length
dw 0x0000 ; autostart line
dw 0x0097 ; program length

basic:

; 0 RANDOMIZE USR ((PEEK VAL &quot;2
; 3635&quot;+VAL &quot;256&quot;*PEEK VAL &quot;23636&quot;
; )+VAL &quot;48&quot;): LOAD &quot;&quot;: REM

db 0x00, 0x00, 0x93, 0x00, 0xf9, 0xc0, 0x28, 0x28
db 0xbe, 0xb0, 0x22, 0x32, 0x33, 0x36, 0x33, 0x35
db 0x22, 0x2b, 0xb0, 0x22, 0x32, 0x35, 0x36, 0x22
db 0x2a, 0xbe, 0xb0, 0x22, 0x32, 0x33, 0x36, 0x33
db 0x36, 0x22, 0x29, 0x2b, 0xb0, 0x22, 0x34, 0x38
db 0x22, 0x29, 0x3a, 0xef, 0x22, 0x22, 0x3a, 0xea

start:

di ; disable interrupts
ld hl, 38 ; HL = length of code
add hl, bc ; BC = entry point (start) from BASIC
ld bc, 0xbf3b ; register select
ld a, 64 ; mode group
out (c), a ;
ld a, 1 ;
ld b, 0xff ; choose register port
out (c), a ; turn palette mode on
xor a ; first register

setreg:

ld b, 0xbf ; choose register port
out (c), a ; select register
ex af, af&#39; ; save current register select
ld a, (hl) ; get data
ld b, 0xff ; choose data port
out (c), a ; set it
ex af, af&#39; ; restore current register
inc hl ; advance pointer
inc a ; increase register
cp 64 ; are we nearly there yet?
jr nz, setreg ; repeat until all 64 have been done
ei ; enable interrupts
ret ; return

; this is where the actual data is stored. The following is an example palette.

registers:

db 0x00, 0x02, 0x18, 0x1b, 0xc0, 0xc3, 0xd8, 0xdb ; INK
db 0x00, 0x02, 0x18, 0x1b, 0xc0, 0xc3, 0xd8, 0xdb ; PAPER
db 0x00, 0x03, 0x1c, 0x1f, 0xe0, 0xe3, 0xfc, 0xff ; +BRIGHT
db 0x00, 0x03, 0x1c, 0x1f, 0xe0, 0xe3, 0xfc, 0xff ;
db 0xdb, 0xd8, 0xc3, 0xc0, 0x1b, 0x18, 0x02, 0x00 ; +FLASH
db 0xdb, 0xd8, 0xc3, 0xc0, 0x1b, 0x18, 0x02, 0x00 ;
db 0xff, 0xfc, 0xe3, 0xe0, 0x1f, 0x1c, 0x03, 0x00 ; +BRIGHT/
db 0xff, 0xfc, 0xe3, 0xe0, 0x1f, 0x1c, 0x03, 0x00 ; +FLASH

terminating_byte:

db 0x0d </code></pre>
<h3 id="layer-1-scrolling">Layer 1 Scrolling</h3>
<p>Layer 1 has two sets of scrolling registers. One for the the legacy modes (ZX Spectrum, Alternate Page, Timex Hi-Resoulution, and Timex Hi-colour) and a second set for the two ZX Spextrum Next specific LoRes modes. All modes scroll as if they were <span class="math inline">256 × 192</span> screens located at global coordinates (32, 32) to (287, 223), The registers for the legacy modes are $26 and $27 and the registers for the LoRes modes are $32 and $33.</p>
<p>Register (R/W) $26 () <span class="math inline">⇒</span> ULA Horizontal Scroll Control</p>
<ul>
<li><p>bits 7-0 = ULA X Offset (0-255) (0 on reset)</p></li>
</ul>
<p>Register (R/W) $27 () <span class="math inline">⇒</span> ULA Vertical Scroll Control</p>
<ul>
<li><p>bits 7-0 = ULA Y Offset (0-191) (0 on reset)</p></li>
</ul>
<p>Register (R/W) $32 () <span class="math inline">⇒</span> Layer 1,0 (LoRes) Horizontal Scroll Control)</p>
<ul>
<li><p>bits 7-0 = X Offset (0-255) ($00 on reset)</p></li>
</ul>
<p>Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and smoothness as Layer 2.</p>
<p>Register (R/W) $33 () <span class="math inline">⇒</span> Layer 1,0 (LoRes) Vertical Scroll Control)</p>
<ul>
<li><p>bits 7-0 = Y Offset (0-191) ($00 on reset)</p></li>
</ul>
<p>Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and smoothness as Layer 2.</p>
<h3 id="layer-1-clipping">Layer 1 Clipping</h3>
<p>All of the modes in the Layer 1 share a single clipping register, $1A. The clip index may alternately be set using register $1C. This is expecially useful for reading the current clipping coordinates as reads on the clipping register do not change the index. Note that clipping coordinates are based on a full display area for the mode of <span class="math inline">256 × 192</span> resolution even though not all modes have that resolution.</p>
<p>Register (R/W) $1A () <span class="math inline">⇒</span> Layer 0 (ULA/LoRes) Clip Window Definition</p>
<ul>
<li><p>bits 7-0 = Coord. of the clip window</p>
<ul>
<li><p>1st write = X1 position</p></li>
<li><p>2nd write = X2 position</p></li>
<li><p>3rd write = Y1 position</p></li>
<li><p>4rd write = Y2 position</p></li>
</ul></li>
</ul>
<p>The values are 0,255,0,191 after a Reset<br />
Reads do not advance the clip position</p>
<p>Register (R/W) $1C () <span class="math inline">⇒</span> Clip Window Control<br />
Read</p>
<ul>
<li><p>bits 7-6 = Layer 3 Clip Index</p></li>
<li><p>bits 5-4 = Layer 0/1 Clip Index</p></li>
<li><p>bits 3-2 = Sprite clip index</p></li>
<li><p>bits 1-0 = Layer 2 Clip Index</p></li>
</ul>
<p>Write</p>
<ul>
<li><p>bits 7-4 = Reserved, must be 0</p></li>
<li><p>bit 3 - reset Layer 3 clip index</p></li>
<li><p>bit 2 - reset Layer 0/1 clip index</p></li>
<li><p>bit 1 - reset sprite clip index.</p></li>
<li><p>bit 0 - reset Layer 2 clip index.</p></li>
</ul>
<h3 id="zx-spectrum-mode">ZX Spectrum Mode</h3>
<p>Timex mode 0</p>
<p>This is the default ULA mode and has its origins in the original ZX Spectrum. It uses <span class="math inline">256 × 192</span> pixels located at global coordinates (32, 32) to (287, 223) with <span class="math inline">8 × 8</span> colour attribute areas mapped into a <span class="math inline">32 × 24</span> grid. If Timex modes are not enabled, this and the LoRes mode are the only ones available, so you would switch back to this mode by writing 000xxxxx to Next register $15 (21, the sprites and layers register). If another Timex mode is enabled, then this is mode 0 so you would write 0 to port $ff to enable it. This is a <span class="math inline">256 × 192</span> video mode. The bitmap 1 area is used for selection between ink and paper colours with one bit per pixel and the attribute 1 area for colour attributes.</p>
<p>The easiest way to visualize the mapping of this mode is to think of the <span class="math inline">256 × 192</span> area as being divided into a <span class="math inline">32 × 24</span> grid of <span class="math inline">8 × 8</span> characters. IF we consider X and Y as the position in the grid and R to the the row within the character. For ink/paper selection, 0=paper, 1=ink and the entries are stored left to right as lsb to msb within the bye. The address for a pixel value is: <span class="math inline">0<em>R</em><sub>4</sub><em>R</em><sub>3</sub><em>Y</em><sub>2</sub><em>Y</em><sub>1</sub><em>Y</em><sub>0</sub><em>R</em><sub>2</sub><em>R</em><sub>1</sub><em>R</em><sub>0</sub><em>C</em><sub>4</sub><em>C</em><sub>3</sub><em>C</em><sub>2</sub><em>C</em><sub>1</sub><em>C</em><sub>0</sub></span>. Each <span class="math inline">8 × 8</span> cell has its own colour attribute where the address for an attribute cell is <span class="math inline">0110<em>R</em><sub>4</sub><em>R</em><sub>3</sub><em>R</em><sub>2</sub><em>R</em><sub>1</sub><em>R</em><sub>0</sub><em>C</em><sub>4</sub><em>C</em><sub>3</sub><em>C</em><sub>2</sub><em>C</em><sub>1</sub><em>C</em><sub>0</sub></span> in other words mapped lineally column-wise starting at the beginning of the attribute 1 area.</p>
<p>Code:</p>
<pre><code>  ;; from any other Timex mode:
  ld a,$00
  ld c,$ff
  out (c),a

  ;; from LoRes mode:
  ld bc,$243B ; next register select port
  ld a,$15
  out (c),a
  ld bc,$253B ; next register r/w port
  in a,(c)
  and $7f
  out (c),a</code></pre>
<h3 id="alternate-page-mode">Alternate Page Mode</h3>
<p>Timex mode 1</p>
<p>This mode is the same as ZX Spectrum mode except it is at an alternate addresses. Alternate page mode is selected by enabling Timex modes by writing 00xxxx1xx to Next register $08 (8, Peripheral 3 setting) then writing 1 to the Timex ULA port ($ff). It is identical to ZX Spectrum mode except the pixel are mapped to the bitmap 2 area giving use pixel addresses of <span class="math inline">1<em>R</em><sub>4</sub><em>R</em><sub>3</sub><em>Y</em><sub>2</sub><em>Y</em><sub>1</sub><em>Y</em><sub>0</sub><em>R</em><sub>2</sub><em>R</em><sub>1</sub><em>R</em><sub>0</sub><em>C</em><sub>4</sub><em>C</em><sub>3</sub><em>C</em><sub>2</sub><em>C</em><sub>1</sub><em>C</em><sub>0</sub></span> and the attributes to the attribute 2 area with addresses of <span class="math inline">1110<em>R</em><sub>4</sub><em>R</em><sub>3</sub><em>R</em><sub>2</sub><em>R</em><sub>1</sub><em>R</em><sub>0</sub><em>C</em><sub>4</sub><em>C</em><sub>3</sub><em>C</em><sub>2</sub><em>C</em><sub>1</sub><em>C</em><sub>0</sub></span>.</p>
<p>Code:</p>
<pre><code>;; disable LoRes mode:
ld bc,$243B ; next register select port
ld a,$15
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
and $7f
out (c),a
;; set Timex mode
ld bc,$243B ; next register select port
ld a,$08
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
or $04
out (c),a
;; set alternate page mode
ld c,$ff
ld a,$01
out (c),a</code></pre>
<h3 id="timex-hi-colour-mode">Timex Hi-Colour Mode</h3>
<p>Timex mode 2</p>
<p>This mode is a <span class="math inline">256 × 192</span> video mode located at global coordinates (32, 32) to (287, 223) with <span class="math inline">8 × 1</span> colour attribute mapping on a <span class="math inline">32 × 192</span> grid. It is selected by writing 2 to the Timex ULA port ($ff). Pixel mapping in this mode is the same as in ZX Spectrum mode using the bitmap 1 area based on <span class="math inline">0<em>R</em><sub>4</sub><em>R</em><sub>3</sub><em>Y</em><sub>2</sub><em>Y</em><sub>1</sub><em>Y</em><sub>0</sub><em>R</em><sub>2</sub><em>R</em><sub>1</sub><em>R</em><sub>0</sub><em>C</em><sub>4</sub><em>C</em><sub>3</sub><em>C</em><sub>2</sub><em>C</em><sub>1</sub><em>C</em><sub>0</sub></span>. The colour attributes use the bitmap 2 area with <span class="math inline">8 × 1</span> colour attribute areas corresponding to the addresses <span class="math inline">1<em>R</em><sub>4</sub><em>R</em><sub>3</sub><em>Y</em><sub>2</sub><em>Y</em><sub>1</sub><em>Y</em><sub>0</sub><em>R</em><sub>2</sub><em>R</em><sub>1</sub><em>R</em><sub>0</sub><em>C</em><sub>4</sub><em>C</em><sub>3</sub><em>C</em><sub>2</sub><em>C</em><sub>1</sub><em>C</em><sub>0</sub></span>.</p>
<p>Code:</p>
<pre><code>;; disable LoRes mode:
ld bc,$243B ; next register select port
ld a,$15
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
and $7f
out (c),a
;; set Timex mode
ld bc,$243B ; next register select port
ld a,$08
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
or $04
out (c),a
;; set hi-colour mode
ld c,$ff
ld a,$02
out (c),a</code></pre>
<h3 id="timex-hi-resolution-mode">Timex Hi-Resolution Mode</h3>
<p>Timex mode 6</p>
<p>This is a monochrome <span class="math inline">512 × 192</span> video mode located at global coordinates (32, 32) to (287, 223) with each pixel being half width. It is selected by writing to the Timex ULA port ($ff with values that also select which two colours (or colour entries in ULANext mode) you use.</p>
<p>Pixels are mapped into both the bitmap 1 and bitmap 2 areas where 8-pixel wide character columns alternate between the two bitmap areas. The pixels within a byte being rendered left to right lsb to msb as in other Spectrum video modes. The addresses for each row within a character are based on a <span class="math inline">64 × 32</span> grid of <span class="math inline">8 × 8</span> characters which using a <span class="math inline">64 × 24</span> R, C, and Y scheme gives us addresses of the form <span class="math inline"><em>C</em><sub>0</sub><em>R</em><sub>4</sub><em>R</em><sub>3</sub><em>Y</em><sub>2</sub><em>Y</em><sub>1</sub><em>Y</em><sub>0</sub><em>R</em><sub>2</sub><em>R</em><sub>1</sub><em>R</em><sub>0</sub><em>C</em><sub>5</sub><em>C</em><sub>4</sub><em>C</em><sub>3</sub><em>C</em><sub>2</sub><em>C</em><sub>1</sub></span>.</p>
<p>Code:</p>
<pre><code>;; disable LoRes mode:
ld bc,$243B ; next register select port
ld a,$15
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
and $7f
out (c),a
;; set Timex mode
ld bc,$243B ; next register select port
ld a,$08
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
or $04
out (c),a
;; set hi-res mode, black on white
ld c,$ff
ld a,$06
out (c),a</code></pre>
<h3 id="lo-resolution-mode">Lo-Resolution Mode</h3>
<p>This is a Spectrum Next specific video mode with a resolution of <span class="math inline">128 × 96</span> located at global coordinates (32, 32) to (287, 223) with each pixel being double height and double width replacing the old Radistan mode. It can either allow for 16 colours, in which case it uses either the bitmap 1 area or the bitmap 2 area, or 256 colours using both bitmap 1 and bitmap 2. The colour of each pixel can be selected independently with data ordered linearly in a row major fashion. In the case of 16 colour mode, the nybbles describing the colours are X major (MSN LSN). Scrolling is by half pixels and uses different registers ($32 and $33) from the rest of the ULA group modes. LoRes mode is enabled by writing <span class="math inline">100<em>x</em><em>x</em><em>x</em><em>x</em><em>x</em></span> to Next register $15 (the sprites and layers register) with Next register $6A used to decide whether it is 16 or 256 colours.</p>
<p>Register (R/W) $15 () <span class="math inline">⇒</span> Sprite and Layer System Setup</p>
<ul>
<li><p>bit 7 = LoRes mode (0 on reset)</p></li>
<li><p>bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on top) (0 on reset)</p></li>
<li><p>bit 5 = Enable sprite clipping in over border mode (0 on reset)</p></li>
<li><p>bits 4-2 = set layers priorities (000 on reset)</p>
<ul>
<li><p>000 - S L U</p></li>
<li><p>001 - L S U</p></li>
<li><p>010 - S U L</p></li>
<li><p>011 - L U S</p></li>
<li><p>100 - U S L</p></li>
<li><p>101 - U L S</p></li>
<li><p>110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7</p></li>
<li><p>111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]</p></li>
</ul></li>
<li><p>bit 1 = Enable Sprites Over border (0 on reset)</p></li>
<li><p>bit 0 = Enable Sprites (0 on reset)</p></li>
</ul>
<p>Register (R/W) $32 () <span class="math inline">⇒</span> Layer 1,0 (LoRes) Horizontal Scroll Control)</p>
<ul>
<li><p>bits 7-0 = X Offset (0-255) ($00 on reset)</p></li>
</ul>
<p>Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and smoothness as Layer 2.</p>
<p>Register (R/W) $33 () <span class="math inline">⇒</span> Layer 1,0 (LoRes) Vertical Scroll Control)</p>
<ul>
<li><p>bits 7-0 = Y Offset (0-191) ($00 on reset)</p></li>
</ul>
<p>Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and smoothness as Layer 2.</p>
<p>Register (R/W) $6A () <span class="math inline">⇒</span> Layer 1,0 (LoRes) Control</p>
<ul>
<li><p>bits 7-6 = reserved, must be 0</p></li>
<li><p>bit 5 = Enable Radistan (16-colour) (0 on reset)</p></li>
<li><p>bit 4 = Radistan DFILE switch (xor with bit 0 of port $ff) (0 on reset)</p></li>
<li><p>bits 3-0 = Radistsan palette offset (0 on reset)</p></li>
<li><p>bits 1-0 = ULAplus palette offset (0 on reset)</p></li>
</ul>
<p>Code: 256 colour</p>
<pre><code>;; enable LoRes mode:
nextreg $15,$80
;; 256-colour mode
ld bc,$243B ; next register select port
ld a,$6A
out (c),a
ld bc,$253B ; next register r/w port
in a,(c)
and $EF ; lores radistan control
out (c),a</code></pre>
<p>Code: 16 colour</p>
<pre><code>;; enable LoRes mode:
nextreg $15,$80
;; 16-colour mode
nextreg $6A,$10</code></pre>
<h2 id="layer-2">Layer 2</h2>
<p>Layer 2 is a for bitmapped graphics. It supports modes with <span class="math inline">256 × 192 × 256</span> resolution at global coordinates (32, 32) to (287, 223) mapped linearly left to right/top to bottom, <span class="math inline">320 × 256 × 256</span> resolution at global coordinates (0, 0) to (318, 255) mapped top to bottom/left to right, and <span class="math inline">640 × 256 × 16</span> resolution at global coordinates (0, 0) to (319, 255) with half width pixels mapped so that the nybbles in a byte are adjacent columns (MSN on the left) and bytes running top to bottom/left to right. It can be mapped starting at any 16k memory blocks. The <span class="math inline">256 × 192 × 256</span> mode requires 3 consecutive blocks (48k) while the others use 5 consecutive blocks (80k).</p>
<h3 id="configuration">Configuration</h3>
<p>Layer 2 is enabled using port $123B or register $69. The mode is selected using register $70. How layer 2 memory is overlaid on main memory is controled by port $123B and register $70. The location in memory is controlled by register $12 with a shadow area pointed to by register $13 for double buffering. Finally port $123B is used to select either the main RAM area or the shadow RAM area for rendering the layer.</p>
<p>Port $123B () Layer 2<br />
Bit 4 = 0</p>
<ul>
<li><p>bits 7-6 = Video RAM bank select</p>
<ul>
<li><p>00 = first 16k</p></li>
<li><p>01 = second 16k</p></li>
<li><p>10 = third 16k</p></li>
<li><p>11 = first 48k</p></li>
</ul></li>
<li><p>bit 5 = Reserved, must be 0</p></li>
<li><p>bit 4 = 0</p></li>
<li><p>bit 3 = Shadow layer 2 select</p></li>
<li><p>bit 2 = Enable layer 2 read paging</p></li>
<li><p>bit 1 = Layer 2 visible (mirrored in register $69)</p></li>
<li><p>bit 0 = Enable layer 2 write paging</p></li>
</ul>
<p>Bit 4 = 1</p>
<ul>
<li><p>bits 7-5 = Reserved, must be 0</p></li>
<li><p>bit 4 = 1</p></li>
<li><p>bit 3 = Reserved, must be 0</p></li>
<li><p>bit 2-0 = 16k bank relative offset</p></li>
</ul>
<p>Register (R/W) $12 () <span class="math inline">⇒</span> Layer 2 Active RAM bank</p>
<ul>
<li><p>bits 7-6 = Reserved, must be 0</p></li>
<li><p>bits 5-0 = RAM bank (point to bank 8 after a Reset, NextZXOS modifies to 9)</p></li>
</ul>
<p>Register (R/W) $13 () <span class="math inline">⇒</span> Layer 2 Shadow RAM bank</p>
<ul>
<li><p>bits 7-6 = Reserved, must be 0</p></li>
<li><p>bits 5-0 = RAM bank (point to bank 11 after a Reset, NextZXOS modifies to 12)</p></li>
</ul>
<p>Register (R/W) $69 () <span class="math inline">⇒</span> Display Control 1</p>
<ul>
<li><p>bit 7 = Layer 2 Enable (Port $123B bit 1 alias)</p></li>
<li><p>bit 6 = ULA Shadow display enable (Port $7FFD bit 3 alias)</p></li>
<li><p>bits 5-0 = Timex alias (Port $FF alias)</p></li>
</ul>
<p>Register (R/W) $70 () <span class="math inline">⇒</span> Layer 2 Control</p>
<ul>
<li><p>bits 7-6 = Reserved, must be 0</p></li>
<li><p>bits 5-4 = Resolution (00 on soft reset)</p>
<ul>
<li><p>00 = <span class="math inline">256 × 192 × 256</span></p></li>
<li><p>01 = <span class="math inline">320 × 256 × 256</span></p></li>
<li><p>10 = <span class="math inline">640 × 256 × 16</span></p></li>
<li><p>11 = Do not use</p></li>
</ul></li>
<li><p>bits 3-0 = Palette offset ($0 on soft reset)</p></li>
</ul>
<h5 id="layer-2-256times192-write-only-overlaid-on-rom">Layer 2 <span class="math inline">256 × 192</span>, Write only overlaid on ROM</h5>
<pre><code>p_layer2: defl $123b
start:
  ld bc,p_layer2
  ld a,$03       ; enable, wo, 1st 16k
  out (c),a
  call wrtpage
  ld bc,p_layer2
  ld a,$43       ; enable, wo, 2nd 16k
  out (c),a
  call wrtpage
  ld bc,p_layer2
  ld a,$83       ; enable, wo, 3rd 16k
  out (c),a
  call wrtpage
  ret
wrtpage:  
  ld hl,$0000
  ld bc,$0040    ; 40*256 writes
loop:
  ld (hl),b
  inc hl
  djnz loop
  dec c
  jr nz,loop</code></pre>
<h5 id="layer-2-256times192-resolution">Layer 2 <span class="math inline">256 × 192</span> resolution</h5>
<pre><code>r_mmu_7:  defl $57
r_disp1:  defl $69
r_layer2: defl $70
start:
  nextreg r_disp1,$80  ; enable layer 2
  nextreg r_layer2,$00 ; 256x192x256
  ld a,$12             ; page 18=bank 9
loop1:
  nextreg r_mmu_7,a    ; map page into slot 7
  ld bc,$0020          ; 20*256 = 8k
  ld hl,$E000          ; address of slot 7
loop2:
  ld (hl),b
  inc hl
  djnz loop2
  dec c
  jp NZ,loop2
  inc a
  cp $18               ; stop at page 24
  jp NZ,loop1</code></pre>
<h5 id="layer-2-320times256-resolution">Layer 2 <span class="math inline">320 × 256</span> resolution</h5>
<pre><code>r_mmu_7:  defl $57
r_disp1:  defl $69
r_layer2: defl $70
start:
  nextreg r_disp1,$80  ; enable layer 2
  nextreg r_layer2,$10 ; 320x256x256
  ld a,$12             ; page 18=bank 9
loop1:
  nextreg r_mmu_7,a    ; map page into slot 7
  ld bc,$0020          ; 20*256 = 8k
  ld hl,$E000          ; start of slot 7
loop2:
  ld (hl),b
  inc hl
  djnz loop2
  dec c
  jp NZ,loop2
  inc a
  cp $1C               ; stop at page 28
  jp NZ,loop1</code></pre>
<h5 id="layer-2-640times256-resolution">Layer 2 <span class="math inline">640 × 256</span> resolution</h5>
<pre><code>r_mmu_7:  defl $57
r_disp1:  defl $69
r_layer2:  defl $70
start:
  nextreg r_disp1, $80   ; enable layer 2
  nextreg r_layer2, $20  ; 640x256x16
  ld a, $12    ; page 18=bank 9
loop1:
  nextreg r_mmu_7, a  ; map page into slot 7
  ld bc, $0020    ; 20*256 = 8k
  ld hl, $E000    ; start address for slot 7
loop2:
  ld (hl), b
  inc hl
  djnz loop2
  dec c
  jp NZ, loop2
  inc a
  cp $1C      ; stop at page 28
  jp NZ, loop1</code></pre>
<h3 id="scrolling-1">Scrolling</h3>
<p>Scrolling Layer 2 is controlled by registers $16 and $17. (Is there a third scrolling register for layer 2?)</p>
<p>Register (R/W) $16 () <span class="math inline">⇒</span> Layer 2 Horizontal Scroll Control</p>
<ul>
<li><p>bits 7-0 = X Offset (0-255)(0 on reset)</p></li>
</ul>
<p>Register (R/W) $17 () <span class="math inline">⇒</span> Layer 2 Vertical Scroll Control</p>
<ul>
<li><p>bits 7-0 = Y Offset (0-191)(0 on reset)</p></li>
</ul>
<h3 id="clipping-1">Clipping</h3>
<p>The Clip area for is based on the local coordinate system for the mode in question and is set using register $18 with the option of selection which write in active using register $1C.</p>
<p>Register (R/W) $18 () <span class="math inline">⇒</span> Layer 2 Clip Window Definition</p>
<ul>
<li><p>bits 7-0 = Coords of the clip window</p>
<ul>
<li><p>1st write - X1 position</p></li>
<li><p>2nd write - X2 position</p></li>
<li><p>3rd write - Y1 position</p></li>
<li><p>4rd write - Y2 position</p></li>
</ul></li>
</ul>
<p>Reads do not advance the clip position<br />
The values are 0,255,0,191 after a Reset</p>
<p>Register (R/W) $1C () <span class="math inline">⇒</span> Clip Window Control<br />
Read</p>
<ul>
<li><p>bits 7-6 = Layer 3 Clip Index</p></li>
<li><p>bits 5-4 = Layer 0/1 Clip Index</p></li>
<li><p>bits 3-2 = Sprite clip index</p></li>
<li><p>bits 1-0 = Layer 2 Clip Index</p></li>
</ul>
<p>Write</p>
<ul>
<li><p>bits 7-4 = Reserved, must be 0</p></li>
<li><p>bit 3 - reset Layer 3 clip index</p></li>
<li><p>bit 2 - reset Layer 0/1 clip index</p></li>
<li><p>bit 1 - reset sprite clip index.</p></li>
<li><p>bit 0 - reset Layer 2 clip index.</p></li>
</ul>
<h2 id="layer-3-tilemap-mode">Layer 3 (Tilemap) Mode</h2>
<p>Started with documentation by Phoebus Dokos, February 25, 2019. Partially rewritten for clarity and to add core 3.00.00 features.</p>
<h3 id="general-description">General Description</h3>
<p>The tilemap is a hardware character oriented display. It uses a set of user defined 4-bit, 16-colour, or 1-bit, 2-colour <span class="math inline">8 × 8</span> tiles. The tiles can be dispplayed in two resolutions: <span class="math inline">40 × 32</span> tiles (<span class="math inline">320 × 256</span> pixels) and <span class="math inline">80 × 32</span> tiles (<span class="math inline">640 × 256</span> pixels).</p>
<p>The display area on screen is the same as the sprite layer, meaning it overlaps the standard <span class="math inline">256 × 192</span> area by 32 pixels on all sides. Vertically this is larger than the physical HDMI display, which will cut off the top and bottom character rows making the visible area <span class="math inline">40 × 30</span> or <span class="math inline">80 × 30</span>, but the full area is visible on VGA.</p>
<p>The obvious application for the tilemap is for a fast, clearly readable and wide multicoloured character display. Less obvious perhaps is that it can also be used to make fast and wide resolution full colour backgrounds with easily animated components such as have historically been used in many games.</p>
<p>The tilemap is defined by two data structures and configured using four NextRegs. The NextRegs are $6b (107), Tilemap Control; $6c (108), Default Tilemap Attribute, $6c (110); Tilemap Base Address; and $6d (111) Tile Definitions Base Address.</p>
<h3 id="data-structures">Data Structures</h3>
<h5 id="tilemap">Tilemap</h5>
<p>The first data structure is the tilemap itself which indicates what characters occupy each cell on screen. Each tilemap entry is either one or two bytes.</p>
<p>If entries are two bytes each, the first byte for each entry is bits 0-7 of the tile number, while the second byte is an attribute byte which is interpreted acctording to the mode set in the tilemap control register ($6b). For <span class="math inline">40 × 32</span> resolution, a full size tilemap will occupy 2560 bytes, and for <span class="math inline">80 × 32</span> resolution the space taken is twice that at 5120 bytes. The tilemap entries are stored in X-major order and each two-byte tilemap entry consists of a tile number byte (bits 0-7 of the tile number) followed an attribute byte:</p>
<p>Tilemap Attribute Byte 4-bit</p>
<ul>
<li><p>bits 7-4 : most significant 4-bits of palette entry</p></li>
<li><p>bit 3 : x mirror</p></li>
<li><p>bit 2 : y mirror</p></li>
<li><p>bit 1 : rotate</p></li>
<li><p>bit 0 : ULA over tilemap (in 512 tile mode, bit 8 of the tile number)</p></li>
</ul>
<p>Tilemap Attribute Byte 1-bit</p>
<ul>
<li><p>bits 7-1 : most significan 7-bits of palette entry</p></li>
<li><p>bit 0 : ULA over tilemap (in 512 tile mode, bit 8 of the tile number)</p></li>
</ul>
<p>The character displayed is indicated by the “tile number” which can be thought of as an ASCII code. The tile number is normally eight bits allowing up to 256 unique tiles to be displayed but this can be extended to nine bits for 512 unique tiles if 512 tile mode is enabled via the Tilemap Control register ($6b).</p>
<p>The other bits are tile attributes that modify how the tile image is drawn. Their function is the same as the equivalent sprite attributes for sprites. Bits apply rotation then mirroring, and colour can be shifted with a palette offset. If 512 tile mode is not enabled, bit 8 will determine if the tile is above or below the ULA display on a per tile basis.</p>
<p>When using 1-byte tilemap entries, the map consists of the tile numbers for tile in the map with the tilemap attribute byte for every tile coming from the default tilemap attribute register ($6c).</p>
<h5 id="tile-definitions">Tile Definitions</h5>
<p>The second data structure is the tile definitions themselves. To find the difinition for a specific tile you would look at (base address) + (tile number) * (definition size).</p>
<p>For 4-bit, 16-colour, tiles, each <span class="math inline">8 × 8</span> tile takes up 32 bytes. Each pixel uses four bits to select one of 16 colours. A tile is defined in X major order with packing in the X direction in the same way that 4-bit sprites are defined. The 4-bit colour of each pixel is augmented by the 4-bit palette offset from the tilemap in the most significant bits to form an 8-bit colour index that is looked up in the tilemap palette to determine the final 9-bit colour sent to the display. Ane of the 16 colours for each tile is the transparency color.</p>
<p>For 1-bit, 2-colour, tiles, each <span class="math inline">8 × 8</span> tile takes up 8 bytes. Each pixel uses one bit to select one of two colours. A tile is defined in X major order with packing in the X direction. The 1-bit colour of each pixel is augmented by the 7-bit palette offset from the tilemap in the most significant bits to form an 8-bit colour index that is looked up in the tilemap palette to determine the final 9-bit colour sent to the display. Transparency for each tile is according to the global transparency colour.</p>
<h3 id="memory-organization-display-layer">Memory Organization &amp; Display Layer</h3>
<p>The tilemap is a logical extension of the ULA and its data structures are contained in 16k banks 5 and 7 (first half only). If both the ULA and tilemap are enabled, this means that the tilemap’s map and tile definitions should be arranged within the 24k to avoid overlap with the display ram used by the ULA.</p>
<p>The tilemap exists on the same display layer as the ULA. The graphics generated by the ULA and tilemap are combined before being forwarded to the SLU layer system as layer U.</p>
<h3 id="combining-ula-tilemap">Combining ULA &amp; Tilemap</h3>
<p>The combination of the ULA and tilemap is done in one of two modes: the standard mode or the stencil mode.</p>
<p>The standard mode uses bit 8 of a tile’s tilemap entry to determine if a tile is above or below the ULA. The source of the final pixel generated is then the topmost non-transparent pixel. If the ULA or tilemap is disabled then they are treated as transparent.</p>
<p>The stencil mode will only be applied if both the ULA and tilemap are enabled. In the stencil mode, the final pixel will be transparent if either the ULA or tilemap are transparent. Otherwise the final pixel is a logical AND of the corresponding colour bits. The stencil mode allows one layer to act as a cut-out for the other.</p>
<h3 id="programming-tilemap-mode">Programming Tilemap mode</h3>
<p>Register (R/W) $6B () <span class="math inline">⇒</span> Layer 3 (Tilemap) Control</p>
<ul>
<li><p>bit 7 = Layer 3 Enable (0 on reset)</p></li>
<li><p>bit 6 = Layer 3 Size control (0 on reset)</p>
<ul>
<li><p>0 = 40x32</p></li>
<li><p>1 = 80x32</p></li>
</ul></li>
<li><p>bit 5 = Disable Arrtibute Entry (0 on reset)</p></li>
<li><p>bit 4 = palette select (0 on reset)</p></li>
<li><p>bit 3 = Enable Text mode (1-bit tilemap) (0 on reset)</p></li>
<li><p>bit 2 = Reserved, must be 0</p></li>
<li><p>bit 1 = Activate 512 tile mode (0 on reset)</p></li>
<li><p>bit 0 = Enable Layer 3 on top of ULA (0 on reset)</p></li>
</ul>
<p>Bits 7 &amp; 6 enable the tilemap and select resolution. Bit 4 selects one of two tilemap palettes used for final colour lookup. Bit 5 changes the structure of the tilemap so that it contains only 8-bit tilemap entries instead of 16-bit tilemap entries. If 8-bit, the tilemap only contains tile numbers and the attributes are instead taken from nextreg $6C.</p>
<p>Bit 5 determines whether the attribute byte for each tile come from the tilemap (0) or from the default tile attribute register (1).</p>
<p>Bit 4 selects either the primary tilemap palette (0) or the secondary tilemap palette (1).</p>
<p>Bit 3 selects whether to use 4-bit, 16-colour, or 1-bit 2-colour tiles.</p>
<p>Bit 1 activates 512 tile mode. In this mode, the “ULA over tilemap” bit in a tile’s attribute is re-purposed as the ninth bit of the tile number, allowing up to 512 unique tiles to be displayed. In this mode, the ULA is always on top of the tilemap.</p>
<p>Bit 0 forces the tilemap to be on top of the ULA. It can be useful in 512 tile mode to change the relative display order of the ULA and tilemap.</p>
<p>Register (R/W) $6C () <span class="math inline">⇒</span> Default Layer 3 Attribute*</p>
<ul>
<li><p>bits 7-4 = Palette Offset ($00 on reset)</p></li>
<li><p>bit 3 = X mirror (0 on reset)</p></li>
<li><p>bit 2 = Y mirror (0 on reset)</p></li>
<li><p>bit 1 = Rotate (0 on reset)</p></li>
<li><p>bit 0 = Bit 8 of the tile number (512 tile mode) (0 on reset)</p></li>
<li><p>bit 0 = ULA over tilemap (256 tile mode) (0 on reset)</p></li>
</ul>
<p>*Active tile attribute if bit 5 of nextreg $6B is set.</p>
<p>If bit 5 of nextreg $6B is set, the tilemap structure is modified to contain only 8-bit tile numbers instead of the usual 16-bit tilemap entries. In this case, the tile attributes used are taken from this register instead.</p>
<p>Register (R/W) $6E () <span class="math inline">⇒</span> Layer 3 Tilemap Base Address</p>
<ul>
<li><p>bit 7 = Bank Select (3.01.08)</p>
<ul>
<li><p>0 = Bank 5</p></li>
<li><p>1 = Bank 7</p></li>
</ul></li>
<li><p>bit 6 = Reserved, must be 0</p></li>
<li><p>bits 5-0 = MSB of address of the tilemap in Bank 5 (16k) or 7 (8k) ($2C on reset)</p></li>
</ul>
<p>Soft Reset default $2C - This is because the address is $6C00 so the MSB is $6C. But the stored value is only the lower 6 bits so it’s an offset into the 16k Bank 5. To calculate therefore subtract $40 leaving you with $2C.</p>
<p>The value written is an offset into the 16k Bank 5 or the 8k lower half of Bank 7 allowinf the tilemap to be placed at any multiple of 256 bytes.</p>
<p>This register determines the tilemapís base address in bank 5. The base address is the MSB of an offset into the 16k bank, allowing the tilemap to begin at any multiple of 256 bytes in the bank. Writing a physical MSB address in $40-$7f or $c0-$ff, corresponding to traditional ULA physical addresses, is permitted. The value read back should be treated as a fully significant 8-bit value.</p>
<p>The tilemap will be <span class="math inline">40 × 32</span> or <span class="math inline">80 × 32</span> in size depending on the resolution selected in nextreg $6B. Each entry in the tilemap is normally two bytes but can be one byte if attributes are eliminated by setting bit 5 of nextreg $6B.</p>
<p>Register (R/W) $6F () <span class="math inline">⇒</span> Layer 3 Tile Definitions Base Address</p>
<ul>
<li><p>bit 7 = Select bank (3.01.08)</p>
<ul>
<li><p>0 = Bank 5</p></li>
<li><p>1 = Bank 7</p></li>
</ul></li>
<li><p>bit 6 = Reserved, must be 0</p></li>
<li><p>bits 5-0 = MSB of address of the tile definitions in Bank 5 (16k) or 7 (8k) ($0C on reset)</p></li>
</ul>
<p>Soft Reset default $0C - This is because the address is $4C00 so the MSB is $4C. But the stored value is only the lower 6 bits so it’s an offset into the 16k Bank 5. To calculate therefore subtract $40 leaving you with $0C.</p>
<p>The value written is an offset into the 16k Bank 5 or the 8k lower half of Bank 7 allowing the tilemap to be placed at any multiple of 256 bytes.</p>
<p>This register determines the base address of tile definitions in bank 5. As with nextreg $6E, the base address is the MSB of the an offset into the 16k bank, allowing tile definitions to begin at any multiple of 256 bytes in the bank. Writing a physical MSB address in $40-$7f or $c0-$ff, corresponding to traditional ULA physical addresses, is permitted. The value read back should be treated as a fully significant 8-bit value.</p>
<p>Each tile definition is 32 bytes in size and is located at address:<br />
Tile Def Base Addr + 32 * (Tile Number)</p>
<p>Register (R/W) $4C () <span class="math inline">⇒</span> Level 3 Transparency Index</p>
<ul>
<li><p>bits 7-4 = Reserved, must be 0</p></li>
<li><p>bits 3-0 = Index value ($0F on reset)</p></li>
</ul>
<p>Defines the transparent colour index for 4-bit tiles. The 4-bit pixels of a tile definition are compared to this value to determine if they are transparent. In the case of 1-bit tiles transparency is determined by comparing the final pixel colour against the global transparency colour.</p>
<p>For palette information see palette section.</p>
<p>Register (R/W) $1B () <span class="math inline">⇒</span> Layer 3 (Tilemap) Clip Window Definition</p>
<ul>
<li><p>bits 7-0 = Coord. of the clip window</p>
<ul>
<li><p>1st write = X1 position</p></li>
<li><p>2nd write = X2 position</p></li>
<li><p>3rd write = Y1 position</p></li>
<li><p>4rd write = Y2 position</p></li>
</ul></li>
</ul>
<p>The values are 0,159,0,255 after a Reset<br />
Reads do not advance the clip position<br />
The X coords are internally doubled.</p>
<p>The tilemap display surface extends 32 pixels around the central <span class="math inline">256 × 192</span> display. The origin of the clip window is the top left corner of this area 32 pixels to the left and 32 pixels above the central <span class="math inline">256 × 192</span> display. The X coordinates are internally doubled to cover the full 320 pixel width of the surface. The clip window indicates the portion of the tilemap display that is non-transparent and its indicated extent is inclusive; it will extend from X1*2 to X2*2+1 horizontally and from Y1 to Y2 vertically.</p>
<p>Register (R/W) $2F () <span class="math inline">⇒</span> Layer 3 (Tilemap) Horizontal Scroll Control MSB</p>
<ul>
<li><p>bits 7-2 = Reserved, must be 0</p></li>
<li><p>bits 1-0 = X Offset MSB ($00 on reset)</p></li>
</ul>
<p>Meaningful Range is 0-319 in 40 char mode, 0-639 in 80 char mode</p>
<p>Register (R/W) $30 () <span class="math inline">⇒</span> Layer 3 (Tilemap) Horizontal Scroll Control LSB</p>
<ul>
<li><p>bits 7-0 = X Offset LSB ($00 on reset)</p></li>
</ul>
<p>Meaningful range is 0-319 in 40 char mode, 0-639 in 80 char mode</p>
<p>Register (R/W) $31 () <span class="math inline">⇒</span> Layer 3 (Tilemap) Vertical Scroll Control</p>
<ul>
<li><p>bits 7-0 = Y Offset (0-255) )$00 on reset)</p></li>
</ul>
<p>Register (R/W) $68 () <span class="math inline">⇒</span> ULA Control</p>
<ul>
<li><p>bit 7 = Disable ULA output (0 on reset)</p></li>
<li><p>bit 6-5 = Color blending control for layering modes 6 &amp; 7 (3.01.01)</p>
<ul>
<li><p>00 = ULA as blend colour</p></li>
<li><p>01 = No blending</p></li>
<li><p>10 = ULA/Tilemap mix result as blend colour</p></li>
<li><p>11 = Tilemap as blend colour</p></li>
</ul></li>
<li><p>bit 4 = Cancel entries in 8x5 matrix for extended keys (3.01.04)</p></li>
<li><p>bit 3 = Enable ULAplus (0 on reset)</p></li>
<li><p>bit 2 = Enable ULA half pixel scroll (0 on reset)</p></li>
<li><p>may change</p></li>
<li><p>bit 1 = Reserved (must be 0)</p></li>
<li><p>bit 0 = Enable stencil mode (0 on reset)</p></li>
<li><p>When ULA and Layer 3 are enabled, if either are transparent, the result is transparent, otherwise the result is the logical AND of both colours.</p></li>
</ul>
<p>Bit 0 can be set to choose stencil mode for the combined output of the ULA and tilemap. Bit 6 determines what colour is used in SLU modes 6 &amp; 7 where the ULA is combined with Layer 2 to generate highlighting effects.</p>
<h5 id="changes-since-2.00.26">Changes Since 2.00.26</h5>
<ol>
<li><p>512 Tile Mode. In 2.00.26, the 512 tile mode was automatically selected when the ULA was disabled. With the ULA disabled, the tilemap attribute bit “ULA on top” was re-purposed to be bit 8 of the tile number. In 2.00.27, selection of the 512 tile mode is moved to bit 1 of Tilemap Control nextreg $6B. This way 512 tile mode can be independently chosen without disabling the ULA. The “ULA on top” bit is still taken as bit 8 of the tile number and in the 512 mode, the tilemap is always displayed underneath the ULA.</p></li>
<li><p>Tilemap Always On Top of ULA. In 2.00.27, bit 0 of Tilemap Control nextreg $6B is used to indicate that the tilemap should always be displayed on top of the ULA. This allows the tilemap to display over the ULA when in 512 mode.</p></li>
<li><p>1-bit tilemaps. In 3.00.00, a number of modifications were made to accomidate 1-bit tilemaps.</p></li>
</ol>
<h5 id="future-direction">Future Direction</h5>
<p>The following compatible changes may be applied at a later date:</p>
<ol>
<li><p>Addition of a bit to Tilemap Control to select a reduced tilemap area of size <span class="math inline">32 × 24</span> or <span class="math inline">64 × 24</span> that covers the ULA screen.</p></li>
<li><p>Addition of a bit to Tilemap Control to select split addressing where the tilemap’s tiles and attributes as well as the tile definitions are split between the two 8k halves of the 16k ULA ram in the same way that the two Timex display files are split. The intention is to make it easier for the tilemap to co-exist with all the display modes of the ULA.</p></li>
</ol>
<h2 id="sprites">Sprites</h2>
<p>February 25, 2019 Victor Trucco</p>
<p>The Spectrum Next has a hardware sprite system with the following characteristics:</p>
<ul>
<li><p>Total of 128 sprites</p></li>
<li><p>Display surface is <span class="math inline">320 × 256</span> overlapping the ULA screen by 32 pixels on each side</p></li>
<li><p>Minimum of 100 sprites per scanline*</p></li>
<li><p>Choice of 512 colours for each pixel</p></li>
<li><p>Site of each sprite is <span class="math inline">16 × 16</span> pixels but sprites can be magnified <span class="math inline">2×</span>, <span class="math inline">4×</span> or <span class="math inline">8×</span> horizontally and vertically</p></li>
<li><p>Sprites can be mirrored and rotated</p></li>
<li><p>Sprites can be grouped together to form larger sprites under the control of a single anchor</p></li>
<li><p>A 16K pattern memory can contain 64 8-bit sprite images or 128 4-bit sprite images and combinations in-between</p></li>
<li><p>A per sprite palette offset allows sprites to share images but colour them differently</p></li>
<li><p>A nextreg interface allows the copper to move sprites during the video frame</p></li>
</ul>
<p>*A minimum of 100 <span class="math inline">16 × 16</span> sprites is guaranteed to be displayed in any scanline. Any additional sprites will not be displayed with the hardware ensuring sprites are not partially plotted.</p>
<p>The actual limit is determined by how many 28MHz clock cycles there are in a scanline. The sprite hardware is able to plot one pixel cycle and uses one cycle to qualify each sprite. Since the number of cycles there are in a scanline varies with video timing (HDMI, VGA), the number of pixels that can be plotted also varies but the minimum will be 1600 pixels per line including overhead cycles needed to qualify 100 sprites. Since sprites magified horizontally involve plotting more pixels, <span class="math inline">2×</span>, <span class="math inline">4×</span>, and <span class="math inline">8×</span> sprites will take more cycles to plot and the presence of these sprites in a line will reduce the total number of sprites that can be plotted.</p>
<h3 id="sprite-patterns">Sprite Patterns</h3>
<p>Sprite patterns are the images that each sprite can take on. The images are stored in a 16K memory internal to the FPGA and are identified by pattern number. A particular sprite chooses a pattern by storing a pattern number in its attributes.</p>
<p>All sprites are <span class="math inline">16 × 16</span> pixels in size but the come in two flavours: 4-bit and 8-bit. The bit width describes how many bits are used to code the colour of each pixel.</p>
<p>An 8-bit sprite uses a full byte to colour each of its pixels so that each pixel can be one of 256 colours. In this case, a <span class="math inline">16 × 16</span> sprite requires 256 bytes of pattern memory to store its image.</p>
<p>A 4-bit sprite uses a nibble to colour each of its pixels so that each pixel can be one of 16 colours. In this case, a <span class="math inline">16 × 16</span> sprite requires just 128 bytes of pattern memory to store its image.</p>
<p>The 16K pattern memory can contain any combination of these images, whether they are 128 bytes or 256 bytes and their locations in the pattern memory are described by a pattern number. This pattern number is 7 bits with bits named as follows:</p>
<h5 id="pattern-number">Pattern Number</h5>
<pre><code>N5 N4 N3 N2 N1 N0 N6</code></pre>
<p>N6, despite the name, is the least significant bit.</p>
<p>This 7-bit pattern number can identify 128 patterns in the 16k pattern memory, each of which are 128 bytes in size. The full 7-bits are therefore used for 4-bit sprites.</p>
<p>For 8-bit sprites, N6=0 always. The remaining 6 bits can identify 64 patterns, each of which is 256 bytes in size.</p>
<p>The N5:N0,N6 bits are stored in a particular sprite’s attributes to identify which image a sprite uses.</p>
<h6 id="bit-sprite-patterns">8-Bit Sprite Patterns</h6>
<p>The <span class="math inline">16 × 16</span> pixel image uses 8-bits for each pixel so that each pixel can be one of 256 colours. One colour indicates transparency and this is programmed into the Sprite Transparency Index register (nextreg $4B). By default the transparent value is $E3.</p>
<p>As an example of an 8-bit sprite, let’s have a look at figure 1.1.</p>
<figure>
<img src="video/sprite_1.png" alt="Pattern Example" /><figcaption aria-hidden="true">Pattern Example</figcaption>
</figure>
<p>Using the default palette, which is initialised with RGB332 colours from 0-255, the hexadecimal values for this pattern arranged in a <span class="math inline">16 × 16</span> array are shown below:</p>
<pre><code>04040404040404E3E3E3E3E3E3E3E3E3
04FFFFFFFFFF04E3E3E3E3E3E3E3E3E3
04FFFBFBFBFF04E3E3E3E3E3E3E3E3E3
04FFFBF5F5FBFF04E3E3E3E3E3E3E3E3
04FFFBF5A8A8FBFF04E3E3E3E3E3E3E3
04FFFFFBA844A8FBFF04E3E3E3E3E3E3
040404FFFBA844A8FBFF04E3E3E3E3E3
E3E3E304FFFBA84444FBFF04E304E3E3
E3E3E3E304FFFB444444FBFF044D04E3
E3E3E3E3E304FFFB44444444FA4D04E3
E3E3E3E3E3E304FFFB44FFF54404E3E3
E3E3E3E3E3E3E304FF44F5A804E3E3E3
E3E3E3E3E3E3E3E304FA4404A804E3E3
E3E3E3E3E3E3E3044D4D04E304F504E3
E3E3E3E3E3E3E3E30404E3E3E304FA04
E3E3E3E3E3E3E3E3E3E3E3E3E3E30404
</code></pre>
<p>Here $E3 is used as the transparent index.</p>
<p>These 256 bytes would be stored in pattern memory in left to right, top to bottom order.</p>
<h6 id="bit-sprite-patterns-1">4-Bit Sprite Patterns</h6>
<p>The <span class="math inline">16 × 16</span> pixel image uses 4-bits for each pixel so that each pixel can be one of 16 colours. One colour indicates transparency and this is programmed into the lower 4-bits of the Sprite Transparency Index register (nextreg $4B). By default the transparency value is $3. Note that the same register is shared with 8-bit patterns to identify the transparent index.</p>
<p>Since each pixel only occupies 4-bits, two pixels are stored in each byte. The leftmost pixel is stored in the upper 4-bits and the rightmost pixel is stored in the lower 4-bits.</p>
<p>As an example we will use the same sprite image as was given in the 8-bit pattern example. Here only the lower 4 bits of each pixel is retained to confine each pixel’s color to 4-bits:</p>
<pre><code>4444444333333333
4FFFFF4333333333
4FBBBF4333333333
4FB55BF433333333
4FB588BF43333333
4FFB848BF4333333
444FB848BF433333
3334FB844BF43433
33334FB444BF4D43
333334FB4444AD43
3333334FB4F54433
33333334F4584333
333333334A448433
33333334DD434543
33333333443334A4
3333333333333344</code></pre>
<p>$3 is used as the transparent index.</p>
<p>These 128 bytes would be stored in pattern memory in left to right, top to bottom order.</p>
<p>The actual colour that will appear on screen will depend on the palette, described below. The default palette will not likely generate suitable colours for 4-bit sprites.</p>
<h3 id="sprite-palette">Sprite Palette</h3>
<p>Each pixel of a sprite image is 8-bit for 8-bit patterns or 4-bit for 4-bit patterns. The pixel value is known as a pixel colour index. This colour index is combined with the sprite’s palette offset. The palette offset is a 4-bit value added to the top 4-bits of the pixel colour index. The purpose of the palette offset is to allow a sprite to change the colour of an image.</p>
<p>The final sprite colour index generated by the sprite hardware is then the sum of the pixel index and the 4-bit palette offset. In pictures using binary math:</p>
<pre><code>8-bit Sprite
PPPP0000
+ IIIIIIII
----------
SSSSSSSS

4-bit Sprite
PPPP0000
+ 0000IIII
----------
SSSSSSSS = PPPPIIII</code></pre>
<p>Where “PPPP” is the 4-bit palette offset from the sprite’s attributes and the “I”s represent the pixel value from the sprite pattern. The final sprite index is represented by the 8-bit value “SSSSSSSS”.</p>
<p>For 4-bit sprites the palette offset can be thought of as selecting one of 16 different 16-colour palettes.</p>
<p>This final 8-bit sprite index is then passed through the sprite palette which acts like a lookup table that returns the 9-bit RGB333 colour associated with the sprite index.</p>
<p>At power up, the sprite palette is initialized such that the sprite index passes through unchanged and is therefore interpretted as an RGB332 colour. The missing third blue bit is generated as the logical OR of the two other blue bits. In short, for 8-bit sprites, the sprite index also acts like the colour when using the default palette.</p>
<h3 id="sprite-attributes">Sprite Attributes</h3>
<p>A sprite’s attributes is a list of properties that determine how and where the sprite is drawn.</p>
<p>Each sprite is described by either 4 or 5 attribute bytes listed below:</p>
<p>Sprite Attribute 0</p>
<pre><code>X X X X X X X X</code></pre>
<p>The least significant eight bits of the sprite’s X coordinate. The ninth bit is found in sprite attribute 2.</p>
<p>Sprite Attribute 1</p>
<pre><code>Y Y Y Y Y Y Y Y</code></pre>
<p>The least significant eight bits of the sprite’s Y coordinate. The ninth bit is optional and is found in attribute 4.</p>
<p>Sprite Attribute 2</p>
<pre><code>P P P P XM YM R X8/PR</code></pre>
<p>P = 4-bit Palette Offset<br />
XM = 1 to mirror the sprite image horizontally<br />
YM = 1 to mirror the sprite image vertically<br />
R = 1 to rotate the sprite image 90 degrees clockwise<br />
X8 = Ninth bit of the sprite’s X coordinate<br />
PR = 1 to indicate P is relative to the anchor’s palette offset (relative sprites only)<br />
Rotation is applied before mirroring.<br />
Relative sprites, described below, replace X8 with PR.</p>
<figure>
<img src="video/flags.png" alt="All Rotate and Mirror Flags" /><figcaption aria-hidden="true">All Rotate and Mirror Flags</figcaption>
</figure>
<p>Sprite Attribute 3</p>
<pre><code>V E N5 N4 N3 N2 N1 N0</code></pre>
<p>V = 1 to make the sprite visible<br />
E = 1 to enable attribute byte 4<br />
N = Sprite pattern to use 0-63<br />
If E=0, the sprite is fully described by sprite attributes 0-3. The sprite pattern is an 8-bit one identified by pattern N=0-63. The sprite is an anchor and cannot be made relative. The sprite is displayed as if sprite attribute 4 is zero.<br />
If E=1, the sprite is further described by sprite attribute 4.</p>
<p>Sprite Attribute 4</p>
<ol type="A">
<li><p>Extended Anchor Sprite</p>
<pre><code>H N6 T X X Y Y Y8</code></pre>
<p>H = 1 if the sprite pattern is 4-bit<br />
N6 = 7th pattern bit if the sprite pattern is 4-bit<br />
T = 0 if relative sprites are composite type else 1 for unified type<br />
XX = Magnification in the X direction (00 = <span class="math inline">1×</span>, 01 = <span class="math inline">2×</span>, 10 = <span class="math inline">4 × 4</span>, 11 = <span class="math inline">8×</span>)<br />
YY = Magnification in the Y direction (00 = <span class="math inline">1×</span>, 01 = <span class="math inline">2×</span>, 10 = <span class="math inline">4×</span>, 11 = <span class="math inline">8×</span>)<br />
Y8 = Ninth bit of the sprite’s Y coordinate<br />
<span>H,N6</span> must not equal <span>0,1</span> as this combination is used to indicate a relative sprite.</p></li>
<li><p>Relative Sprite, Composite Type</p>
<pre><code>0 1 N6 X X Y Y PO</code></pre>
<p>N6 = 7th pattern bit if the sprite pattern is 4-bit<br />
XX = Magnification in the X direction (00 = <span class="math inline">1×</span>, 01 = <span class="math inline">2×</span>, 10 = <span class="math inline">4×</span>, 11 = <span class="math inline">8×</span>)<br />
YY = Magnification in the Y direction (00 = <span class="math inline">1×</span>, 01 = <span class="math inline">2×</span>, 10 = <span class="math inline">4×</span>, 11 = <span class="math inline">8×</span>)<br />
PO = 1 to indicate the sprite pattern number is relative to the anchor’s</p></li>
<li><p>Relative Sprite, Unified Type</p>
<pre><code>0 1 N6 0 0 0 0 PO</code></pre>
<p>N6 = 7th pattern bit if the sprite pattern is 4-bit<br />
PO = 1 to indicate the sprite pattern number is relative to the anchor’s</p></li>
</ol>
<p>The display surface for sprites is <span class="math inline">320 × 256</span>. The X coordinate of the sprite is nine bits, ranging over 0-511, and the Y coordinate is optionally nine bits again ranging over 0-511 or is eight bits ranging over 0-255. The full extent 0-511 wraps on both axes, meaning a sprite 16 pixels wide plotted at X coordinate 511 would see its first pixel not displayed (coordinate 511) and the following pixels displayed in coordinates 0-14.</p>
<p>The full display area is visible in VGA. However, the HDMI display is vertically shorter so the top eight pixel rows (Y = 0-7) and the bottom eight pixel rows (Y = 248-255) will not be visible on an HDMI display.</p>
<p>Sprites can be fully described by sprite attributes 0-3 if the E bit in sprite attribute 3 is zero. These sprites are compatible with the original sprite module from core versions prior to 2.00.26.</p>
<p>If the E bit is set then a fifth sprite attribute, sprite attribute 4, becomes active. This attribute introduces scaling, 4-bit patterns, and relative sprites. Scaling is self-explanatory and 4-bit patterns were described in the last section. Relative sprites are described in the next section.</p>
<h3 id="relative-sprites">Relative Sprites</h3>
<p>Normal sprites (sprites that are not relative) are known as anchor sprites. As the sprite module draws sprites in the order 0-127 (there are 128 sprites), it internally stores characteristics of the last anchor sprite seen. If following sprites are relative, they inherit some of these characteristics, which allows relative sprites to have, among other things, coordinates relative to the anchor. This means moving the anchor sprite also causes its relatives to move with it.</p>
<p>There are two types of relative sprites supported known as “Composite Sprites” and “Unified Sprites”. The type is determined by the anchor in the T bit of sprite attribute 4.</p>
<ol type="A">
<li><p>Composite Sprites<br />
The sprite module records the following information from the anchor:</p>
<ul>
<li><p>Anchor.visible</p></li>
<li><p>Anchor.Y</p></li>
<li><p>Anchor.palette_offset</p></li>
<li><p>Anchor.N (pattern number)</p></li>
<li><p>Anchor.H (indicates if the sprite uses 4-bit patterns)</p></li>
</ul>
<p>These recorded items are not used by composite sprites:</p>
<ul>
<li><p>Anchor.rotate</p></li>
<li><p>Anchor.xmirror</p></li>
<li><p>Anchor.ymirror</p></li>
<li><p>Anchor.xscale</p></li>
<li><p>Anchor.yscale</p></li>
</ul>
<p>The anchor determines if all its relative sprites use 4-bit patterns or not.</p>
<p>The visibility of a particular relative sprite is the result of ANDing the anchor’s visibility with the relative sprite’s visibility. In other words, if the anchor is invisible then so are all its relatives.</p>
<p>Relative sprites only have 8-bit X and Y coordinates (the ninth bits are taken for other purposes). These are signed offsets from the anchor’s X,Y coordinate. Moving the anchor moves all its relatives along with it.</p>
<p>If the relative sprite has its PR bit set in sprite attribute 2, then the anchor’s palette offset is added to the relative sprite’s to determine the active palette offset for the relative sprite. Otherwise the relative sprite uses its own palette offset as usual.</p>
<p>If the relative sprite has its PO bit set in sprite attribute 4, then the anchor’s pattern number is added to the relative sprite’s to determine the pattern used for display. Otherwise the relative sprite uses its own pattern number as usual. The intention is to supply a method to easily animate a large sprite by manipulating the pattern number in the anchor.</p>
<p>A composite sprite is like a collection of independent sprites tied to an anchor.</p></li>
<li><p>Unified Sprites</p>
<p>Unified sprites are a further extension of the composite type. The same information is recorded from the anchor and the same behaviour as described under composite sprites applies.</p>
<p>The difference is the collection of anchor and relatives is treated as if it were a single <span class="math inline">16 × 16</span> sprite. The anchor’s rotation, mirror, and scaling bits apply to all its relatives. Rotating the anchor causes all the relatives to rotate around the anchor. Mirroring the anchor causes the relatives to mirror around the anchor. The sprite hardware will automatically adjust X,Y coords and rotation, scaling and mirror bits of all relatives according to settings in the anchor.</p>
<p>Unified sprites should be defined as if all its parts are <span class="math inline">16 × 16</span> in size with the anchor controlling the look of the whole.</p>
<p>A unified sprite is like a big version of an individual <span class="math inline">16 × 16</span> sprite controlled by the anchor.</p></li>
</ol>
<h3 id="programming-sprites">Programming Sprites</h3>
<p>Sprites are created via three io registers and a nextreg interface.</p>
<p>Port $303B () Sprite Slot/Flags<br />
Write: Sprite Slot Select<br />
select sprite slot for Sprite Attribute and Sprite Pattern ports which independently auto-increment<br />
Read: Sprite status</p>
<ul>
<li><p>bits 7-2 = reserved</p></li>
<li><p>bit 1 = Max sprites per line</p></li>
<li><p>bit 0 = Collision flag</p></li>
</ul>
<pre><code>X S S S S S S S
N6 X N N N N N N</code></pre>
<p>A write to this port has two effects.</p>
<p>One is it selects one of 128 sprites for writing sprite attributes via port $57.</p>
<p>The other is it selects one of 128 4-bit patterns in pattern memory for writing sprite patterns via port $5B. The N6 bit shown is the least significant in the 7-bit pattern number and should always be zero when selecting one of 64 8-bit patterns indicated by N.</p>
<p>Port $57 () Sprite Attributes<br />
Byte 1</p>
<ul>
<li><p>bits 7-0 = LSB of X coordinate (bit 8 is in byte 3)</p></li>
</ul>
<p>Byte 2</p>
<ul>
<li><p>bits 7-0 = LSB of Y coordinate (bit 8 is in byte 5)</p></li>
</ul>
<p>Byte 3</p>
<ul>
<li><p>bits 7-4 = Palette Offset</p></li>
<li><p>bit 3 = Enable X Mirror</p></li>
<li><p>bit 2 = Enable Y Mirror</p></li>
<li><p>bit 1 = Enable Roration</p></li>
<li><p>bit 0 = By Sprite Type</p>
<ul>
<li><p>Anchor = MSB of X coordinate</p></li>
<li><p>Relative = Enable relative palette offset</p></li>
</ul></li>
</ul>
<p>Byte 4</p>
<ul>
<li><p>bit 7 = Enable visibility</p></li>
<li><p>bit 6 = Enable Byte 5</p></li>
<li><p>bit 5-0 = Pattern Index (“name”)</p></li>
</ul>
<p>Byte 5 (optional)<br />
Anchor</p>
<ul>
<li><p>bit 7-6 = type and pattern</p>
<ul>
<li><p>00 = 8-bit color</p></li>
<li><p>01 = relative</p></li>
<li><p>10 = 4-bit color, lower half of pattern (bytes 0-127)</p></li>
<li><p>11 = 4-bit color, upper half of pattern (byets 128-255)</p></li>
</ul></li>
<li><p>bit 5 = Attached relative sprite type</p>
<ul>
<li><p>0 = composite</p></li>
<li><p>1 = big sprite</p></li>
</ul></li>
<li><p>bit 4-3 = X-axis scale factor</p>
<ul>
<li><p>00 = <span class="math inline">1×</span></p></li>
<li><p>01 = <span class="math inline">2×</span></p></li>
<li><p>10 = <span class="math inline">4×</span></p></li>
<li><p>11 = <span class="math inline">8×</span></p></li>
</ul></li>
<li><p>bit 2-1 = Y-axis scale factor</p></li>
<li><p>bit 0 = MSB of Y coordinate</p></li>
</ul>
<p>Composite Relative</p>
<ul>
<li><p>bits 7-6 = 01</p></li>
<li><p>bit 5 = N6<br />
8-bit</p>
<ul>
<li><p>Reserved, must be 0</p></li>
</ul>
<p>4-bit</p>
<ul>
<li><p>0 = lower half of pattern (bytes 0-127)</p></li>
<li><p>1 = upper half of pattern (bytes 128-255)</p></li>
</ul></li>
<li><p>bit 4-3 = X-axis scale factor</p></li>
<li><p>bit 2-1 = Y-axis scale factor</p></li>
<li><p>bit 0 = Enable relative pattern offset</p></li>
</ul>
<p>Big-sprite Relative</p>
<ul>
<li><p>bits 7-6 = 01</p></li>
<li><p>bit 5 = N6<br />
8-bit</p>
<ul>
<li><p>Reserved, must be 0</p></li>
</ul>
<p>4-bit</p>
<ul>
<li><p>0 = lower half of pattern (bytes 0-127)</p></li>
<li><p>1 = upper half of pattern (bytes 128-255)</p></li>
</ul></li>
<li><p>bit 4-1 = Reserved, must be 0</p></li>
<li><p>bit 0 = Enable relative pattern offset</p></li>
</ul>
<p>Once a sprite is selected via port $303B, its attributes can be written to this port one byte after another. Sprites can have either four or five attribute bytes and the internal attribute pointer will move onto the next sprite after those four or five attribute bytes are written. This means you can select a sprite via port $303B and write attributes for as many sequential sprites as desired. The attribute pointer will roll over from sprite 127 to sprite 0.</p>
<p>Port $5B () Sprite Pattern<br />
Load data into sprite pattern memory auto-incrementing. Port $303B can be used to set the starting sprite pattern number.</p>
<p>Once a pattern number is selected via port $303B, the 256-byte or 128-byte pattern can be written to this port. The internal pattern pointer auto-increments after each write so as many sequential patterns as desired can be written. The internal pattern pointer will roll over from pattern 127 to pattern 0 (4-bit patterns) or from pattern 63 to pattern 0 (8-bit patterns) automatically.</p>
<p>Port $303B (R)</p>
<pre><code>0 0 0 0 0 0 M C</code></pre>
<p>M = 1 if the maximum number of sprites per line was exceeded<br />
C = 1 if any two displayed sprites collide on screen<br />
Reading this port automatically resets the M and C bits.</p>
<p>Besides the i/o interface, there is a nextreg interface to sprite attributes. The nextreg interface allows the copper to manipulate sprites and grants the program random access to a sprite’s individual attribute bytes.</p>
<p>Register (R/W) $34 () <span class="math inline">⇒</span> Sprite Number<br />
Lockstep (NextReg $09 bit 4 set)</p>
<ul>
<li><p>bit 7 = Pattern address offset (Add 128 to pattern address)</p></li>
<li><p>bits 6-0 = Sprite number 0-127, Pattern number 0-63</p></li>
<li><p>effectively performs an out to port $303B</p></li>
</ul>
<p>No Lockstep (NextReg $09 bit 4 clear)</p>
<ul>
<li><p>bit 7 = Reserved, must be 0</p></li>
<li><p>bits 6-0 = Sprite number 0-127</p></li>
</ul>
<p>This register selects which sprite has its attributes connected to the sprite attribute registers</p>
<p>Register (W) $35 () <span class="math inline">⇒</span> Sprite Attribute 0</p>
<ul>
<li><p>bits 7-0 = Sprite X coordinate LSB (MSB in NextReg $37)</p></li>
</ul>
<p>Register (W) $75 () <span class="math inline">⇒</span> Sprite Attribute 0 (Auto-incrementing)<br />
See nextreg $35</p>
<p>Register (W) $36 () <span class="math inline">⇒</span> Sprite Attribute 1</p>
<ul>
<li><p>bits 7-0 = Sprite Y coordinate LSB (MSB in NextReg $39)</p></li>
</ul>
<p>Register (W) $76 () <span class="math inline">⇒</span> Sprite Attribute 1 (Auto-incrementing)<br />
See nextreg $36</p>
<p>Register (W) $37 () <span class="math inline">⇒</span> Sprite Attribute 2</p>
<ul>
<li><p>bits 7-4 = 4-bit Palette offset</p></li>
<li><p>bit 3 = Enable horizontal mirror (reverse)</p></li>
<li><p>bit 2 = Enable vertical mirror (reverse)</p></li>
<li><p>bit 1 = Enable 90<span class="math inline"><sup><em>O</em></sup></span> Clockwise Rotation</p></li>
</ul>
<p>Normal Sprites</p>
<ul>
<li><p>bit 0 = X coordinate MSB</p></li>
</ul>
<p>Relative Sprites</p>
<ul>
<li><p>bit 0 = Palette offset is relative to anchor sprite</p></li>
</ul>
<p>Rotation is applied before mirroring</p>
<p>Register (W) $77 () <span class="math inline">⇒</span> Sprite Attribute 2 (Auto-incrementing)<br />
See nextreg $37</p>
<p>Register (W) $38 () <span class="math inline">⇒</span> Sprite Attribute 3</p>
<ul>
<li><p>bit 7 = Enable Visiblity</p></li>
<li><p>bit 6 = Enable Attribute 4 (0 = Attribute 4 effectively $00)</p></li>
<li><p>bits 5-0 = Sprite Pattern Number</p></li>
</ul>
<p>Register (W) $78 () <span class="math inline">⇒</span> Sprite Attribute 3 (Auto-incrementing)<br />
See nextreg $38</p>
<p>Register (W) $39 () <span class="math inline">⇒</span> Sprite Attribute 4<br />
Normal Sprites</p>
<ul>
<li><p>bit 7 = 4-bit pattern switch (0 = 8-bit sprite, 1 = 4-bit sprite)</p></li>
<li><p>bit 6 = Pattern number bit-7 for 4-bit, 0 for 8-bit</p></li>
<li><p>bit 5 = Type of attached relative sprites (0 = Composite, 1 = Unified)</p></li>
<li><p>bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)</p></li>
<li><p>bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)</p></li>
<li><p>bit 0 = MSB of Y coordinate</p></li>
</ul>
<p>Relative, Composite Sprites</p>
<ul>
<li><p>bit 7-6 = 01</p></li>
<li><p>bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit</p></li>
<li><p>bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)</p></li>
<li><p>bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)</p></li>
<li><p>bit 0 = Pattern number is relative to anchor</p></li>
</ul>
<p>Relative, Unified Sprites</p>
<ul>
<li><p>bit 7-6 = 01</p></li>
<li><p>bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit</p></li>
<li><p>bits 4-1 = 0000</p></li>
<li><p>bit 0 = Pattern number is relative to anchor</p></li>
</ul>
<p>Register (W) $79 () <span class="math inline">⇒</span> Sprite Attribute 4 (Auto-incrementing)<br />
See nextreg $39</p>
<h3 id="global-control-of-sprites">Global Control of Sprites</h3>
<p>The following nextreg are also of interest for sprites.</p>
<p>Register (R/W) $09 () <span class="math inline">⇒</span> Peripheral 4 setting:</p>
<ul>
<li><p>bit 7 = PSG 2 Mono Enable (0 on hard reset)</p></li>
<li><p>bit 6 = PSG 1 Mono Enable (0 on hard reset)</p></li>
<li><p>bit 5 = PSG 0 Mono Enable (0 on hard reset)</p></li>
<li><p>bit 4 = Sprite ID lockstep enable (1 = Nextreg $34 and IO Port $303B are in lockstep, 0 on reset)</p></li>
<li><p>bit 3 = divMMC mapRAM bit Control (reset bit 7 of port $E3)</p></li>
<li><p>bit 2 = HDMI audio mute (0 on hard reset)</p></li>
<li><p>bits 1-0 = scanlines</p>
<ul>
<li><p>00 = scanlines off</p></li>
<li><p>01 = scanlines 12.5%</p></li>
<li><p>10 = scanlines 25%</p></li>
<li><p>11 = scanlines 50%</p></li>
</ul></li>
<li><p>In Sprite lockstep, NextREG $34 and Port $303B are in lockstep</p></li>
</ul>
<p>Register (R/W) $15 () <span class="math inline">⇒</span> Sprite and Layer System Setup</p>
<ul>
<li><p>bit 7 = LoRes mode (0 on reset)</p></li>
<li><p>bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on top) (0 on reset)</p></li>
<li><p>bit 5 = Enable sprite clipping in over border mode (0 on reset)</p></li>
<li><p>bits 4-2 = set layers priorities (000 on reset)</p>
<ul>
<li><p>000 - S L U</p></li>
<li><p>001 - L S U</p></li>
<li><p>010 - S U L</p></li>
<li><p>011 - L U S</p></li>
<li><p>100 - U S L</p></li>
<li><p>101 - U L S</p></li>
<li><p>110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7</p></li>
<li><p>111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]</p></li>
</ul></li>
<li><p>bit 1 = Enable Sprites Over border (0 on reset)</p></li>
<li><p>bit 0 = Enable Sprites (0 on reset)</p></li>
</ul>
<p>The sprite module draws sprites in the order 0-127 in each scanline. Bit 6 determines whether sprite 0 is topmost or sprite 127 is topmost.</p>
<p>Bits 4:2 determine layer priority and how sprites overlay or are obscured by other layers.</p>
<p>Register (R/W) $19 () <span class="math inline">⇒</span> Sprite Clip Window Definition</p>
<ul>
<li><p>bits 7-0 = Cood. of the clip window</p>
<ul>
<li><p>1st write - X1 position</p></li>
<li><p>2nd write - X2 position</p></li>
<li><p>3rd write - Y1 position</p></li>
<li><p>4rd write - Y2 position</p></li>
</ul></li>
</ul>
<p>The values are 0,255,0,191 after a Reset<br />
Reads do not advance the clip position</p>
<p>When the clip window is enabled for sprites in "over border" mode, the X coords are internally doubled and the clip window origin is moved to the sprite origin inside the border.</p>
<p>When the clip window is enabled for sprites in “over border” mode, the X coords are internally doubled and the clip window origin is moved to the sprite origin inside the border.</p>
<p>Sprites will only be visible inside the clipping window. When not in over-border mode (bit 1 of nextreg $15) the clipping window is given in ULA screen coordinates with 0,0 correspoding to the top left corner of the ULA screen. In over-border mode, the clipping window’s origin is moved to the sprite coordinate origin 32 pixels to the left and 32 pixels above the ULA screen origin.</p>
<p>Regardless, sprite position is always in sprite coordinates with 32,32 corresponding to the top left corner of the ULA screen.</p>
<p>Register (R/W) $1C () <span class="math inline">⇒</span> Clip Window Control<br />
Read</p>
<ul>
<li><p>bits 7-6 = Layer 3 Clip Index</p></li>
<li><p>bits 5-4 = Layer 0/1 Clip Index</p></li>
<li><p>bits 3-2 = Sprite clip index</p></li>
<li><p>bits 1-0 = Layer 2 Clip Index</p></li>
</ul>
<p>Write</p>
<ul>
<li><p>bits 7-4 = Reserved, must be 0</p></li>
<li><p>bit 3 - reset Layer 3 clip index</p></li>
<li><p>bit 2 - reset Layer 0/1 clip index</p></li>
<li><p>bit 1 - reset sprite clip index.</p></li>
<li><p>bit 0 - reset Layer 2 clip index.</p></li>
</ul>
<p>Register (R/W) $4B () <span class="math inline">⇒</span> Sprite Transparency Index</p>
<ul>
<li><p>bits 7-0 = Index value ($E3 if reset)</p></li>
</ul>
<p>For 4-bit sprites only the bottom 4-bits are relevant.</p>
<h1 id="audio">Audio</h1>
<h2 id="zx-spectrum-1-bit">ZX Spectrum 1-bit</h2>
<p>The baseline sound of the ZX Spectrum was produced by toggling the Ear bit (bit 4) of $fe (254) The ULA port to produce 1-bit audio. It is enabled by bit 4 of Next register $08 (8). While this does work on the ZX Spectrum Next, there are other much better methods and this is only supported for backward compatibility.</p>
<p>Code:</p>
<pre><code>;; enable internal speaker
ld bc,$243B
ld a,$08
out (c),a
ld bc,$253B
in a,(c)
or $10
out (c),a</code></pre>
<h2 id="sampled-8-bit">Sampled 8-bit</h2>
<p>The ZX Next has four 8-bit D/A audio channels connected to provide sampled stereo sound. Channels A and B are the left channels, while C and D are the right channels. In order use 8-bit sound, it must first be enabled by setting bit 3 on nextreg $08. In order to emulate legacy hardware there are a number of ports that can be used to control the four channels additionally these are mirrored to three nextregs to enable driving audio using the copper. Channel A is mapped to ports $0f, $3f, and $f1; channel B to ports $1f and $f3 and nextreg $2C; channel C to ports $4f, and $f9 and nextreg $2E; and channel D to: $5f and $fb; with port $df connected to both channel A and C and nextreg $2D connected to both channel A and D.</p>
<p>Code:</p>
<pre><code>;; enable SpecDrum/Convox audio
ld bc,$243B
ld a,$08
out (c),a
ld bc,$253B
in a,(c)
or $08
out (c),a</code></pre>
<h2 id="turbosound">Turbosound</h2>
<p>TurboSound consists of the implementation of three AY-3-8912 chips. To enable TurboSound set bit 1 of Next Register $08 (8). Once enabled the sound chips and registers of the sound chips are selected using port $fffd (65533) TurboSound Next Control while the registers are accessed using $bffd () Sound Chip Register Access. To enable access to a particular chip write 111111xx to the control register where 01=AY1, 10=AY2, and 11=AY3. Access to particular registers of the selected chip is selected by writing the register number to the control register. You can then access a chip register using the access port.</p>
<p>Code:</p>
<pre><code>;; enable TurboSound audio
ld bc,$243B
ld a,$08
out (c),a
ld bc,$253B
in a,(c)
or $02
out (c),a</code></pre>
<p>Each of the three AY chips has three channels, A, B, and C whose mapping is controlled by bit 5 of Next register 0x08 (8).</p>
<p>Register (R/W) $00 () <span class="math inline">⇒</span> Channel A fine tune</p>
<p>Register (R/W) $01 () <span class="math inline">⇒</span> Channel A coarse tune (4 bits)</p>
<p>Register (R/W) $02 () <span class="math inline">⇒</span> Channel B fine tune</p>
<p>Register (R/W) $03 () <span class="math inline">⇒</span> Channel B coarse tune (4 bits)</p>
<p>Register (R/W) $04 () <span class="math inline">⇒</span> Channel C fine tune</p>
<p>Register (R/W) $05 () <span class="math inline">⇒</span> Channel C coarse tune (4 bits)</p>
<p>Register (R/W) $06 () <span class="math inline">⇒</span> Noise period (5 bits)</p>
<p>Register (R/W) $07 () <span class="math inline">⇒</span> Tone Enable</p>
<ul>
<li><p>bit 5 = Channel C tone enable (0=enable, 1=disable)</p></li>
<li><p>bit 4 = Channel B tone enable (0=enable, 1=disable)</p></li>
<li><p>bit 3 = Channel A tone enable (0=enable, 1=disable)</p></li>
<li><p>bit 2 = Channel C noise enable (0=enable, 1=disable)</p></li>
<li><p>bit 1 = Channel B noise enable (0=enable, 1=disable)</p></li>
<li><p>bit 0 = Channel A noise enable (0=enable, 1=disable)</p></li>
</ul>
<p>Register (R/W) $08 () <span class="math inline">⇒</span> Channel A amplitude</p>
<ul>
<li><p>bit 4 = enable fixed amplitude</p>
<ul>
<li><p>0 = fixed amplitude</p></li>
<li><p>1 = use envelope generator (bits 0-3 ignored)</p></li>
</ul></li>
<li><p>bits 3-0 = value of fixed amplitude</p></li>
</ul>
<p>Register (R/W) $09 () <span class="math inline">⇒</span> Channel B amplitude</p>
<ul>
<li><p>bit 4 = enable fixed amplitude</p>
<ul>
<li><p>0 = fixed amplitude</p></li>
<li><p>1 = use envelope generator (bits 0-3 ignored)</p></li>
</ul></li>
<li><p>bits 3-0 = value of fixed amplitude</p></li>
</ul>
<p>Register (R/W) $0A () <span class="math inline">⇒</span> Channel C amplitude</p>
<ul>
<li><p>bit 4 = enable fixed amplitude</p>
<ul>
<li><p>0 = fixed amplitude</p></li>
<li><p>1 = use envelope generator (bits 0-3 ignored)</p></li>
</ul></li>
<li><p>bits 3-0 = value of fixed amplitude</p></li>
</ul>
<p>Register (R/W) $0B () <span class="math inline">⇒</span> Envelope period fine</p>
<p>Register (R/W) $0C () <span class="math inline">⇒</span> Envelope period coarse</p>
<p>Register (R/W) $0D () <span class="math inline">⇒</span> Envelope shape</p>
<ul>
<li><p>bit 3 = Continue</p>
<ul>
<li><p>0 = drop to amplitude 0 after 1 cycle</p></li>
<li><p>1 = use ‘Hold’ value</p></li>
</ul></li>
<li><p>bit 2 = Attack</p>
<ul>
<li><p>0 = generator counts down</p></li>
<li><p>1 = generator counts up</p></li>
</ul></li>
<li><p>bit 1 = Alternate<br />
hold = 0</p>
<ul>
<li><p>0 = generator resets after each cycle</p></li>
<li><p>1=generator reverses direction each cycle</p></li>
</ul>
<p>hold=1</p>
<ul>
<li><p>0 = hold final value</p></li>
<li><p>1 = hold initial value</p></li>
</ul></li>
<li><p>bit 0 = Hold</p>
<ul>
<li><p>0 = cycle continuously</p></li>
<li><p>1 = perform one cycle and hold</p></li>
</ul></li>
</ul>
<h3 id="pi-audio">Pi Audio</h3>
<p>If connected the Pi Zero is configured to use the ZX Next as a soundcard over an I<sup>2</sup>S interface making the Raspberry Pi a fully configurable audio source for the ZX Spectrum Next.</p>
<h1 id="memory">Memory</h1>
<p>The ZX Spectrum Next commonly has with either 1MB or 2MB SRAM memory. This is more the 64kB directly addressable by its Z80N CPU. It is therefore necessary to use some form of memory paging to address all of the memory. This is accomplished using 8k pages or 16k banks. 256k of the total memory is used by the ROM images and device specific RAM leaving either 768k (pages 0-95/banks 0-47) or 1792k (pages 0-223/banks 0-111) that can be paged in as RAM. Pages 10, 11, and 14 are a little odd in that rather than coming from the normal SRAM, they come from BRAM internal to the FPGA.</p>
<h2 id="memory-management">Memory Management</h2>
<p>There are a number of different systems for controling memory papping into the 64k memory space of the Z80N CPU in the ZX Next: ZX Next native memory paging, ZX Spectrum 128, ZX Spectrum +3, divMMC, and Multiface.</p>
<h3 id="default-layout">Default Layout</h3>
<p>The default mapping of memory banks is the same as on 128k Spectrum models with a ROM0 (128k editor and menu system) mapped in at $0000-$3FFF, bank 5 at $4000-$7FFF, bank 2 at $8000-$BFFF, and bank 0 at $C000-$FFFF.</p>
<h3 id="ram">RAM</h3>
<h5 id="zx-spectrum-next-native">ZX Spectrum Next Native</h5>
<p>Registers $50 to $57 control the which SRAM pages are in each of the eight memory slots. Registers $50 and $51 support the special value $FF which indicates that the currently selected ROM is to be mapped into slots 0 and/or 1 ($0000-$3FFF).</p>
<p>Register (R/W) $50 () <span class="math inline">⇒</span> MMU Slot 0 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $0000 to $1FFF ($ff on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.<br />
A 255 value causes the ROM to become visible.</p>
<p>Register (R/W) $51 () <span class="math inline">⇒</span> MMU Slot 1 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $2000 to $3FFF ($ff on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.<br />
A 255 value causes the ROM to become visible.</p>
<p>Register (R/W) $52 () <span class="math inline">⇒</span> MMU Slot 2 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $4000 to $5FFF ($0A on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.</p>
<p>Register (R/W) $53 () <span class="math inline">⇒</span> MMU Slot 3 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $6000 to $7FFF ($0B on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.</p>
<p>Register (R/W) $54 () <span class="math inline">⇒</span> MMU Slot 4 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $8000 to $9FFF ($04 on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.</p>
<p>Register (R/W) $55 () <span class="math inline">⇒</span> MMU Slot 5 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $A000 to $BFFF ($05 on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.</p>
<p>Register (R/W) $56 () <span class="math inline">⇒</span> MMU Slot 6 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $C000 to $DFFF ($00 on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.</p>
<p>Register (R/W) $57 () <span class="math inline">⇒</span> MMU Slot 7 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $E000 to $FFFF ($01 on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.</p>
<p>Writing to ports $1FFD, $7FFD and $DFFD writes $FF to MMU0 and MMU1 and writes appropriate values to MMU6 and MMU7 to map in the selected 16k bank.</p>
<p>+3 special modes override the MMUs if used.</p>
<p>In addition the ZX Next has special controls which allow the data area for Layer 2 to be overlaied on memory in a fashion that permits selective read or write access. For details see the section on Layer 2 video.</p>
<h5 id="zx-spectrum-128">ZX Spectrum 128</h5>
<p>In addition to the native memory management, the ZX Next supports a memory management system that is an expanded, and backward compatible, version of the the system used on earlier ZX Spectrum models. This system uses registers $1FFD, $7FFD, and $DFFD.</p>
<p>Port $1FFD () Plus 3 Memory Paging Control</p>
<ul>
<li><p>bits 7-3 = Unused, nust be 0</p></li>
<li><p>bit 2 = High bit of ROM selection (low bit is in Port $7FFD)</p>
<ul>
<li><p>00 = ROM0 = 128k editor and menu system</p></li>
<li><p>01 = ROM1 = 128k syntax checker</p></li>
<li><p>10 = ROM2 = +3DOS</p></li>
<li><p>11 = ROM3 = 48k BASIC</p></li>
</ul></li>
<li><p>bit 1 = Special mode: Low bit of memory configuration number</p></li>
<li><p>bit 0 = Paging mode</p>
<ul>
<li><p>0 = Normal</p></li>
<li><p>1 = Special</p></li>
</ul></li>
</ul>
<p>You should echo writes to $5B67</p>
<p>Port $7FFD () Memory Paging Control</p>
<ul>
<li><p>bits 6-7 = reserved</p></li>
<li><p>bit 5 = Lock memory paging</p></li>
<li><p>bit 4 = low bit of ROM Select (high bit is in Port $1FFD)</p>
<ul>
<li><p>00 = ROM0 = 128k editor and menu system</p></li>
<li><p>01 = ROM1 = 128k syntax checker</p></li>
<li><p>10 = ROM2 = +3DOS</p></li>
<li><p>11 = ROM3 = 48k BASIC</p></li>
</ul></li>
<li><p>bit 3 = Shadow screen toggle</p></li>
<li><p>bits 2-0 = LSB of Bank number for slot 4 (MSB is in Port $DFFD)</p></li>
</ul>
<p>Disable with bit 5 port $7FFD</p>
<p>Port $DFFD () Next Memory Bank Select</p>
<ul>
<li><p>bits 7-4 = Reserved, must be 0</p></li>
<li><p>bits 3-0 = MSB of bank number for slot 4 (LSB is in Port $7FFD)</p></li>
</ul>
<h6 id="spectrum-128-standard-paging">Spectrum 128 Standard Paging</h6>
<p>128-style memory management can only alter the bank addressed at $c000 (16k-slot 4, or 8k-slots 7-8). The active 16k-bank at $c000 is selected by writing the 3 LSBs of the 16k-bank number to the bottom 3 bits of Memory Paging Control ($7FFD), and the 4 MSBs to the bottom 4 bits of Next Memory Bank Select ($DFFD). (The reason for the division is that the original Spectrum 128, having only 128k of memory, only needed 3 bits.)</p>
<p>If you are using the standard interrupt handler or OS routines, then any time you write to Memory Paging Control ($7FFD) you should also store the value at $5B5C. Any time you write to Plus 3 Memory Paging Control ($1FFD) you should also store the value at $5B67. There is no corresponding system variable for the Next-only Next Memory Bank Select ($DFFD) and standard OS routines may not support the extended banks properly.</p>
<h6 id="paging-out-rom">Paging out ROM</h6>
<p>ROM can be paged out by enabling AllRam mode, or by using Next memory management. Beware that some programs may assume that they can find ROM service routines at fixed addresses between $0000-$3fff. More importantly, if the default interrupt mode (IM 1) is set, the Z80 will jump the program counter to $0038 every frame expecting to find an interrupt handler there. If it does not, pain and suffering will likely result. DI is your friend. On the plus side, this does allow you to write your own interrupt handler without the nuisance of using IM 2.</p>
<h6 id="spectrum-128-special-paging">Spectrum 128 Special Paging</h6>
<p>“Special paging mode” (also called “AllRam mode” or “CP/M mode”) is enabled by writing a value with the LSB set to Plus 3 Memory Paging Control ($1FFD). Depending on the 3 low bits of this value a memory configuration is selected as follows:</p>
<h3 id="rom">ROM</h3>
<p>The ZX Spectrum Next had several ROMS: ROM0 (16k) - 128k editor and menu system, ROM1 (16k) - 128k syntax checker, ROM2 (16k) - +3DOS, ROM3 (16k) - 48k BASIC, divMMC/esxDOS ROM (8k), divMMC RAM (128k), Multiface ROM (8k) and Alternate ROM (16k).</p>
<h5 id="zx-next-native">ZX Next native</h5>
<p>Slots 0 and 1 select use by ROM by selecting page $FF. Which what ROM is mapped in is determined by the other memory management system. If the rest of the system selected the 48k ROM, Nextreg $8C determines whether the actual 48k ROM, or the ZX Next Alternate ROM is in use. In addition, it is possible to enable writing to the Alternate ROM.</p>
<p>Register (R/W) $8C () <span class="math inline">⇒</span> Alternate ROM<br />
Immediate</p>
<ul>
<li><p>bit 7 = Alt ROM Enable (0 on hard reset)</p></li>
<li><p>bit 6 = Alt ROM visible ONLY during writes (0 on hard reset)</p></li>
<li><p>bit 5 = Reserved, must be 0</p></li>
<li><p>bit 4 = 48k ROM Lock (0 on hard reset)</p></li>
</ul>
<p>After Soft Reset (copied into bits 7-4)</p>
<ul>
<li><p>bit 3 = Alt ROM Enable (0 on hard reset)</p></li>
<li><p>bit 2 = Alt ROM visible ONLY during writes (0 on hard reset)</p></li>
<li><p>bit 1 = Reserved, must be 0</p></li>
<li><p>bit 0 = 48k ROM Lock (0 on hard reset)</p></li>
</ul>
<h5 id="zx-spectrum-128k">ZX Spectrum 128k</h5>
<h6 id="rom-paging-and-selection">ROM paging and selection</h6>
<p>$0000-$3fff is usually mapped to ROM. This area can only be fully remapped using Next memory management. ROM is not considered one of the numbered banks; it is mapped to the two 8k-banks by default, or by setting their 8k-bank numbers to 255.</p>
<p>The 128k Spectrum has 2 ROM pages. Which of these is mapped is selected by altering Bit 4 of Memory Paging Control ($7FFD). The +2a/+3 has 4 ROM pages; the extra bit needed to select between these is bit 2 of Plus 3 Memory Paging Control ($1FFD). This maintains compatibility with the original machines’ ROM paging as long as the ROM is not paged out.</p>
<h5 id="divmmc">divMMC</h5>
<p>The divMMC ROM mapping can take priority when it is enabled by port $E3 or, when automapping has been enabled by nextreg $06, when it has been automapped due to reading one of the appropriate addresses. Port $E3 also controls whether the divMMC maps the esxDOS ROM or divMMC RAM page 3 into slot 0 and which divMMC RAM page is mapped into slot 1.</p>
<p>Port $E3 () divMMC Control<br />
Disable with bit 2 of Nextreg $09</p>
<ul>
<li><p>bit 7 = conmem, enable divMMC memory</p></li>
<li><p>bit 6 = mapram, enable divMMC allRAM mode</p></li>
<li><p>bits 3-0 = bank, selected divMMC ram bank for $2000-$3FFF region</p></li>
<li><p>conmem can be used to manually control divMMC mapping. When enabled<br />
$0000-$1FFF contains esxDOS ROM or esxDOS page 3<br />
$2000-$3FFF contains esxDOS RAM page selected by bits 3-0</p></li>
<li><p>divMMC automatically maps itself in when instruction fetches hit specific addresses in the ROM. When this happens, the esxDOS ROM (or divMMC bank 3 if mapram is set) appears in $0000-$1FFF and the selected divMMC bank appears as RAM in $2000-$3FFF</p></li>
<li><p>bit 6 can only be set, once set only a power cycle can reset it. nextreg $09 bit 3 can be set to reset this bit.</p></li>
</ul>
<p>divMMC automapping is normally disabled by NextZXOS see nextreg $06 bit 4.<br />
Register (R/W) $06 () <span class="math inline">⇒</span> Peripheral 2 Settings</p>
<ul>
<li><p>bit 7 = F8 CPU Speed Hotkey Enable (1 on reset)</p></li>
<li><p>bit 6 = Enable classic audio mode (beep and tape to internal speaker, other audio to ear and HDMI, 3.01.02)</p></li>
<li><p>bit 5 = F3 50Hz/60Hz Hotkey Enable (1 on reset)</p></li>
<li><p>bit 4 = divMMC Automap/NMI Enable (0 on hard reset)</p></li>
<li><p>bit 3 = NMI Button Enable (0 on hard reset)</p></li>
<li><p>bit 2 = PS/2 Mode (0 = keyboard, 1 = mouse)</p></li>
<li><p>bits 1-0 = PSG Mode (00 = YM, 01 = AY, 11 = hold all PSGs in Reset)</p></li>
</ul>
<h5 id="multiface">Multiface</h5>
<p>Need to find useful docs on the Multiface memory.</p>
<p>9f 1-In, 128-In2<br />
1f 1-Out<br />
bf 128-In, 3-Out<br />
3f 128-Out, 3-In, 3-button<br />
7f3f 3-7ffd<br />
1f3f 3-1ffd</p>
<h2 id="interactions-between-paging-methods">Interactions between paging methods</h2>
<p>Changes made in 128 style and Next style memory management are synchronized. The most recent change always has priority. This means that</p>
<p>using 128-style memory management to select a new 16k-bank in 16k-slot 4 will update the MMU registers for the two 8k-slots with the corresponding 8k-bank numbers. enabling AllRam mode will update all of the 8k-bank values with the appropriate 8k-slot numbers. These may then be overwritten using Next memory management without needing to alter the value at port $1FFD. Since the 128-style memory management ports are not readable, there is no synchronization applicable in the other direction.</p>
<h2 id="memory-map">Memory Map</h2>
<h3 id="global-memory-map">Global Memory Map</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Physical Address</strong></th>
<th style="text-align: left;"><strong>Size</strong></th>
<th style="text-align: left;"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">$000000-$00FFFF</td>
<td style="text-align: left;">64k</td>
<td style="text-align: left;">ZX Spectrum ROM (ROM0-3)</td>
</tr>
<tr class="even">
<td style="text-align: left;">$010000-$011FFF</td>
<td style="text-align: left;">8k</td>
<td style="text-align: left;">EsxDOS ROM</td>
</tr>
<tr class="odd">
<td style="text-align: left;">$012000-$013FFF</td>
<td style="text-align: left;">8k</td>
<td style="text-align: left;">Multiface ROM</td>
</tr>
<tr class="even">
<td style="text-align: left;">$014000-$017FFF</td>
<td style="text-align: left;">16k</td>
<td style="text-align: left;">EsxDOS Extra ROM</td>
</tr>
<tr class="odd">
<td style="text-align: left;">$018000-$01BFFF</td>
<td style="text-align: left;">16k</td>
<td style="text-align: left;">Alternate ROM</td>
</tr>
<tr class="even">
<td style="text-align: left;">$01C000-$01FFFF</td>
<td style="text-align: left;">16k</td>
<td style="text-align: left;">Multiface RAM</td>
</tr>
<tr class="odd">
<td style="text-align: left;">$020000-$03FFFF</td>
<td style="text-align: left;">128k</td>
<td style="text-align: left;">DivMMC RAM</td>
</tr>
<tr class="even">
<td style="text-align: left;">$040000-$0FFFFF</td>
<td style="text-align: left;">768k</td>
<td style="text-align: left;">Standard RAM</td>
</tr>
<tr class="odd">
<td style="text-align: left;">$100000-$1FFFFF</td>
<td style="text-align: left;">1024k</td>
<td style="text-align: left;">Expanded RAM</td>
</tr>
</tbody>
</table>
<p>Normal RAM is divided into 8k pages or 16k banks which may be mapped into the 64k memory space by the memory management hardware of the Next. Some of these pages have special properties.</p>
<p>Pages 10, 11 and 14 are used by Layer 1/0 (ULA) video modes with 10 used by standard Spectrum ULA video, 10 and 11 used by Timex Hi-res and Hi-colour modes, 11 used by Timex alternate video and page 14 used by the ULA shadow mode. Pages 10 an 11 are usable by Layer 3 (Tilemap) video.</p>
<h3 id="z80-visible-memory-map">Z80 Visible Memory Map</h3>
<h1 id="zxndma">zxnDMA</h1>
<p>February 25, 2019 Phoebus Dokos Off Hardware, Resources,</p>
<p>The ZX Spectrum Next DMA (zxnDMA)</p>
<h2 id="overview">Overview</h2>
<p>The ZX Spectrum Next DMA (zxnDMA) is a single channel dma device that implements a subset of the Z80 DMA functionality. The subset is large enough to be compatible with common uses of the similar Datagear interface available for standard ZX Spectrum computers and compatibles. It also adds a burst mode capability that can deliver audio at programmable sample rates to the DAC device.</p>
<h2 id="accessing-the-zxndma">Accessing the zxnDMA</h2>
<p>The zxnDMA is mapped to a single Read/Write IO Port 0x6B which is the same one used by the Datagear but unlike the Datagear it doesn’t also map itself to a second port 0x0B similar to the MB-02 interface.</p>
<pre><code>PORT $6b: zxnDMA</code></pre>
<h2 id="description">Description</h2>
<p>The normal Z80 DMA (Z8410) chip is a pipelined device and because of that it has numerous off-by-one idiosyncrasies and requirements on the order that certain commands should be carried out. These issues are not duplicated in the zxnDMA. You can continue to program the zxnDMA as if it is were a Z8410 DMA device but it can also be programmed in a simpler manner.</p>
<p>The single channel of the zxnDMA chip consists of two ports named A and B. Transfers can occur in either direction between ports A and B, each port can describe a target in memory or IO, and each can be configured to autoincrement, autodecrement or stay fixed after a byte is transferred.</p>
<p>A special feature of the zxnDMA can force each byte transfer to take a fixed amount of time so that the zxnDMA can be used to deliver sampled audio.</p>
<h2 id="modes-of-operation">Modes of Operation</h2>
<p>The zxnDMA can operate in a z80-dma compatibility mode.</p>
<p>The z80-dma compatibility mode is selected by setting bit 6 of nextreg $06. In this mode, all transfers involve length+1 bytes which is the same behaviour as the z80-dma chip. In zxn-dma mode, the transfer length is exactly the number of bytes programmed. This mode is mainly present to accommodate existing spectrum software that uses the z80-dma and for cp/m programs that may have a z80-dma option.</p>
<p>The zxnDMA can also operate in either burst or continuous modes.</p>
<p>Continuous mode means the DMA chip runs to completion without allowing the CPU to run. When the CPU starts the DMA, the DMA operation will complete before the CPU executes its next instruction.</p>
<p>Burst mode nominally means the DMA lets the CPU run if either port is not ready. This condition can’t happen in the zxnDMA chip except when operated in the special fixed time transfer mode. In this mode, the zxnDMA will let the CPU run while it waits for the fixed time to expire between bytes transferred.</p>
<p>Note that there is no byte transfer mode as in the Z80 DMA.</p>
<h2 id="programming-the-zxndma">Programming the zxnDMA</h2>
<p>Like the Z80 DMA chip, the zxnDMA has seven write registers named WR0-WR6 that control the device. Each register WR0-WR6 can have zero or more parameters associated with it.</p>
<p>In a first write to the zxnDMA port, the write value is compared against a bitmask to determine which of the WR0-WR6 is the target. Remaining bits in the written value can contain data as well as a list of associated parameter bits. The parameter bits determine if further writes are expected to deliver parameter values. If there are multiple parameter bits set, the expected order of parameter values written is determined by parameter bit position from right to left (bit 0 through bit 7). Once all parameters are written, the zxnDMA again expects a regular register write selecting WR0-WR6.</p>
<p>The table X.Y describes the registers and the bitmask required to select them on the zxnDMA.</p>
<h2 id="zxndma-registers">zxnDMA Registers</h2>
<p>These are described below following the same convention used by Zilog for its DMA chip:</p>
<h5 id="wr0-write-register-group-0">WR0 – Write Register Group 0</h5>
<pre><code>D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
 0   |   |   |   |   |   |   |
     |   |   |   |   |   0   0  Do not use
     |   |   |   |   |   0   1  Transfer (Prefer this for Z80 DMA compatibility)
     |   |   |   |   |   1   0  Do not use (Behaves like Transfer, Search on Z80
     |   |   |   |   |                       DMA)
     |   |   |   |   |   1   1  Do not use (Behaves like Transfer, Search/Trans-
     |   |   |   |   |                      fer on Z80 DMA)
     |   |   |   |   0 = Port B -&gt; Port A (Byte transfer direction)
     |   |   |   |   1 = Port A -&gt; Port B
     |   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  PORT A STARTING ADDRESS (LOW BYTE)
     |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  PORT A STARTING ADDRESS (HIGH BYTE)
     |   V
D7  D6  D5  D4  D3  D2  D1  D0  BLOCK LENGTH (LOW BYTE)
     V
D7  D6  D5  D4  D3  D2  D1  D0  BLOCK LENGTH (HIGH BYTE)</code></pre>
<p>Several registers are accessible from WR0. The first write to WR0 is to the base register byte. Bits D6:D3 are optionally set to indicate that associated registers in this group will be written next. The order the writes come in are from D3 to D6 (right to left). For example, if bits D6 and D3 are set, the next two writes will be directed to PORT A STARTING ADDRESS LOW followed by BLOCK LENGTH HIGH.</p>
<h5 id="wr1-write-register-group-1">WR1 – Write Register Group 1</h5>
<pre><code>D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
 0   |   |   |   |   1   0   0
     |   |   |   |
     |   |   |   0 = Port A is memory
     |   |   |   1 = Port A is IO
     |   |   |
     |   0   0 = Port A address decrements
     |   0   1 = Port A address increments
     |   1   0 = Port A address is fixed
     |   1   1 = Port A address is fixed
     |
     V
D7  D6  D5  D4  D3  D2  D1  D0  PORT A VARIABLE TIMING BYTE
 0   0   0   0   0   0   |   |
                         0   0 = Cycle Length = 4
                         0   1 = Cycle Length = 3
                         1   0 = Cycle Length = 2
                         1   1 = Do not use</code></pre>
<p>The cycle length is the number of cycles used in a read or write operation. The first cycle asserts signals and the last cycle releases them. There is no half cycle timing for the control signals.</p>
<h5 id="wr2-write-register-group-2">WR2 – Write Register Group 2</h5>
<pre><code>D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
 0   |   |   |   |   0   0   0
     |   |   |   |
     |   |   |   0 = Port B is memory
     |   |   |   1 = Port B is IO
     |   |   |
     |   0   0 = Port B address decrements
     |   0   1 = Port B address increments
     |   1   0 = Port B address is fixed
     |   1   1 = Port B address is fixed
     |
     V
D7  D6  D5  D4  D3  D2  D1  D0  PORT B VARIABLE TIMING BYTE
 0   0   |   0   0   0   |   |
         |               0   0 = Cycle Length = 4
         |               0   1 = Cycle Length = 3
         |               1   0 = Cycle Length = 2
         |               1   1 = Do not use
         |
         V
D7  D6  D5  D4  D3  D2  D1  D0  ZXN PRESCALAR (FIXED TIME TRANSFER)</code></pre>
<p>The ZXN PRESCALAR is a feature of the zxnDMA implementation. If non-zero, a delay will be inserted after each byte is transferred such that the total time needed for each transfer is determined by the prescalar. This works in both the continuous mode and the burst mode. If the DMA is operated in burst mode, the DMA will give up any waiting time to the CPU so that the CPU can run while the DMA is idle.</p>
<p>The rate of transfer is given by the formula “Frate = 875kHz / prescalar” or, rearranged, “prescalar = 875kHz / Frate”. The formula is framed in terms of a sample rate (Frate) but Frate can be inverted to set a transfer time for each byte instead. The 875kHz constant is a nominal value assuming a 28MHz system clock; the system clock actually varies from this depending on the video timing selected by the user (HDMI, VGA0-6) so for complete accuracy the constant should be prorated according to documentation for nextreg $11.</p>
<p>In a DMA audio setting, selecting a sample rate of 16kHz would mean setting the prescalar value to 55. This sample period is constant across changes in CPU speed.</p>
<h5 id="wr3-write-register-group-3">WR3 – Write Register Group 3</h5>
<pre><code>D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
 1   |   0   0   0   0   0   0
     |
     1 = DMA Enable</code></pre>
<p>The Z80 DMA defines more fields but they are ignored by the zxnDMA.</p>
<p>The two other registers defined by the Z80 DMA in this group on D4 and D3 are implemented by the zxnDMA but they do nothing.</p>
<p>It is preferred to start the DMA by writing an Enable DMA command to WR6.</p>
<h5 id="wr4-write-register-group-4">WR4 – Write Register Group 4</h5>
<pre><code>D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
 1   |   |   0   |   |   0   1
     |   |       |   |
     0   0 = Do not use (Behaves like Continuous mode, Byte mode on Z80 DMA)
     0   1 = Continuous mode
     1   0 = Burst mode
     1   1 = Do not use
                 |   |
                 |   V
D7  D6  D5  D4  D3  D2  D1  D0  PORT B STARTING ADDRESS (LOW BYTE)
                 |
                 V
D7  D6  D5  D4  D3  D2  D1  D0  PORT B STARTING ADDRESS (HIGH BYTE)</code></pre>
<p>The Z80 DMA defines three more registers in this group through D4 that define interrupt behaviour. Interrups and pulse generation are not implemented in the zxnDMA nor are these registers available for writing.</p>
<h5 id="wr5-write-register-group-5">WR5 – Write Register Group 5</h5>
<pre><code>D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
 1   0   |   |   0   0   1   0
         |   |
         |   0 = /ce only
         |   1 = /ce &amp; /wait multiplexed
         |
         0 = Stop on end of block
         1 = Auto restart on end of block</code></pre>
<p>The /ce &amp; /wait mode is implemented in the zxnDMA but is not currently used. This mode has an external device using the DMA’s /ce pin to insert wait states during the DMA’s transfer.</p>
<p>The auto restart feature causes the DMA to automatically reload its source and destination addresses and reset its byte counter to zero to repeat the last transfer when a previous one is finished.</p>
<h5 id="wr6-command-register">WR6 – Command Register</h5>
<pre><code>D7  D6  D5  D4  D3  D2  D1  D0  BASE REGISTER BYTE
 1   ?   ?   ?   ?   ?   1   1
     |   |   |   |   |
     1   0   0   0   0 = \$C3 = Reset
     1   0   0   0   1 = \$C7 = Reset Port A Timing
     1   0   0   1   0 = \$CB = Reset Port B Timing
     0   1   1   1   1 = \$BF = Read Status Byte
     0   0   0   1   0 = \$8B = Reinitialize Status Byte
     0   1   0   0   1 = \$A7 = Initialize Read Sequence
     1   0   0   1   1 = \$CF = Load
     1   0   1   0   0 = \$D3 = Continue
     0   0   0   0   1 = \$87 = Enable DMA
     0   0   0   0   0 = \$83 = Disable DMA
 +-- 0   1   1   1   0 = \$BB = Read Mask Follows
 |
D7  D6  D5  D4  D3  D2  D1  D0  READ MASK
 0   |   |   |   |   |   |   |
     |   |   |   |   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Status Byte
     |   |   |   |   |   |
     |   |   |   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Byte Counter Low
     |   |   |   |   |
     |   |   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Byte Counter High
     |   |   |   |
     |   |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Port A Address Low
     |   |   |
     |   |   V
D7  D6  D5  D4  D3  D2  D1  D0  Port A Address High
     |   |
     |   V
D7  D6  D5  D4  D3  D2  D1  D0  Port B Address Low
     |
     V
D7  D6  D5  D4  D3  D2  D1  D0  Port B Address High</code></pre>
<p>Unimplemented Z80 DMA commands are ignored.</p>
<p>Prior to starting the DMA, a LOAD command must be issued to copy the Port A and Port B addresses into the DMA’s internal pointers. Then an ìEnable DMAî command is issued to start the DMA.</p>
<p>The ìContinueî command resets the DMA’s byte counter so that a following ìEnable DMAî allows the DMA to repeat the last transfer but using the current internal address pointers. I.e. it continues from where the last copy operation left off.</p>
<p>Registers can be read via an IO read from the DMA port after setting the read mask. (At power up the read mask is set to $7f). Register values are the current internal dma counter values. So ìPort Address A Lowî is the lower 8-bits of Port A’s next transfer address. Once the end of the read mask is reached, further reads loop around to the first one.</p>
<p>The format of the DMA status byte is as follows:</p>
<p>00E1101T</p>
<p>E is set to 0 if the total block length has been transferred at least once.</p>
<p>T is set to 1 if at least one byte has been transferred.</p>
<h5 id="operating-speed">Operating speed</h5>
<p>The zxnDMA operates at the same speed as the CPU, that is 3.5MHz, 7MHz or 14MHz. This is a contended clock that is modified by the ULA and the auto-slowdown by Layer2.</p>
<p>Auto-slowdown occurs without user intervention if speed exceeds 7Mhz and the active Layer2 display is being generated (higher speed operation resumes when the active Layer2 display is not generated). Programmers do NOT need to account for speed differences regarding DMA transfers as this happens automatically.</p>
<p>Because of this, the cycle lengths for Ports A and B can be set to their minimum values without ill effects. The cycle lengths specified for Ports A and B are intended to selectively slow down read or write cycles for hardware that cannot operate at the DMA’s full speed.</p>
<h5 id="the-dma-and-interrupts">The DMA and Interrupts</h5>
<p>The zxnDMA cannot currently generate interrupts.</p>
<p>The other side of this is that while the DMA controls the bus, the Z80 cannot respond to interrupts. On the Z80, the nmi interrupt is edge triggered so if an nmi occurs the fact that it occurred is stored internally in the Z80 so that it will respond when it is woken up. On the other hand, maskable interrupts are level triggered. That is, the Z80 must be active to regularly sample the /INT line to determine if a maskable interrupt is occurring. On the Spectrum and the ZX Next, the ULA (and line interrupt) are only asserted for a fixed amount of time  30 cycles at 3.5MHz. If the DMA is executing a transfer while the interrupt is asserted, the CPU will not be able to see this and it will most likely miss the interrupt. In burst mode, the CPU will never miss these interrupts, although this may change if multiple channels are implemented.</p>
<h2 id="programming-examples">Programming examples</h2>
<p>A simple way to program the DMA is to walk down the list of registers WR0-WR5, sending desired settings to each. Then start the DMA by sending a LOAD command followed by an ENABLE_DMA command to WR6. Once more familiar with the DMA, you will discover that the amount of information sent can be reduced to what changes between transfers.</p>
<ol>
<li><p>Assembly</p>
<p>Short example program to DMA memory to the screen then DMA a sprite image from memory to sprite RAM, and then showing said sprite scroll across the screen.</p>
<pre><code>;------------------------------------------------------------------------------
device zxspectrum48
;------------------------------------------------------------------------------
; DEFINE testing
;------------------------------------------------------------------------------
; DMA (Register 6)
;
;------------------------------------------------------------------------------
;zxnDMA programming example
;------------------------------------------------------------------------------
;(c) Jim Bagley
;------------------------------------------------------------------------------
DMA_RESET equ $c3
DMA_RESET_PORT_A_TIMING equ $c7
DMA_RESET_PORT_B_TIMING equ $cb
DMA_LOAD equ $cf ; %11001111
DMA_CONTINUE equ $d3
DMA_DISABLE_INTERUPTS equ $af
DMA_ENABLE_INTERUPTS equ $ab
DMA_RESET_DISABLE_INTERUPTS equ $a3
DMA_ENABLE_AFTER_RETI equ $b7
DMA_READ_STATUS_BYTE equ $bf
DMA_REINIT_STATUS_BYTE equ $8b
DMA_START_READ_SEQUENCE equ $a7
DMA_FORCE_READY equ $b3
DMA_DISABLE equ $83
DMA_ENABLE equ $87
DMA_WRITE_REGISTER_COMMAND equ $bb
DMA_BURST equ %11001101
DMA_CONTINUOUS equ %10101101
ZXN_DMA_PORT equ $6b
SPRITE_STATUS_SLOT_SELECT equ $303B
SPRITE_IMAGE_PORT equ $5b
SPRITE_INFO_PORT equ $57
;------------------------------------------------------------------------------

IFDEF testing
org $6000
ELSE
org $2000
ENDIF

start
ld hl,$0000
ld de,$4000
ld bc,$800
call TransferDMA ; copy some random data to the screen pointing
; to ROM for now, for the purpose of showing
; how to do a DMA copy.
ld a,0 ; sprite image number we want to update
ld bc,SPRITE_STATUS_SLOT_SELECT
out (c),a ; set the sprite image number
ld bc,1*256 ; number to transfer (1)
ld hl,testsprite ; from
call TransferDMASprite ; transfer to sprite ram

nextreg 21,1 ; turn sprite on. for more info on this check
; out https://www.specnext.com/tbblue-io-port-system/
ld de,0
ld (xpos),de ; set initial X position ( doesn&#39;t need it for
; this demo, but if you run the .loop again it
; will continue from where it was
ld a,$20
ld (ypos),a ; set initial Y position

.loop
ld a,0 ; sprite number we want to position
ld bc,SPRITE_STATUS_SLOT_SELECT
out (c),a
ld de,(xpos)
ld hl,(ypos) ; ignores H so doing this rather than
; ld a,(ypos):ld l,a
ld bc,(image) ; not flipped or palette shifted
call SetSprite

halt

ld de,(xpos)
inc de
ld (xpos),de
ld a,d
cp $01
jr nz,.loop ; if high byte of xpos is not 1 (right of
; screen )
ld a,e
cp $20+1
jr nz,.loop ; if low byte is not $21 just off the right of
; the screen, $20 is off screen but as the
; INC DE is just above and not updated sprite
; after it, it needs to be $21
xor a
ret ; return back to basic with OK

xpos dw 0 ; x position
ypos db 0 ; y position
; these next two BITS and IMAGE are swapped
; as bits needs to go into B register image
; db 0+$80 ; use image 0 (for the image we
; transfered)+$80 to set the sprite to active
bits db 0 ; not flipped or palette shifted

c1 = %11100000
c2 = %11000000
c3 = %10100000
c4 = %10000000
c5 = %01100000
c6 = %01000000
c7 = %00100000
c8 = %00000000

testsprite
db c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1
db c1,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c1
db c1,c2,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c2,c1
db c1,c2,c3,c4,c4,c4,c4,c4,c4,c4,c4,c4,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c5,c5,c5,c5,c5,c5,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c6,c6,c6,c6,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c7,c7,c7,c7,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c7,c8,c8,c7,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c7,c8,c8,c7,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c7,c7,c7,c7,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c6,c6,c6,c6,c6,c6,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c5,c5,c5,c5,c5,c5,c5,c5,c4,c3,c2,c1
db c1,c2,c3,c4,c4,c4,c4,c4,c4,c4,c4,c4,c4,c3,c2,c1
db c1,c2,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c3,c2,c1
db c1,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c2,c1
db c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1,c1

;-------------------------------------------------
; de = X
; l = Y
; b = bits
; c = sprite image
SetSprite
push bc
ld bc,SPRITE_INFO_PORT
out (c),e ; Xpos
out (c),l ; Ypos
pop hl
ld a,d
and 1
or h
out (c),a
ld a,l:or $80
out (c),a ; image
ret

;--------------------------------
; hl = source
; de = destination
; bc = length
;--------------------------------
TransferDMA
di
ld (DMASource),hl
ld (DMADest),de
ld (DMALength),bc
ld hl,DMACode
ld b,DMACode_Len
ld c,ZXN_DMA_PORT
otir
ei
ret

DMACode db DMA_DISABLE
db %01111101 ; R0-Transfer mode, A -&gt; B, write adress
; + block length
DMASource dw 0 ; R0-Port A, Start address
; (source address)
DMALength dw 0 ; R0-Block length (length in bytes)
db %01010100 ; R1-write A time byte, increment, to
; memory, bitmask
db %00000010 ; 2t
db %01010000 ; R2-write B time byte, increment, to
; memory, bitmask
db %00000010 ; R2-Cycle length port B
db DMA_CONTINUOUS ; R4-Continuous mode (use this for block
; transfer), write dest adress
DMADest dw 0 ; R4-Dest address (destination address)
db %10000010 ; R5-Restart on end of block, RDY active
; LOW
db DMA_LOAD ; R6-Load
db DMA_ENABLE ; R6-Enable DMA

DMACode_Len equ $-DMACode

;------------------------------------------------------------------------------
; hl = source
; bc = length
; set port to write to with TBBLUE_REGISTER_SELECT
; prior to call
;------------------------------------------------------------------------------
TransferDMAPort
di
ld (DMASourceP),hl
ld (DMALengthP),bc
ld hl,DMACodeP
ld b,DMACode_LenP
ld c,ZXN_DMA_PORT
otir
ei
ret

DMACodeP db DMA_DISABLE
db %01111101 ; R0-Transfer mode, A -&gt; B, write adress
; + block length
DMASourceP dw 0 ; R0-Port A, Start address (source address)
DMALengthP dw 0 ; R0-Block length (length in bytes)
db %01010100 ; R1-read A time byte, increment, to
; memory, bitmask
db %00000010 ; R1-Cycle length port A
db %01101000 ; R2-write B time byte, increment, to
; memory, bitmask
db %00000010 ; R2-Cycle length port B
db %10101101 ; R4-Continuous mode (use this for block
; transfer), write dest adress
dw $253b ; R4-Dest address (destination address)
db %10000010 ; R5-Restart on end of block, RDY active
; LOW
db DMA_LOAD ; R6-Load
db DMA_ENABLE ; R6-Enable DMA

DMACode_LenP equ $-DMACodeP
;------------------------------------------------------------------------------
; hl = source
; bc = length
;------------------------------------------------------------------------------
TransferDMASprite
di
ld (DMASourceS),hl
ld (DMALengthS),bc
ld hl,DMACodeS
ld b,DMACode_LenS
ld c,ZXN_DMA_PORT
otir
ei
ret

DMACodeS db DMA_DISABLE
db %01111101 ; R0-Transfer mode, A -&gt; B, write adress
; + block length
DMASourceS dw 0 ; R0-Port A, Start address (source address)
DMALengthS dw 0 ; R0-Block length (length in bytes)
db %01010100 ; R1-read A time byte, increment, to
; memory, bitmask
db %00000010 ; R1-Cycle length port A
db %01101000 ; R2-write B time byte, increment, to
; memory, bitmask
db %00000010 ; R2-Cycle length port B
db %10101101 ; R4-Continuous mode (use this for block
; transfer), write dest adress
dw SPRITE_IMAGE_PORT ; R4-Dest address (destination address)
db %10000010 ; R5-Restart on end of block, RDY active
; LOW
db DMA_LOAD ; R6-Load
db DMA_ENABLE ; R6-Enable DMA
DMACode_LenS equ $-DMACodeS
;------------------------------------------------------------------------------
; de = dest, a = fill value, bc = lenth
;------------------------------------------------------------------------------
DMAFill
di
ld (FillValue),a
ld (DMACDest),de
ld (DMACLength),bc
ld hl,DMACCode
ld b,DMACCode_Len
ld c,ZXN_DMA_PORT
otir
ei
ret

FillValue db 22
DMACCode db DMA_DISABLE
db %01111101
DMACSource dw FillValue
DMACLength dw 0
db %00100100,%00010000,%10101101
DMACDest dw 0
db DMA_LOAD,DMA_ENABLE
DMACCode_Len equ $-DMACCode

;------------------------------------------------------------------------------
; End of file
;------------------------------------------------------------------------------

IFDEF testing
savesna &quot;dmatest.sna&quot;,start
ELSE
fin
savebin &quot;DMATEST&quot;,start,fin-start
ENDIF</code></pre></li>
</ol>
<h1 id="copper-and-display-timing">Copper and Display Timing</h1>
<p>From: KevB (aka 9bitcolour)</p>
<h5 id="introduction-1">Introduction</h5>
<p>The ZX Spectrum Next includes a co-processor named “COPPER”. It functions in a similar way to the Copper found in the Commodore Amiga Agnus custom chip. It’s role is to free the Z80 of tasks that require the writing of hardware registers at precise pixel co-ordinates.</p>
<h5 id="overview-1">Overview</h5>
<p>The ZX Spectrum Next COPPER has three instructions: NOOP, MOVE, WAIT.</p>
<p>NOOP is used to fine tune timing. MOVE writes data to a specific range of hardware registers. WAIT waits for a pixel position on the video display.</p>
<p>These instructions are stored in 2k (2048 BYTES) of dedicated write-only program RAM also known as a “Copper list”.</p>
<p>Each instruction is 16 bits (WORD) in size allowing for a maximum of 1024 instructions to be stored in the program RAM. The COPPER uses an internal 10 bit program counter (PC) which wraps to zero at the end of the list. The PC can be reset to zero, this is the default value after a hard/soft reset.</p>
<p>The instructions are stored in big endian format and transferred to the 2k program RAM using the Z80 or DMA (bits 15..8 followed by bits 7..0).</p>
<p>Three write-only hardware registers control access to the program RAM as well as the operating modes.</p>
<p>System performance is not affected when the COPPER is executing instructions.</p>
<p>The hardware registers and COPPER program RAM are not connected to the main memory BUS. The overall design of this system together with the use of alternate clock edges means that contention between the COPPER, Z80 and DMA has been eliminated.</p>
<p>The COPPER has a base clock speed of 13.5Mhz for HDMI and 14Mhz for VGA.</p>
<p>The bandwidth is around 14 million single cycle NOOP/WAIT instructions and 7 million two cycle MOVE instructions per second.</p>
<h2 id="timing">Timing</h2>
<p>To fully understand the COPPER, you must first understand the display timing for each of the machines and video modes found in the ZX Spectrum Next.</p>
<p>There are several display timing configurations due to the four machine types, two refresh rates, two video systems (VGA/HDMI) and Timex HIRES mode.</p>
<p>Details of these timings are outlined in this chapter.</p>
<h5 id="machines">Machines</h5>
<p>The ZX Spectrum Next has four machine types (48k, 128k, Pentagon, and HDMI). The machine timing and HDMI determine the number of T-states per line which determines the base dot clock frequency and Z80/DMA clock speed.</p>
<p>This guide groups machine types by their timing for convenience. The HDMI video mode overrides the default machine timing so it is included as an extra machine type which does not exist in the official documentation.</p>
<h5 id="display">Display</h5>
<p>The ZX Spectrum Next doesn’t have video modes based on resolution that you would expect to find on graphics card based hardware. There is one fixed resolution of <span class="math inline">256 × 192</span> which can be doubled to <span class="math inline">512 × 192</span> in Timex HIRES mode. What it does have is the ability to set the refresh rate from 50Hz to 60Hz and horizontal dot clock. This in turn together with the VGA and HDMI timing affects the vertical line count giving several combinations in total.</p>
<p>VGA modes 0..6 are included as one single VGA mode as the internal machine timing is constant across those seven refresh rate steps.</p>
<p>More details can be found in Video modes.</p>
<h5 id="resolution">Resolution</h5>
<p>There are two main horizontal resolutions: standard <span class="math inline">256 × 192</span> and Timex HIRES <span class="math inline">512 × 192</span>. Details of LORES <span class="math inline">128 × 96</span> are not included to simplify this guide.</p>
<p>The frame buffer height is fixed at 192 pixels and surrounded by a large border and overscan as well as horizontal and vertical blanking periods.</p>
<p>There are five vertical line counts: 261, 262, 311, 312, 320. Several pixels are hidden in the overscan and blanking periods beyond the visible border.</p>
<p>The result is <span class="math inline">256 × 192</span> and <span class="math inline">512 × 192</span> pixel resolutions with a large border.</p>
<p>The colour of the visible border beyond the frame buffer can be manipulated. Visual changes will not show during the overscan and blanking periods.</p>
<h5 id="dot-clock">Dot Clock</h5>
<p>The dot clock on the ZX Spectrum Next runs at 13.5Mhz for HDMI and around 14Mhz for VGA. The COPPER clock runs at the same frequency as the dot clock. For v3.00 the copper runs at twice the frequency of the dot clock.</p>
<p>The number of dot clocks per line is calculated by multiplying the number of 3.5Mhz Z80 T-states per line by four. Example: 228Ts * 4 = 912 dot clocks.</p>
<p>The number of dot clocks per second is calculated by the following:</p>
<p>T-states per line * 4 * line count * refresh rate</p>
<p>In standard <span class="math inline">256 × 192</span> resolution the duration of one pixel is two dot clocks. In Timex HIRES <span class="math inline">512 × 192</span> resolution the duration of one pixel is one dot clock.</p>
<p>Details of the dot clock counts can be found in tables 5.1 and 5.2.</p>
<h5 id="coordinates">Coordinates</h5>
<p>The top left pixel of the frame buffer is line 0 and horizontal dot clock 0. This is also known as “0,0”.</p>
<p>The bottom right pixel of the frame buffer in standard <span class="math inline">256 × 192</span> resolution is line 191 and horizontal dot clocks 510+511.</p>
<p>The bottom right pixel of the frame buffer in Timex HIRES <span class="math inline">512 × 192</span> resolution is line 191 and horizontal dot clock 511.</p>
<p>The line one pixel above the frame buffer is the last line of the video frame and equal to the total line count minus one (312-1 for example).</p>
<p>The line one pixel below the frame buffer is line 192.</p>
<p>The COPPER horizontal dot clock compare is locked to every eight pixels in standard <span class="math inline">256 × 192</span> resolution and every sixteen pixels in Timex HIRES <span class="math inline">512 × 192</span> resolution. The NOOP instruction can be used to fine tune timing in single dot clock steps.</p>
<h5 id="compare">Compare</h5>
<p>The COPPER uses a 9 bit vertical line compare allowing it to handle the various line counts.</p>
<p>The COPPER horizontal compare is 6 bits meaning that it can wait for 64 positions across each line. The range of this value is limited by the machine timing as that determines the number of dot clocks per line.</p>
<p>Each horizontal compare is in steps of 16 dot clocks to cover the full range across a raster line.</p>
<p>16 dot clocks = 4 pixels in lo <span class="math inline">128 × 96</span> resolution</p>
<p>16 dot clocks = 8 pixels in standard <span class="math inline">256 × 192</span> resolution</p>
<p>16 dot clocks = 16 pixels in high <span class="math inline">512 × 192</span> resolution</p>
<p>There is some slack to consider after the maximum horizontal compare value. The slack is calculated using the following:</p>
<p>dot clocks per line - maximum horizontal compare * 16</p>
<p>Table 5.5 provides details of the horizontal display, left/right border, blanking and COPPER dot clock/pixel position compare values:</p>
<p>– Dot clock compare is out of range.</p>
<p>Table 5.6 provides a detailed list of vertical display, top/bottom border and blanking as well as maximum COPPER line compare. It also provides the ULA VBLANK interrupt line number.</p>
<p>– Line compare is out of range</p>
<p>* ULA VBLANK interrupt.</p>
<p>Note: The HDMI overscan and blanking period is larger than that of a VGA monitor which can auto-adjust alignment. The following data is based on visible results from various monitors thus subject to refinement.</p>
<p>Pixels are visible during DISPLAY/BORDER and hidden during BLANKING.</p>
<h5 id="overscan">Overscan</h5>
<p>The visible area of the display can extend to resolutions exceeding <span class="math inline">256 × 192</span>.</p>
<p>The 50/60 Hz refresh rate mode dictates the vertical limit.</p>
<p>VGA and HDMI differ with VGA providing more visible pixels beyond the range of HDMI. Table 5.7 provides ideal extended pixel resolutions:</p>
<p>Maximum Extended VGA Resolutions</p>
<p>50Hz = <span class="math inline">352 × 288</span> (standard 256 resolution)</p>
<p>60Hz = <span class="math inline">352 × 240</span> (standard 256 resolution)</p>
<p>Table 5.8 provides COPPER horizontal position and vertical line compare parameters for ideal extended resolutions:</p>
<p>TOP: Initial line of the extended top border area - see notes below*</p>
<p>BOT: Last line of the extended bottom border area - see notes below*</p>
<p>LEFT: First pixel of the extended left border area - see notes below**</p>
<p>RIGHT: Last pixel of the extended right border area - see notes below**</p>
<p>* Line compare value for MOVE (bits 8..0).</p>
<p>** The integer part is the horizontal value for MOVE (bits 14..9).</p>
<p>** The fractional part is specified in dot clocks (NOOP instructions).</p>
<h2 id="instructions">Instructions</h2>
<p>This section describes the behaviour of the COPPER instructions as well as the bit definitions and execution time.</p>
<p>The three 16 bit COPPER instructions are comprised of the following bit definitions:</p>
<p>H 6 bit horizontal dot clock compare</p>
<p>V 9 bit vertical line compare</p>
<p>R 7 bit Next register 0x00..0x7F</p>
<p>D 8 bit data</p>
<h5 id="noop">NOOP</h5>
<p>NOOP (no-operation) executes in one dot clock. It is useful for fine tuning timing, initialising COPPER RAM and ’NOP’ out COPPER program instructions.</p>
<p>It can be used to align colour and display changes to half pixel positions in standard <span class="math inline">256 × 192</span> resolution. Its duration is equal to one Timex HIRES pixel.</p>
<p>This guide uses the name ’NOOP’ to avoid confusion with the Z80 opcode NOP.</p>
<h5 id="move">MOVE</h5>
<p>MOVE executes in two dot clocks. It moves 8 bits of data into any of the Next hardware registers in the range $00 (0) .. $7F (127).</p>
<p>The WORD value $0000 is reserved for the NOOP instruction so no register access is carried out for that special case. Register $00 is read-only so not affected by the restriction of not being able to write zero to it.</p>
<p>This instruction can perform 7 million register writes per second for VGA and 6.75 million register writes per second for HDMI.</p>
<h5 id="wait">WAIT</h5>
<p>WAIT executes in one dot clock. It performs a compare with the current vertical line number and the current horizontal dot clock.</p>
<p>WAIT will hold until the current raster line matches the 9 bit value stored in bits 8..0. When the line compare matches, WAIT will still hold if the current horizontal dot clock is less than the value in bits 14..9.</p>
<p>This compare logic means that out of order vertical line compares will cause the COPPER to wait until the next video frame as the test is for an exact match of the line number. The COPPER will continue to the next instruction after an out of order horizontal pixel position compare as the test checks for the current dot clock being greater than or equal to the compare value.</p>
<p>WAIT will stop the COPPER when a compare is made against an out of range vertical line or horizontal dot clock position as they will never occur</p>
<p>A standard way to terminate a COPPER program is to wait for line 511 and horizontal position 63. This encodes into the instruction WORD $FFFF.</p>
<p>The horizontal dot clock position compare includes an adjustment meaning that the compare completes three dot clocks early in standard <span class="math inline">256 × 192</span> resolution and two dot clocks early in Timex HIRES <span class="math inline">512 × 192</span> resolution. In practice, a pixel position can be specified with clocks to spare to write a register value before the pixel is displayed. This saves software having to auto-adjust positions to arrive early. It also means that a wait for 0,0 can affect the first pixel of the frame buffer before it is displayed and set the scroll registers without visual artefacts.</p>
<h5 id="example">Example</h5>
<p>The following example provides a simple COPPER program to move data to a hardware register at two specific pixel positions. The BYTES for the program are listed in the left column:</p>
<pre><code>         PAL8 equ   0x41           ; 8 bit palette hardware register

$80,$00       WAIT  0,0            ; wait for pixel position 0,0 (H,V)
$00,$00       NOOP                 ; fine tune timing by one dot clock
$41,$E0       MOVE  PAL8,11100000b ; write RED to palette register

$C0,$BF       WAIT  32,191         ; wait for pixel position 256,191
$00,$00       NOOP                 ; fine tune timing by one dot clock
$41,$00       MOVE  PAL8,00000000b ; write BLACK to palette register

$FF,$FF       WAIT  63,511         ; wait for an out of range position</code></pre>
<h2 id="control">Control</h2>
<p>The COPPER is controlled by the following three write-only registers:</p>
<ul>
<li><p>$60 (96) Copper data</p></li>
<li><p>$61 (97) Copper control LO BYTE</p></li>
<li><p>$62 (98) Copper control HI BYTE</p></li>
</ul>
<p>The COPPER instructions are written one BYTE at a time to the program RAM using register $60 (Copper data).</p>
<p>An index system is used to select the destination write address within the 2K program RAM. Eleven bits are needed to represent the index. Registers $61 and $62 hold this 11 bit index.</p>
<p>The index increments each time one BYTE is written to register $60. The index wraps to zero when the last BYTE of program RAM is written.</p>
<p>The instruction data is normally written in big endian format although there is no rule stating that partial instruction BYTES cannot be written. It is safe to write to the COPPER program RAM while the COPPER is executing as long the instruction data written does not create a mall formed instruction which comprises of one half of the current executing instruction and one half the new instruction - this could result in unexpected behaviour.</p>
<p>The Z80 and DMA can be used to write the instruction data.</p>
<p>Writing to program RAM while the COPPER is running has no impact on system performance as the RAM is contention free. COPPER timing is not affected by the Z80 or DMA writing to the program RAM. Program RAM is write-only.</p>
<p>The contents of the 2k program RAM are preserved during a hard/soft reset.</p>
<p>Register $61 holds the lower 8 bits of the index. Register $62 holds the upper 3 bits of the index as well as two control bits which set the COPPER operating mode.</p>
<p>D 8 bit data</p>
<p>I 11 bit index</p>
<p>C 2 bit control</p>
<p>The COPPER has an internal 10 bit program counter (PC). Each instruction advances the program counter by one after completion. The program counter wraps to zero after the last instruction at location 1023. This causes the copper list to loop.</p>
<p>The program counter defaults to zero during a hard/soft reset.</p>
<p>The control bits require a change to update the operating mode. This feature preserves COPPER operation when setting the program RAM index address.</p>
<p>The program counter is preserved when stopping the COPPER. Two of the four control settings reset the internal PC to zero.</p>
<p>Table 5.11 describes the control bits:</p>
<p>The control mode names used in this guide differ from the official names.</p>
<p>Here is a detailed description of the control bits:</p>
<h5 id="stop">STOP</h5>
<p>This is the default operating mode set during a hard/soft reset. The COPPER is idle in this state and will STOP if currently executing when entering this mode. It is safe to write to any location within the 2K program RAM when the COPPER is stopped.</p>
<p>Entering STOP mode preserves the internal program counter so that the COPPER may continue when restarted.</p>
<h5 id="reset">RESET</h5>
<p>The program counter is RESET to zero when entering this mode. The COPPER is started if idle otherwise entering this mode acts as a jump to location zero when the COPPER is running.</p>
<h5 id="start">START</h5>
<p>Entering this mode causes an idle COPPER to start executing instructions from the current program counter. Entering this mode while the COPPER is running has no effect other than to disable FRAME mode if active.</p>
<h5 id="frame">FRAME</h5>
<p>The program counter is RESET to zero when entering this mode. The COPPER is started if idle otherwise entering this mode acts as a jump to location zero when the COPPER is running.</p>
<p>Entering this state enables FRAME mode. The program counter will be reset to zero each frame at 0,0.</p>
<h2 id="configuration-1">Configuration</h2>
<p>Hardware registers provide timing and configuration data allowing software to build and configure COPPER programs that function correctly across the various video modes and machine types. It is not essential to detect the machine type but it should be noted that software should not assume that it is running on a specific machine as the COPPER hardware is available across all four machine types.</p>
<p>Three registers can be read to determine the machine configuration for Ts per line, dot clocks, refresh rate, line count and maximum horizontal dot clock/pixel position compare.</p>
<h5 id="refresh-rate">Refresh Rate</h5>
<p>The refresh rate must be taken into account and can change real-time so should be monitored and auto-configured when the COPPER is active as the line count will change with the refresh rate. This could lead to the COPPER waiting for lines that never occur.</p>
<p>Register (R/W) $05 () <span class="math inline">⇒</span> Peripheral 1 Settings</p>
<ul>
<li><p>bits 7-6 = joystick 1 mode (MSB)</p></li>
<li><p>bits 5-4 = joystick 2 mode (MSB)</p></li>
<li><p>bit 3 = joystick 1 mode (LSB)</p></li>
<li><p>bit 2 = 50/60 Hz mode (0 = 50Hz, 1 = 60Hz)</p></li>
<li><p>bit 1 = joystick 2 mode (LSB)</p></li>
<li><p>bit 0 = Enable Scandoubler</p></li>
</ul>
<p>Joystick modes</p>
<ul>
<li><p>000 = Sinclair 2 (67890)</p></li>
<li><p>001 = Kempston 2 (port $37)</p></li>
<li><p>010 = Kempston 1 (port $1F)</p></li>
<li><p>011 = Megadrive 1 (port $1F)</p></li>
<li><p>100 = Cursor</p></li>
<li><p>101 = Megadrive 2 (port $37)</p></li>
<li><p>110 = Sinclair 1 (12345)</p></li>
<li><p>111 = I/O Mode (3.01.04) Both joysticks are places in I/O Mode if either is set to I/O Mode. The underlying joystick type is not changed and reads of this register will continue to return the last joystick type. Ehether the joystick is in io mode or not is invisible but this state can be cleared either through reset or by re-writing the gegister with joystick type not equal to 111. Recovery time for a normal joystick read after leaving I/O Mode is at most 64 scan lines.</p></li>
</ul>
<h5 id="video-modes">Video Modes</h5>
<p>The video mode can only be changed during the boot process so one initial read is required of this register during software start up phase.</p>
<p>The machine timing is identical for the seven VGA modes although the physical refresh rate of the video output speeds up for each mode in turn by roughly 1Hz. The internal timing of the machine remains constant and as close to the original hardware as possible. VGA is a perfect Amstrad ZX Spectrum 128k +3 for example as far as timing is concerned across the seven VGA modes.</p>
<p>The effect of this speed up means that mode 0 will execute in one second of time whereas mode 6 will execute in a shorter time period. Mode 0 is as close to 50/60 Hz as possible where mode 6 is closer to 60/70 Hz. That would mean that one second of machine time for mode 6 will execute in 0.83 seconds of human time when running 50 frames per second at 60Hz.</p>
<p>The eighth mode (mode 7) is used for HDMI timing. Machine configuration is forced for this mode. Line counts, Ts and various other settings are set to meet the rigid HDMI timing specification. For mode 7, 50/60 Hz are rock solid but the original hardware timing loses Ts across all machines to meet HDMI display requirements.</p>
<p>Software that was previously written for specific hardware with hard-coded software timing loops may fail. This is one of the risks of coding timing loops counting Ts. We saw evidence of this with the release of the 1985 Sinclair ZX Spectrum 128k+ and the later Amstrad models as previous software written for the ZX Spectrum 48k/48k+ would fail when trying to display colour attribute and border effects as the number of Ts per line was changed from 224Ts (1982 original 48k) to 228Ts (128k models). The ZX Spectrum Next runs slower in HDMI mode. Demos may fail to display correctly and games may slow down although setting the Z80 to 7Mhz can solve the game slow down, demos should be run in VGA mode for maximum compatibility.</p>
<p>Video timing also affects audio output as the sample rate can vary depending on the output timing method.</p>
<p>The following register allows software to read the video timing mode:</p>
<p>Register (R/W) $11 () <span class="math inline">⇒</span> Video Timing (writable in config mode only)</p>
<ul>
<li><p>bits 7-3 = Reserved, must be 0</p></li>
<li><p>bits 2-0 = Mode (VGA = 0..6, HDMI = 7)</p>
<ul>
<li><p>000 = Base VGA timing, clk28 = 28000000</p></li>
<li><p>001 = VGA setting 1, clk28 = 28571429</p></li>
<li><p>010 = VGA setting 2, clk28 = 29464286</p></li>
<li><p>011 = VGA setting 3, clk28 = 30000000</p></li>
<li><p>100 = VGA setting 4, clk28 = 31000000</p></li>
<li><p>101 = VGA setting 5, clk28 = 32000000</p></li>
<li><p>110 = VGA setting 6, clk28 = 33000000</p></li>
<li><p>111 = HDMI, clk28 = 27000000</p></li>
</ul></li>
<li><p>50/60Hz selection depends on bit 2 of register $05</p></li>
<li><p>Only writable in config mode</p></li>
</ul>
<h5 id="machine-type">Machine Type</h5>
<p>The machine type register can be used to provide the number of Ts per line, line count, dot clock and maximum horizontal COPPER wait.</p>
<p>The dot clock (DC) is the number of Ts per line * 4.</p>
<p>The maximum horizontal COPPER wait (H) is in multiples of 16 clocks.</p>
<p>Video mode 7 (HMDI) overrides the timing.</p>
<p>The following list shows the various parameters that can be gained from reading the machine register combined with the refresh register and video mode bits:</p>
<p>Register (R/W) $03 () <span class="math inline">⇒</span> Machine Type<br />
A write to this register disables the boot rom in config mode<br />
bits 2-0 select machine type when in config mode</p>
<ul>
<li><p>bit 7 = (W) Display Timing change enable (allow changes to bits 6-4) (0 on hard reset)</p></li>
<li><p>bits 6-4 = Display Timing</p></li>
<li><p>bit 3 = Display Timing user lock control</p></li>
<li><p>Read</p>
<ul>
<li><p>0 = No user lock on display timing</p></li>
<li><p>1 = User lock on display timing</p></li>
</ul></li>
<li><p>Write</p>
<ul>
<li><p>1 = Apply user lock on display timing (0 on hard reset)</p></li>
</ul></li>
<li><p>bits 2-0 = Machine Type (config mode only)<br />
determines roms loaded</p></li>
<li><p>Machine Types/Display Timings</p>
<ul>
<li><p>000 or 001 = ZX 48K</p></li>
<li><p>010 = ZX 128K/+2 (Grey)</p></li>
<li><p>011 = ZX +2A-B/+3e/Next Native</p></li>
<li><p>100 = Pentagon 128K</p></li>
</ul></li>
</ul>
<h5 id="summary">Summary</h5>
<p>Table 5.13 provides a full list of video timing configuration data:</p>
<h1 id="interrupts">Interrupts</h1>
<h2 id="interrupt-types">Interrupt Types</h2>
<p>The Z80 has three different hardware interrupt signals: <span class="math inline">$\overline{\hbox{RESET}}$</span>, <span class="math inline">$\overline{\hbox{NMI}}$</span>, and <span class="math inline">$\overline{\hbox{INT}}$</span>.</p>
<h5 id="overlinehboxreset"><span class="math inline">$\overline{\hbox{RESET}}$</span></h5>
<p><span class="math inline">$\overline{\hbox{RESET}}$</span> is used to return the CPU to a known state. When the <span class="math inline">$\overline{\hbox{RESET}}$</span> line is pulled low, a <span class="math inline">$\overline{\hbox{RESET}}$</span> is generated. The CPU then does several things. I, and R are set to $00. PC is set to $0000. SP becomes $FFFF. A and F are set to $FF. The interrupt mode is set to 0. And (maskable) interrupts are disabled by clearing IFF1 and IFF2.</p>
<h5 id="overlinehboxnmi"><span class="math inline">$\overline{\hbox{NMI}}$</span></h5>
<p><span class="math inline">$\overline{\hbox{NMI}}$</span> is the non-maskable interrupt. Upon receiving a non-maskable interrupt (<span class="math inline">$\overline{\hbox{NMI}}$</span> being pulled low) one of two sequences occur depending on the calue of bit 3 of the interrupt control register (nextreg $C0).</p>
<p>Register (R/W) $C0 () <span class="math inline">⇒</span> Interrupt Control (3.01.09)<br />
($00 on reset)</p>
<ul>
<li><p>bits 7-5 = Programmable portion of IM2 vector *</p></li>
<li><p>bit 4 = Reserved, must be 0</p></li>
<li><p>bit 3 = Enable stackless <span class="math inline">$\overline{\hbox{NMI}}$</span> response</p></li>
<li><p>bits 2-1 = Reserved, must be 0</p></li>
<li><p>bit 0 = Maskable interrupt mode</p>
<ul>
<li><p>0 - pulse</p></li>
<li><p>1 - IM2</p></li>
</ul></li>
</ul>
<p>* In IM2 mode vector generated is:</p>
<ul>
<li><p>bits 7-5 = nextreg $C0 bits 7-5</p></li>
<li><p>bits 4-1 = Interrupt source</p>
<ul>
<li><p>0 - line interrupt (highest priority)</p></li>
<li><p>1 - UART 0 Rx</p></li>
<li><p>2 - UART 1 Rx</p></li>
<li><p>3–10 - CTC channels 0-7</p></li>
<li><p>11 - ULA</p></li>
<li><p>12 - UART 0 Tx</p></li>
<li><p>13 - UART 1 Tx (lowest priority)</p></li>
</ul></li>
<li><p>bit 0 = 0</p></li>
</ul>
<p>If bit 3 is clear (0) PC is pushed on the stack, IFF1 is copied to IFF2, IFF1 is cleared (inhibiting maskable interrupts). The <span class="math inline">$\overline{\hbox{NMI}}$</span> should end with RETN which copies the contents of IFF2 to IFF1 (returning the interrupt state to what it was before the <span class="math inline">$\overline{\hbox{NMI}}$</span>) and PC is popped off the stack.</p>
<p>If bit 3 is set (1) PC is stored in the <span class="math inline">$\overline{\hbox{NMI}}$</span> return address registers (nextregs $C2 and $C3), IFF1 is copied to IFF2, IFF1 is cleared (inhibiting maskable interrupts). The <span class="math inline">$\overline{\hbox{NMI}}$</span> should end with RETN which copies the contents of IFF2 to IFF1 (returning the interrupt state to what it was before the <span class="math inline">$\overline{\hbox{NMI}}$</span>) and PC is compied from the <span class="math inline">$\overline{\hbox{NMI}}$</span> return address registers.</p>
<p>Register (R/W) $C2 () <span class="math inline">⇒</span> <span class="math inline">$\overline{\hbox{NMI}}$</span> Return Address LSB (3.01.09)<br />
($00 on reset)</p>
<p>Register (R/W) $C3 () <span class="math inline">⇒</span> <span class="math inline">$\overline{\hbox{NMI}}$</span> Return Address MSB (3.01.09)<br />
($00 on reset)</p>
<h5 id="overlinehboxint"><span class="math inline">$\overline{\hbox{INT}}$</span></h5>
<p>The interrupt generally of most interest to programmers is <span class="math inline">$\overline{\hbox{INT}}$</span>. So much so that if programmers talk about interrupts on the Z80, they are probebly only talking about <span class="math inline">$\overline{\hbox{INT}}$</span>. The processing of <span class="math inline">$\overline{\hbox{INT}}$</span> is controlled by IFF1 and IFF2 which are set using EI to enable interrupts and reset using DI to disable interrupts. Interrupts can happen at any time and should preserve register contents. If none of your code uses the alternate registers the EXX and EX AF,AF’ instructions can make this faster and easier. Interrupt routined should end with EI and RETI to reenable interrupts, potentially inform the interrupting device that its interrupt has been serviced, and return from the interrupt routine. In general the Spectrum machines do not make any distingtion between RET and RETI, but future developments in the ZX Spectrum Next may make the distinction important.</p>
<p>The ZX Spectrum Next has 14 internal sources for <span class="math inline">$\overline{\hbox{INT}}$</span> signals. This can be enabled and disabled using nextregs $C4 – $C6. Which signals have been received can be read/cleared using nexregs $C8 – $CA.</p>
<p>Interrupt Enable</p>
<p>Register (R/W) $C4 () <span class="math inline">⇒</span> Interrupt Enable 0 (3.01.08)<br />
($83 on reset)</p>
<ul>
<li><p>bit 7 = Expansion bus <span class="math inline">$\overline{\hbox{INT}}$</span></p></li>
<li><p>bits 6-2 = Reserved must be zero</p></li>
<li><p>bit 1 = Line</p></li>
<li><p>bit 0 = ULA</p></li>
</ul>
<p>Register (R/W) $C5 () <span class="math inline">⇒</span> Interrupt Enable 1 (3.01.08)<br />
($00 on reset)</p>
<ul>
<li><p>bit 7 = ctc channel 7 zc/to</p></li>
<li><p>bit 6 = ctc channel 6 zc/to</p></li>
<li><p>bit 5 = ctc channel 5 zc/to</p></li>
<li><p>bit 4 = ctc channel 4 zc/to</p></li>
<li><p>bit 3 = ctc channel 3 zc/to</p></li>
<li><p>bit 2 = ctc channel 2 zc/to</p></li>
<li><p>bit 1 = ctc channel 1 zc/to</p></li>
<li><p>bit 0 = ctc channel 0 zc/to</p></li>
</ul>
<p>Register (W) $C6 () <span class="math inline">⇒</span> Interrupt Enable 2 (3.01.08)<br />
($00 on reset)</p>
<ul>
<li><p>bit 7 = Reserved, must be 0</p></li>
<li><p>bit 6 = UART1 Tx empty</p></li>
<li><p>bit 5 = UART1 Rx half full *</p></li>
<li><p>bit 4 = UART1 Rx available *</p></li>
<li><p>bit 3 = Reserved, must be 0</p></li>
<li><p>bit 2 = UART0 Tx empty</p></li>
<li><p>bit 1 = UART0 Rx half full *</p></li>
<li><p>bit 0 = UART0 Rx available *</p></li>
</ul>
<p>* For each UART, Rx half full and Rx available are shared interrupts</p>
<p>Interupt Status</p>
<p>Register (R/W) $C8 () <span class="math inline">⇒</span> Interrupt Status 0 (3.01.09)<br />
($00 on reset)</p>
<ul>
<li><p>bits 7-2 = Reserved, must be zero</p></li>
<li><p>bit 1 = Line</p></li>
<li><p>bit 0 = ULA</p></li>
</ul>
<p>* Set bits indicate the device generated an interrupt in the past * Writes clear bits where bits are set except in IM2 mode</p>
<p>Register (R/W) $C9 () <span class="math inline">⇒</span> Interrupt Status 1 (3.01.09)</p>
<ul>
<li><p>bit 7 = ctc channel 7 zc/to</p></li>
<li><p>bit 6 = ctc channel 6 zc/to</p></li>
<li><p>bit 5 = ctc channel 5 zc/to</p></li>
<li><p>bit 4 = ctc channel 4 zc/to</p></li>
<li><p>bit 3 = ctc channel 3 zc/to</p></li>
<li><p>bit 2 = ctc channel 2 zc/to</p></li>
<li><p>bit 1 = ctc channel 1 zc/to</p></li>
<li><p>bit 0 = ctc channel 0 zc/to</p></li>
</ul>
<p>* Set bits indicate the device generated an interrupt in the past * Writes clear bits where bits are set except in IM2 mode</p>
<p>Register (R/W) $CA () <span class="math inline">⇒</span> Interrupt Status 2 (3.01.09) ($00 on reset)</p>
<ul>
<li><p>bit 7 = Reserved, must be zero</p></li>
<li><p>bit 6 = UART1 Tx empty</p></li>
<li><p>bit 5 = UART1 Rx almost full *</p></li>
<li><p>bit 4 = UART1 Rx available *</p></li>
<li><p>bit 3 = Reserved must be zero</p></li>
<li><p>bit 2 = UART0 Tx empty</p></li>
<li><p>bit 1 = UART0 Rx almost full *</p></li>
<li><p>bit 0 = UART0 Rx available *</p></li>
</ul>
<p>* For each UART Rx half full and Rx available are shared interrupts ** Set bits indicate the device generated an interrupt in the past ** Writes clear bits where bits are set except in IM2 mode</p>
<p>Internal Interrupt Sources</p>
<ul>
<li><p>0 = Line (highest priority)</p></li>
<li><p>1 = UART 0 Rx</p></li>
<li><p>2 = UART 1 Rx</p></li>
<li><p>3-10 = CTC channels 0-7</p></li>
<li><p>11 = ULA</p></li>
<li><p>12 = UART 0 Tx</p></li>
<li><p>13 = UART 1 Tx (lowest priority)</p></li>
</ul>
<h2 id="interrupt-modes">Interrupt Modes</h2>
<h5 id="im0">IM0</h5>
<p>When an interrupt is received by the CPU it disables interrupts and executes the instruction placed on the bus by the interrupting device and (no known use on the Next) It is enabled with the IM0 instruction and enabling interrupts (EI).</p>
<h5 id="im1">IM1</h5>
<p>When an interrupt is received, the CPU disables interrupts and jumps to an interrupt handler at $0038 (normally in ROM). The ROM interrupt handler updates the frame counter and scans the keyboard. This is the default interrupt handling method for the ZX Spectrum and is probably the method to use if you don’t need the ROMs for anything. It is enabled using the IM1 instruction and enabling interrupts.</p>
<h5 id="im2">IM2</h5>
<p>The ZX Spectrum Next has both a legacy method for handling IM2 and an updated one which makes better use of the capabilities of IM2 which was added in Core 3.01.09.</p>
<p>The ZX Spectrum Next has 14 interrupt devices which can all be given independent interrupt vectors when using IM2. These interrupts are controlled by nextregs $C0 – $CF. The address of the vector for a given interrupt is created by composing the I register (bits 15-0), nextreg $C0 bits 7-5 (bits 7-5) and the interrupt number of the interrupt device (bits 4-1). This means that even if you use all 14 internal interrupt sources, your interrupt vector table is no more than 28 bytes which can be at any 32 byte boundry. It also means that far less processing has to be done on interrupts which are received. External interrupts are a little different. If no vector is supplied by a device the implied LSB will be $FF.</p>
<p>While in IM2 mode, it is possible for interrupts to interrupt DMA transfers. This capability is controlled by The DMA Interrupt enable registers (nextregs $CC – $CE). When DMA is interrupted, one instruction of the main program will be processed, then the interrupt will be taken. On return, DMA will continue.</p>
<p>Register (R/W) $CC () <span class="math inline">⇒</span> DMA Interrupt Enable 0 (3.01.09) ($00 on reset)</p>
<ul>
<li><p>bits 7-2 = Reserved, must be 0</p></li>
<li><p>bit 1 = Line</p></li>
<li><p>bit 0 = ULA</p></li>
</ul>
<p>* Set bits indicate the specified interrupt will interrupt a DMA operation when in IM2 mode</p>
<p>Register (R/W) $CD () <span class="math inline">⇒</span> DMA Interrupt Enable 1 (3.01.09) ($00 on reset)</p>
<ul>
<li><p>bit 7 = CTC channel 7 zc/to</p></li>
<li><p>bit 6 = CTC channel 6 zc/to</p></li>
<li><p>bit 5 = CTC channel 5 zc/to</p></li>
<li><p>bit 4 = CTC channel 4 zc/to</p></li>
<li><p>bit 3 = CTC channel 3 zc/to</p></li>
<li><p>bit 2 = CTC channel 2 zc/to</p></li>
<li><p>bit 1 = CTC channel 1 zc/to</p></li>
<li><p>bit 0 = CTC channel 0 zc/to</p></li>
</ul>
<p>* Set bits indicate the corresponding interrupt will interrupt a DMA operation when in IM2 mode</p>
<p>Register (R/W) $CE () <span class="math inline">⇒</span> DMA Interrupt Enable 2 (3.01.09) ($00 on reset)</p>
<ul>
<li><p>bit 7 = Reserved, must be 0</p></li>
<li><p>bit 6 = UART1 Tx empty</p></li>
<li><p>bit 5 = UART1 Rx half full</p></li>
<li><p>bit 4 = UART1 Rx available</p></li>
<li><p>bit 3 = Reserved, must be 0</p></li>
<li><p>bit 2 = UART0 Tx empty</p></li>
<li><p>bit 1 = UART0 Tx half full</p></li>
<li><p>bit 0 = UART0 Tx available</p></li>
</ul>
<p>* Set bits indicate the corresponding interrupt will interrupt a DMA operation when in IM2 mode.</p>
<p>In legacy mode, when the CPU receives an interrupt it disables interrupts and jumps to an interrupt routine starting at the contents of the jump table at I. The start of the interrupt routine is the contents of I*$100+bus and I*$100+bus+1. Most devices that can supply interrupts on the ZX Spectrum leave the data bus in a floating state. As a result the interpreted state of the data bus while generally $FF is not entirely predictable. The solution to place your interrupt routine at an address where the MSB and LSB are the same ($0101, $0202, … $FFFF) then place 257 copies of that value in a block starting at I*$100 (you can set the value of the I register).</p>
<p>Code:</p>
<pre><code>;; my program
org $8000
;; enable interrupt mode im2
ld i,$fe
im2
ei
;; program body
;; interrupt routine
handler:
;; preserve registers used
;; handle interrupt
;; restore registers
ei
reti
;; jump to interrupt routine
org $fdfd
jp handler
;; im2 jump table
org $fe00 ; not actually legal
defs $101,$fd</code></pre>
<h2 id="z80-ctc">Z80 CTC</h2>
<p>(3.01.08) Untested, assuming it acts like two Z80 CTCs.</p>
<p>Eight independent CTC channels are available on ports $183B through $1F3B. These perform counter/timer functions that can be used to generate timer interrupts or to generate interrupts from physical signals.</p>
<p>The CTC is a standard Zilog part. Its datasheet can be found at http://www.zilog.com/docs/z80/ps0181.pdf . The Zilog documentation is ambiguous around how soft resets are treated so the following clarifies some points in the Next’s implementation.</p>
<ol>
<li><p>Hard reset requires both a control word and a time constant to be written to a channel even if bit 2 = 0 in the first control word.</p></li>
<li><p>Soft reset with bit 2 = 0 causes the entire control register to be modified. Soft reset with bit 2 = 1 does not change the control register contents. In both cases a time constant must follow to resume operation.</p></li>
<li><p>Changing the trigger edge selection in bit 4 while the channel is in operation counts as a clock edge. A pending timer trigger will be fired and, in counter mode, an edge will be received.</p></li>
<li><p>ZC/TO is asserted for one clock cycle and not for the entire duration that the count is at zero.</p></li>
</ol>
<p>At the moment, any interrupt generated by the CTC will assert the z80’s /INT line for 32 cpu cycles. This is the same way that the ULA and line interrupts operate.</p>
<p>At the moment, the ZC/TO output of each channel is fed into the CLK/TRG input of the succeeding channel so that time and count periods can be cascaded.</p>
<h5 id="programming">Programming</h5>
<p>Initial values are set by a write of a channel control word followed by a time constant. In timer mode, the counter decrements every time it is triggered. In counter mode it decrements every time the prescaler counter reaches zero.</p>
<p>Channel Control Word</p>
<ul>
<li><p>bit 7 = Enable Interrupt</p></li>
<li><p>bit 6 = Mode</p>
<ul>
<li><p>0 = Timer mode</p></li>
<li><p>1 = Counter mode</p></li>
</ul></li>
<li><p>bit 5 = Prescalar value (Timer mode only)</p>
<ul>
<li><p>0 = 16</p></li>
<li><p>1 = 256</p></li>
</ul></li>
<li><p>bit 4 = CLK/TRG edge selection</p>
<ul>
<li><p>0 = Falling Edge</p></li>
<li><p>1 = Rising Edge</p></li>
</ul></li>
<li><p>bit 3 = Timer Trigger (Timer mode only)</p>
<ul>
<li><p>0 = Starts on loading of time constant</p></li>
<li><p>1 = Starts on CLK/TRG</p></li>
</ul></li>
<li><p>bit 2 = Time constant follows</p></li>
<li><p>bit 1 = Software reset</p></li>
<li><p>bit 0 = 0 (Control Word)</p></li>
</ul>
<p>If we are running at 28MHz (Mode 0) and wish to trigger an interrupt every 1 sec, that is 28 million T-States/cycles we could program CTC 5 as a counter with a prescalar of 16 and a period of 175, CTC 6 as a counter with a prescalar of 16 and a period of 125, and CTC 7 as a timer with a period of 5.</p>
<p>CTC 5 triggers ZC5 every 280 cycles or 10 usec.</p>
<p>CTC 6 triggers ZC6 every 560,000 cycles or 20 msec.</p>
<p>CTC 7 triggers ZC7 and an interrupt every 28,000,000 cycles or 1 sec.</p>
<pre><code>di
; set up interrupt routine
im 2
ld bc,$183B     ; CTC 0
ld hl,$FFFA     ; address pointing to start of interrupt routine
ld de,interrupt ; start of interrupt routine
ld (hl),de
ld i,$FF
ld a,l          ; Vector to address at on this interrupt
out (c),a
; set up CTC 5
ld b,$1D        ; CTC 5
ld a,$87
out (c),a       ; Interrupt mode, timer mode, time constant, soft, control
ld a,$05
out (c),a       ; once every 5 times 
; set up CTC 6
inc b           ; CTC 6
ld a,$47
out (c),a       ; 16x, counter mode, time constant, soft, control
ld a,$7D        ; 125 = once every 2000 times
out (c),a
; set up CTC 7
inc b           ; CTC 7
ld a,$47
out (c),a       ; 16x, counter mode, time constant, soft, control
ld a,$AF        ; 175 = once every 2800 times
ei</code></pre>
<h1 id="serial-communication">Serial Communication</h1>
<p>The Spectrum Next has two independent fully featured UARTs. The UARTS share I/O ports so it is important to select the correct one before communicating with it. Each has its own 64 byte Tx buffer and 512 byte Rx buffer. One UART can be connected to either the ESP of joystick port while the other can be connected to the Raspberry Pi accelerator or joystick port. The UARTS are controlled using ports $37, $133B, $143B, $153B, and $163B. The UARTs are connected to the IM2 interrupt system. Nextreg $c6 allows interrupts to be enabled for the status of each UART. UART interrupts correspond to interrupts 1, 2, 12, and 13 (see Interrupts).</p>
<p>Port $37 () Kempston/Mega Drive Joystick 2<br />
Read</p>
<ul>
<li><p>bit 7 = ”start” button</p></li>
<li><p>bit 6 = A/X button</p></li>
<li><p>bit 5 = C/Z button</p></li>
<li><p>bit 4 = Fire/C/Y button</p></li>
<li><p>bit 3 = Up</p></li>
<li><p>bit 2 = Down</p></li>
<li><p>bit 1 = Left</p></li>
<li><p>bit 0 = Right</p></li>
</ul>
<p>Disable with Nextreg $05<br />
Write ($00 on reset, 3.01.04)</p>
<ul>
<li><p>bits 7-6 = Select I/O Mode</p>
<ul>
<li><p>00 = Bit Bang</p></li>
<li><p>01 = Clock</p></li>
<li><p>10 = UART</p></li>
<li><p>11 = Reserved (don’t use)</p></li>
</ul></li>
<li><p>bit 5 = Reserved, must be 0</p></li>
<li><p>bit 4 = Select Joystick Port for Read</p>
<ul>
<li><p>0 = Left</p></li>
<li><p>1 = Right</p></li>
</ul></li>
<li><p>bits 3-1 = Reserved, must be $00</p></li>
<li><p>bit 0 = Pin 7 state (both ports)</p>
<ul>
<li><p>Bit Bang - bit 0 on pin 7</p></li>
<li><p>Clock - clock on pin 7<br />
0 = Slow clock (Fsys/2048 = 12.672 kHz)<br />
1 = Fast clock (Fsys/8 = 3.5 MHz)</p></li>
<li><p>UART - Pin 7 = TX, Pin 9 = RX 0 = ESP<br />
1 = Pi</p></li>
</ul></li>
</ul>
<p>** A Runt clock may appear in the first cycle<br />
The I/O mode should be set by writing this port first followed by enabling io mo de on the joysticks with a write to nextreg 0x05.</p>
<p>Port $133B () UART tx<br />
Read: UART Status<br />
</p>
<ul>
<li><p>bits 7-4 = Reserved (0)</p></li>
<li><p>bit 3 = UART at least half full (3.01.09)</p></li>
<li><p>bit 2 = UART full</p></li>
<li><p>bit 1 = UART transmit busy</p></li>
<li><p>bit 0 = UART receive has data</p></li>
</ul>
<p>Write: UART Transmit</p>
<p>Port $143B () UART rx<br />
Read: UART Receive<br />
Write: UART Prescalar</p>
<ul>
<li><p>bit 7 = select prescalar part</p>
<ul>
<li><p>0 = Bits 6-0 of prescalar</p></li>
<li><p>1 = Bits 13-7 of prescalar</p></li>
</ul></li>
<li><p>bits 6-0 = Prescalar bits</p></li>
</ul>
<p>Port $153B () UART select</p>
<ul>
<li><p>bit 7 = Reserved (0)</p></li>
<li><p>bit 6 = UART select (0 on soft reset) **</p>
<ul>
<li><p>0 = ESP</p></li>
<li><p>1 = Pi *</p></li>
</ul></li>
<li><p>bit 5 = Reserved (0)</p></li>
<li><p>bit 4 = Prescalar valid in this write</p></li>
<li><p>bit 3 = Reserved (0)</p></li>
<li><p>bits 2-0 = Bits 16-14 of prescalar (0 on hard reset)</p></li>
</ul>
<p>* Pi GPIO must be configured for UART, see nextreg $A0<br />
** Either UART can be redirected to the joystick ports, see port $037</p>
<p>Port $153B () UART frame (upcoming)<br />
($18 on hard reset)</p>
<ul>
<li><p>bit 7 = Immediately reset Rx and Tx to idle and empty FIFOs</p></li>
<li><p>bit 6 = Assert break (Tx=0) when Tx reaches idle</p></li>
<li><p>bit 5 = Enable hardware flow control *</p></li>
<li><p>bits 4-3 = Number of bits in a frame</p>
<ul>
<li><p>00 = 5 bits</p></li>
<li><p>01 = 6 bits</p></li>
<li><p>10 = 7 bits</p></li>
<li><p>11 = 8 bits</p></li>
</ul></li>
<li><p>bit 2 = Enable parity</p></li>
<li><p>bit 1 = Parity</p>
<ul>
<li><p>0 = Even parity</p></li>
<li><p>1 = Odd parity</p></li>
</ul></li>
<li><p>bit 0 = Number of stop bits</p>
<ul>
<li><p>0 = 1 stop bit</p></li>
<li><p>1 = 2 stop bits</p></li>
</ul></li>
</ul>
<p>Register (R/W) $C0 () <span class="math inline">⇒</span> Interrupt Control (3.01.09)<br />
($00 on reset)</p>
<ul>
<li><p>bits 7-5 = Programmable portion of IM2 vector *</p></li>
<li><p>bit 4 = Reserved, must be 0</p></li>
<li><p>bit 3 = Enable stackless <span class="math inline">$\overline{\hbox{NMI}}$</span> response</p></li>
<li><p>bits 2-1 = Reserved, must be 0</p></li>
<li><p>bit 0 = Maskable interrupt mode</p>
<ul>
<li><p>0 - pulse</p></li>
<li><p>1 - IM2</p></li>
</ul></li>
</ul>
<p>* In IM2 mode vector generated is:</p>
<ul>
<li><p>bits 7-5 = nextreg $C0 bits 7-5</p></li>
<li><p>bits 4-1 = Interrupt source</p>
<ul>
<li><p>0 - line interrupt (highest priority)</p></li>
<li><p>1 - UART 0 Rx</p></li>
<li><p>2 - UART 1 Rx</p></li>
<li><p>3–10 - CTC channels 0-7</p></li>
<li><p>11 - ULA</p></li>
<li><p>12 - UART 0 Tx</p></li>
<li><p>13 - UART 1 Tx (lowest priority)</p></li>
</ul></li>
<li><p>bit 0 = 0</p></li>
</ul>
<p>Register (W) $C6 () <span class="math inline">⇒</span> Interrupt Enable 2 (3.01.08)<br />
($00 on reset)</p>
<ul>
<li><p>bit 7 = Reserved, must be 0</p></li>
<li><p>bit 6 = UART1 Tx empty</p></li>
<li><p>bit 5 = UART1 Rx half full *</p></li>
<li><p>bit 4 = UART1 Rx available *</p></li>
<li><p>bit 3 = Reserved, must be 0</p></li>
<li><p>bit 2 = UART0 Tx empty</p></li>
<li><p>bit 1 = UART0 Rx half full *</p></li>
<li><p>bit 0 = UART0 Rx available *</p></li>
</ul>
<p>* For each UART, Rx half full and Rx available are shared interrupts</p>
<h1 id="raspberry-pi0-acceleration">Raspberry Pi0 Acceleration</h1>
<p>The Spectrum Next has a header (with male pins) which can be attached to a Raspberry Pi Zero. There is a modified version of DietPi called NextPi which is the standard distro for the Raspberry Pi0 accelerator. Software for the general public should be written assuming that it will be interfacing with a Pi0 running this distro.</p>
<p>If you are more adventurous, you may choose to use another distro, or even another accelerator that uses the Raspberry Pi style (40 pin) expansion bus. Chief concers when doing this is that you have a console presented on the UART that defaults to 115,200 bps, you don’t need to login, the machine is configured with a driver to treat the I<sup>2</sup>S interface as a sound card, and the presence of the nextpi scripts.</p>
<p>The Raspberry Pi 0 has a Broadcom BCM2835 SoC with an ARMv6 core, a Videocore 4 GPU, and its own 512 MB memory and HDMI output. It has its own SD card from which it boots. For this application the Pi 0 ships with a 1GB microSD card containing NextPi a customized version of DietPi.</p>
<p>The Pi Zero, if installed, is a smart peripheral for the ZX Spectrum Next. Available interfaces are: low level access to the GPIO pins, higher level access to standardized I/O interfaces, and use of the Pi Zero as a sound card.</p>
<p>When using the low level GPIO interface Pi Zero GPIO pins 2-27 can be configured as either inputs or outputs using nextregs $90-$93. If they are outputs, the output state can be set by writing to nextregs $98-$9b. The current status of the GPIO pins can be read from nextregs $98-$9b whether it is the state driven by the ZX Spectrum Next or the state drive by some other peripherial attached to the bus (normally the Raspberry Pi Zero).</p>
<p>Register (R/W) $90 () <span class="math inline">⇒</span> Pi GPIO output enable 1/4</p>
<ul>
<li><p>bit 7 = Enable Pin 7 (0 on reset)</p></li>
<li><p>bit 6 = Enable Pin 6 (0 on reset)</p></li>
<li><p>bit 5 = Enable Pin 5 (0 on reset)</p></li>
<li><p>bit 4 = Enable Pin 4 (0 on reset)</p></li>
<li><p>bit 3 = Enable Pin 3 (0 on reset)</p></li>
<li><p>bit 2 = Enable Pin 2 (0 on reset)</p></li>
<li><p>bit 1 = Enable Pin 1 (cannot be enabled) (0 on reset)</p></li>
<li><p>bit 0 = Enable Pin 0 (cannot be enabled) (0 on reset)</p></li>
</ul>
<p>Register (R/W) $91 () <span class="math inline">⇒</span> Pi GPIO output enable 2/4</p>
<ul>
<li><p>bit 7 = Enable Pin 15 (0 on reset)</p></li>
<li><p>bit 6 = Enable Pin 14 (0 on reset)</p></li>
<li><p>bit 5 = Enable Pin 13 (0 on reset)</p></li>
<li><p>bit 4 = Enable Pin 12 (0 on reset)</p></li>
<li><p>bit 3 = Enable Pin 11 (0 on reset)</p></li>
<li><p>bit 2 = Enable Pin 10 (0 on reset)</p></li>
<li><p>bit 1 = Enable Pin 9 (0 on reset)</p></li>
<li><p>bit 0 = Enable Pin 8 (0 on reset)</p></li>
</ul>
<p>Register (R/W) $92 () <span class="math inline">⇒</span> Pi GPIO output enable 3/4</p>
<ul>
<li><p>bit 7 = Enable Pin 23 (0 on reset)</p></li>
<li><p>bit 6 = Enable Pin 22 (0 on reset)</p></li>
<li><p>bit 5 = Enable Pin 21 (0 on reset)</p></li>
<li><p>bit 4 = Enable Pin 20 (0 on reset)</p></li>
<li><p>bit 3 = Enable Pin 19 (0 on reset)</p></li>
<li><p>bit 2 = Enable Pin 18 (0 on reset)</p></li>
<li><p>bit 1 = Enable Pin 17 (0 on reset)</p></li>
<li><p>bit 0 = Enable Pin 16 (0 on reset)</p></li>
</ul>
<p>Register (R/W) $93 () <span class="math inline">⇒</span> Pi GPIO output enable 4/4</p>
<ul>
<li><p>bits 7-4 = Reserved</p></li>
<li><p>bit 3 = Enable Pin 27 (0 on reset)</p></li>
<li><p>bit 2 = Enable Pin 26 (0 on reset)</p></li>
<li><p>bit 1 = Enable Pin 25 (0 on reset)</p></li>
<li><p>bit 0 = Enable Pin 24 (0 on reset)</p></li>
</ul>
<p>Register (R/W) $98 () <span class="math inline">⇒</span> Pi GPIO Pin State 1/4</p>
<ul>
<li><p>bit 7 = Pin 7 Data (1 on reset)</p></li>
<li><p>bit 6 = Pin 6 Data (1 on reset)</p></li>
<li><p>bit 5 = Pin 5 Data (1 on reset)</p></li>
<li><p>bit 4 = Pin 4 Data (1 on reset)</p></li>
<li><p>bit 3 = Pin 3 Data (1 on reset)</p></li>
<li><p>bit 2 = Pin 2 Data (1 on reset)</p></li>
<li><p>bit 1 = Pin 1 Data (1 on reset)</p></li>
<li><p>bit 0 = Pin 0 Data (1 on reset)</p></li>
</ul>
<p>Register (R/W) $99 () <span class="math inline">⇒</span> Pi GPIO Pin State 2/4</p>
<ul>
<li><p>bit 7 = Pin 15 Data (1 on reset)</p></li>
<li><p>bit 6 = Pin 14 Data (1 on reset)</p></li>
<li><p>bit 5 = Pin 13 Data (1 on reset)</p></li>
<li><p>bit 4 = Pin 12 Data (1 on reset)</p></li>
<li><p>bit 3 = Pin 11 Data (1 on reset)</p></li>
<li><p>bit 2 = Pin 10 Data (1 on reset)</p></li>
<li><p>bit 1 = Pin 9 Data (1 on reset)</p></li>
<li><p>bit 0 = Pin 8 Data (1 on reset)</p></li>
</ul>
<p>Register (R/W) $9A () <span class="math inline">⇒</span> Pi GPIO Pin State 3/4</p>
<ul>
<li><p>bit 7 = Pin 23 Data (1 on reset)</p></li>
<li><p>bit 6 = Pin 22 Data (1 on reset)</p></li>
<li><p>bit 5 = Pin 21 Data (1 on reset)</p></li>
<li><p>bit 4 = Pin 20 Data (1 on reset)</p></li>
<li><p>bit 3 = Pin 19 Data (1 on reset)</p></li>
<li><p>bit 2 = Pin 18 Data (1 on reset)</p></li>
<li><p>bit 1 = Pin 17 Data (1 on reset)</p></li>
<li><p>bit 0 = Pin 16 Data (1 on reset)</p></li>
</ul>
<p>Register (R/W) $9B () <span class="math inline">⇒</span> Pi GPIO Pin State 4/4</p>
<ul>
<li><p>bits 7-4 = Reserved</p></li>
<li><p>bit 3 = Pin 27 Data (1 on reset)</p></li>
<li><p>bit 2 = Pin 26 Data (1 on reset)</p></li>
<li><p>bit 1 = Pin 25 Data (1 on reset)</p></li>
<li><p>bit 0 = Pin 24 Data (1 on reset)</p></li>
</ul>
<p>Standardized I/O access with the Pi Zero can use the I<sup>2</sup>C , SPI, or UART interfaces and is configured using nextreg $a0. Any enabled port will disable low level (write) access to the corresponding GPIO pins.</p>
<p>Register (R/W) $A0 () <span class="math inline">⇒</span> Pi Peripheral Enable</p>
<ul>
<li><p>bits 7-6 = Reserved, must be 0</p></li>
<li><p>bit 5 = Enable UART on GPIO 14, 15 (0 on reset)*</p></li>
<li><p>bit 4 = Communication Type (0 on reset)</p>
<ul>
<li><p>0 = Rx to GPIO 15, Tx to GPIO 14 (Pi)</p></li>
<li><p>1 = Rx to GPIO 14, Tx to GPIO 15 (Pi Hats)</p></li>
</ul></li>
<li><p>bit 3 = Enable I<sup>2</sup>C on GPIO 2, 3 (0 on reset)*</p></li>
<li><p>bits 2-1 = Reserved, must be 0</p></li>
<li><p>bit 0 = Enable SPI on GPIO 7, 8, 9, 10, 11 (0 on reset)*</p></li>
</ul>
<p>*Overrides GPIO Enables</p>
<p>The I<sup>2</sup>C interface is controlled using ports $103b (SCL) and $113b (SDA). This is the same I<sup>2</sup>C interface that is used for the optional Real Time Clock. Interfacing with the Pi Zero over I<sup>2</sup>C is complicated by the fact that it is a master/slave interface, but both the ZX Spectrum Next and Pi Zero are configured to be bus masters.</p>
<p>Port $103B () I<sup>2</sup>C SCL (rtc, rpi)</p>
<p>Port $113B () I<sup>2</sup>C SDA (rtc, rpi)</p>
<p>The SPI interface is controlled using ports $e7 (/CS) and $eb (/DATA). The SPI interface is shared between the SD card(s), the flash memory, and the Pi Zero. Interfacing with the Pi Zero over SPI is complicated by the fact it is a master/slave interface and both the ZX Spectrum Next and Pi Zero are configured to be bus masters.</p>
<p>Port $E7 () SPI <span class="math inline">$\overline{\hbox{CS}}$</span> (SD card, flash, rpi)<br />
Disable with bit 2 of Nextreg $09</p>
<p>Port $EB () SPI <span class="math inline">$\overline{\hbox{DATA}}$</span> (SD card, flash, rpi)<br />
Disable with bit 2 of Nextreg $09</p>
<p>The default means of communication between the ZX Next and the Pi is through the UART interface (see serial communications chapter). In order to communicate withe the Pi the Pi UART must be connected to the Pi by setting nextreg $a0 bits 5 and 4 to 1, selecting the Pi UART by setting port $153b bit 6 to 1 and ensuring that both ends are using matching communication protocols (by default 115,200 bps, 8N1 and no flow control). On the Pi end the UART is connected to the serial console.</p>
<pre><code>;; enable UART connection with Pi Zero
   ld c,$3b
   ld b,$15 ; UART control
;; select Pi on UART control
   in a,(c)
   or $40
   out (c),a
   ld b,$24 ; Next Register Select
   ld a,$a0
   out (c),a
   inc b ; Next Register Data
;; Enable UART on GPIO and select Pi
   in a,(c)
   or $30
   out (c),a</code></pre>
<p>The I<sup>2</sup>S sound interface between the ZX Spectrum Next and the Pi Zero is controlled by nextregs $a2 and $a3. Normally, one would control the Pi through some other channel such as the UART recieve audio from the Pi to either use as a fulloy programmable sound card or to allow loading of tape files on the ZX Spectrum Next.</p>
<p>Register (R/W) $A2 () <span class="math inline">⇒</span> Pi I<sup>2</sup>S Audio Control</p>
<ul>
<li><p>bits 7-6 = I<sup>2</sup>S State ($00 on reset)</p>
<ul>
<li><p>00 = I<sup>2</sup>S Disabled</p></li>
<li><p>01 = I<sup>2</sup>S is mono, source R</p></li>
<li><p>10 = I<sup>2</sup>S is mono, source L</p></li>
<li><p>11 = I<sup>2</sup>S is stereo</p></li>
</ul></li>
<li><p>bit 5 = Reserved, must be 0</p></li>
<li><p>bit 4 = Audio Flow Direction (0 on reset)</p>
<ul>
<li><p>0 = PCM_DOUT to Pi, PCM_DIN from Pi (Hats)</p></li>
<li><p>1 = PCM_DOUT from Pi, PCM_DIN to Pi (Pi)</p></li>
</ul></li>
<li><p>bit 3 = Mute left (0 on reset)</p></li>
<li><p>bit 2 = Mute right (0 on reset)</p></li>
<li><p>bit 1 = Slave mode, Reserved must be 1 (remove in 3.01.05)</p></li>
<li><p>bit 0 = Direct I<sup>2</sup>S audio to EAR on port $FE (0 on reset)</p></li>
</ul>
<p>Register (R/W) $A3 () <span class="math inline">⇒</span> Pi I<sup>2</sup>S Clock Divide (Master Mode) (removed in 3.01.05)</p>
<ul>
<li><p>bits 7-0 = Clock divide value ($0B on reset)</p></li>
</ul>
<p><span class="math inline">$\hbox{Divider}=\frac{538461}{\hbox{Rate}}-1$</span> or <span class="math inline">$\hbox{Rate}=\frac{538461}{\hbox{Divider}+1}$</span></p>
<h1 id="system-software">System Software</h1>
<h2 id="cpm">CP/M</h2>
<p>The ZX Spextrum Next has support for CP/M+ 3.0. CP/M was the most popular microcomputer coperating system prior to the advent of MS-DOS.</p>
<h3 id="utilities">Utilities</h3>
<p>From the Digital Research: CP/M 3 Command Reference Manual 1984</p>
<p>This section documents all standard CP/M+ 3 commands plus those extras included with the ZX Spectrum Next CP/M system.</p>
<p><span><strong>COLOURS</strong></span></p>
<p><span>Parameters:</span><span><strong>Syntax:</strong></span> <strong>COLOURS [RGB] <em>paper</em> <em>ink</em></strong></p>
<p><strong>Function:</strong> Sets the screen colours</p>
<p><strong>Parameters:</strong></p>
<p><span>Parameters</span><span><em>paper</em></span> Paper (background) colour</p>
<p><span>Parameters:</span><span><em>ink</em></span> Ink (foreground) colour</p>
<p><strong>Options:</strong></p>
<p><span>Parameters:</span><span>RGB</span> Causes ink and paper colours to be interpreted as 9-bit octal RGB numbers</p>
<p><strong>Notes:</strong> Sets the screen colours using standard ZX colours or octal 9-bit RGB numbers.</p>
<p><strong>Examples:</strong></p>
<p>colours 1 6</p>
<p>colours rgb 000 750</p>
<p><span><strong>COPYSYS</strong></span></p>
<p><span>Parameters:</span><span><strong>Syntax:</strong></span> <strong>COPYSYS</strong></p>
<p><strong>Function:</strong> Copy CP/M system</p>
<p><strong>Notes:</strong> COPYSYS copies the CP/M Plus system from a CP/M Plus system diskette to another diskette. The new diskette must have the same format as the original system diskette.</p>
<p><span><strong>DATE</strong></span></p>
<p><span>Parameters:</span><span><strong>Syntax:</strong></span> <strong>DATE</strong><br />
<strong>DATE C</strong><br />
<strong>DATE CONTINUOUS</strong><br />
<strong>DATE <em>time-specification</em></strong><br />
<strong>DATE SET</strong></p>
<p><strong>Function:</strong> The DATE command lets you display and set the date and time of day.</p>
<p><strong>Parameters:</strong></p>
<p><span>Parameters</span><span><em>time-specification</em></span> Time/date in the format MM/DD/YY HH:MM:SS</p>
<p><strong>Options:</strong></p>
<p><span>Parameters:</span><span>C</span> Continuously show the date and time until a key is pressed</p>
<p><span>Parameters:</span><span>CONTINUOUS</span> Continuously show the date and time until a key is pressed</p>
<p><span>Parameters:</span><span>SET</span> Prompt the user for the current date and time</p>
<p><strong>Notes:</strong> The DATE command is a transient utility that lets you display and set the date and time of day. When you start CP/M 3, the date and time are set to the creation date of your CP/M 3 system. Use DATE to change this initial value to the current date and time.</p>
<p><strong>Examples:</strong></p>
<p>DATE</p>
<p>DATE C</p>
<p>DATE CONTINUOUS</p>
<p>DATE 08/13/82 09:15:37</p>
<p>DATE SET</p>
<p><strong>DEVICE</strong></p>
<p>Syntax:<br />
DEVICE<br />
DEVICE NAMES<br />
DEVICE VALUES<br />
DEVICE logical-dev {XON<span class="math inline">|</span>NOXON<span class="math inline">|</span>baud-rate},<br />
DEVICE physical-dev {XON<span class="math inline">|</span>NOXON<span class="math inline">|</span>baud-rate}<br />
DEVICE logical-dev=physical-dev {option} {,physical-dev {option},...}<br />
DEVICE logical-dev = NULL<br />
DEVICE CONSOLE {PAGE}<br />
DEVICE CONSOLE {COLUMNS=n, LINES=n}<br />
DEVICE displays current logical device assignments and physical device names.</p>
<p><strong>DIR</strong> (built-in)</p>
<p>Syntax:<br />
DIR<br />
DIR d:<br />
DIR filespec<br />
DIR d: options<br />
DIR filespec,... filespec options</p>
<p>The DIR command displays the names of files catalogued in the directory of an online disk that belong to current user number and have the Directory (DIR) attribute. DIR accepts the * and ? wildcards in the file specification.</p>
<p>The DIR command with options displays the names of files and the characteristics associated with the files. DIR is a built-in utility. DIR with options is a transient utility and must be loaded into memory from the disk.</p>
<p><strong>DIRSYS/DIRS</strong> (built-in)</p>
<p>Syntax:<br />
DIRSYS<br />
DIRSYS d:<br />
DIRSYS filespec</p>
<p>The DIRSYS command lists the names of files in the current directory that have the system (SYS) attribute. DIRSYS accept the * and ? wildcards in the file specification. DIRSYS is a built-in utility.</p>
<p><strong>DUMP</strong></p>
<p>Syntax:<br />
DUMP filespec</p>
<p>DUMP displays the contents of a file in and ASCII format.</p>
<p><strong>ECHO</strong> (ZX Spectrum Next)</p>
<p>Syntax:<br />
ECHO string</p>
<p>Echo characters to the terminal</p>
<p>The following special character sequences may be used</p>
<ul>
<li><p>\a alert (bell) (ASCII 7)</p></li>
<li><p>\b backspace (ASCII 8)</p></li>
<li><p>\e escape (ASCII 27)</p></li>
<li><p>\n line feed (ASCII 10)</p></li>
<li><p>\r carriage return (ASCII 13)</p></li>
<li><p>\l interpret further characters as lower-case</p></li>
<li><p>\u interpret further characters as upper-case</p></li>
<li><p>\\backslash (’\’)</p></li>
</ul>
<p>Note that CP/M converts all your typed characters to upper-case before providing them to ECHO.COM. Therefore you will need to use \l and \u to specify the case of characters if it is important (in ESCape sequences, for example).</p>
<p><strong>ED</strong></p>
<p>Syntax:<br />
ED<br />
ED input-filespec<br />
ED input-filespec {d: <span class="math inline">|</span> output-filespec}</p>
<p>Character file editor. To redirect or rename the new version of the file specify the destination drive or destination filespec.</p>
<p><strong>ERASE/ERA</strong> (built-in)</p>
<p>Syntax:<br />
ERASE<br />
ERASE filespec<br />
ERASE filespec [CONFIRM]</p>
<p>The ERASE command removes one or more files from the directory of a disk. Wildcard characters are accepted in the filespec. Directory and data space are automatically reclaimed for later use by another file. The ERASE command can be abbreviated to ERA.</p>
<p>[CONFIRM] option informs the system to prompt for verification before erasing each file that matches the filespec. CONFIRM can be abbreviated to C.</p>
<p><strong>EXIT</strong> (ZX Spectrum Next)</p>
<p>Syntax:<br />
EXIT</p>
<p>The EXIT command leaves CP/M (rebooting the ZX Spectrum Next)</p>
<p><strong>EXPORT</strong> (ZX Spectrum Next)</p>
<p>Syntax:<br />
EXPORT cpm-filespec nextzxos-filespec</p>
<p>NextZXOS file export utility</p>
<p>Export file to a NextZXOS drive.</p>
<p><strong>GENCOM</strong></p>
<p>Syntax:<br />
GENCOM COM-Eilespec RSX-filespec... RSX-Eilespec {[LOADER <span class="math inline">|</span> SCB=(Offset,value)]}<br />
GENCOM RSX-filespec ... RSX-filespec {[NULL <span class="math inline">|</span> SCB=(Offset,value)l}<br />
GENCOM filename<br />
GENCOM filename [SCB=(offset,value)]</p>
<p>The GENCOM command attaches RSX files to a COM file, or creates a dummy COM file containing only RSXS. It can also restore a previously GENCOMed file to the original COM file without the header and RSXS, add or replace RSXs in already GENCOMed files, and attach header records to COM files without RSXS.</p>
<p><strong>GENCPM</strong></p>
<p>Syntax:<br />
GENCPM {AUTO<span class="math inline">|</span>AUTO DISPLAY}</p>
<p>GENCPM creates a memory image CPM3.SYS file, containing the CP/M 3 BDOS and customized BIOS. The GENCPM utility performs late resolution of intermodule references between system modules. GENCPM can accept its command input interactively from the console or from a file GENCPM.DAT.</p>
<p>In the nonbanked system, GENCPM creates a CPM3.SYS file from the BDOS3.SPR and BIOS3.SPR files. In the banked system, GENCPM creates the CPM3.SYS file from the RESBDOS3.SPR, the BNKBDOS3.SPR and the BNKBIOS3.SPR files. Remember to back up your CPM3.SYS file before executing GENCPM, because GENCPM deletes any existing CPM3.SYS file before it generates a new system.</p>
<p><strong>GET</strong></p>
<p>Syntax:<br />
GET {CONSOLE INPUT FROM} FILE filespec options<br />
GET {CONSOLE INPUT FROM} CONSOLE</p>
<p>GET directs the system to take console input from a file for the next system comand or user program entered at the console.</p>
<p>Console input is taken from a file until the program terminates. If the file is exhausted before program input is terminated, the program looks for subsequent input from the console. If the program terminates before exhausting all its input, the system reverts back to the console for console input.</p>
<p><strong>HELP</strong></p>
<p>Syntax:<br />
HELP<br />
HELP topic<br />
HELP topic subtopic<br />
HELP topic [NOPAGE]<br />
HELP topic subtopic1...subtopic8<br />
HELP<span class="math inline">&gt;</span>topic<br />
HELP<span class="math inline">&gt;</span>.subtopic</p>
<p>HELP displays a list of topics and provides summarized information for CP/M Plus commands.</p>
<p>Typing HELP topic displays information about that topic. Typing HELP topic subtopic displays information about that subtopics One or two letters is enough to identify the topics. After HELP displays information for your topic, it displays the special prompt HELP<span class="math inline">&gt;</span> on your screen, followed by a list of subtopics.</p>
<ul>
<li><p>Enter ? to display list of main topics.</p></li>
<li><p>Enter a period and subtopic name to access subtopics.</p></li>
<li><p>Enter a period to redisplay what you just read.</p></li>
<li><p>Press RETURN to return to the CP/M Plus system prompt.</p></li>
<li><p><span>[NOPAGE]</span> option disables the 24 lines per page console display.</p></li>
<li><p>Press any key to exit a display and return to the HELP<span class="math inline">&gt;</span> prompt.</p></li>
</ul>
<p><strong>HEXCOM</strong></p>
<p>Syntax:<br />
HEXCOM filename</p>
<p>The HEXCOM Command generates a command file (filetype COM) from a HEX input file. it names the output tile with the same filename as the input file but with filetype COM. HEXCOM always looks for a file with filetype HEX.</p>
<p><strong>IMPORT</strong> (ZX Spectrum Next)</p>
<p>Syntax:<br />
IMPORT nextzxos-filespec<br />
IMPORT nextzxos-filespec cpm-filespec</p>
<p>NextZXOS file import utility</p>
<p>List or import files from a NextZXOS drive.</p>
<p><strong>INITDIR</strong> (Not included)</p>
<p>Syntax:<br />
INITDIR d:</p>
<p>The INITDIR command initializes a disk directory to allow date and time stamping of files on that disk. INITDIR can also recover time/date directory space.</p>
<p><strong>NEXTREG</strong> (ZX Spectrum Next)</p>
<p>Syntax:<br />
NEXTREG register {value}</p>
<p>NextReg Utility</p>
<p>Show or change a NextReg register (use at your own risk!)</p>
<p><strong>LIB</strong> (Not included)</p>
<p>Syntax:<br />
LIB filespec options<br />
LIB filespec options=filespec <span class="math inline">&lt;</span>modifier<span class="math inline">&gt;</span> f,filespec<span class="math inline">&lt;</span>modifier<span class="math inline">&gt;</span></p>
<p>A library is a file that contains a collection of object modules.</p>
<p>Use the LIB utility to create libraries, and to append, replace, select, or delete modules from an existing library. Use LIB to obtain information about the contents of library files. LIB creates and maintains library files that contain object modules in Microsoft REL file format. These modules are produced by the Digital Research relocatable macro-assembler program, RMAC, or other language translator that produces modules in Microsoft REL file format.</p>
<p>You can use LINK-80 to link the object modules contained in a library to other object files. LINK-80 automatically selects from the library only those modules needed by the program being linked, and then forms an executable file with a filetype of Com.</p>
<p><strong>LINK</strong> (Not included)</p>
<p>Syntax:<br />
LINK filespec [options]<br />
LINK filespec [options],...filespec [options]<br />
LINK filespec [options]=filespec [options],...<br />
LINK combines relocatable object modules such as those produced by RMAC and PL/I- 80 into a COM file ready for execution. Relocatable files can contain external references and publics. Relocatable files can reference modules in library files. LINK searches the library files and includes the referenced modules in the output file. See the Programmer’s Utilities Guide for the CP/M Family of Operating Systems for a complete description of LINK-80.</p>
<p>Use LINK option switches to control execution parameters. Link options follow the file specifications and are enclosed within square brackets. Multiple switches are separated by commas.</p>
<p><strong>MAC</strong> (Not included)</p>
<p>Syntax:<br />
MAC filename [$options]</p>
<p>MAC, the CP/M Plus macro assembler, reads assembly language statements from a file of type ASM, assembles the statements, and produces three output files with the input filename and filetypes of HEX, PRN, and SYM. Filename.HEX contains Intel hexadecimal format object code. Filename.PRN contains an annotated source listing that you can print or examine at the console. Filename.SYM contains a sorted list of symbols defined in the program.</p>
<p>Use options to direct the input and output of MAC. Use a letter with the option to indicate the source and destination drives, and console, printer, or zero output. Valid drive names are A through 0. X, P, and Z specify console, printer, and zero output, respectively.</p>
<p><strong>PATCH</strong></p>
<p>Syntax:<br />
PATCH filename.typ n</p>
<p>The PATCH command displays or installs patch number n to the CP/M Plus system or command files. The patch number n must be between 1 and 32 inclusive.</p>
<p><strong>PIP</strong></p>
<p>Syntax:<br />
PIP Destination = Source<br />
PIP d:[Gn]=filespec [options]<br />
PIP filespec[Gn]=filespec [options]<br />
PIP filespec[Gn]device=filespec [options] device</p>
<p>The file copy program PIP copies files, combines files, and transfers files between disks, printers, consoles, or other devices attached to your computer. The first filespec is the destination. The second filespec is the source. Use two or more source filespecs separated by commas to combine two or more files into one file. [options] is any combination of the available options. The [Gn] option in the destination filespec tells PIP to copy your file to that user number. PIP with no command tail displays an * prompt and awaits your series of commands, entered and processed one line at a time. The source or destination can optionally be any CP/M Plus logical device.</p>
<p><strong>PUT</strong></p>
<p>Syntax:<br />
PUT CONSOLE {OUTPUT TO} FILE filespec {option}<br />
PUT PRINTER {OUTPUT TO} FILE filespec {option}<br />
PUT CONSOLE {OUTPUT TO} CONSOLE<br />
PUT PRINTER {OUTPUT TO} PRINTER</p>
<p>PUT puts console or printer output to a file for the next command entered at the console, until the program terminates. Then console output reverts to the console. Printer output is directed to a file until the program terminates. Then printer output is put back to the printer.</p>
<p>PUT with the SYSTEM option directs all subsequent console/printer output to the specified file. This option terminates when you enter the PUT CONSOLE or PUT PRINTER command.</p>
<p><strong>RENAME/REN</strong> (built-in)</p>
<p>Syntax:<br />
RENAME<br />
RENAME new-filespec=old-filespec</p>
<p>RENAME lets you change the name of a file in the directory of a disk. To change several filenames in one command use the * or ? wildcards in the file specifications. You can abbreviate the RENAME command to REN. REN prompts you for input.</p>
<p><strong>RMAC</strong> (Not included)</p>
<p>Syntax:<br />
RMAC filespec <span>options</span></p>
<p>RMAC, a relocatable macro assembler, assembles ASM files into REL files that you can link to create COM files.</p>
<p>RMAC options specify the destination of the output files. Replace d with the destination drive letter for the output files.</p>
<p><strong>SAVE</strong></p>
<p>Syntax:<br />
SAVE</p>
<p>SAVE copies the contents of memory to a file. To use SAVE, first issue the SAVE command, then run your program which reads a file into memory. Your program exits to the SAVE utility which prompts you for a filespec to which it copies the contents of memory, and the beginning and ending address of the memory to be SAVED.</p>
<p><strong>SET</strong></p>
<p>Syntax:<br />
SET [options]<br />
SET d: [options]<br />
SET filespec [options]<br />
SET [option = modifier]<br />
SET filespec [option = modifier]</p>
<p>SET initiates password protection and time stamping of files. It also sets the file and drive attributes Read/Write, Read/Only, DIR and SYS. It lets you label a disk and passord protect the label. To enable time stamping of files, you must first run INITDIR to format the disk directory.</p>
<p><strong>SET Default password operation:</strong></p>
<p>Syntax:<br />
SET [DEFAULT=password]</p>
<p>Instructs the system to use a default password if you do not enter a password for a password-protected file.</p>
<p><strong>SET Time-stamp operations:</strong></p>
<p>Syntax:<br />
SET <span>d:</span> [CREATE=ON<span class="math inline">|</span>OFF]<br />
SET <span>d:</span> [ACCESS=ON<span class="math inline">|</span>OFF]<br />
SET <span>d:</span> [UPDATE=ON<span class="math inline">|</span>OFF]</p>
<p>The above set commands allw YOU to keep a record of the time and date of file creation and update or of the last access update of your files.</p>
<p><strong>SET Drive operations:</strong></p>
<p>Syntax:<br />
SET <span>d:</span> [RO]<br />
SET <span>d:</span> [RW]</p>
<p>Adds or removes write protection from a drive.</p>
<p><strong>SETDEF</strong></p>
<p>Syntax:<br />
SETDEF<br />
SETDEF [TEMPORARY=d:]<br />
SETDEF d:i,d:i,d:i,d:i<br />
SETDEF [ORDER= (typ1, typn)]<br />
SETDEF [DISPLAY <span class="math inline">|</span> NO DISPLAY)<br />
SETDEF [PAGE <span class="math inline">|</span> NOPAGE]</p>
<p>SETDEF allows the user to display or define up to four drives for the program search order, the drive for temporary files, and the filetype search order. The SETDEF definitions affect only the loading of programs and/or execution of SUBMIT (SUB) files. SETDEF turns on/off the system Display and Console Page modes. When on, the system displays the location and name of programs loaded or SUBmit files executed, and stops after displaying one full console screen of information.</p>
<p><strong>SHOW</strong></p>
<p>Syntax:<br />
SHOW<br />
SHOW d:<br />
SHOW d: [SPACE]<br />
SHOW d: [LABEL]<br />
SHOW d: [USERS]<br />
SHOW d: [DIR]<br />
SHOW d: [DRIVE]</p>
<p>The SHOW command displays the following disk drive information:</p>
<ul>
<li><p>access mode and the amount of free disk space</p></li>
<li><p>disk label</p></li>
<li><p>current user number</p></li>
<li><p>number of files for each user number on the disk</p></li>
<li><p>number of free directory entries for the disk</p></li>
<li><p>drive characteristics</p></li>
</ul>
<p><strong>SID</strong></p>
<p>Syntax:<br />
SID [pgm-filespec],{sym-filespec}</p>
<p>The SID symbolic debugger allows you to monitor and test programs developed for the 8080 microprocessor. SID supports real-time breakpoints, fully monitored execution, symbolic disassembly, assembly, and memory display and fill functions. SID can dynamically load SID utility programs to provide traceback and histogram facilities.</p>
<p><strong>SUBMIT</strong></p>
<p>Syntax:<br />
SUBMIT<br />
SUBMIT filespec<br />
SUBMIT filespec argument ... argument</p>
<p>The SUBMIT command lets you execute a group (batch) of commands from a SUBmit file (a file with filetype of SUB).</p>
<p>SUB files:</p>
<p>The SUB file can contain the following types of lines:</p>
<ul>
<li><p>any valid CP/M Plus command</p></li>
<li><p>any valid CP/M Plus command with SUBMIT parameters ($0-$9)</p></li>
<li><p>any data input line</p></li>
<li><p>any program input line with parameters ($0 to $9)</p></li>
</ul>
<p>The command line cannot exceed 135 characters.</p>
<p><strong>TERMINFO</strong> (ZX Spectrum Next)</p>
<p>Syntax:<br />
TERMINFO</p>
<p>This program provides information on the terminal facilities provided by the BIOS on the ZX Spectrum Next.</p>
<p><strong>TERMSIZE</strong> (ZX Spectrum Next)</p>
<p>Syntax:<br />
TERMSIZE top left height width</p>
<p>Terminal resize utility</p>
<p>Size can be up to 32x80 (defaults to 24x80, suitable for many programs). If setting a reduced size, the top and left parameters can be used to make the image more centered on your screen.</p>
<p><strong>TYPE/TYP</strong> (built-in)</p>
<p>Syntax:<br />
TYPE<br />
TYPE filespec<br />
TYPE filespec [PAGE]<br />
TYPE filespec [NOPAGE]</p>
<p>The TYPE command displays the contents of an ASCII character file on your screen.</p>
<p><strong>UPGRADE</strong> (ZX Spectrum Next)</p>
<p>Syntax:<br />
UPGRADE</p>
<p>UPGRADE CP/M from C:/NEXTZXOS/CPMBASE.P3D</p>
<p><strong>USER/USE</strong> (built-in)</p>
<p>Syntax:<br />
USER<br />
USER n</p>
<p>The USER command sets the current user number. The disk directory can be divided into distinct groups according to a User Number. User numbers range from 0 through 15.</p>
<p><strong>XREF</strong> (Not included)</p>
<p>Syntax:<br />
XREF {d:} filename {$P}</p>
<p>XREF provides a cross-reference summary of variable usage in a program. XREF requires the PRN and SYM files produced by MAC or RMAC for input to the program. The SYM and PRN files must have the same filename as the filename in the XREF command tail. XREF outputs a file of type XRF.</p>
<h3 id="bdos">BDOS</h3>
<p>From the CP/M 3 Programmers’ Guide 1984</p>
<p>This section documents all BDOS system calls to include the parameters that must be passes to them and the values that are returned to the calling program.</p>
<p>BDOS function 0: <strong>SYSTEM RESET</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $00</p></li>
</ul>
<p>The System Reset function terminates the calling program and returns control to the CCP via a warm start sequence. Calling this function has the same effect as a jump to location $0000 of Page Zero.</p>
<p>Note that the disk subsystem is not reset by System Reset under CP/M 3. The calling program can pass a return code to the CCP by calling Function 108, Get/Set Program Return Code, prior to making a System Reset call or jumping to location $0000.</p>
<p>BDOS function 1: <strong>CONSOLE INPUT</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $01</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: ASCII Character</p></li>
</ul>
<p>The Console Input function reads the next character from the logical console, CONIN:, to register A. Graphic characters, along with carriage return, line-feed, and backspace, CTRL-H, are echoed to the console. Tab characters, CTR-L-1, are expanded in columns of 8 characters. CTRL-S, CTRL-Q, and CTRL-P are normally intercepted as described below. All other non-graphic characters are returned in register A but are not echoed to the console.</p>
<p>When the Console Mode is in the default state Function 1 intercepts the stop scroll, CTRL-S, start scroll, CTRL-Q, and start/stop printer echo, CTRL-P, characters. Any characters that are typed following a CTRL-S and preceding a CTRL-Q are also intercepted. However, if start/stop scroll has been disabled by the Console Mode, the CTRL-S, CTRL-Q, and CTRL-P characters are not intercepted. Instead, they are returned in register A, but are not echoed to the console.</p>
<p>If printer echo has been invoked, all characters that are echoed to the console are also sent to the list device, LST:. Function 1 does not return control to the calling program until a non-intercepted character is typed, thus suspending execution if a character is not ready.</p>
<p>BDOS function 2: <strong>CONSOLE OUTPUT</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $02</p></li>
<li><p>E: ASCII Character</p></li>
</ul>
<p>The Console Output function sends the ASCII character from register E to the logical console device, CONOUT:. When the Console Mode is in the default state (see Section 2.2.1), Function 2 expands tab characters, CTRL-1, in columns of 8 characters, checks for stop scroll, CTRL-S, start scroll, CTRL-Q, and echoes characters to the logical list device, LST:, if printer echo, CTRL-P, has been invoked.</p>
<p>BDOS function 3: <strong>AUXILIARY INPUT</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $03</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: ASCII Character</p></li>
</ul>
<p>The Auxiliary Input function reads the next character from the logical auxiliary input device, AUXIN:, into register A. Control does not return to the calling program ’I the character is read. unti</p>
<p>BDOS function 4: <strong>AUXILIARY OUTPUT</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $04</p></li>
<li><p>E: ASCII Character</p></li>
</ul>
<p>The Auxiliary Output function sends the ASCII character from register E to the logical auxiliary output device, AUXOUT:.</p>
<p>BDOS function 5: <strong>LIST OUTPUT</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $05</p></li>
<li><p>E: ASCII Character</p></li>
</ul>
<p>The List Output function sends the ASCII character in register E to the logical list device, LST:.</p>
<p>BDOS function 6: <strong>DIRECT CONSOLE I/O</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $06</p></li>
<li><p>E: function/data (see description)</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: char/status/no value (see description)</p></li>
</ul>
<p>CP/M 3 supports direct I/O to the logical console, CONIN:, for those specialized applications where unadorned console input and output is required. Use Direct Console I/O carefully because it bypasses all the normal control character functions. Programs that perform direct I/O through the BIOS under previous releases of CP/M should be changed to use direct I/O so that they can be fully supported under future releases of MP/M and CP/M.</p>
<p>A program calls Function 6 by passing one of four different values in register E.</p>
<ul>
<li><p>$FF Console input/status command returns an input character; if no character is ready, a value of zero is returned.</p></li>
<li><p>$FE Console status command (On return, register A contains 00 if no character is ready; otherwise it contains $FF.)</p></li>
<li><p>$FD Console input command, returns an input character; this function will suspend the calling process until a character is ready.</p></li>
<li><p>ASCII Function 6 assumes that register E contains a valid ASCII chararacter and sends it to the console.</p></li>
</ul>
<p>BDOS function 7: <strong>AUXILIARY INPUT STATUS</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $07</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Auxiliary Input Status</p></li>
</ul>
<p>The Auxiliary Input Status function returns the value $FF in register A if a character is ready for input from the logical auxiliary input device, AUXIN:. If no character is ready for input, the value $00 is returned.</p>
<p>BDOS function 8: <strong>AUXILIARY OUTPUT STATUS</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $08</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Auxiliary Output Status</p></li>
</ul>
<p>The Auxiliary Output Status function returns the value $FF in register A if the logical auxiliary output device, AUXOUT:, is ready to accept a character for output. If the device is not ready for output, the value $00 is returned.</p>
<p>BDOS function 9: <strong>PRINT STRING</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $09</p></li>
<li><p>DE: String Address</p></li>
</ul>
<p>The Print String function sends the character string addressed by register pair DE to the logical console, CONOUT:, until it encounters a delimiter in the string. Usually the delimiter is a dollar sign, $, but it can be changed to any other value by Function 110, Get/Set Output Delimiter. If the Console Mode is in the default state, Function 9 expands tab characters, CTRL-I, in columns of 8 characters. It also checks for stop scroll, CTRL-S, start scroll, CTRL-Q, and echoes to the logical list device, LST:, if printer echo, CTRL-P, has been invoked.</p>
<p>BDOS function 10: <strong>READ CONSOLE BUFFER</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $0A</p></li>
<li><p>DE: Buffer Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>Console Characters in Buffer</p></li>
</ul>
<p>The Read Console Buffer function reads a line of edited console input from the logical console, CONIN:, to a buffer that register pair DE addresses. It terminates input and returns to the calling program when it encounters a return, CTRL-M, or a line feed, CTRL-J, character. Function 10 also discards all input characters after the input buffer is filled. In addition, it outputs a bell character, CTRL-G, to the console when it discards a character to signal the user that the buffer is full. The input buffer addressed by DE has the following format:</p>
<p>where mx is the maximum number of characters which the buffer holds, and nc is the number of characters placed in the buffer. The characters entered by the operator follow the nc value. The value mx must be set prior to making a Function 10 call and may range in value from 1 to 255. Setting mx to zero is equivalent to setting mx to one. The value nc is returned to the calling program and may range from zero to mx. If nc &lt; mx, then uninitialized positions follow the last character, denoted by ?? in the figure. Note that a terminating return or line feed character is not placed in the buffer and not included in the count nc.</p>
<p>If register pair DE is set to zero, Function 10 assumes that an initialized input buffer is located at the current DMA address (see Function 26, Set DMA Address). This allows a program to put a string on the screen for the user to edit. To initialize the input buffer, set characters c1 through cn to the initial value followed by a binary zero terminator.</p>
<p>When a program calls Function 10 with an initialized buffer, Function 10 operates as if the user had typed in the string. When Function 10 encounters the binary zero terminator, it accepts input from the console. At this point, the user can edit the initialized string or accept it as it is by pressing the RETURN key. However, if the initialized string contains a return, CTRL-M, or a linefeed, CTRL-J, character, Function 10 returns to the calling program without giving the user the opportunity to edit the string.</p>
<p>The level of console editing supported by Function 10 differs for the banked and nonbanked versions of CP/M 3. Refer to the CPIM Plus (CPIM Version 3) Operating System User’s Guide for a detailed description of console editing. In the nonbanked version, Function 10 recognizes the following edit control characters.</p>
<p>Nonbanked CP/M 3</p>
<ul>
<li><p>rub/del Removes and echoes the last character; GENCPM can change this function to CTRL-H</p></li>
<li><p>CTRL-C Reboots when at the beginning of line; the Console Mode can disable this function</p></li>
<li><p>CTRL-E Causes physical end of line</p></li>
<li><p>CTRL-H Backspaces one character position; GENCPM can change this function to rub/del</p></li>
<li><p>CTRL-J (Line-feed) terminates input line</p></li>
<li><p>CTRL-M (Return) terminates input line</p></li>
<li><p>CTRL-P Echoes console output to the list device</p></li>
<li><p>CTRL-R Retypes the current line after new line</p></li>
<li><p>CTRL-U Removes current line after new line</p></li>
<li><p>CTRL-X Backspaces to beginning of current line</p></li>
</ul>
<p>The banked version of CP/M 3 expands upon the editing provided in the non-banked version. The functionality of the two versions is similar when the cursor is positioned at the end of the line. However, in the banked version, the user can move the cursor anywhere in the current line, insert characters, delete characters, and perform other editing functions. In addition, the banked version saves the previous command line; it can be recalled when the current line is empty. In the banked version, Function 10 recognizes the following edit control characters.</p>
<p>Banked CP/M 3</p>
<ul>
<li><p>rub/del Removes and echoes the last character if at the end of the line; otherwise deletes the character to the left of the current cursor position; GENCPM can change this function to CTRL-H.</p></li>
<li><p>CTRL-A Moves cursor one character to the left.</p></li>
<li><p>CTRL-B Moves cursor to the beginning of the line when not at the beginning; otherwise moves cursor to the end of the line.</p></li>
<li><p>CTRL-C Reboots when at the beginning of line; the Console Mode can disable this function.</p></li>
<li><p>CTRL-E Causes physical end-of-line; if the cursor is positioned in the middle of a line, the characters at and to the right of the cursor are displayed on the next line.</p></li>
<li><p>CTRL-F Moves cursor one character to the right.</p></li>
<li><p>CTRL-G Deletes the character at the current cursor position when in the middle of the line; has no effect when the cursor is at the end of the line.</p></li>
<li><p>CTRL-H Backspaces one character position when positioned at the end of the line,; otherwise deletes the character to the left of the cursor; GENCPM can change this function to rub/del.</p></li>
<li><p>CTRL-J (Line-feed) terminates input; the cursor can be positioned anywhere in the line; the entire input line is accepted; sets the previous line buffer to the input line.</p></li>
<li><p>CTRL-K Deletes all characters to the right of the cursor along with the character at the cursor.</p></li>
<li><p>CTRL-M (Return) terminates input; the cursor can be positioned anywhere in the line; the entire input line is accepted; sets the previous line buffer to the input line.</p></li>
<li><p>CTRL-P Echoes console output to the list device.</p></li>
<li><p>CTRL-R Retypes the characters to the left of the cursor on the new line.</p></li>
<li><p>CTRL-U Updates the previous line buffer to contain the characters to the left of the cursor; deletes current line, and advances to new line.</p></li>
<li><p>CTRL-W Recalls previous line if current line is empty; otherwise moves cursor to end-of-line.</p></li>
<li><p>CTRL-X Deletes all characters to the left of the cursor.</p></li>
</ul>
<p>For banked systems, Function 10 uses the console width field defined in the System Control Block. If the console width is exceeded when the cursor is positioned at the end of the line, Function 10 automatically advances to the next line. The beginning of the line can be edited by entering a CTRL-R.</p>
<p>When a character is typed while the cursor is positioned in the middle of the line, the typed character is inserted into the line. Characters at and to the right of the cursor are shifted to the right. If the console width is exceeded, the characters disappear off the right of the screen. However, these characters are not lost. They reappear if characters are deleted out of the line, or if a CTRL-E is typed.</p>
<p>BDOS function 11: <strong>GET CONSOLE STATUS</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $0B</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Console Status</p></li>
</ul>
<p>The Get Console Status function checks to see if a character has been typed at the logical console, CONIN:. If the Console Mode is in the default state, Function 11 returns the value $01 in register A when a character is ready. If a character is not ready, it returns a value of $00.</p>
<p>If the Console Mode is in CTRL-C Only Status mode, Function 11 returns the value $01 in register A only if a CTRL-C has been typed at the console.</p>
<p>BDOS function 12: <strong>RETURN VERSION NUMBER</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $0C</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>HL: Version Number</p></li>
</ul>
<p>The Return Version Number function provides information that allows version independent programming. It returns a two-byte value in register pair HL: H contains $00 for CP/M and L contains $31, the BDOS file system version number. Function 12 is useful for writing applications programs that must run on multiple versions of CP/M and MP/M.</p>
<p>BDOS function 13: <strong>RESET DISK SYSTEM</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $0D</p></li>
</ul>
<p>The Reset Disk System function restores the file system to a reset state where all the disk drives are set to read-write (see Functions 28 and 29), the default disk is set to drive A, and the default DMA address is reset to $0080. This function can be used, for example, by an application program that requires disk changes during operation. Function 37, Reset Drive, can also be used for this purpose.</p>
<p>BDOS function 14: <strong>SELECT DISK</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $0E</p></li>
<li><p>E: Selected Disk</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Error Flag</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>The Select Disk function designates the disk drive named in register E as the default disk for subsequent BDOS file operations. Register E is set to 0 for drive A, 1 for drive B, and so on through 15 for drive P in a full 16-drive system. In addition, Function 14 logs in the designated drive if it is currently in the reset state. Logging-in a drive activates the drive’s directory until the next disk system reset or drive reset operation.</p>
<p>FCBs that specify drive code zero (dr = $00) automatically reference the currently selected default drive. FCBs with drive code values between 1 and 16, however, gnore the selected default drive and directly reference drives A through P.</p>
<p>Upon return, register A contains a zero if the select operation was successful. If a physical error was encountered, the select function performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is in the default mode, a message identifying the error is displayed at the console, and the calling program is terminated. Otherwise, the select function returns to the calling program with register A set to $FF and register H set to one of the following</p>
<p>physical error codes:</p>
<ul>
<li><p>01 Disk I/O Error</p></li>
<li><p>04 Invalid drive</p></li>
</ul>
<p>BDOS function 15: <strong>OPEN FILE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $0F</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Directory Code</p></li>
<li><p>H: Physical or Extended Error</p></li>
</ul>
<p>The Open File function activates the FCB for a file that exists in the disk directory under the currently active user number or user zero. The calling program passes the address of the FCB in register pair DE, with byte 0 of the FCB specifying the drive, bytes 1 through 11 specifying the filename and filetype, and byte 12 specifying the extent. Usually, byte 12 of the FCB is initialized to zero.</p>
<p>If the file is password protected in Read mode, the correct password must be placed in the first eight bytes of the current DMA, or have been previously established as the default password (see Function 106). If the current record field of the FCB, cr, is set to $FF, Function 15 returns the byte count of the last record of the file in the cr field. You can set the last record byte count for a file with Function 30, Set File Attributes. Note that the current record field of the FCB, cr, must be zeroed by the calling program before beginning read or write operations if the file is to be accessed sequentially from the first record.</p>
<p>If the current user is non-zero, and the file to be opened does not exist under the current user number, the open function searches user zero for the file. If the file exists under user zero, and has the system attribute, t2’, set, the file is opened under user zero. Write operations are not supported for a file that is opened under user zero in this manner.</p>
<p>If the open operation is successful, the user’s FCB is activated for read and write operations. The relevant directory information is copied from the matching directory FCB into bytes d0 through dn of the FCB. If the file is opened under user zero when the current user number is not zero, interface attribute f8’ is set to one in the user’s FCB. In addition, if the referenced file is password protected in Write mode, and the correct password was not passed in the DMA, or did not match the default password, interface attribute f7’ is set to one. Write operations are not supported for an activated FCB if interface attribute f7’ or f8’ is true.</p>
<p>When the open operation is successful, the open function also makes an Access date and time stamp for the opened file when the following conditions are satisfied: the referenced drive has a directory label that requests Access date and time stamping, and the FCB extent number field is zero.</p>
<p>Upon return, the Open File function returns a directory code in register A with the value $00 if the open was successful, or $FF, 255 decimal, if the file was not found. Register H is set to zero in both of these cases. If a physical or extended error was encountered, the Open File function performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is in the default mode, a message identifying the error is displayed at the console and the program is terminated. Otherwise, the Open File function returns to the calling program with register A set to $FF, and register H set to one of the following physical or extended error codes:</p>
<ul>
<li><p>01 : Disk I/O Error</p></li>
<li><p>04 : Invalid drive error</p></li>
<li><p>07 : File password error</p></li>
<li><p>09 : ? in the FCB filename or filetype field</p></li>
</ul>
<p>BDOS function 16: <strong>CLOSE FILE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $10</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Directory Code</p></li>
<li><p>H: Physical or Extended Error</p></li>
</ul>
<p>The Close File function performs the inverse of the Open File function. The calling program passes the address of an FCB in register pair DE. The referenced FCB must have been previously activated by a successful Open or Make function call (see Functions 15 and 22). Interface attribute f5’ specifies how the file is to be closed as shown below:</p>
<ul>
<li><p>f5’ = 0 - Permanent close (default mode)</p></li>
<li><p>f5’ = 1 - Partial close</p></li>
</ul>
<p>A permanent close operation indicates that the program has completed file operations on the file. A partial close operation updates the directory, but indicates that the file is to be maintained in the open state.</p>
<p>If the referenced FCB contains new information because of write operations to the FCB, the close function permanently records the new information in the referenced disk directory. Note that the FCB does not contain new information, and the directory update step is bypassed if only read or update operations have been made to the referenced FCB.</p>
<p>Upon return, the close function returns a directory code in register A with the value $00 if the close was successful,, or $FF, 255 Decimal, if the file was not found. Register H is set to zero in both of these cases. If a physical or extended error is encountered, the close function performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is in the default mode, a message identifying the error is displayed at the console, and the calling program is terminated. Otherwise, the close function returns to the calling program with register A set to $FF and register H set to one of the following physical error codes:</p>
<ul>
<li><p>01 Disk I/O error</p></li>
<li><p>02 Read/only disk</p></li>
<li><p>04 Invalid drive error</p></li>
</ul>
<p>BDOS function 17: <strong>SEARCH FOR FIRST</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $11</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li></li>
<li><p>A: Directory Code</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>The Search For First function scans the directory for a match with the FCB addressed by register pair DE. Two types of searches can be performed. For standard searches, the calling program initializes bytes 0 through 12 of the referenced FCB, with byte 0 specifying the drive directory to be searched, bytes 1 through 11 specifying the file or files to be searched for,, and byte 12 specifying the extent. Usually byte 12 is set to zero. An ASCII question mark, 63 decimal, 3F hex, in any of the bytes 1 through 12 matches all entries on the directory in the corresponding position. This facility, called ambiguous reference, can be used to search for multiple files on the directory. When called in the standard mode, the Search function scans for the first file entry in the specified directory that matches the FCB, and belongs to the current user number.</p>
<p>The Search For First function also initializes the Search For Next function. After the Search function has located the first directory entry matching the referenced FCB, the Search For Next function can be called repeatedly to locate all remaining matching entries. In terms of execution sequence, however, the Search For Next call must either follow a Search For First or Search For Next call with no other intervening BDOS disk-related function calls.</p>
<p>If byte 0 of the referenced FCB is set to a question mark, the Search function ignores the remainder of the referenced FCB, and locates the first directory entry residing on the current default drive. All remaining directory entries can be located by making multiple Search For Next calls. This type of search operation is not usually made by application programs, but it does provide complete flexibility to scan all current directory values. Note that this type of search operation must be performed to access a drive’s directory label.</p>
<p>Upon return, the Search function returns a Directory Code in register A with the value 0 to 3 if the search is successful, or $FF, 255 Decimal, if a matching directory entry is not found. Register H is set to zero in both of these cases. For successful searches, the current DMA is also filled with the directory record containing the matching entry, and the relative starting position is A * 32 (that is, rotate the A register left 5 bits, or ADD A five times). Although it is not usually required for application programs, the directory information can be extracted from the buffer at this position.</p>
<p>If the directory has been initialized for date and time stamping by INITDIR, then an SFCB resides in every fourth directory entry, and successful Directory Codes are restricted to the values 0 to 2. For successful searches, if the matching directory record is an extent zero entry, and if an SFCB resides at offset 96 within the current DMA, contents of (DMA Address + 96) = $21, the SFCB contains the date and time stamp information, and password mode for the file. This information is located at the relative starting position of 97 + (A * 10) within the current DMA in the following format:</p>
<ul>
<li><p>0 - 3 Create or Access Date and Time Stamp Field</p></li>
<li><p>4 - 7 Update Date and Time Stamp Field</p></li>
<li><p>8 : Password Mode Field</p></li>
</ul>
<p>If a physical error is encountered, the Search function performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is in the default mode, a message identifying the error is displayed at the console, and the calling program is terminated. Otherwise, the Search function returns to the calling program with register A set to $FF, and register H set to one of the following physical error codes:</p>
<ul>
<li><p>01 Disk I/O error</p></li>
<li><p>04 Invalid drive error</p></li>
</ul>
<p>BDOS function 18: <strong>SEARCH FOR NEXT</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $12</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Directory Code</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>The Search For Next function is identical to the Search For First function, except that the directory scan continues from the last entry that was matched. Function 18 returns a Directory code in register A, analogous to Function 17.</p>
<p>Note: in execution sequence, a Function 18 call must follow either a Function 17 or another Function 18 call with no other intervening BDOS disk-related function calls.</p>
<p>BDOS function 19: <strong>DELETE FILE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $13</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Directory Code</p></li>
<li><p>H: Extended or Physical Error</p></li>
</ul>
<p>The Delete File function removes files or XFCBs that match the FCB addressed in register pair DE. The filename and filetype can contain ambiguous references, that is, question marks in bytes f1’ through t3’, but the dr byte cannot be ambiguous, as it can in the Search and Search Next functions. Interface attribute f5’ specifies the type of delete operation that is performed.</p>
<ul>
<li><p>f5’ = 0 - Standard Delete (default mode)</p></li>
<li><p>f5’ = 1 - Delete only XFCBs</p></li>
</ul>
<p>If any of the files that the referenced FCB specify are password protected, the correct password must be placed in the first eight bytes of the current DMA buffer, or have been previously established as the default password (see Function 106).</p>
<p>For standard delete operations, the Delete function removes all directory entries belonging to files that match the referenced FCB. All disk directory and data space owned by the deleted files is returned to free space, and becomes available for allocation to other files. Directory XFCBs that were owned by the deleted files are also removed from the directory. If interface attribute f5’ of the FCB is set to 1, Function 19 deletes only the directory XFCBs that match the referenced FCB.</p>
<p>Note: if any of the files that match the input FCB specification fall the password check, or are Read-Only, then the Delete function does not delete any files or XFCBS. This applies to both types of delete operations.</p>
<p>In nonbanked systems, file passwords and XFCBs are not supported. Thus, if the Delete function is called with interface attribute f5’ set to true, the Delete function performs no action but returns with register A set to zero.</p>
<p>Upon return, the Delete function returns a Directory Code in register A with the value 0 if the delete is successful, or $FF, 255 Decimal, if no file that matches the referenced FCB is found. Register H is set to zero in both of these cases. If a physical, or extended error is encountered, the Delete function performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is the default mode, a message identifying the error is displayed at the console and the calling program is terminated. Otherwise, the Delete function returns to the calling program with register A set to $FF and register H set to one of the following physical or extended error codes:</p>
<ul>
<li><p>01 : Disk I/O error</p></li>
<li><p>02 : Read-Only disk</p></li>
<li><p>03 : Read-Only file</p></li>
<li><p>04 : Invalid drive error</p></li>
<li><p>07 : File password error</p></li>
</ul>
<p>BDOS function 20: <strong>READ SEQUENTIAL</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $14</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Error Code</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>The Read Sequential function reads the next 1 to 128 128-byte records from a file into memory beginning at the current DMA address. The BDOS Multi-Sector Count (see Function 44) determines the number of records to be read. The default is one record. The FCB addressed by register pair DE must have been previously activated by an Open or Make function call.</p>
<p>Function 20 reads each record from byte cr of the extent, then automatically increments the cr field to the next record position. If the cr field overflows, then the function automatically opens the next logical extent and resets the cr field to 0 in preparation for the next read operation. The calling program must set the cr field to 0 following the Open call if the intent is to read sequentially from the beginning of the file. Upon return, the Read Sequential function sets register A to zero if the read operation is successful. Otherwise, register A contains an error code identifying the error as shown below:</p>
<ul>
<li><p>01 Reading unwritten data (end-of-file)</p></li>
<li><p>09 Invalid FCB</p></li>
<li><p>10 Media change occurred</p></li>
<li><p>255 Physical Error; refer to register H</p></li>
</ul>
<p>Error Code 01 is returned if no data exists at the next record position of the file. Usually, the no data situation is encountered at the end of a file. However, it can also occur if an attempt is made to read a data block that has not been previously written, or an extent which has not been created. These situations are usually restricted to files created or appended with the BDOS random write functions (see Functions 34 and 40).</p>
<p>Error Code 09 is returned if the FCB is invalidated by a previous BDOS close call that returns an error.</p>
<p>Error Code 10 is returned if a media change occurs on the drive after the referenced FCB is activated by a BDOS Open, or Make Call.</p>
<p>Error Code 255 is returned if a physical error is encountered and the BDOS error mode is Return Error mode, or Return and Display Error mode (see Function 45). If the error mode is the default mode, a message identifying the physical error is displayed at the console, and the calling program is terminated. When a physical error is returned to the calling program, register H contains one of the following error codes:</p>
<ul>
<li><p>01 Disk I/O error</p></li>
<li><p>04 Invalid drive error</p></li>
</ul>
<p>On all error returns except for physical error returns, A = 255, Function 20 sets register H to the number of records successfully read before the error is encountered. This value can range from 0 to 127 depending on the current BDOS Multi-Sector Count. It is always set to zero when the Multi-Sector Count is equal to one.</p>
<p>BDOS function 21: <strong>WRITE SEQUENTIAL</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $15</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Error Code</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>The Write Sequential function writes 1 to 128 128-byte data records, beginning at the current DMA address into the file named by the FCB addressed in register pair DE. The BDOS Multi-Sector Count (see Function 44) determines the number of 128 byte records that are written. The default is one record. The referenced FCB must have been previously activated by a BDOS Open or Make function call.</p>
<p>Function 21 places the record into the file at the position indicated by the cr byte of the FCB, and then automatically increments the cr byte to the next record position. If the cr field overflows, the function automatically opens, or creates the next logical extent, and resets the cr field to 0 in preparation for the next write operation. If Function 21 is used to write to an existing file, then the newly written records overlay those already existing in the file. The calling program must set the cr field to 0 following an Open or Make call if the intent is to write sequentially from the beginning of the file.</p>
<p>Function 21 makes an Update date and time for the file if the following conditions are satisfied: the referenced drive has a directory label that requests date and time stamping, and the file has not already been stamped for update by a previous Make or Write function call.</p>
<p>Upon return, the Write Sequential function sets register A to zero if the write operation is successful. Otherwise, register A contains an error code identifying the error as shown below:</p>
<ul>
<li><p>01 No available directory space</p></li>
<li><p>02 No available data block</p></li>
<li><p>09 Invalid FCB</p></li>
<li><p>10 Media change occurred</p></li>
<li><p>255 Physical Error : refer to register H</p></li>
</ul>
<p>Error Code 01 is returned when the write function attempts to create a new extent that requires a new directory entry, and no available directory entries exist on the selected disk drive.</p>
<p>Error Code 02 is returned when the write command attempts to allocate a new data block to the file, and no unallocated data blocks exist on the selected disk drive.</p>
<p>Error Code 09 is returned if the FCB is invalidated by a previous BDOS close call that returns an error.</p>
<p>Error Code 10 is returned if a media change occurs on the drive after the referenced FCB is activated by a BDOS Open or Make call.</p>
<p>Error Code 255 is returned if a physical error is encountered and the BDOS error mode is Return Error mode, or Return and Display Error mode (see Function 45). If the error mode is the default mode, a message identifying the physical error is displayed at the console, and the calling program is terminated. When a physical error is returned to the calling program, register H contains one of the following error codes:</p>
<ul>
<li><p>01 Disk I/O error</p></li>
<li><p>02 Read-Only disk</p></li>
<li><p>03 Read-Only file or File open from user 0 when the current user number is non-zero or File password protected in Write mode</p></li>
<li><p>04 Invalid drive error</p></li>
</ul>
<p>On all error returns, except for physical error returns, A = 255, Function 21 sets register H to the number of records successfully written before the error was encountered. This value can range from 0 to 127 depending on the current BDOS Multi-Sector Count. It is always set to zero when the Multi-Sector Count is set to one.</p>
<p>BDOS function 22: <strong>MAKE FILE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $16</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Directory Code</p></li>
<li><p>H: Physical or Extended Error</p></li>
</ul>
<p>The Make File function creates a new directory entry for a file under the current user number. It also creates an XFCB for the file if the referenced drive has a directory label that enables password protection on the drive, and the calling program assigns a password to the file.</p>
<p>The calling program passes the address of the FCB in register pair DE, with byte 0 of the FCB specifying the drive, bytes 1 through 11 specifying the filename and filctype, and byte 12 set to the extent number. Usually, byte 12 is set to zero. Byte 32 of the FCB, the cr field, must be initialized to zero, before or after the Make call, if the intent is to write sequentially from the beginning of the file.</p>
<p>Interface attribute f6’ specifies whether a password is to be assigned to the created file.</p>
<ul>
<li><p>f6’ = 0 - Do not assign password (default)</p></li>
<li><p>f6’ = 1 - Assign password to created file</p></li>
</ul>
<p>When attribute f6’ is set to 1, the calling program must place the password in the first 8 bytes of the current DMA buffer, and set byte 9 of the DMA buffer to the password mode (see Function 102). Note that the Make function only interrogates interface attribute f6’ if passwords are activated on the referenced drive. In nonbanked systems, file passwords are not supported, and attribute f6’ is never interrogated.</p>
<p>The Make function returns with an error if the referenced FCB names a file that currently exists in the directory under the current user number.</p>
<p>If the Make function is successful, it activates the referenced FCB for file operations by opening the FCB, and initializes both the directory entry and the referenced FCB to an empty file. It also initializes all file attributes to zero. In addition, Function 22 makes a Creation date and time stamp for the file if the following conditions are satisfied: the referenced drive has a directory label that requests Creation date and time stamping and the FCB extent number field is equal to zero. Function 22 also makes an Update stamp if the directory label requests update stamping and the FCB extent field is equal to zero.</p>
<p>If the referenced drive contains a directory label that enables password protection, and if interface attribute f6’ has been set to 1, the Make function creates an XFCB for the file. In addition, Function 22 also assigns the password, and password mode placed in the first nine bytes of the DMA, to the XFCB.</p>
<p>Upon return, the Make function returns a directory code in register A with the value 0 if the make operation is successful, or $FF, 255 decimal, if no directory space is available. Register H is set to zero in both of these cases. If a physical or extended error is encountered, the Make function performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is the default mode, a message identifying the error is displayed at the console, and the calling program is terminated. Otherwise, the Make function returns to the calling program with register A set to $FF, and register H set to one of the following physical or extended error codes:</p>
<ul>
<li><p>01 : Disk I/O error</p></li>
<li><p>02 : Read-Only disk</p></li>
<li><p>04 : Invalid drive error</p></li>
<li><p>08 : File already exists</p></li>
<li><p>09 : ? in filename or filetype field</p></li>
</ul>
<p>BDOS function 23: <strong>RENAME FILE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $17</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Directory Code</p></li>
<li><p>H: Physical or Extended Error</p></li>
</ul>
<p>The Rename function uses the FCB, addressed by register pair DE, to change all directory entries of the file specified by the filename in the first 16 bytes of the FCB to the filename in the second 16 bytes. If the file specified by the first filename is password protected, the correct password must be placed in the first eight bytes of the current DMA buffer, or have been previously established as the default password (see Function 106). The calling program must also ensure that the filenames specified in the FCB are valid and unambiguous, and that the new filename does not already exist on the drive. Function 23 uses the dr code at byte 0 of the FCB to select the drive. The drive code at byte 16 of the FCB is ignored.</p>
<p>Upon return, the Rename function returns a Directory Code in register A with the value 0 if the rename is successful, or $0FF, 255 Decimal, if the file named by the first filename in the FCB is not found. Register H is set to zero in both of these cases. If a physical or extended error is encountered, the Rename function performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is the default mode, a message identifying the error is displayed at the console and the program is terminated. Otherwise, the Rename function returns to the calling program with register A set to $0FF and register H set to one of the following physical or extended error codes:</p>
<ul>
<li><p>01 Disk I/O error</p></li>
<li><p>02 Read-Only disk</p></li>
<li><p>03 Read-Only file</p></li>
<li><p>04 Invalid drive error</p></li>
<li><p>07 File password error</p></li>
<li><p>08 File already exists</p></li>
<li><p>09 ? in filename or filetype field</p></li>
</ul>
<p>BDOS function 24: <strong>RETURN LOGIN VECTOR</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $18</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>HL: Login Vector</p></li>
</ul>
<p>Function 24 returns the login vector in register pair HL. The login vector is a 16-bit value with the least significant bit of L corresponding to drive A, and the highorder bit of H corresponding to the 16th drive, labelled P. A 0 bit indicates that the drive is not on-line, while a 1 bit indicates the drive is active. A drive is made active by either an explicit BDOS Select Disk call, number 14, or an implicit selection when a BDOS file operation specifies a non-zero dr byte in the FCB. Function 24 maintains compatibilty with earlier releases since registers A and L contain the same values upon return.</p>
<p>BDOS function 25: <strong>RETURN CURRENT DISK</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $19</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Current Disk</p></li>
</ul>
<p>Function 25 returns the currently selected default disk number in register A. The disk numbers range from 0 through 15 corresponding to drives A through P.</p>
<p>BDOS function 26: <strong>SET DMA ADDRESS</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $1A</p></li>
<li><p>DE: DMA Address</p></li>
</ul>
<p>DMA is an acronym for Direct Memory Address, which is often used in connection with disk controllers that directly access the memory of the computer to transfer data to and from the disk subsystem. Under CP/M 3, the current DMA is usually defined as the buffer in memory where a record resides before a disk write, and after a disk read operation. If the BDOS Multi-Sector Count is equal to one (see Function 44), the size of the buffer is 128 bytes. However, if the BDOS Multi-Sector Count is greater than one, the size of the buffer must equal N * 128, where N equals the Multi-Sector Count.</p>
<p>Some BDOS functions also use the current DMA to pass parameters, and to return values. For example, BDOS functions that check and assign file passwords require that the password be placed in the current DMA. As another example, Function 46, Get Disk Free Space, returns its results in the first 3 bytes of the current DMA. When the current DMA is used in this context, the size of the buffer in memory is determined by the specific requirements of the called function.</p>
<p>When a transient program is initiated by the CCP, its DMA address is set to $0080. The BDOS Reset Disk System function, Function 13, also sets the DMA address to $0080. The Set DMA function can change this default value to another memory address. The DMA address is set to the value passed in the register pair DE. The DMA address remains at this value until it is changed by another Set DMA Address, or Reset Disk System call.</p>
<p>BDOS function 27: <strong>GET ADDR(ALLOC)</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $1B</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>HL: ALLOC Address</p></li>
</ul>
<p>CP/M 3 maintains an allocation vector in main memory for each active disk drive. Some programs use the information provided by the allocation vector to determine the amount of free data space on a drive. Note, however, that the allocation information might be inaccurate if the drive has been marked Read-Only.</p>
<p>Function 27 returns in register pair HL, the base address of the allocation vector for the currently selected drive. If a physical error is encountered when the BDOS error mode is one of the return modes (see Function 45), Function 27 returns the value $FFFF in the register pair HL.</p>
<p>In banked CP/M 3 systems, the allocation vector can be placed in bank zero. In this case, a transient program cannot access the allocation vector. However, the BDOS function, Get Disk Free Space (Function 46), can be used to directly return the number of free 128-byte records on a drive. The CP/M 3 utilities that display a drive’s free space, DIR and SHOW, use Function 46 for that purpose.</p>
<p>BDOS function 28: <strong>WRITE PROTECT DISK</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $1C</p></li>
</ul>
<p>The Write Protect Disk function provides temporary write protection for the currently selected disk by marking the drive as Read-Only, No program can write to a disk that is in the Read-Only state. A drive reset operation must be performed for a Read-Only drive to restore it to the Read-Write state (see Functions 13 and 37).</p>
<p>BDOS function 29: <strong>GET READ-ONLY VECTOR</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: l$D</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>HL: R/O Vector Value</p></li>
</ul>
<p>Function 29 returns a bit vector in register pair HL that indicates which drives have the temporary Read-Only bit set. The Read-Only bit can be set only by a BDOS Write Protect Disk call.</p>
<p>The format of the bit vector is analogous to that of the login vector returned by Function 24. The least significant bit corresponds to drive A, while the most significant bit corresponds to drive P.</p>
<p>BDOS function 30: <strong>SET FILE ATTRIBUTES</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $1E</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Directory Code</p></li>
<li><p>H: Physical or Extended error</p></li>
</ul>
<p>By calling the Set File Attributes function, a program can modify a file’s attributes and set its last record byte count. Other BDOS functions can be called to interrogate these file parameters, but only Function 30 can change them. The file attributes that can be set or reset by Function 30 are fl’ through f4’, Read-Only, t1’, System, t2’, and Archive, t3’. The register pair DE addresses an FCB containing a filename with the appropriate attributes set or reset. The calling program must ensure that it does not specify an ambiguous filename. In addition, if the specified file is password totected, the correct password must be placed in the first eight bytes of the current DMA buffer or have been previously established as the default password (see Function 106).</p>
<p>Interface attribute f6’ specifies whether the last record byte count of the specified file is to be set:</p>
<ul>
<li><p>f6’ = 0 - Do not set byte count (default mode)</p></li>
<li><p>f6’ = 1 - Set byte count</p></li>
</ul>
<p>If interface attribute f6’ is set, the calling program must set the cr field of the referenced FCB to the byte count value. A program can access a file’s byte count value with the BDOS Open, Search, or Search Next functions.</p>
<p>Function 30 searches the referenced directory for entries belonging to the current user number that matches the FCB specified name and type fields. The function then updates the directory to contain the selected indicators, and if interface attribute f6’ is set, the specified byte count value. Note that the last record byte count is maintained in byte 13 of a file’s directory FCBS.</p>
<p>File attributes t1’, t2’, and t3’ are defined by CP/M 3. (They are described in Section 2.3.4.) Attributes fl’ through f4’ are not presently used, but can be useful for application programs, because they are not involved in the matching program used by the BDOS during Open File and Close File operations. Indicators f5’ through f8’ are reserved for use as interface attributes.</p>
<p>Upon return, Function 30 returns a Directory Code in register A with the value 0 if the function is successful, or $FF, 255 Decimal, if the file specified by the referenced FCB is not found. Register H is set to zero in both of these cases. If a physical or extended error is encountered’, the Set File Attributes function performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is the default mode, a message identifying the error is displayed at the console, and the program is terminated. Otherwise, Function 30 returns to the calling program with reg’ls-Ler A set to $FF, and register H set to one of the following physical or extended error codes:</p>
<ul>
<li><p>01 Disk I/O error</p></li>
<li><p>02 Read-Only disk</p></li>
<li><p>04 Select error</p></li>
<li><p>07 File password error</p></li>
<li><p>09 ? in filename or filetype field</p></li>
</ul>
<p>BDOS function 31: <strong>GET ADDR(DPB PARMS)</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $1F</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>HL: DPB Address</p></li>
</ul>
<p>Function 31 returns in register pair HL the address of the BIOS-resident Disk Parameter Block, DPB, for the currently selected drive. (Refer to the CP/M Plus (CP/M Version 3) Operating System System Guide for the format of the DPB). The calling program can use this address to extract the disk parameter values.</p>
<p>If a physical error is encountered when the BDOS error mode is one of the return modes (see Function 45), Function 31 returns the value $FFFF in the register pair HL.</p>
<p>BDOS function 32: <strong>SET/GET USER CODE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $20</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>E: $FF (get) or User Code (set)</p></li>
<li><p>A: Current Code or (no value)</p></li>
</ul>
<p>A program can change, or interrogate the currently active user number by calling Function 32. If register E = $FF, then the value of the current user number is returned in register A, where the value is in the range of 0 to 15. If register E is not $FF, then the current user number is changed to the value of E, modulo 16.</p>
<p>BDOS function 33: <strong>READ RANDOM</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $21</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Error Code</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>The Read Random function is similar to the Read Sequential function except that the read operation takes place at a particular random record number, selected by the 24-bit value constructed from the three byte, r0, r1, r2, field beginning at position 33 of the FCB. Note that the sequence of 24 bits is stored with the least significant byte first, rO, the middle byte next, rl, and the high byte last, r2. The random record number can range from 0 to 262,143. This corresponds to a maximum value of 3 in byte r2.</p>
<p>To read a file with Function 33, the calling program must first open the base extent, extent 0. This ensures that the FCB is properly initialized for subsequent random access operations. The base extent may or may not contain any allocated data. Function 33 reads the record specified by the random record field into the current DMA address. The function automatically sets the logical extent and current record values, but unlike the Read Sequential function, it does not advance the current record number. Thus, a subsequent Read Random call rereads the same record. After a random read operation, a file can be accessed sequentially, starting from the current randomly accessed position. However, the last randomly accessed record is reread or rewritten when switching from random to sequential mode.</p>
<p>If the BDOS Multi-Sector Count is greater than one (see Function 44), the Read Random function reads multiple consecutive records into memory beginning at the current DMA. The rO, rl, and r2 field of the FCB is automatically incremented to read each record. However, the FCBs random record number is restored to the first record’s value upon return to the calling program.</p>
<p>Upon return, the Read Random function sets register A to zero if the read operation was successful. Otherwise, register A contains one of the following error codes:</p>
<ul>
<li><p>01 Reading unwritten data (end-of-file)</p></li>
<li><p>03 Cannot close current extent</p></li>
<li><p>04 Seek to unwritten extent</p></li>
<li><p>06 Random record number out of range</p></li>
<li><p>10 Media change occurred</p></li>
<li><p>255 Physical Error : refer to register H</p></li>
</ul>
<p>Error Code 01 is returned if no data exists at the next record position of the file. Usually, the no data situation is encountered at the end of a file. However, it can also occur if an attempt is made to read a data block that has not been previously written.</p>
<p>Error Code 03 is returned when the Read Random function cannot close the current extent prior to moving to a new extent.</p>
<p>Error Code 04 is returned when a read random operation accesses an extent that has not been created.</p>
<p>Error Code 06 is returned when byte 35, r2, of the referenced FCB is greater than 3.</p>
<p>Error Code 10 is returned if a media change occurs on the drive after the referenced FCB is activated by a BDOS Open or Make Call.</p>
<p>Error Code 255 is returned if a physical error is encountered, and the BDOS error mode is one of the return modes (see Function 45). If the error mode is the default mode, a message identifying the physical error is displayed at the console, and the calling program is terminated. When a physical error is returned to the calling program, register H contains one of the following error codes:</p>
<ul>
<li><p>01 Disk I/O error</p></li>
<li><p>04 Invalid drive error</p></li>
</ul>
<p>On all error returns except for physical errors, A = 255, the Read Random function sets register H to the number of records successfully read before the error is encountered. This value can range from 0 to 127 depending on the current BDOS Multi-Sector Count. It is always set to zero when the Multi-Sector Count is equal to one.</p>
<p>BDOS function 34: <strong>WRITE RANDOM</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $22</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Error Code</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>The Write Random function is analogous to the Read Random function, except that data is written to the disk from the current DMA address. If the disk extent or data block where the data is to be written is not already allocated, the BDOS automatically performs the allocation before the write operation continues.</p>
<p>To write to a file using the Write Random function, the calling program must first open the base extent, extent 0. This ensures that the FCB is properly initialized for subsequent random access operations. If the file is empty, the calling program must create the base extent with the Make File function before calling Function 34. The base extent might or might not contain any allocated data, but it does record the file in the directory, so that the file can be displayed by the DIR utility.</p>
<p>The Write Random function sets the logical extent and current record positions to correspond with the random record being written, but does not change the random record number. Thus, sequential read or write operations can follow a random write, with the current record being reread or rewritten as the calling program switches from random to sequential mode.</p>
<p>Function 34 makes an Update date and time stamp for the file if the following conditions are satisfied: the referenced drive has a directory label that requests Update date and time stamping if the file has not already been stamped for update by a previous BDOS Make or Write call.</p>
<p>If the BDOS Multi-Sector Count is greater than one (see Function 44), the Write Random function reads multiple consecutive records into memory beginning at the current DMA. The rO, rl, and r2 field of the FCB is automatically incremented to write each record. However, the FCB’s random record number is restored to the first record’s value when it returns to the calling program. Upon return, the Write Random function sets register A to zero if the write operation is successful. Otherwise, register A contains one of the following error codes:</p>
<ul>
<li><p>02 No available data block</p></li>
<li><p>03 Cannot Close current extent</p></li>
<li><p>05 No available directory space</p></li>
<li><p>06 Random record number out of range</p></li>
<li><p>10 Media change occurred</p></li>
<li><p>255 Physical Error : refer to register H</p></li>
</ul>
<p>Error Code 02 is returned when the write command attempts to allocate a new data block to the file and no unallocated data blocks exist on the selected disk drive.</p>
<p>Error Code 03 is returned when the Write Random function cannot close the current extent prior to moving to a new extent.</p>
<p>Error Code 05 is returned when the write function attempts to create a new extent that requires a new directory entry and no available directory entries exist on the selected disk drive.</p>
<p>Error Code 06 is returned when byte 35, r2, of the referenced FCB is greater than 3.</p>
<p>Error Code 10 is returned if a media change occurs on the drive after the referenced FCB is activated by a BDOS Open or Make Call.</p>
<p>Error Code 255 is returned if a physical error is encountered and the BDOS error mode is one of the return modes (see Function 45). If the error mode is the default mode, a message identifying the physical error is displayed at the console, and the calling program is terminated. When a physical error is returned to the calling program, it is identified by register H as shown below:</p>
<ul>
<li><p>01 Disk I/O error</p></li>
<li><p>02 Read-Only disk</p></li>
<li><p>03 Read-Only file or File open from user 0 when the current user number is nonzero or File password protected in Write mode</p></li>
<li><p>04 Invalid drive error</p></li>
</ul>
<p>On all error returns, except for physical errors, A = 255, the Write Random function sets register H to the number of records successfully written before the error is encountered. This value can range from 0 to 127 depending on the current BDOS Multi-Sector Count. It is always set to zero when the Multi-Sector Count is equal to one.</p>
<p>BDOS function 35: <strong>COMPUTE FILE SIZE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $23</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Error Flag</p></li>
<li><p>H: Physical or Extended error</p></li>
<li><p>Random Record Field Set</p></li>
</ul>
<p>The Compute File Size function determines the virtual file size, which is, in effect, the address of the record immediately following the end of the file. The virtual size of a file corresponds to the physical size if the file is written sequentially. If the file is written in random mode, gaps might exist in the allocation, and the file might contain fewer records than the indicated size. For example, if a single record with record number 262,143, the CP/M 3 maximum is written to a file using the Write Random function, then the virtual size of the file is 262,144 records even though only 1 data block ’is actually allocated.</p>
<p>To compute file size, the calling program passes in register pair DE the address of an FCB in random mode format, bytes rO, rl and r2 present. Note that the FCB must contain an unambiguous filename and filetype. Function 35 sets the random record field of the FCB to the random record number + 1 of the last record in the file. If the r2 byte is set to 04, then the file contains the maximum record count 262,144.</p>
<p>A program can append data to the end of an existing file by calling Function 35 to set the random record position to the end of file, and then performing a sequence of random writes starting at the preset record address.</p>
<p>Note: the BDOS does not require that the file be open to use Function 35. However, if the file has been written to, it must be closed before calling Function 35. Otherwise, an incorrect file size might be returned.</p>
<p>Upon return, Function 35 returns a zero in register A if the file specified by the referenced FCB is found, or an $FF in register A if the file is not found. Register H is set to zero in both of these cases. If a physical error is encountered, Function 35 performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is the default mode, a message identifying the error is displayed at the console and the program is terminated. Otherwise, Function 35 returns to the calling program with register A set to $FF, and register H set to one of the following physical errors:</p>
<ul>
<li><p>01 Disk I/O error</p></li>
<li><p>04 Invalid drive error</p></li>
</ul>
<p>BDOS function 36: <strong>SET RANDOM RECORD</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $24</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>Random Record Field Set</p></li>
</ul>
<p>The Set Random Record function returns the random record number of the next record to be accessed from a file that has been read or written sequentially to a particular point. This value is returned in the random record field, bytes rO, rl, and r2, of the FCB addressed by the register pair DE. Function 36 can be useful in two ways,</p>
<p>First, it is often necessary to initially read and scan a sequential file to extract the positions of various key fields. As each key is encountered, Function 36 is called to compute the random record position for the data corresponding to this key. If the data unit size is 128 bytes, the resulting record number minus one is placed into a table with the key for later retrieval. After scanning the entire file and tabularizing the keys and their record numbers, you can move directly to a particular record by performing a random read using the corresponding random record number that you saved earlier. The scheme is easily generalized when variable record lengths are involved, because the program need only store the buffer-relative byte position along with the key and record number to find the exact starting position of the keyed data at a later time.</p>
<p>A second use of Function 36 occurs when switching from a sequential read or write over to random read or write. A file is sequentially accessed to a particular point in the file, then Function 36 is called to set the record number, and subsequent random read and write operations continue from the next record in the file.</p>
<p>BDOS function 37: <strong>RESET DRIVE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $25</p></li>
<li><p>DE: Drive Vector</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: $00</p></li>
</ul>
<p>The Reset Drive function programmatically restores specified drives to the reset state. A reset drive is not logged-in and is in Read-Write status. The passed parameter in register pair DE is a 16-bit vector of drives to be reset, where the least significant bit corresponds to the first drive A, and the high-order bit corresponds to the sixteenth drive, labelled P. Bit values of 1 indicate that the specified drive is to be reset.</p>
<p>BDOS function 38: <strong>ACCESS DRIVE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $26</p></li>
</ul>
<p>This is an MP/M function that is not supported under CP/M 3. If called, the file system returns a zero In register A indicating that the access request is successful.</p>
<p>BDOS function 39: <strong>FREE DRIVE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $27</p></li>
</ul>
<p>This is an MP/M function that is not supported under CP/M 3. If called, the file system returns a zero In register A indicating that the free request is successful.</p>
<p>BDOS function 40: <strong>WRITE RANDOM WITH ZERO FILL</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $28</p></li>
<li><p>DE: FCB address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Error Code</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>The Write Random With Zero Fill function is identical to the Write Random function (Function 34) with the exception that a previously unallocated data block is filled with zeros before the record is written. If this function has been used to create a file, records accessed by a read random operation that contain all zeros identify unwritten random record numbers. Unwritten random records in allocated data blocks of files created using the Write Random function (Function 34) contain uninitialized data.</p>
<p>BDOS function 41: <strong>TEST AND WRITE RECORD</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $29</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Error Code</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>The Test and Write Record function is an MP/M function that is not supported under CP/M 3. If called, Function 41 returns with register A set to $FF and register H set to zero.</p>
<p>BDOS function 42: <strong>LOCK RECORD</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $2A</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: $00</p></li>
</ul>
<p>The Lock Record function is an MP/M II function that is supported under CP/M 3 only to provide compatibility between CP/M 3 and MP/M. It is intended for use in situations where more than one running program has Read-Write access to a common file. Because CP/M 3 is a single-user operating system in which only one program can run at a time, this situation cannot occur. Thus, under CP/M 3, Function 42 performs no action except to return the value $00 in register A indicating that the record lock operation is successful.</p>
<p>BDOS function 43: <strong>UNLOCK RECORD</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $2B</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: $00</p></li>
</ul>
<p>The Unlock Record function is an MP/M II function that is supported under CP/M 3 only to provide compatibility between CP/M 3 and MP/M. It is intended for use in situations where more than one running program has Read-Write access to a common file. Because CP/M 3 is a single-user operating system in which only one program can run at a time, this situation cannot occur. Thus, under CP/M 3, Function 43 performs no action except to return the value $00 in register A indicating that the record unlock operation is successful.</p>
<p>BDOS function 44: <strong>SET MULTI-SECTOR COUNT</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $2C</p></li>
<li><p>E: Number of Sectors</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Return Code</p></li>
</ul>
<p>The Set Multi-Sector Count function provides logical record blocking under CP/M 3. It enables a program to read and write from 1 to 128 records of 128 bytes at a time during subsequent BDOS Read and Write functions.</p>
<p>Function 44 sets the Multi-Sector Count value for the calling program to the value passed in register E. Once set, the specified Multi-Sector Count remains in effect until the calling program makes another Set Multi-Sector Count function call and changes the value. Note that the CCP sets the Multi-Sector Count to one when it initiates a transient program.</p>
<p>The Multi-Sector Count affects BDOS error reporting for the BDOS Read and Write functions. If an error interrupts these functions when the Multi-Sector is greater than one, they return the number of records successfully read or written in register H for all errors except for physical errors (A = 255).</p>
<p>Upon return, register A is set to zero if the specified value is in the range of 1 to 128. Otherwise, register A is set to $FF.</p>
<p>BDOS function 45: <strong>SET BDOS ERROR MODE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $2D</p></li>
<li><p>E: BDOS Error Mode</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>None</p></li>
</ul>
<p>Function 45 sets the BDOS error mode for the calling program to the mode specified in register E. If register E is set to $FF, 255 decimal, the error mode is set to Return Error mode. If register E is set to $FE, 254 decimal, the error mode is set to Return and Display mode. If register E is set to any other value, the error mode is set to the default mode.</p>
<p>The SET BDOS Error Mode function determines how physical and extended errors (see Section 2.2.13) are handled for a program. The Error Mode can exist in three modes: the default mode, Return Error mode, and Return and Display Error mode. In the default mode, the BDOS displays a system message at the console that identifies the error and terminates the calling program. In the return modes, the BDOS sets register A to $FF, 255 decimal, places an error code that identifies the physical or extended error in register H and returns to the calling program. In Return and Display mode, the BDOS displays the system message before returning to the calling program. No system messages are displayed, however, when the BDOS is in Return Error mode.</p>
<p>BDOS function 46: <strong>GET DISK FREE SPACE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $2E</p></li>
<li><p>E: Drive</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>First 3 bytes of current DMA buffer</p></li>
<li><p>A: Error Flag</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>The Get Disk Free Space function determines the number of free sectors, 128 byte records, on the specified drive. The calling program passes the drive number in register E, with 0 for drive A, 1 for B, and so on, through 15 for drive P in a full 16drive system. Function 46 returns a binary number in the first 3 bytes of the current DMA buffer. This number is returned in the following format:</p>
<p>fso fsl fs2</p>
<p>Disk Free Space Field Format</p>
<p>fso = low byte<br />
fsl = middle byte<br />
fs2 = high byte<br />
Note that the returned free space value might be inaccurate if the drive has been marked Read-Only.</p>
<p>Upon return, register A is set to zero if the function is successful. However, if the BDOS Error Mode is one of the return modes (see Function 45), and a physical error is encountered, register A is set to $FF, 255 decimal, and register H is set to one of the following values:</p>
<ul>
<li><p>01 - Disk I/O error</p></li>
<li><p>04 - Invalid drive error</p></li>
</ul>
<p>BDOS function 47: <strong>CHAIN TO PROGRAM</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $2F</p></li>
<li><p>E: Chain Flag</p></li>
</ul>
<p>The Chain To Program function provides a means of chaining from one program to the next without operator intervention. The calling program must place a command line terminated by a null byte, OOH, in the default DMA buffer. If register E is set to $FF, the CCP initializes the default drive and user number to the current program values when it passes control to the specified transient program. Otherwise, these parameters are set to the default CCP values. Note that Function 108, Get/Set Program Return Code, can be used to pass a two byte value to the chained program.</p>
<p>Function 47 does not return any values to the calling program and any encountered errors are handled by the CCP.</p>
<p>BDOS function 48: <strong>FLUSH BUFFERS</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $30</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Error Flag</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>E: Purge Flag</p>
<p>The Flush Buffers function forces the write of any write-pending records contained in internal blocking/deblocking buffers. If register E is set to $FF, this function also purges all active data buffers. Programs that provide write with read verify support need to purge internal buffers to ensure that verifying reads actually access the disk instead of returning data that is resident in internal data buffers. The CP/M 3 PIP utility is an example of such a program.</p>
<p>Upon return, register A is set to zero if the flush operation is successful. If a physical error is encountered, the Flush Buffers function performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is in the default mode,, a message identifying the error is displayed at the console and the calling program is terminated. Otherwise, the Flush Buffers function returns to the calling program with register A set to $FF and register H set to the following physical error code:</p>
<ul>
<li><p>0 1 Disk I/O error</p></li>
<li><p>02 Read/only disk</p></li>
<li><p>04 Invalid drive error</p></li>
</ul>
<p>BDOS function 49: <strong>GET/SET SYSTEM CONTROL BLOCK</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $31</p></li>
<li><p>DE: SCB PB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Returned Byte</p></li>
<li><p>HL: Returned Word</p></li>
</ul>
<p>Function 49 allows access to parameters located in the CP/M 3 System Control Block (SCB). The SCB is a 100-byte data structure residing within the BDOS that contains flags and data used by the BDOS, CCP and other system components. Note that Function 49 is a CP/M 3 specific function. Programs intended for both MP/M 11 and CP/M 3 should either avoid the use of this function or isolate calls to this function in CP/M 3 version-dependent sections.</p>
<p>To use Function 49, the calling program passes the address of a data structure called the SCB parameter block in register pair DE. This data structure identifies the byte or word of the SCB to be updated or returned. The SCB parameter block is defined as:</p>
<pre><code>SCBPB: DB OFFSET ; Offset within SCB
       DB SET ; 0FFH if setting a byte
       ; 0FEH if setting a word
       ; 001H - 0FDH are reserved
       ; 000H if a get operation
       DW VALUE ; Byte or word value to be set</code></pre>
<p>The OFFSET parameter identifies the offset of the field within the SCB to be updated or accessed. The SET parameter determines whether Function 49 is to set a byte or word value in the SCB or if it is to return a byte from the SCB. The VALUE parameter is used only in set calls. In addition, only the first byte of VALUE is referenced in set byte calls.</p>
<p>Use caution when you set SCB fields. Some of these parameters reflect the current state of the operating system. If they are set to invalid values, software errors can result. In general, do not use Function 49 to set a system parameter if another BDOS function can achieve the same result. For example, Function 49 can be called to update the Current DMA Address field within the SCB. This is not equivalent to making a Function 26, Set DMA Address call, and updating the SCB Current DMA field in this way would result in system errors. However, you can use Function 49 to return the Current DMA address. The System Control Block is summarized in <a href="#table:91" data-reference-type="ref" data-reference="table:91">[table:91]</a>.</p>
<p>If Function 49 is called with the OFFSET parameter of the SCB parameter block greater than $63, the function performs no action but returns with registers A and HL set to zero.</p>
<p>BDOS function 50: <strong>DIRECT BIOS CALLS</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $32</p></li>
<li><p>DE: BIOS PB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>BIOS RETURN</p></li>
</ul>
<p>Function 50 provides a direct BIOS call through the BDOS to the BIOS. The calling program passes the address of a data structure called the BIOS Parameter Block (BIOSPB) in register pair DE. The BIOSPB contains the BIOS function number and register contents as shown below:</p>
<pre><code>BIOSPB: db FUNC ; BIOS function no.
        db AREG ; A register contents
        dw BCREG ; BC register contents
        dw DEREG ; DE register contents
        dw HLREG ; HL register contents</code></pre>
<p>System Reset (Function 0) is equivalent to Function 50 with a BIOS function number of 1.</p>
<p>Note that the register pair BIOSPB fields (BCREG, DEREG, HLREG) arc defined in low byte, high byte order. For example, in the BCREG field, the first byte contains the C register value, the second byte contains the B register value. Under CP/M 3, direct BIOS calls via the BIOS jump vector are only supported for the BIOS Console I/O and List functions. You must use Function 50 to call any other</p>
<p>BIOS functions. In addition, Function 50 intercepts BIOS Function 27 (Select Memory) calls and returns with register A set to zero. Refer to the CPIM Plus (CP/M Version 3) Operating System System Guide for the definition of the BIOS functions and their register passing and return conventions.</p>
<p>BDOS function 59: <strong>LOAD OVERLAY</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $3B</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Error Code</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>Only transient programs with an RSX header can use the Load Overlay function because BDOS Function 59 is supported by the LOADER module. The calling program must have a header to force the LOADER to remain resident after the program is loaded (see Section 1.3).</p>
<p>Function 59 loads either an absolute or relocatable module. Relocatable modules are identified by a filetype of PRL. Function 59 does not call the loaded module.</p>
<p>The referenced FCB must be successfully opened before Function 59 is called. The load address is specified in the first two random record bytes of the FCB, rO and rl. The LOADER returns an error if the load address is less than $100, or if performing the requested load operation would overlay the LOADER, or any other Resident System Extensions that have been previously loaded.</p>
<p>When loading relocatable files, the LOADER requires enough room at the load address for the complete PRL file including the header and bit map (see Appendix B). Otherwise an error is returned. Function 59 also returns an error on PRL file load requests if the specified load address is not on a page boundary.</p>
<p>Upon return, Function 59 sets register A to zero if the load operation is successful. If the LOADER RSX is not resident in memory because the calling program did not have a RSX header, the BDOS returns with register A set to $FF and register H set to zero. If the LOADER detects an invalid load address, or if insufficient memory is available to load the overlay, Function 59 returns with register A set to $FE. All other error returns are consistent with the error codes returned by BDOS Function 20, Read Sequential.</p>
<p>BDOS function 60: <strong>CALL RESIDENT SYSTEM EXTENSION</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $3C</p></li>
<li><p>DE: RSX PB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Error Code</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>Function 60 is a special BDOS function that you use when you call Resident System Extensions. The RSX subfunction is specified in a structure called the RSX Parameter Block, defined as follows:</p>
<pre><code>RSXPB: db FUNC ; RSX Function number
       db NUMPARMS ; Number of word Parameters
       dw PARMETER1 ; Parameter I
       dw PARMETER2 ; Parameter 2
       . . .
       dw PARMETERN ; Parameter n</code></pre>
<p>RSX modules filter all BDOS calls and capture RSX function calls that they can handle. If there is no RSX module present in memory that can handle a specific RSX function call, the call is not trapped, and the BDOS returns $FF in registers A and L. RSX function numbers from 0 to 127 are available for CP/M 3 compatible software use. RSX function numbers 128 to 255 are reserved for system use.</p>
<p>BDOS function 98: <strong>FREE BLOCKS</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $62</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Error Flag</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>The Free Blocks function scans all the currently logged-in drives, and for each drive returns to free space all temporarily-allocated data blocks. A temporarily-allocated data block is a block that has been allocated to a file by a BDOS write operation but has not been permanently recorded in the directory by a BDOS close operation. The CCP calls Function 98 when it receives control following a system warm start. Be sure to close your file, particularly any file you have written to, prior to calling Function 98.</p>
<p>In the nonbanked version of CP/M 3, Function 98 frees only temporarily allocated blocks for systems that request double allocation vectors in GENCPM.</p>
<p>Upon return, register A is set to zero if Function 98 is successful. If a physical error is encountered, the Free Blocks function performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is in the default mode, a message identifying the error is displayed at the console and the calling program is terminated. Otherwise, the Free Blocks function returns to the calling program with register A set to $FF and register H set to the following physical error code:</p>
<ul>
<li><p>04 : Invalid drive error</p></li>
</ul>
<p>BDOS function 99: <strong>TRUNCATE FILE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $63</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Directory Code</p></li>
<li><p>H: Extended or Physical Error</p></li>
</ul>
<p>The Truncate File function sets the last record of a file to the random record number contained in the referenced FCB. The calling program passes the address of the FCB in register pair DE, with byte 0 of the FCB specifying the drive, bytes 1 through 11 specifying the filename and filetype, and bytes 33 through 35, rO, rl, and r2, specifying the last record number of the file. The last record number is a 24 bit value, stored with the least significant byte first, rO, the middle byte next, rl, and the high byte last, r2. This value can range from 0 to 262,143, which corresponds to a maximum value of 3 in byte r2.</p>
<p>If the file specified by the referenced FCB is password protected, the correct password must be placed in the first eight bytes of the current DMA buffer, or have been previously established as the default password (see Function 106).</p>
<p>Function 99 requires that the file specified by the FCB not be open, particularly if the file has been written to. In addition, any activated FCBs naming the file are not valid after Function 99 is called. Close your file before calling Function 99, and then reopen it after the call to continue processing on the file.</p>
<p>Function 99 also requires that the random record number field of the referenced FCB specify a value less than the current file size. In addition, if the file is sparse, the random record field must specify a record in a region of the file where data exists.</p>
<p>Upon return, the Truncate function returns a Directory Code in register A with the value 0 if the Truncate function is successful, or $FF, 255 decimal, if the file is not found or the record number is invalid. Register H is set to zero in both of these cases. If a physical or extended error is encountered, the Truncate function performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is in the default mode, a message identifying the error is displayed at the console and the program is terminated. Otherwise, the Truncate function returns to the calling program with register A set to $FF and register H set to one of the following physical or extended error codes:</p>
<ul>
<li><p>01 Disk I/O error</p></li>
<li><p>02 Read-Only disk</p></li>
<li><p>03 Read-Only file</p></li>
<li><p>04 Invalid drive error</p></li>
<li><p>07 File password error</p></li>
<li><p>09 ? in filename or filetype field</p></li>
</ul>
<p>BDOS function 100: <strong>SET DIRECTORY LABEL</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $64</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Directory Code</p></li>
<li><p>H: Physical or Extended Error</p></li>
</ul>
<p>The Set Directory Label function creates a directory label, or updates the existing directory label for the specified drive. The calling program passes in register pair DE the address of an FCB containing the name, type, and extent fields to be assigned to the directory label. The name and type fields of the referenced FCB are not used to locate the directory label in the directory; they are simply copied into the updated or created directory label. The extent field of the FCB, byte 12, contains the user’s specificat-on of the directory label data byte. The definition of the directory label data byte is:</p>
<ul>
<li><p>7 - Require passwords for password-protected files (Not supported in nonbanked CP/M 3 systems)</p></li>
<li><p>6 - Perform access date and time stamping</p></li>
<li><p>5 - Perform update date and time stamping</p></li>
<li><p>4 - Perform create date and time stamping</p></li>
<li><p>0 - Assign a new password to the directory label</p></li>
</ul>
<p>If the current directory label is password protected, the correct password must be placed in the first eight bytes of the current DMA, or have been previously established as the default password (see Function 106). If bit 0, the low-order bit, of byte 12 of the FCB is set to 1, it indicates that a new password for the directory label has been placed in the second eight bytes of the current DMA.</p>
<p>Note that Function 100 is implemented as an RSX, DIRLBL.RSX, in nonbanked CP/M 3 systems. If Function 100 is called in nonbanked systems when the DIRLBL.RSX is not resident an error code of $0FF is returned.</p>
<p>Function 100 also requires that the referenced directory contain SFCBs to activate date and time stamping on the drive. If an attempt is made to activate date and time stamping when no SFCBs exist, Function 100 returns an error code of $FF in register A and performs no action. The CP/M 3 INITDIR utility initializes a directory for date and time stamping by placing an SFCB record in every fourth entry of the directory.</p>
<p>Function 100 returns a Directory Code in register A with the value 0 if the directory label create or update is successful, or $FF, 255 decimal, if no space exists in the referenced directory to create a directory label, or if date and time stamping was requested and the referenced directory did not contain SFCBS. Register H is set to zero in both of these cases. If a physical error or extended error is encountered, Function 100 performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is the default mode, a message identifying the error is displayed at the console and the calling program is terminated. Otherwise, Function 100 returns to the calling program with register A set to $FF and register H set to one of the following physical or extended error codes:</p>
<ul>
<li><p>01 Disk I/O error</p></li>
<li><p>02 Read-Only disk</p></li>
<li><p>04 Invalid drive error</p></li>
<li><p>07 File password error</p></li>
</ul>
<p>BDOS function 101: <strong>RETURN DIRECTORY LABEL DATA</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $65</p></li>
<li><p>E: Drive</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Directory Label Data Byte</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>The Return Directory Label Data function returns the data byte of the directory label for the specified drive. The calling program passes the drive number in register E with 0 for drive A, 1 for drive B, and so on through 15 for drive P in a full sixteen drive system. The format of the directory label data byte is shown below:</p>
<ul>
<li><p>7 - Require passwords for password protected files</p></li>
<li><p>6 - Perform access date and time stamping</p></li>
<li><p>5 - Perform update date and time stamping</p></li>
<li><p>4 - Perform create date and time stamping</p></li>
<li><p>0 - Directory label exists on drive</p></li>
</ul>
<p>Function 101 returns the directory label data byte to the calling program in register A. Register A equal to zero indicates that no directory label exists on the specified drive. If a physical error is encountered by Function 101 when the BDOS Error mode is in one of the return modes (see Function 45), this function returns with register A set to $FF, 25S decimal, and register H set to one of the following:</p>
<ul>
<li><p>01 Disk I/O error</p></li>
<li><p>04 Invalid drive error</p></li>
</ul>
<p>BDOS function 102: <strong>READ FILE DATE STAMPS AND PASSWORD MODE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $66</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Directory Code</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>Function 102 returns the date and time stamp information and password mode for the specified file in byte 12 and bytes 24 through 32 of the specified FCB. The calling program passes in register pair DE, the address of an FCB in which the drive, filename, and filetype fields have been defined.</p>
<p>If Function 102 is successful, it sets the following fields in the referenced FCB:</p>
<ul>
<li><p>byte 12 : Password mode field</p>
<ul>
<li><p>7 - Read mode</p></li>
<li><p>6 - Write mode</p></li>
<li><p>4 - Delete mode</p></li>
</ul></li>
</ul>
<p>Byte 12 equal to zero indicates the file has not been assigned a password. In nonbanked systems, byte 12 is always set to zero.</p>
<ul>
<li><p>byte 24 - 27 Create or Access time stamp field</p></li>
<li><p>byte 28 - 31 Update time stamp field</p></li>
</ul>
<p>The date stamp fields are set to binary zeros if a stamp has not been made. The format of the time stamp fields is the same as the format of the date and time structure described in Function 104.</p>
<p>Upon return, Function 102 returns a Directory Code in register A with the value zero if the function is successful, or $FF, 255 decimal, if the specified file is not found. Register H is set to zero in both of these cases. If a physical or extended error is encountered, Function 102 performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is in the default mode, a message identifying the error is displayed at the console and the calling program is terminated. Otherwise, Function 102 returns to the calling program with register A set to $FF and register H set to one of the following physical or extended error codes:</p>
<ul>
<li><p>01 Disk I/O error</p></li>
<li><p>04 Invalid drive error</p></li>
<li><p>09 ? in filename or filetype field</p></li>
</ul>
<p>BDOS function 103: <strong>WRITE FILE XFCB</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $67</p></li>
<li><p>DE: FCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Directory Code</p></li>
<li><p>H: Physical Error</p></li>
</ul>
<p>The Write File XFCB function creates a new XFCB or updates the existing XFCB for the specified file. The calling program passes in register pair DE the address of an FCB in which the drive, name, type, and extent fields have been defined. The extent field specifies the password mode and whether a new password is to be assigned to the file. The format of the extent byte is shown below:</p>
<p>FCB byte 12 (ex) : XFCB password mode</p>
<ul>
<li><p>7 - Read mode</p></li>
<li><p>6 - Write mode</p></li>
<li><p>5 - Delete mode</p></li>
<li><p>0 - Assign new password to the file</p></li>
</ul>
<p>If the specified file is currently password protected, the correct password must reside in the first eight bytes of the current DMA, or have been previously established as the default password (see Function 106). If bit 0 is set to 1, the new password must reside in the second eight bytes of the current DMA.</p>
<p>Upon return, Function 103 returns a Directory Code in register A with the value zero if the XFCB create or update is successful, or $FF, 255 decimal, if no directory label exists on the specified drive, or the file named in the FCB is not found, or no space exists in the directory to create an XFCB. Function 103 also returns with $FF in register A if passwords are not enabled by the referenced directory’s label. On nonbanked systems, this function always returns with register A = $FF because passwords are not supported. Register H is set to zero in all of these cases. If a physical or extended error is encountered, Function 103 performs different actions depending on the BDOS error mode (see Function 45). If the BDOS error mode is the default mode, a message identifying the error is displayed at the console and the calling program is terminated. Otherwise, Function 103 returns to the calling program with register A set to $FF and register H set to one of the following physical or extended error codes:</p>
<ul>
<li><p>01 Disk I/O error</p></li>
<li><p>02 Read-Only disk</p></li>
<li><p>04 Invalid drive error</p></li>
<li><p>07 File password error</p></li>
<li><p>09 ? in filename or filetype field</p></li>
</ul>
<p>BDOS function 104: <strong>SET DATE AND TIME</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $68</p></li>
<li><p>DE: DAT Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>none</p></li>
</ul>
<p>The Set Date and Time function sets the system internal date and time. The calling program passes the address of a 4-byte structure containing the date and time specification in the register pair DE. The format of the date and time (DAT) data structure is:</p>
<ul>
<li><p>0 - 1 Date field</p></li>
<li><p>2 Hour field</p></li>
<li><p>3 Minute field</p></li>
</ul>
<p>The date is represented as a 16-bit integer with day 1 corresponding to January 1, 1978. The time is represented as two bytes: hours and minutes are stored as two BCD digits.</p>
<p>This function also sets the seconds field of the system date and time to zero.</p>
<p>BDOS function 105: <strong>GET DATE AND TIME</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $69</p></li>
<li><p>DE: DAT Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: seconds</p></li>
<li><p>DAT set</p></li>
</ul>
<p>The Get Date and Time function obtains the system internal date and time. The calling program passes in register pair DE, the address of a 4-byte data structure which receives the date and time values. The format of the date and time, DAT, data structure is the same as the format described in Function 104. Function 105 also returns the seconds field of the system date and time in register A as a two digit BCD value.</p>
<p>BDOS function 106: <strong>SET DEFAULT PASSWORD</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $6A</p></li>
<li><p>DE: Password Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>none</p></li>
</ul>
<p>The Set Default Password function allows a program to specify a password value before a file protected by the password is accessed. When the file system accesses a password-protected file, it checks the current DMA, and the default password for the correct value. If either value matches the file’s password, full access to the file is allowed. Note that this function performs no action in nonbanked CP/M 3 systems because file passwords are not supported.</p>
<p>To make a Function 106 call, the calling program sets register pair DE to the address of an 8-byte field containing the password.</p>
<p>BDOS function 107: <strong>RETURN SERIAL NUMBER</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $6B</p></li>
<li><p>DE: Serial Number Field</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>Serial number field set</p></li>
</ul>
<p>Function 107 returns the CP/M 3 serial number to the 6-byte field addressed by register pair DE.</p>
<p>BDOS function 108: <strong>GET/SET PROGRAM RETURN CODE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $6C</p></li>
<li><p>DE: $0FFFF (Get) or Program Return Code (Set)</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>HL: Program Return Code or (no value)</p></li>
</ul>
<p>CP/M 3 allows programs to set a return code before terminating. This provides a mechanism for programs to pass an error code or value to a following job step in batch environments. For example, Program Return Codes are used by the CCP in CP/M 3’s conditional command line batch facility. Conditional command lines are command lines that begin with a colon, :. The execution of a conditional command depends on the successful execution of the preceding command. The CCP tests the return code of a terminating program to determine whether it successfully completed or terminated in error. Program return codes can also be used by programs to pass an error code or value to a chained program (see Function 47, Chain To Program).</p>
<p>A program can set or interrogate the Program Return Code by calling Function 108. If re ’ster pair DE = $FFFF, then the current Program Return Code is returned in register pair HL. Otherwise, Function 108 sets the Program Return Code to the ’value contained in register pair DE. Program Return Codes are defined in <a href="#table:92" data-reference-type="ref" data-reference="table:92">[table:92]</a></p>
<p>BDOS function 109: <strong>GET/SET CONSOLE MODE</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $6D</p></li>
<li><p>DE: $FFFF (Get) or Console Mode (Set)</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>HL: Console Mode or (no value)</p></li>
</ul>
<p>A program can set or interrogate the Console Mode by calling Function 109. If register pair DE = $FFFF, then the current Console Mode is returned in register HL. Otherwise, Function 109 sets the Console Mode to the value contained in register pair DE.</p>
<p>The Console Mode is a 16-bit system parameter that determines the action of certain BDOS Console I/O functions. The definition of the Console Mode is:</p>
<ul>
<li><p>= 1 - CTRL-C only status for Function 1 1.<br />
= 0 - Normal status for Function 1 1.</p></li>
<li><p>= 1- Disable stop scroll, CTRL-S, start scroll, CTRL-Q, support.<br />
= 0-Enable stop scroll, start scroll support.</p></li>
<li><p>= 1- Raw console output mode. Disables tab expansion for Functions 2, 9 and 111. Also disables printer echo, CTIRL-P, support.<br />
= 0 - Normal console output mode.</p></li>
<li><p>= 1 - Disable CTRL-C program termination<br />
= 0 - Enable CTRL-C program termination</p></li>
<li><p>-Console status mode for RSXs that perform console input redirection from a file. These bits determine how the RSX responds to console status requests.</p>
<ul>
<li><p>bit 8 = 0, bit 9 = 0 - conditional status</p></li>
<li><p>bit 8 = 0, bit 9 = 1 - false status</p></li>
<li><p>bit 8 = 1, bit 9 = 0 - true status</p></li>
<li><p>bit 8 = 1, bit 9 = 1 - bypass redirection</p></li>
</ul></li>
</ul>
<p>Note that the Console Mode bits are numbered from right to left.</p>
<p>The CCP initializes the Console Mode to zero when it loads a program unless the program has an RSX that overrides the default value. Refer to Section 2.2.1 for detailed information on Console Mode.</p>
<p>BDOS function 110: <strong>GET/SET OUTPUT DELIMITER</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $6E</p></li>
<li><p>DE: $FFFF (Get) or</p></li>
<li><p>E: Output Delimiter (Set)</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>A: Output Delimiter or (no value)</p></li>
</ul>
<p>A program can set or interrogate the current Output Delimiter by calling Function 110. If register pair DE = $FFFF, then the current Output Delimiter is returned in register A. Otherwise, Function 110 sets the Output Delimiter to the value contained in register E.</p>
<p>Function 110 sets the string delimiter for Function 9, Print String. The default delimiter value is a dollar sign, $. The CCP restores the Output Delimiter to the default value when a transient program is loaded.</p>
<p>BDOS function 111: <strong>PRINT BLOCK</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $6F</p></li>
<li><p>DE: CCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>none</p></li>
</ul>
<p>The Print Block function sends the character string located by the Character Control Block, CCB, addressed in register pair DE, to the logical console, CONOUT:. If the Console Mode is in the default state (see Section 2.2.1), Function 111 expands tab characters, CTRL-I, in columns of eight characters. It also checks for stop scroll, CTRL-S, start scroll, CTRL-Q, and echoes to the logical list device, LST:, if printer echo, CTRL-P, has been invoked.</p>
<p>The CCB format is:</p>
<ul>
<li><p>0 - 1 Address of character string (word value)</p></li>
<li><p>2 - 3 Length of character string (word value)</p></li>
</ul>
<p>BDOS function 112: <strong>LIST BLOCK</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $70</p></li>
<li><p>DE: CCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>none</p></li>
</ul>
<p>The List Block function sends the character string located by the Character Control Block, CCB, addressed in register pair DE, to the logical list device, LST:.</p>
<p>The CCB format is:</p>
<ul>
<li><p>0 - 1 Address of character string (word value)</p></li>
<li><p>2 - 3 Length of character string (word value)</p></li>
</ul>
<p>BDOS function 152: <strong>PARSE FILENAME</strong></p>
<p>Entry Parameters:</p>
<ul>
<li><p>C: $98</p></li>
<li><p>DE: PFCB Address</p></li>
</ul>
<p>Returned Value:</p>
<ul>
<li><p>HL: Return code</p></li>
<li><p>Parsed file control block</p></li>
</ul>
<p>The Parse Filename function parses an ASCII file specification and prepares a File Control Block, FCB. The calling program passes the address of a data structure called the Parse Filename Control Block, PFCB, in register pair DE. The PFCB contains the address of the input ASCII filename string followed by the address of the target FCB as shown below:</p>
<pre><code> PFCB: DW INPUT ; Address of input ASCII string
       DW FCB ; Address of target FCB</code></pre>
<p>The maximum length of the input ASCII string to be parsed is 128 bytes. The target FCB must be 36 bytes in length.</p>
<p>Function 152 assumes the input string contains file specifications in the following form:</p>
<p>{d:}filename{.typ}{;password}</p>
<p>where items enclosed in curly brackets are optional. Function 152 also accepts isolated drive specifications d: in the input string. When it encounters one, it sets the filename, filetype, and password fields in the FCB to blank.</p>
<p>The Parse Filename function parses the first file specification it finds in the input string. The function first eliminates leading blanks and tabs. The function then assumes that the file specification ends on the first delimiter it encounters that is out of context with the specific field it is parsing. For instance, if it finds a colon, and it is not the second character of the file specification, the colon delimits the entire file specification.</p>
<p>Function 152 recognizes the following characters as detimiters:</p>
<ul>
<li><p>space</p></li>
<li><p>tab</p></li>
<li><p>return</p></li>
<li><p>nut]</p></li>
<li><p>; (semicolon) - except before password field</p></li>
<li><p>= (equal)</p></li>
<li><p><span class="math inline">&lt;</span> (less than)</p></li>
<li><p><span class="math inline">&gt;</span> (greater than)</p></li>
<li><p>. (period) - except after filename and before filetype</p></li>
<li><p>: (colon) - except before filename and after drive</p></li>
<li><p>, (comma)</p></li>
<li><p><span class="math inline">|</span> (vertical bar)</p></li>
<li><p>] (right square bracket)</p></li>
</ul>
<p>If Function 152 encounters a non-graphic character in the range 1 through 31 not listed above, it treats the character as an error. The Parse Filename function initializes the specified FCB shown in <a href="#table:93" data-reference-type="ref" data-reference="table:93">[table:93]</a>.</p>
<p>If an error occurs, Function 152 returns an $FFFF in register pair HL.</p>
<p>On a successful parse, the Parse Filename function checks the next item in the input string. It skips over trailing blanks and tabs and looks at the next character. If the character is a null or carriage return, it returns a 0 indicating the end of the input string. If the character is a delimiter, it returns the address of the delimiter. If the character is not a delimiter, it returns the address of the first trailing blank or tab.</p>
<p>If the first non-blank or non-tab character in the input string is a null, 0, or carriage return, the Parse Filename function returns a zero indicating the end of string.</p>
<p>If the Parse Filename function is to be used to parse a subsequent file specification in the input string, the returned address must be advanced over the delimiter before placing it in the PFCB.</p>
<h3 id="bios">BIOS</h3>
<h4 id="system-initialization-functions">System Initialization Functions</h4>
<p>This section defines the BIOS system initialization routines BOOT, WBOOT, DEVTBL, DEVINI, and DRVTBL.</p>
<p>BIOS Function 0: BOOT</p>
<p>Get Control from Cold Start Loader and Initialize System<br />
Entry Parameters: None<br />
Returned Values: None</p>
<p>The BOOT entry point gets control from the Cold Start Loader in Bank 0 and is responsible for basic system initialization. Any remaining hardware initialization that is not done by the boot ROMS, the Cold Boot Loader, or the LDRBIOS should be performed by the BOOT routine.</p>
<p>BIOS Function 1: WBOOT</p>
<p>Get Control When a Warm Start Occurs<br />
Entry Parameters: None<br />
Returned Values: None</p>
<p>The WBOOT entry point is entered when a warm start occurs. A warm start is performed whenever a user program branches to location 0000H or attempts to return to the CCP.</p>
<p>BIOS Function 20: DEVTBL</p>
<p>Return Address of Character I/O Table<br />
Entry Parameters: None<br />
Returned Values: HL=address of Chrtbl</p>
<p>The DEVTBL and DEVINI entry points allow you to support device assignment with a flexible, yet completely optional system. It replaces the IOBYTE facility of CP/M 2.2.</p>
<p>BIOS Function 21: DEVINI</p>
<p>Initialize Character I/O Device<br />
Entry Parameters: C=device number, 0-15<br />
Returned Values: None</p>
<p>The DEVINI routine initializes the physical character device specified in register C to the baud rate contained in the appropriate entry of the CHRTBL.</p>
<p>BIOS Function 22: DRVTBL</p>
<p>Return Address of Disk Drive Table<br />
Entry Parameters: None<br />
Returned Values:</p>
<ul>
<li><p>HL=Address of Drive Table of Disk Parameter Headers (DPH); Hashing can utilized if specified by the DPHs Referenced by this DRVTBL.</p></li>
<li><p>HL=$ffff if no Drive Table; GENCPM does not set up buffers. Hashing is supported.</p></li>
<li><p>HL=$fffe if no Drive Table; GENCPM does not set up buffers. Hashing is not supported.</p></li>
</ul>
<p>The first instruction of this subroutine must be an LXI H,&lt;address&gt; where &lt;address&gt; is one of the above returned values. The GENCPM utility accesses the address in this instruction to locate the drive table and the disk parameter data structures to determine which system configuration to use.</p>
<h4 id="character-io-functions">Character I/O Functions</h4>
<p>This section defines the CP/M 3 character I/O routines CONST, CONIN, CONOUT, LIST, AUXOUT, AUXIN, LISTST, CONOST, AUXIST, and AUXOST. CP/M 3 assumes all simple character I/O operations are performed in eight-bit ASCII, upper and lowercase, with no parity. An ASCII CTRL-Z ($1a) denotes an end-of-file condition for an input device.</p>
<p>In CP/M 3, you can direct each of the five logical character devices to any combination of up to twelve physical devices. Each of the five logical devices has a 16-bit vector in the System Control Block (SCB) . Each bit of the vector represents a physical device where bit 15 corresponds to device zero, and bit 4 is device eleven. Bits 0 through 3 are reserved for future system use.</p>
<p>BIOS Function 2: CONST</p>
<p>Sample the Status of the Console Input Device<br />
Entry Parameters: None<br />
Returned value:</p>
<ul>
<li><p>A=$ff if a console character is ready to read</p></li>
<li><p>A=$00 if no console character is ready to read</p></li>
</ul>
<p>Read the status of the currently assigned console device and return $ff in register A if a character is ready to read, and $ff in register A if no console characters are ready.</p>
<p>BIOS Function 3: CONIN</p>
<p>Read a Character from the Console<br />
Entry Parameters: None<br />
Returned Values: A=Console Character</p>
<p>Read the next console character into register A with no parity. If no console character is ready, wait until a character is available before returning.</p>
<p>BIOS Function 4: CONOUT</p>
<p>Output Character to Console<br />
Entry Parameters: C=Console Character<br />
Returned Values: None</p>
<p>Send the character in register C to the console output device. The character is in ASCII with no parity.</p>
<p>BIOS Function 5: LIST</p>
<p>Output Character to List Device<br />
Entry Parameters: C=Character<br />
Returned Values: None</p>
<p>Send the character from register C to the listing device. The character is in ASCII with no parity.</p>
<p>BIOS Function 6: AUXOUT</p>
<p>Output a Character to the Auxiliary Output Device<br />
Entry Parameters: C=Character<br />
Returned Values: None</p>
<p>Send the character from register C to the currently assigned AUXOUT device. The character is in ASCII with no parity.</p>
<p>BIOS Function 7: AUXIN</p>
<p>Read a Character from the Auxiliary Input Device<br />
Entry Parameters: None<br />
Returned Values: A=Character</p>
<p>Read the next character from the currently assigned AUXIN device into register A with no parity. A returned ASCII CTRL-Z ($1a) reports an end-of-file.</p>
<p>BIOS Function 15: LISTST</p>
<p>Return the Ready Status of the List Device<br />
Entry Parameters: None<br />
Returned Values:</p>
<ul>
<li><p>A=$00 if list device is not ready to accept a character</p></li>
<li><p>A=$ff if list device is ready to accept a character</p></li>
</ul>
<p>BIOS Function 17: CONOST</p>
<p>Return Output Status of Console<br />
Entry Parameters: None<br />
Returned Values:</p>
<ul>
<li><p>A=$ff if ready</p></li>
<li><p>A=$00 if not ready</p></li>
</ul>
<p>The CONOST routine checks the status of the console. CONOST returns an $ff if the console is ready to display another character. This entry point allows for full polled handshaking communications support.</p>
<p>BIOS Function 18: AUXIST</p>
<p>Return Input Status of Auxiliary Port<br />
Entry Parameters: None<br />
Returned Values:</p>
<ul>
<li><p>A=$ff if ready</p></li>
<li><p>A=$00 if not ready</p></li>
</ul>
<p>The AUXIST routine checks the input status of the auxiliary port. This entry point allows full polled handshaking for communications support using an auxiliary port.</p>
<p>BIOS Function 19: AUXOST</p>
<p>Return Output Status of Auxiliary Port<br />
Entry Parameters: None<br />
Returned Values:</p>
<ul>
<li><p>A=$ff if ready</p></li>
<li><p>A=$00 if not ready</p></li>
</ul>
<p>The AUXOST routine checks the output status of the auxiliary port. This routine allows full polled handshaking for communications support using an auxiliary port.</p>
<h4 id="disk-io-functions">Disk I/O Functions</h4>
<p>This section defines the CP/M 3 BIOS disk I/O routines HOME, SELDSK, SETTRK, SETSEC, SETDMA, READ, WRITE, SECTRN, MULTIO, and FLUSH.</p>
<p>BIOS Function 8: HOME</p>
<p>Select Track 00 of the Specified Drive<br />
Entry Parameters: None<br />
Returned Values: None</p>
<p>Return the disk head of the currently selected disk to the track 00 position. Usually, you can translate the HOME call into a call on SETTRK with a parameter of 0.</p>
<p>BIOS Function 9: SELDSK</p>
<p>Select the Specified Disk Drive<br />
Entry Parameters:</p>
<ul>
<li><p>C=Disk Drive (0-15)</p></li>
<li><p>E=Initial Select Flag</p></li>
</ul>
<p>Returned Values:</p>
<ul>
<li><p>HL=Address of Disk Parameter Header (DPH) if drive exists</p></li>
<li><p>HL=0000H if drive does not exist</p></li>
</ul>
<p>Select the disk drive specified in register C for further operations, where register C contains 0 for drive A, 1 for drive B, and so on to 15 for drive P. On each disk select, SELDSK must return in HL the base address of a 25-byte area called the Disk Parameter Header. If there is an attempt to select a nonexistent drive, SELDSK returns HL=$0000 as an error indicator. On entry to SELDSK, you can determine if it is the first time the specified disk is selected. Bit 0, the least significant bit in register E, is set to 0 if the drive has not been previously selected. This information is of interest in systems that read configuration information from the disk to set up a dynamic disk definition table.</p>
<p>BIOS Function 10: SETTRK</p>
<p>Set Specified Track Number<br />
Entry Parameters: BC=Track Number<br />
Returned Values: None</p>
<p>Register BC contains the track number for a subsequent disk access on the currently selected drive. Normally, the track number is saved until the next READ or WRITE occurs.</p>
<p>BIOS Function 11: SETSEC</p>
<p>Set Specified Sector Number<br />
Entry Parameters: BC=Sector Number<br />
Returned Values: None</p>
<p>Register BC contains the sector number for the subsequent disk access on the currently selected drive. This number is the value returned by SECTRN. Usually, you delay actual sector selection until a READ or WRITE operation occurs.</p>
<p>BIOS Function 12: SETDMA</p>
<p>Set Address for Subsequent Disk I/O<br />
Entry Parameters: BC=Direct Memory Access Address<br />
Returned Values: None</p>
<p>Register BC contains the DMA (Direct Memory Access) address for the subsequent READ or WRITE operation. For example, if B = $00 and C = $80 when the BDOS calls SETDMA, then the subsequent read operation reads its data starting at $80, or the subsequent write operation gets its data from 80H, until the next call to SETDMA occurs.</p>
<p>BIOS Function 13: READ</p>
<p>Read a Sector from the Specified Drive<br />
Entry Parameters: None<br />
Returned Values:</p>
<ul>
<li><p>A=$00 if no errors occurred</p></li>
<li><p>A=$01 if nonrecoverable error condition occurred</p></li>
<li><p>A=$ff if media has changed</p></li>
</ul>
<p>Assume the BDOS has selected the drive, set the track, set the sector, and specified the DMA address. The READ subroutine attempts to read one sector based upon these parameters, then returns one of the error codes in register A as described above.</p>
<p>If the value in register A is $00, then CP/M 3 assumes that the disk operation completed properly. If an error occurs, the BIOS should attempt several retries to see if the error is recoverable before returning the error code.</p>
<p>If an error occurs in a system that supports automatic density selection, the system should verify the density of the drive. If the density has changed, return a $ff in the accumulator. This causes the BDOS to terminate the current operation and relog in the disk.</p>
<p>BIOS Function 14: WRITE</p>
<p>Write a Sector to the Specified Disk<br />
Entry Parameters: C=Deblocking Codes<br />
Returned Values:</p>
<ul>
<li><p>A=$00 if no error occurred</p></li>
<li><p>A=$01 if physical error occurred</p></li>
<li><p>A=$02 if disk is Read-Only</p></li>
<li><p>A=$ff if media has changed</p></li>
</ul>
<p>Write the data from the currently selected DMA address to the currently selected drive, track, and sector. Upon each call to WRITE, the BDOS provides the following information in register C:</p>
<ul>
<li><p>0 = deferred write</p></li>
<li><p>1 = nondeferred write</p></li>
<li><p>2 = deferred write to the first sector of a new data block</p></li>
</ul>
<p>This information is provided for those BIOS implementations that do blocking/deblocking in the BIOS instead of the BDOS.</p>
<p>BIOS Function 16: SECTRN</p>
<p>Translate Sector Number Given Translate Table Entry Parameters:</p>
<ul>
<li><p>BC=Logical Sector Number</p></li>
<li><p>DE=Translate Table Address</p></li>
</ul>
<p>Returned Values: HL=Physical Sector Number</p>
<p>SECTRN performs logical sequential sector address to physical sector translation to improve the overall response of CP/M 3.</p>
<p>BIOS Function 23: MULTIO</p>
<p>Set Count of Consecutive Sectors for READ or WRITE<br />
Entry Parameters: C=Multisector Count<br />
Returned Values: None</p>
<p>To transfer logically consecutive disk sectors to or from contiguous memory locations, the BDOS issues a MULTIO call, followed by a series of READ or WRITE calls. This allows the BIOS to transfer multiple sectors in a single disk operation. The maximum value of the sector count is dependent on the physical sector size, ranging from 128 with 128-byte sectors, to 4 with 4096-byte sectors. Thus, the BIOS can transfer up to 16K directly to or from the TPA with a single operation.</p>
<p>BIOS Function 24: FLUSH</p>
<p>Force Physical Buffer Flushing for User-supported Deblocking<br />
Entry Parameters: None<br />
Returned Values:</p>
<ul>
<li><p>A=$00 if no error occurred</p></li>
<li><p>A=$001 if physical error occurred</p></li>
<li><p>A=$002 if disk is Read-Only</p></li>
</ul>
<p>The flush buffers entry point allows the system to force physical sector buffer flushing when your BIOS is performing its own record blocking and deblocking. The BDOS calls the FLUSH routine to ensure that no dirty buffers remain in memory.</p>
<h3 id="memory-select-and-move-functions">Memory Select and Move Functions</h3>
<p>This section defines the memory management functions MOVE, XMOVE, SELMEM, and SETBNK.</p>
<p>BIOS Function 25: MOVE</p>
<p>Memory-to-Memory Block Move<br />
Entry Parameters:</p>
<ul>
<li><p>HL=Destination address</p></li>
<li><p>DE=Source address</p></li>
<li><p>BC=Count</p></li>
</ul>
<p>Returned Values: HL and DE must point to next bytes following move operation</p>
<p>The BDOS calls the MOVE routine to perform memory to memory block moves to allow use of the Z80 LDIR instruction or special DMA hardware, if available. Note that the arguments in HL and DE are reversed from the Z8O machine instruction, necessitating the use of XCHG instructions on either side of the LDIR. The BDOS uses this routine for all large memory copy operations. On return, the HL and DE registers are expected to point to the next bytes following the move.</p>
<p>Usually, the BDOS expects MOVE to transfer data within the currently selected bank or common memory. However, if the BDOS calls the XMOVE entry point before calling MOVE, the MOVE routine must perform an interbank transfer.</p>
<p>BIOS Function 27: SELMEM</p>
<p>Select Memory Bank<br />
Entry Parameters: A=Memory Bank<br />
Returned Values; None</p>
<p>The SELMEM entry point is only present in banked systems. The banked version of the CP/M 3 BDOS calls SELMEM to select the current memory bank for further instruction execution or buffer references. You must preserve or restore all registers other than the accumulator, A, upon exit.</p>
<p>BIOS Function 28: SETBNK</p>
<p>Specify Bank for DMA Operation<br />
Entry Parameters: A=Memory Bank<br />
Returned Values: None</p>
<p>SETBNK only occurs in the banked version of CP/M 3. SETBNK specifies the bank that the subsequent disk READ or WRITE routine must use for memory transfers. The BDOS always makes a call to SETBNK to identify the DMA bank before performing a READ or WRITE call. Note that the BDOS does not reference banks other than 0 or 1 unless another bank is specified by the BANK field of a Data Buffer Control Block (BCB).</p>
<p>BIOS Function 29: XMOVE</p>
<p>Set Banks for Following MOVE<br />
Entry Parameters:</p>
<ul>
<li><p>B=destination bank</p></li>
<li><p>C=source bank</p></li>
</ul>
<p>Returned Values: None</p>
<p>XMOVE is provided for banked systems that support memory-to- memory DMA transfers over the entire extended address range. Systems with this feature can have their data buffers located in an alternate bank instead of in common memory, as is usually required. An XMOVE call affects only the following MOVE call. All subsequent MOVE calls apply to the memory selected by the latest call to SELMEM. After a call to the XMOVE function, the following call to the MOVE function is not more than 128 bytes of data.</p>
<h4 id="clock-support-function">Clock Support Function</h4>
<p>This section defines the clock support function TIME.</p>
<p>BIOS Function 26: TIME</p>
<p>Get and Set Time<br />
Entry Parameters: C=Time Get/Set Flag<br />
Returned values: None</p>
<p>The BDOS calls the TIME function to indicate to the BIOS whether it has just set the Time and Date fields in the SCB, or whether the BDOS is about to get the Time and Date from the SCB. On entry to the TIME function, a zero in register C indicates that the BIOS should update the Time and Date fields in the SCB. A $ff in register C indicates that the BDOS has just set the Time and Date in the SCB and the BIOS should update its clock. Upon exit, you must restore register pairs HL and DE to their entry values.</p>
<h2 id="nextzxos">NextZXOS</h2>
<h2 id="nextzxos-1">NextZXOS</h2>
<p>A ZX Spectrum I/O system supported by the ZX Spectrum Next. This Documentation is largely from Garry Lancaster’s DOCs at https://gitlab.com/thesmog358/tbblue/blob/master/docs/nextzxos/NextZXOS_and_esxDOS_APIs.pdf. Before making any calls disable writes to Layer 2 in the $0000-$3fff area with port $123b.</p>
<h3 id="dos-compatible-api">+3DOS compatible API</h3>
<p>Generally to make these calls, you need to set up: place ROM 2 at $0000-$3fff, RAM bank 7 at $c000-$ffff, stack below $bfe0, and set up the parameters for the call in the indicated registers. Call the function at its address. Then, restore your system to its previous configuration. In general the carry bit of F is cleared on error with the error code in A. Calls generally affect the contnts of AF, BC, DE, HL, and IX leaving AF’, BC’, DE’, HL’, IY, and SP intact. To simplify, descriptions will assume this is true and only indicate exceptions to the rule.</p>
<p>$0056 <strong>IDE_STREAM_OPEN</strong></p>
<p>Open stream to a channel</p>
<p>$0059 <strong>IDE_STREAM_CLOSE</strong></p>
<p>Close stream and attached channel</p>
<p>$005c <strong>IDE_STREAM_IN</strong></p>
<p>Get byte from current stream</p>
<p>$005f <strong>IDE_STREAM_OUT</strong></p>
<p>Write byte to current stream</p>
<p>$0062 <strong>IDE_STREAM_PTR</strong></p>
<p>Get or set pointer information for current stream</p>
<p>$00A0 <strong>IDE_VERSION</strong></p>
<p>Get IDEDOS version number</p>
<p>$00A3 <strong>IDE_INTERFACE</strong></p>
<p>Initialise card interfaces</p>
<p>$00A6 <strong>IDE_INIT</strong></p>
<p>Initialise IDEDOS</p>
<p>$00A9 <strong>IDE_DRIVE</strong></p>
<p>Get unit handle</p>
<p>$00AC <strong>IDE_SECTOR_READ</strong></p>
<p>Low-level sector read</p>
<p>$00AF <strong>IDE_SECTOR_WRITE</strong></p>
<p>Low-level sector write</p>
<p>$00B2 <strong>IDE_FORMAT</strong></p>
<p>Format a partition</p>
<p>$00B5 <strong>IDE_PARTITION_FIND</strong></p>
<p>Find named partition</p>
<p>$00B8 <strong>IDE_PARTITION_NEW</strong></p>
<p>Create partition</p>
<p>$00BB <strong>IDE_PARTITION_INIT</strong></p>
<p>Initialise partition</p>
<p>$00BE <strong>IDE_PARTITION_ERASE</strong></p>
<p>Delete a partition</p>
<p>$00C1 <strong>IDE_PARTITION_RENAME</strong></p>
<p>Rename a partition</p>
<p>$00C4 <strong>IDE_PARTITON_READ</strong></p>
<p>Read a partition entry</p>
<p>$00C7 <strong>IDE_PARTITION_WRITE</strong></p>
<p>Write a partition entry</p>
<p>$00CA <strong>IDE_PARTITION_WINFO</strong></p>
<p>Write type-specific partition information</p>
<p>$00CD <strong>IDE_PARTITION_OPEN</strong></p>
<p>Open a partition</p>
<p>$00D0 <strong>IDE_PARTITION_CLOSE</strong></p>
<p>Close a partition</p>
<p>$00D3 <strong>IDE_PARTITION_GETINFO</strong></p>
<p>Get byte from type-specific partition information</p>
<p>$00D6 <strong>IDE_PARTITION_SETINFO</strong></p>
<p>Set byte in type-specific partition information</p>
<p>$00D9 (217) <strong>IDE_SWAP_OPEN</strong></p>
<p>Open a swap partition (file)</p>
<p>$00DC <strong>IDE_SWAP_CLOSE</strong></p>
<p>Close a swap partition</p>
<p>$00DF <strong>IDE_SWAP_OUT</strong></p>
<p>Write block to swap partition</p>
<p>$00E2 <strong>IDE_SWAP_IN</strong></p>
<p>Read block from swap partition</p>
<p>$00E5 (231) <strong>IDE_SWAP_EX</strong></p>
<p>Exchange block with swap partition</p>
<p>Deprecated, use IDE_SWAP_IN and IDE_SWAP_OUT</p>
<p>$00E8 <strong>IDE_SWAP_POS</strong></p>
<p>Get current block number in swap partition</p>
<p>$00EB <strong>IDE_SWAP_MOVE</strong></p>
<p>Set current block number in swap partition</p>
<p>$00EE <strong>IDE_SWAP_RESIZE</strong></p>
<p>Change block size of swap partition</p>
<p>$00F1 (241) <strong>IDE_DOS_MAP</strong></p>
<p>Map drive to partition or physical device</p>
<p>$00F4 (244) <strong>IDE_DOS_UNMAP</strong></p>
<p>Unmap drive</p>
<p>$00F7 (247) <strong>IDE_DOS_MAPPING</strong></p>
<p>Get drive mapping</p>
<p>$00FA <strong>IDE_DOS_UNPERMANENT</strong></p>
<p>Remove permanent drive mapping</p>
<p>$00FD (253) <strong>IDE_SNAPLOAD</strong></p>
<p>Load a snapshot</p>
<p>$0100 <strong>DOS_INITIALISE</strong></p>
<p>Initialise +3DOS</p>
<p>$0103 <strong>DOS_VERSION</strong></p>
<p>Get +3DOS issue and version numbers</p>
<p>$0106 (262) <strong>DOS_OPEN</strong></p>
<p>Create and/or open a file</p>
<p>$0109 <strong>DOS_CLOSE</strong></p>
<p>Close a file</p>
<p>$010C <strong>DOS_ABANDON</strong></p>
<p>Abandon a file</p>
<p>$010F <strong>DOS_REF_HEAD</strong></p>
<p>Point at the header data for this file</p>
<p>$0112 <strong>DOS_READ</strong></p>
<p>Read bytes into memory</p>
<p>$0115 <strong>DOS_WRITE</strong></p>
<p>Write bytes from memory</p>
<p>$0118 <strong>DOS_BYTE_READ</strong></p>
<p>Read a byte</p>
<p>$011B <strong>DOS_BYTE_WRITE</strong></p>
<p>Write a byte</p>
<p>$011E (286) <strong>DOS_CATALOG</strong></p>
<p>Catalog disk directory</p>
<p>$0121 (289) <strong>DOS_FREE_SPACE</strong></p>
<p>Free space on disk</p>
<p>$0124 <strong>DOS_DELETE</strong></p>
<p>Delete a file</p>
<p>$0127 <strong>DOS_RENAME</strong></p>
<p>Rename a file</p>
<p>$012A <strong>DOS_BOOT</strong></p>
<p>Boot an operating system or other program</p>
<p>$012D <strong>DOS_SET_DRIVE</strong></p>
<p>Set/get default drive</p>
<p>$0130 <strong>DOS_SET_USER</strong></p>
<p>Set/get default user number</p>
<p>$0133 (307) <strong>DOS_GET_POSITION</strong></p>
<p>Get file pointer for random access</p>
<p>$0136 <strong>DOS_SET_POSITION</strong></p>
<p>Set file pointer for random access</p>
<p>$0139 (313) <strong>DOS_GET_EOF</strong></p>
<p>Get end of file position for random access</p>
<p>$013C <strong>DOS_GET_1346</strong></p>
<p>Get memory usage in pages 1  3  4  6</p>
<p>$013F <strong>DOS_SET_1346</strong></p>
<p>Re-allocate memory usage in pages 1  3  4  6</p>
<p>$0142 <strong>DOS_FLUSH</strong></p>
<p>Bring disk up to date</p>
<p>$0145 <strong>DOS_SET_ACCESS</strong></p>
<p>Change open file’s access mode</p>
<p>$0148 <strong>DOS_SET_ATTRIBUTES</strong></p>
<p>Change a file’s attributes</p>
<p>$014B <strong>DOS_OPEN_DRIVE</strong></p>
<p>Open a drive as a single file</p>
<p>$014E <strong>DOS_SET_MESSAGE</strong></p>
<p>Enable/disable error messages</p>
<p>$0151 <strong>DOS_REF_XDPB</strong></p>
<p>Point at XDPB for low level disk access</p>
<p>$0154 <strong>DOS_MAP_B</strong></p>
<p>Map B: onto unit 0 or 1</p>
<p>$0157 <strong>DD_INTERFACE</strong></p>
<p>Is the floppy disk driver interface present?</p>
<p>$015A <strong>DD_INIT</strong></p>
<p>Initialise disk driver</p>
<p>$015D <strong>DD_SETUP</strong></p>
<p>Specify drive parameters</p>
<p>$0160 <strong>DD_SET_RETRY</strong></p>
<p>Set try/retry count</p>
<p>$0163 <strong>DD_READ_SECTOR</strong></p>
<p>Read a sector</p>
<p>$0166 <strong>DD_WRITE_SECTOR</strong></p>
<p>Write a sector</p>
<p>$0169 <strong>DD_CHECK_SECTOR</strong></p>
<p>Check a sector</p>
<p>$016C <strong>DD_FORMAT</strong></p>
<p>Format a track</p>
<p>$016F <strong>DD_READ_ID</strong></p>
<p>Read a sector identifier</p>
<p>$0172 <strong>DD_TEST_UNSUITABLE</strong></p>
<p>Test media suitability</p>
<p>$0175 <strong>DD_LOGIN</strong></p>
<p>Log in disk, initialise XDPB</p>
<p>$0178 <strong>DD_SEL_FORMAT</strong></p>
<p>Pre-initialise XDPB for DD FORMAT</p>
<p>$017B <strong>DD_ASK_1</strong></p>
<p>Is unit 1 (external drive) present?</p>
<p>$017E <strong>DD_DRIVE_STATUS</strong></p>
<p>Fetch drive status</p>
<p>$0181 <strong>DD_EQUIPMENT</strong></p>
<p>What type of drive?</p>
<p>$0184 <strong>DD_ENCODE</strong></p>
<p>Set intercept routine for copy protection</p>
<p>$0187 <strong>DD_L_XDPB</strong></p>
<p>Initialise an XDPB from a disk specification</p>
<p>$018A <strong>DD_L_DPB</strong></p>
<p>Initialise a DPB from a disk specification</p>
<p>$018D <strong>DD_L_SEEK</strong></p>
<p>uPD765A seek driver</p>
<p>$0190 <strong>DD_L_READ</strong></p>
<p>uPD765A read driver</p>
<p>$0193 <strong>DD_L_WRITE</strong></p>
<p>uPD765A write driver</p>
<p>$0196 <strong>DD_L_ON_MOTOR</strong></p>
<p>Motor on, wait for motor-on time</p>
<p>$0199 <strong>DD_L_T_OFF_MOTOR</strong></p>
<p>Start the motor-off ticker</p>
<p>$019C <strong>DD_L_OFF_MOTOR</strong></p>
<p>Turn the motor off</p>
<p>$01a2 <strong>IDE_IDENTIFY</strong></p>
<p>Return IDE drive identity information</p>
<p>$01a5 <strong>IDE_PARTITIONS</strong></p>
<p>Get number of open partitions</p>
<p>$01b1 (433) <strong>IDE_PATH</strong></p>
<p>Create, delete, change or get directory</p>
<p>$01b4 (436) <strong>IDE_CAPACITY</strong></p>
<p>Get card capacity</p>
<p>$01b7 (439) <strong>IDE_GET_LFN</strong></p>
<p>Get long filename</p>
<p>Obtain a long file name and other file information.</p>
<p>$01ba (442) <strong>IDE_BROWSER</strong></p>
<p>File browser</p>
<p>$01bd (445) <strong>IDE_BANK</strong></p>
<p>Allocate or free 8K pages in ZX or DivMMC memory</p>
<p>$01c0 <strong>IDE_BASIC</strong></p>
<p>Execute a BASIC command line</p>
<p>$01c3 <strong>IDE_WINDOW_LINEIN</strong></p>
<p>Input line from current window stream</p>
<p>$01c6 <strong>IDE_WINDOW_STRING</strong></p>
<p>Output string to current window stream</p>
<p>$01c9 <strong>IDE_INTEGER_VAR</strong></p>
<p>Get or set NextBASIC integer variable</p>
<p>$01cc <strong>IDE_RTC</strong></p>
<p>Query the real-time-clock module</p>
<p>$01cf <strong>IDE_DRIVER</strong></p>
<p>Access the driver API</p>
<p>$01d2 <strong>IDE_MOUNT</strong></p>
<p>Unmount/remount SD cards</p>
<p>$01d2 <strong>IDE_MOUNT</strong></p>
<p>Unmount/remount SD cards</p>
<p>$01d5 <strong>IDE_MODE</strong></p>
<p>Query NextBASIC display mode info, or change mode</p>
<p>$01d8 <strong>IDE_TOKENISER</strong></p>
<p>Convert BASIC between plain text &amp; tokenised forms</p>
<h3 id="esxdos-compatible-api">esxDOS compatible API</h3>
<h3 id="next-extensions">Next Extensions</h3>
<p>$0085 <strong>DISK_FILEMAP</strong></p>
<div class="sourceCode" id="cb45" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_disk_filemap(uint8_t handle,<span class="kw">struct</span> esx_filemap *fmap)</span></code></pre></div>
<p>Obtain a map of card addresses describing the space occupies by the file. Can be called multiple times if the buffer is filled, continuing from previous.</p>
<p><strong>DISK_STREAM_BYTES</strong></p>
<div class="sourceCode" id="cb46" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> *esx_disk_stream_bytes(<span class="dt">void</span> *dst,uint16_t len)</span></code></pre></div>
<p>$0087 <strong>DISK_STREAM_END</strong></p>
<div class="sourceCode" id="cb47" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_disk_stream_end(<span class="dt">void</span>)</span></code></pre></div>
<p>Stop current streaming operation.</p>
<p><strong>DISK_STREAM_SECTORS</strong></p>
<div class="sourceCode" id="cb48" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> *esx_disk_stream_sectors(<span class="dt">void</span> *dst,uint8_t sectors)</span></code></pre></div>
<p>$0086 <strong>DISK_STREAM_START</strong></p>
<div class="sourceCode" id="cb49" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_disk_stream_start(<span class="kw">struct</span> esx_filemap_entry *entry)</span></code></pre></div>
<p>Start reading from the card in streaming mode.</p>
<p><strong>DOS_CATALOG</strong></p>
<div class="sourceCode" id="cb50" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_dos_catalog(<span class="kw">struct</span> esx_cat *cat)</span></code></pre></div>
<p><strong>DOS_CATALOG_NEXT</strong></p>
<div class="sourceCode" id="cb51" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_dos_catalog_next(<span class="kw">struct</span> esx_cat *cat)</span></code></pre></div>
<p><strong>DOS_GETSET_DRIVE</strong></p>
<div class="sourceCode" id="cb52" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_dos_get_drive(<span class="dt">void</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_dos_set_drive(<span class="dt">unsigned</span> <span class="dt">char</span> drive)</span></code></pre></div>
<h3 id="esxdos-compatible-api-1">esxDOS compatible API</h3>
<p>The esxDOS-compatible API is a bit simpler to use than the +3DOS-compatible API.</p>
<p>To make a call, you only need to set up the entry parameters as indicated and perform a RST $08; DEFB hook_code. On return, registers AF,BC,DE,HL will all be changed. IX,IY and the alternate registers are never changed (except for M_P3DOS).</p>
<p>(Note that the standard 48K BASIC ROM must be paged in to the bottom of memory, but this is the usual situation after starting a machine code program with a USR function call).</p>
<p>Notice that error codes are different from those returned by +3DOS calls, and also the carry flag is SET for an error condition when returning from an esxDOS call (instead of RESET, as is the case for +3DOS).</p>
<p>If desired, you can use the M_GETERR hook to generate a BASIC error report for any error returned, or even use it to generate your own custom BASIC error report.</p>
<p>All of the calls where a filename is specified will accept long filenames (LFNs) and most will accept wildcards (for an operation such as F_OPEN where a single file is always used, the first matching filename will be used).</p>
<p>$00A9 <strong>F_CHDIR</strong></p>
<div class="sourceCode" id="cb53" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_chdir(<span class="dt">unsigned</span> <span class="dt">char</span> *pathname)</span></code></pre></div>
<p>Change directory.</p>
<p>$00AF <strong>F_CHMOD</strong></p>
<div class="sourceCode" id="cb54" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_chmod(<span class="dt">unsigned</span> <span class="dt">char</span> *filename, uint8_t attr_mask, uint8_t attr)</span></code></pre></div>
<p>Modify file attributes.</p>
<p>$009B<strong>F_CLOSE</strong></p>
<div class="sourceCode" id="cb55" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_close(<span class="dt">unsigned</span> <span class="dt">char</span> handle)</span></code></pre></div>
<p>Close a file or directory.</p>
<p><strong>F_CLOSEDIR</strong></p>
<div class="sourceCode" id="cb56" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_closedir(<span class="dt">unsigned</span> <span class="dt">char</span> handle)</span></code></pre></div>
<p>$00A0 <strong>F_FGETPOS</strong></p>
<div class="sourceCode" id="cb57" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>uint32_t esx_f_fgetpos(<span class="dt">unsigned</span> <span class="dt">char</span> handle)</span></code></pre></div>
<p>Get current file position.</p>
<p>$00A1 <strong>F_FSTAT</strong></p>
<div class="sourceCode" id="cb58" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_fstat(<span class="dt">unsigned</span> <span class="dt">char</span> handle, <span class="kw">struct</span> esx_stat *es)</span></code></pre></div>
<p>Get file information/status.</p>
<p>$00A2 <strong>F_FTRUNC</strong></p>
<div class="sourceCode" id="cb59" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_ftrunc(<span class="dt">unsigned</span> <span class="dt">char</span> handle, uint32_t size)</span></code></pre></div>
<p>Truncate/extend file.</p>
<p><strong>F_GET_CANONICAL_PATH</strong></p>
<div class="sourceCode" id="cb60" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_get_canonical_path(<span class="dt">char</span> *pathname, <span class="dt">char</span> *canonical)</span></code></pre></div>
<p>$00A8 <strong>F_GETCWD</strong></p>
<div class="sourceCode" id="cb61" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_getcwd(<span class="dt">unsigned</span> <span class="dt">char</span> *buf)</span></code></pre></div>
<p>Get current working directory.</p>
<p><strong>F_GETCWD_DRIVE</strong></p>
<div class="sourceCode" id="cb62" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_getcwd_drive(<span class="dt">unsigned</span> <span class="dt">char</span> drive, <span class="dt">char</span> *buf)</span></code></pre></div>
<p>$00B1 <strong>F_GETFREE</strong></p>
<div class="sourceCode" id="cb63" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>uint32_t esx_f_getfree(<span class="dt">void</span>)</span></code></pre></div>
<p>Gets free space on drive.</p>
<p>$00AA <strong>F_MKDIR</strong></p>
<div class="sourceCode" id="cb64" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_mkdir(<span class="dt">unsigned</span> <span class="dt">char</span> *pathname)</span></code></pre></div>
<p>Create directory.</p>
<p>$009A <strong>F_OPEN</strong></p>
<div class="sourceCode" id="cb65" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_open(<span class="dt">unsigned</span> <span class="dt">char</span> *filename,<span class="dt">unsigned</span> <span class="dt">char</span> mode)</span></code></pre></div>
<p>Open a file.</p>
<p>$00A3 <strong>F_OPENDIR</strong></p>
<div class="sourceCode" id="cb66" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_opendir(<span class="dt">unsigned</span> <span class="dt">char</span> *dirname)</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_opendir_ex(<span class="dt">unsigned</span> <span class="dt">char</span> *dirname,uint8_t mode)</span></code></pre></div>
<p>Open directory.</p>
<p>$009A <strong>F_OPEN</strong></p>
<div class="sourceCode" id="cb67" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_open_p3(<span class="dt">unsigned</span> <span class="dt">char</span> *filename,<span class="dt">unsigned</span> <span class="dt">char</span> mode,<span class="kw">struct</span> esx_p3_hdr *h)</span></code></pre></div>
<p>Open a file.</p>
<p>$009D <strong>F_READ</strong></p>
<div class="sourceCode" id="cb68" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>uint16_t esx_f_read(<span class="dt">unsigned</span> <span class="dt">char</span> handle, <span class="dt">void</span> *dst, size_t nbytes)</span></code></pre></div>
<p>Read bytes from file.</p>
<p>$00A4 <strong>F_READDIR</strong></p>
<div class="sourceCode" id="cb69" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_readdir(<span class="dt">unsigned</span> <span class="dt">char</span> handle,<span class="kw">struct</span> esx_dirent *dirent)</span></code></pre></div>
<p>Read next directory entry.</p>
<p>$00B0 <strong>F_RENAME</strong></p>
<div class="sourceCode" id="cb70" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_rename(<span class="dt">unsigned</span> <span class="dt">char</span> *old, <span class="dt">unsigned</span> <span class="dt">char</span> *new)</span></code></pre></div>
<p>Rename or move a file.</p>
<p>$00A7 <strong>F_REWINDDIR</strong></p>
<div class="sourceCode" id="cb71" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_rewinddir(<span class="dt">unsigned</span> <span class="dt">char</span> handle)</span></code></pre></div>
<p>Rewind directory position to the start of the directory.</p>
<p>$00AB <strong>F_RMDIR</strong></p>
<div class="sourceCode" id="cb72" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_rmdir(<span class="dt">unsigned</span> <span class="dt">char</span> *pathname)</span></code></pre></div>
<p>Remove directory.</p>
<p>$009F <strong>F_SEEK</strong></p>
<div class="sourceCode" id="cb73" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>uint32_t esx_f_seek(<span class="dt">unsigned</span> <span class="dt">char</span> handle, uint32_t distance, <span class="dt">unsigned</span> <span class="dt">char</span> whence)</span></code></pre></div>
<p>Seek to position in file.</p>
<p>$00A6 <strong>F_SEEKDIR</strong></p>
<div class="sourceCode" id="cb74" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_seekdir(<span class="dt">unsigned</span> <span class="dt">char</span> handle,uint32_t pos)</span></code></pre></div>
<p>Set current directory position.</p>
<p>$00AC <strong>F_STAT</strong></p>
<p>Get unopened file information/status.</p>
<p>$009C <strong>F_SYNC</strong></p>
<div class="sourceCode" id="cb75" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_sync(<span class="dt">unsigned</span> <span class="dt">char</span> handle)</span></code></pre></div>
<p>Sync file changes to disk.</p>
<p>$00A5 <strong>F_TELLDIR</strong></p>
<div class="sourceCode" id="cb76" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>uint32_t esx_f_telldir(<span class="dt">unsigned</span> <span class="dt">char</span> handle)</span></code></pre></div>
<p>Get current directory position.</p>
<p>$00AE <strong>F_TRUNC</strong></p>
<div class="sourceCode" id="cb77" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_trunc(<span class="dt">unsigned</span> <span class="dt">char</span> *filename,uint32_t size)</span></code></pre></div>
<p>Truncate/extend unopened file.</p>
<p>$00AD <strong>F_UNLINK</strong></p>
<div class="sourceCode" id="cb78" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_f_unlink(<span class="dt">unsigned</span> <span class="dt">char</span> *filename)</span></code></pre></div>
<p>Delete file.</p>
<p>$009E <strong>F_WRITE</strong></p>
<div class="sourceCode" id="cb79" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>uint16_t esx_f_write(<span class="dt">unsigned</span> <span class="dt">char</span> handle, <span class="dt">void</span> *src, size_t nbytes)</span></code></pre></div>
<p>Write bytes to file.</p>
<p><strong>IDE_BANK_ALLOC</strong></p>
<div class="sourceCode" id="cb80" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_ide_bank_alloc(<span class="dt">unsigned</span> <span class="dt">char</span> banktype)</span></code></pre></div>
<p><strong>IDE_BANK_AVAIL</strong></p>
<div class="sourceCode" id="cb81" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_ide_bank_avail(<span class="dt">unsigned</span> <span class="dt">char</span> banktype)</span></code></pre></div>
<p><strong>IDE_BANK_FREE</strong></p>
<div class="sourceCode" id="cb82" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_ide_bank_free(<span class="dt">unsigned</span> <span class="dt">char</span> banktype, <span class="dt">unsigned</span> <span class="dt">char</span> page)</span></code></pre></div>
<p><strong>IDE_BANK_RESERVE</strong></p>
<div class="sourceCode" id="cb83" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_ide_bank_reserve(<span class="dt">unsigned</span> <span class="dt">char</span> banktype,<span class="dt">unsigned</span> <span class="dt">char</span> page)</span></code></pre></div>
<p><strong>IDE_BANK_TOTAL</strong></p>
<div class="sourceCode" id="cb84" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_ide_bank_total(<span class="dt">unsigned</span> <span class="dt">char</span> banktype)</span></code></pre></div>
<p><strong>IDE_BROWSER</strong></p>
<div class="sourceCode" id="cb85" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_ide_browser(uint8_t browsercaps, <span class="dt">void</span> *filetypes, <span class="dt">char</span> *help,<span class="dt">char</span> *dst_sfn, <span class="dt">char</span> *dst_lfn)</span></code></pre></div>
<p><strong>IDE_GET_LFN</strong></p>
<div class="sourceCode" id="cb86" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_ide_get_lfn(<span class="kw">struct</span> esx_lfn *dir, <span class="kw">struct</span> esx_cat_entry *query)</span></code></pre></div>
<p><strong>IDE_MODE_GET</strong></p>
<div class="sourceCode" id="cb87" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_ide_mode_get(<span class="kw">struct</span> esx_mode *mode)</span></code></pre></div>
<p><strong>IDE_MODE_SET</strong></p>
<div class="sourceCode" id="cb88" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_ide_mode_set(<span class="kw">struct</span> esx_mode *mode)</span></code></pre></div>
<p>$0088 <strong>M_DOSVER</strong></p>
<p>Get API version/mode information.</p>
<p>$0092 <strong>M_DRVAPI</strong></p>
<div class="sourceCode" id="cb89" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_drvapi(<span class="kw">struct</span> esx_drvapi *)</span></code></pre></div>
<p>Access API for installable drivers.</p>
<p>$0095 <strong>M_ERRH</strong></p>
<div class="sourceCode" id="cb90" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> esx_m_errh(<span class="dt">void</span> (*handler)(uint8_t error))</span></code></pre></div>
<p>Install error handler for dot command.<br />
$008F <strong>M_EXECCMD</strong></p>
<div class="sourceCode" id="cb91" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>uint16_t esx_m_execcmd(<span class="dt">unsigned</span> <span class="dt">char</span> *cmdline)</span></code></pre></div>
<p>Execute a dot command.</p>
<p>$008E <strong>M_GETDATE</strong></p>
<div class="sourceCode" id="cb92" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_getdate(<span class="kw">struct</span> dos_tm *)</span></code></pre></div>
<p>Get the current date/time.</p>
<p>$0093 <strong>M_GETERR</strong></p>
<div class="sourceCode" id="cb93" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> esx_m_geterr(uint16_t error,<span class="dt">unsigned</span> <span class="dt">char</span> *msg)</span></code></pre></div>
<p>$008D <strong>M_GETHANDLE</strong></p>
<div class="sourceCode" id="cb94" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_gethandle(<span class="dt">void</span>)</span></code></pre></div>
<p>Get the file handle of the currently running dot command</p>
<p>$0089 <strong>M_GETSETDRV</strong></p>
<div class="sourceCode" id="cb95" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_getdrv(<span class="dt">void</span>)</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_setdrv(<span class="dt">unsigned</span> <span class="dt">char</span> drive)</span></code></pre></div>
<p>Get or set the default drive.</p>
<p>$0091 <strong>M_SETCAPS</strong></p>
<div class="sourceCode" id="cb96" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_setcaps(<span class="dt">unsigned</span> <span class="dt">char</span> caps)</span></code></pre></div>
<p>$008B <strong>M_TAPEIN</strong></p>
<div class="sourceCode" id="cb97" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_tapein_close(<span class="dt">void</span>)</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_tapein_flags(uint8_t flags)</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>uint16_t esx_m_tapein_getpos(<span class="dt">void</span>)</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_tapein_info(uint8_t *drive,<span class="dt">unsigned</span> <span class="dt">char</span> *filename)</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_tapein_open(<span class="dt">unsigned</span> <span class="dt">char</span> *filename)</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_tapein_setpos(uint16_t block)</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_tapein_toggle_pause(<span class="dt">void</span>)</span></code></pre></div>
<p>Tape input redirection control.</p>
<p>$008C <strong>M_TAPEOUT</strong></p>
<div class="sourceCode" id="cb98" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_tapeout_close(<span class="dt">void</span>)</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_tapeout_info(uint8_t *drive,<span class="dt">unsigned</span> <span class="dt">char</span> *filename)</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_tapeout_open(<span class="dt">unsigned</span> <span class="dt">char</span> *appendname)</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> esx_m_tapeout_trunc(<span class="dt">unsigned</span> <span class="dt">char</span> *filename)</span></code></pre></div>
<p>Tape output redirection control.</p>
<p><strong>SLICE_DIRENT</strong></p>
<div class="sourceCode" id="cb99" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> esx_dirent_slice *esx_slice_dirent(<span class="kw">struct</span> esx_dirent *)</span></code></pre></div>
<p><strong>EXTENDED_SNA_LOAD</strong></p>
<div class="sourceCode" id="cb100" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> extended_sna_load(<span class="dt">unsigned</span> <span class="dt">char</span> handle)</span></code></pre></div>
<p><strong>P3DOS_COPY_CSTR_TO_PSTR</strong></p>
<div class="sourceCode" id="cb101" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> *p3dos_copy_cstr_to_pstr(<span class="dt">char</span> *pdst, <span class="dt">const</span> <span class="dt">char</span> *csrc)</span></code></pre></div>
<p><strong>P3DOS_COPY_PSTR_TO_CSTR</strong></p>
<div class="sourceCode" id="cb102" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> *p3dos_copy_pstr_to_cstr(<span class="dt">char</span> *cdst, <span class="dt">const</span> <span class="dt">char</span> *psrc)</span></code></pre></div>
<p><strong>P3DOS_CSTR_TO_PSTR</strong></p>
<div class="sourceCode" id="cb103" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> *p3dos_cstr_to_pstr(<span class="dt">unsigned</span> <span class="dt">char</span> *s)</span></code></pre></div>
<p><strong>P3DOS_DOSNAME_FROM_CATNAME</strong></p>
<div class="sourceCode" id="cb104" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> *p3dos_dosname_from_catname(<span class="dt">char</span> *dosname, <span class="dt">char</span> *catname)</span></code></pre></div>
<p><strong>P3DOS_EDRV_FROM_PDRV</strong></p>
<div class="sourceCode" id="cb105" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> p3dos_edrv_from_pdrv(<span class="dt">unsigned</span> <span class="dt">char</span> pdrv)</span></code></pre></div>
<p><strong>P3DOS_PDRV_FROM_EDRV</strong></p>
<div class="sourceCode" id="cb106" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> p3dos_pdrv_from_edrv(<span class="dt">unsigned</span> <span class="dt">char</span> edrv)</span></code></pre></div>
<p><strong>P3DOS_PSTR_TO_CSTR</strong></p>
<div class="sourceCode" id="cb107" data-language="C"><pre class="sourceCode objectivec"><code class="sourceCode objectivec"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> *p3dos_pstr_to_cstr(<span class="dt">unsigned</span> <span class="dt">char</span> *s)</span></code></pre></div>
<h1 id="ports">Ports</h1>
<h2 id="bit">8-bit</h2>
<p>Port $6B () DMA Control (Z80 Mode, 3.01.02)</p>
<p>Port $0F () DAC B</p>
<ul>
<li><p>bits 7-0 = DAC Value</p></li>
</ul>
<p>Disable with bit 3 of Nextreg $08</p>
<p>Port $1F () Kempston/Mega Drive Joystick 1/DAC A<br />
Read</p>
<ul>
<li><p>bit 7 = ”start” button</p></li>
<li><p>bit 6 = A/X button</p></li>
<li><p>bit 5 = C/Z button</p></li>
<li><p>bit 4 = Fire/C/Y button</p></li>
<li><p>bit 3 = Up</p></li>
<li><p>bit 2 = Down</p></li>
<li><p>bit 1 = Left</p></li>
<li><p>bit 0 = Right</p></li>
</ul>
<p>Disable with Nextreg $05<br />
Write</p>
<ul>
<li><p>bits 7-0 = DAC Value</p></li>
</ul>
<p>Disable with bit 3 of Nextreg $08</p>
<p>Port $37 () Kempston/Mega Drive Joystick 2<br />
Read</p>
<ul>
<li><p>bit 7 = ”start” button</p></li>
<li><p>bit 6 = A/X button</p></li>
<li><p>bit 5 = C/Z button</p></li>
<li><p>bit 4 = Fire/C/Y button</p></li>
<li><p>bit 3 = Up</p></li>
<li><p>bit 2 = Down</p></li>
<li><p>bit 1 = Left</p></li>
<li><p>bit 0 = Right</p></li>
</ul>
<p>Disable with Nextreg $05<br />
Write ($00 on reset, 3.01.04)</p>
<ul>
<li><p>bits 7-6 = Select I/O Mode</p>
<ul>
<li><p>00 = Bit Bang</p></li>
<li><p>01 = Clock</p></li>
<li><p>10 = UART</p></li>
<li><p>11 = Reserved (don’t use)</p></li>
</ul></li>
<li><p>bit 5 = Reserved, must be 0</p></li>
<li><p>bit 4 = Select Joystick Port for Read</p>
<ul>
<li><p>0 = Left</p></li>
<li><p>1 = Right</p></li>
</ul></li>
<li><p>bits 3-1 = Reserved, must be $00</p></li>
<li><p>bit 0 = Pin 7 state (both ports)</p>
<ul>
<li><p>Bit Bang - bit 0 on pin 7</p></li>
<li><p>Clock - clock on pin 7<br />
0 = Slow clock (Fsys/2048 = 12.672 kHz)<br />
1 = Fast clock (Fsys/8 = 3.5 MHz)</p></li>
<li><p>UART - Pin 7 = TX, Pin 9 = RX 0 = ESP<br />
1 = Pi</p></li>
</ul></li>
</ul>
<p>** A Runt clock may appear in the first cycle<br />
The I/O mode should be set by writing this port first followed by enabling io mo de on the joysticks with a write to nextreg 0x05.</p>
<p>Port $3F () DAC A</p>
<ul>
<li><p>bits 7-0 = DAC Value</p></li>
</ul>
<p>Disable with bit 3 of Nextreg $08</p>
<p>Port $4F () DAC C</p>
<ul>
<li><p>bits 7-0 = DAC Value</p></li>
</ul>
<p>Disable with bit 3 of Nextreg $08</p>
<p>Port $57 () Sprite Attributes<br />
Byte 1</p>
<ul>
<li><p>bits 7-0 = LSB of X coordinate (bit 8 is in byte 3)</p></li>
</ul>
<p>Byte 2</p>
<ul>
<li><p>bits 7-0 = LSB of Y coordinate (bit 8 is in byte 5)</p></li>
</ul>
<p>Byte 3</p>
<ul>
<li><p>bits 7-4 = Palette Offset</p></li>
<li><p>bit 3 = Enable X Mirror</p></li>
<li><p>bit 2 = Enable Y Mirror</p></li>
<li><p>bit 1 = Enable Roration</p></li>
<li><p>bit 0 = By Sprite Type</p>
<ul>
<li><p>Anchor = MSB of X coordinate</p></li>
<li><p>Relative = Enable relative palette offset</p></li>
</ul></li>
</ul>
<p>Byte 4</p>
<ul>
<li><p>bit 7 = Enable visibility</p></li>
<li><p>bit 6 = Enable Byte 5</p></li>
<li><p>bit 5-0 = Pattern Index (“name”)</p></li>
</ul>
<p>Byte 5 (optional)<br />
Anchor</p>
<ul>
<li><p>bit 7-6 = type and pattern</p>
<ul>
<li><p>00 = 8-bit color</p></li>
<li><p>01 = relative</p></li>
<li><p>10 = 4-bit color, lower half of pattern (bytes 0-127)</p></li>
<li><p>11 = 4-bit color, upper half of pattern (byets 128-255)</p></li>
</ul></li>
<li><p>bit 5 = Attached relative sprite type</p>
<ul>
<li><p>0 = composite</p></li>
<li><p>1 = big sprite</p></li>
</ul></li>
<li><p>bit 4-3 = X-axis scale factor</p>
<ul>
<li><p>00 = <span class="math inline">1×</span></p></li>
<li><p>01 = <span class="math inline">2×</span></p></li>
<li><p>10 = <span class="math inline">4×</span></p></li>
<li><p>11 = <span class="math inline">8×</span></p></li>
</ul></li>
<li><p>bit 2-1 = Y-axis scale factor</p></li>
<li><p>bit 0 = MSB of Y coordinate</p></li>
</ul>
<p>Composite Relative</p>
<ul>
<li><p>bits 7-6 = 01</p></li>
<li><p>bit 5 = N6<br />
8-bit</p>
<ul>
<li><p>Reserved, must be 0</p></li>
</ul>
<p>4-bit</p>
<ul>
<li><p>0 = lower half of pattern (bytes 0-127)</p></li>
<li><p>1 = upper half of pattern (bytes 128-255)</p></li>
</ul></li>
<li><p>bit 4-3 = X-axis scale factor</p></li>
<li><p>bit 2-1 = Y-axis scale factor</p></li>
<li><p>bit 0 = Enable relative pattern offset</p></li>
</ul>
<p>Big-sprite Relative</p>
<ul>
<li><p>bits 7-6 = 01</p></li>
<li><p>bit 5 = N6<br />
8-bit</p>
<ul>
<li><p>Reserved, must be 0</p></li>
</ul>
<p>4-bit</p>
<ul>
<li><p>0 = lower half of pattern (bytes 0-127)</p></li>
<li><p>1 = upper half of pattern (bytes 128-255)</p></li>
</ul></li>
<li><p>bit 4-1 = Reserved, must be 0</p></li>
<li><p>bit 0 = Enable relative pattern offset</p></li>
</ul>
<p>Port $5B () Sprite Pattern<br />
Load data into sprite pattern memory auto-incrementing. Port $303B can be used to set the starting sprite pattern number.</p>
<p>Port $5F () DAC D</p>
<ul>
<li><p>bits 7-0 = DAC Value</p></li>
</ul>
<p>Disable with bit 3 of Nextreg $08</p>
<p>Port $6B () DMA Control (Next Mode, 3.01.02)</p>
<p>Port $DF () DAC A,D</p>
<ul>
<li><p>bits 7-0 = DAC Value</p></li>
</ul>
<p>Disable with bit 3 of Nextreg $08</p>
<p>Port $E3 () divMMC Control<br />
Disable with bit 2 of Nextreg $09</p>
<ul>
<li><p>bit 7 = conmem, enable divMMC memory</p></li>
<li><p>bit 6 = mapram, enable divMMC allRAM mode</p></li>
<li><p>bits 3-0 = bank, selected divMMC ram bank for $2000-$3FFF region</p></li>
<li><p>conmem can be used to manually control divMMC mapping. When enabled<br />
$0000-$1FFF contains esxDOS ROM or esxDOS page 3<br />
$2000-$3FFF contains esxDOS RAM page selected by bits 3-0</p></li>
<li><p>divMMC automatically maps itself in when instruction fetches hit specific addresses in the ROM. When this happens, the esxDOS ROM (or divMMC bank 3 if mapram is set) appears in $0000-$1FFF and the selected divMMC bank appears as RAM in $2000-$3FFF</p></li>
<li><p>bit 6 can only be set, once set only a power cycle can reset it. nextreg $09 bit 3 can be set to reset this bit.</p></li>
</ul>
<p>divMMC automapping is normally disabled by NextZXOS see nextreg $06 bit 4.<br />
Port $E7 () SPI <span class="math inline">$\overline{\hbox{CS}}$</span> (SD card, flash, rpi)<br />
Disable with bit 2 of Nextreg $09</p>
<p>Port $EB () SPI <span class="math inline">$\overline{\hbox{DATA}}$</span> (SD card, flash, rpi)<br />
Disable with bit 2 of Nextreg $09</p>
<p>Port $F1 () DAC A (precedence over $xxFD)</p>
<ul>
<li><p>bits 7-0 = DAC Value</p></li>
</ul>
<p>Disable with bit 3 of Nextreg $08</p>
<p>Port $F3 () DAC B</p>
<ul>
<li><p>bits 7-0 = DAC Value</p></li>
</ul>
<p>Disable with bit 3 of Nextreg $08</p>
<p>Port $F9 () DAC C (precedence over $xxFD)</p>
<ul>
<li><p>bits 7-0 = DAC Value</p></li>
</ul>
<p>Disable with bit 3 of Nextreg $08</p>
<p>Port $FB () DAC A,D</p>
<ul>
<li><p>bits 7-0 = DAC Value</p></li>
</ul>
<p>Disable with bit 3 of Nextreg $08</p>
<p>Port $FE () ULA</p>
<ul>
<li><p>bits 7-5 = Unused</p></li>
<li><p>bit 4 = enable ear output</p></li>
<li><p>bit 3 = enable mic output</p></li>
<li><p>bit 2-0 = border colour</p></li>
</ul>
<p>Port $FF () Timex Sinclair/Floating Bus</p>
<ul>
<li><p>bit 7 = memory paging (not on ZX Next)</p></li>
<li><p>bit 6 = Disable generation of interrupts</p></li>
<li><p>bit 5-3 = Hi-res mode color combination</p>
<ul>
<li><p>000 = Black on white (indexes 0, 135)</p></li>
<li><p>001 = Blue on Yellow (indexes 1, 134)</p></li>
<li><p>010 = Green on Magenta (indexes 2, 133)</p></li>
<li><p>011 = Cyan on Red (indexes 3, 132)</p></li>
<li><p>100 = Red on Cyan (indexes 4, 131)</p></li>
<li><p>101 = Magenta on Green (indexes 5, 130)</p></li>
<li><p>110 = Yellow on Blue (indexes 6, 129)</p></li>
<li><p>111 = White on Black (indexes 7, 128)</p></li>
</ul></li>
<li><p>bit 2-0 = ULA Mode</p>
<ul>
<li><p>000 = Normal ULA address</p></li>
<li><p>001 = Alternate ULA address</p></li>
<li><p>010 = Hi-color mode</p></li>
<li><p>110 = Hi-res mode</p></li>
</ul></li>
</ul>
<p>Disable with bit 2 of Nextreg $08</p>
<h2 id="bit-1">16-bit</h2>
<p>Port $103B () I<sup>2</sup>C SCL (rtc, rpi)</p>
<p>Port $113B () I<sup>2</sup>C SDA (rtc, rpi)</p>
<p>Port $123B () Layer 2<br />
Bit 4 = 0</p>
<ul>
<li><p>bits 7-6 = Video RAM bank select</p>
<ul>
<li><p>00 = first 16k</p></li>
<li><p>01 = second 16k</p></li>
<li><p>10 = third 16k</p></li>
<li><p>11 = first 48k</p></li>
</ul></li>
<li><p>bit 5 = Reserved, must be 0</p></li>
<li><p>bit 4 = 0</p></li>
<li><p>bit 3 = Shadow layer 2 select</p></li>
<li><p>bit 2 = Enable layer 2 read paging</p></li>
<li><p>bit 1 = Layer 2 visible (mirrored in register $69)</p></li>
<li><p>bit 0 = Enable layer 2 write paging</p></li>
</ul>
<p>Bit 4 = 1</p>
<ul>
<li><p>bits 7-5 = Reserved, must be 0</p></li>
<li><p>bit 4 = 1</p></li>
<li><p>bit 3 = Reserved, must be 0</p></li>
<li><p>bit 2-0 = 16k bank relative offset</p></li>
</ul>
<p>Port $133B () UART tx<br />
Read: UART Status<br />
</p>
<ul>
<li><p>bits 7-4 = Reserved (0)</p></li>
<li><p>bit 3 = UART at least half full (3.01.09)</p></li>
<li><p>bit 2 = UART full</p></li>
<li><p>bit 1 = UART transmit busy</p></li>
<li><p>bit 0 = UART receive has data</p></li>
</ul>
<p>Write: UART Transmit</p>
<p>Port $143B () UART rx<br />
Read: UART Receive<br />
Write: UART Prescalar</p>
<ul>
<li><p>bit 7 = select prescalar part</p>
<ul>
<li><p>0 = Bits 6-0 of prescalar</p></li>
<li><p>1 = Bits 13-7 of prescalar</p></li>
</ul></li>
<li><p>bits 6-0 = Prescalar bits</p></li>
</ul>
<p>Port $153B () UART select</p>
<ul>
<li><p>bit 7 = Reserved (0)</p></li>
<li><p>bit 6 = UART select (0 on soft reset) **</p>
<ul>
<li><p>0 = ESP</p></li>
<li><p>1 = Pi *</p></li>
</ul></li>
<li><p>bit 5 = Reserved (0)</p></li>
<li><p>bit 4 = Prescalar valid in this write</p></li>
<li><p>bit 3 = Reserved (0)</p></li>
<li><p>bits 2-0 = Bits 16-14 of prescalar (0 on hard reset)</p></li>
</ul>
<p>* Pi GPIO must be configured for UART, see nextreg $A0<br />
** Either UART can be redirected to the joystick ports, see port $037</p>
<p>Port $153B () UART frame (upcoming)<br />
($18 on hard reset)</p>
<ul>
<li><p>bit 7 = Immediately reset Rx and Tx to idle and empty FIFOs</p></li>
<li><p>bit 6 = Assert break (Tx=0) when Tx reaches idle</p></li>
<li><p>bit 5 = Enable hardware flow control *</p></li>
<li><p>bits 4-3 = Number of bits in a frame</p>
<ul>
<li><p>00 = 5 bits</p></li>
<li><p>01 = 6 bits</p></li>
<li><p>10 = 7 bits</p></li>
<li><p>11 = 8 bits</p></li>
</ul></li>
<li><p>bit 2 = Enable parity</p></li>
<li><p>bit 1 = Parity</p>
<ul>
<li><p>0 = Even parity</p></li>
<li><p>1 = Odd parity</p></li>
</ul></li>
<li><p>bit 0 = Number of stop bits</p>
<ul>
<li><p>0 = 1 stop bit</p></li>
<li><p>1 = 2 stop bits</p></li>
</ul></li>
</ul>
<p>Port $183B () CTC Channel 0</p>
<p>Port $193B () CTC Channel 1</p>
<p>Port $1A3B () CTC Channel 2</p>
<p>Port $1B3B () CTC Channel 3</p>
<p>Port $1C3B () CTC Channel 4</p>
<p>Port $1D3B () CTC Channel 5</p>
<p>Port $1E3B () CTC Channel 6</p>
<p>Port $183B () CTC Channel 7</p>
<p>Port $1FFD () Plus 3 Memory Paging Control</p>
<ul>
<li><p>bits 7-3 = Unused, nust be 0</p></li>
<li><p>bit 2 = High bit of ROM selection (low bit is in Port $7FFD)</p>
<ul>
<li><p>00 = ROM0 = 128k editor and menu system</p></li>
<li><p>01 = ROM1 = 128k syntax checker</p></li>
<li><p>10 = ROM2 = +3DOS</p></li>
<li><p>11 = ROM3 = 48k BASIC</p></li>
</ul></li>
<li><p>bit 1 = Special mode: Low bit of memory configuration number</p></li>
<li><p>bit 0 = Paging mode</p>
<ul>
<li><p>0 = Normal</p></li>
<li><p>1 = Special</p></li>
</ul></li>
</ul>
<p>You should echo writes to $5B67</p>
<p>Port $243B () Next Register Select</p>
<p>Port $253B () Next Register Data</p>
<p>Port $303B () Sprite Slot/Flags<br />
Write: Sprite Slot Select<br />
select sprite slot for Sprite Attribute and Sprite Pattern ports which independently auto-increment<br />
Read: Sprite status</p>
<ul>
<li><p>bits 7-2 = reserved</p></li>
<li><p>bit 1 = Max sprites per line</p></li>
<li><p>bit 0 = Collision flag</p></li>
</ul>
<p>Port $7FFD () Memory Paging Control</p>
<ul>
<li><p>bits 6-7 = reserved</p></li>
<li><p>bit 5 = Lock memory paging</p></li>
<li><p>bit 4 = low bit of ROM Select (high bit is in Port $1FFD)</p>
<ul>
<li><p>00 = ROM0 = 128k editor and menu system</p></li>
<li><p>01 = ROM1 = 128k syntax checker</p></li>
<li><p>10 = ROM2 = +3DOS</p></li>
<li><p>11 = ROM3 = 48k BASIC</p></li>
</ul></li>
<li><p>bit 3 = Shadow screen toggle</p></li>
<li><p>bits 2-0 = LSB of Bank number for slot 4 (MSB is in Port $DFFD)</p></li>
</ul>
<p>Disable with bit 5 port $7FFD</p>
<p>Port $7FFE () Keyboard 8 (read only)</p>
<ul>
<li><p>bit 0: ’B’</p></li>
<li><p>bit 1: ’N’</p></li>
<li><p>bit 2: ’M’</p></li>
<li><p>bit 3: Symbol Shift</p></li>
<li><p>bit 4: Space</p></li>
</ul>
<p>Port $BF3B () ULAplus register</p>
<ul>
<li><p>bits 7-6 = Select register group</p>
<ul>
<li><p>00 = palette group</p></li>
<li><p>01 = mode group</p></li>
</ul></li>
<li><p>bits 5-0 = data</p>
<ul>
<li><p>If palette group, selects index 0-63 in ULAplus palette</p></li>
<li><p>If mode group, ignored</p></li>
</ul></li>
</ul>
<p>Port $BFF5 () AY Info (3.01.09<br />
(R)</p>
<ul>
<li><p>bits 7-6 = Active AY chip</p>
<ul>
<li><p>01 = AY 0 active</p></li>
<li><p>10 = AY 1 active</p></li>
<li><p>11 = AY 2 active</p></li>
</ul></li>
<li><p>bit 5 = Reserved</p></li>
<li><p>bits 4-0 = currently selected AY register</p></li>
</ul>
<p>Port $BFFD () AY Data</p>
<p>Port $BFFE () Keyboard 7 (read only)</p>
<ul>
<li><p>bit 0 = ’H’</p></li>
<li><p>bit 1 = ’J’</p></li>
<li><p>bit 2 = ’K’</p></li>
<li><p>bit 3 = ’L’</p></li>
<li><p>bit 4 = Enter</p></li>
</ul>
<p>Port $DFFD () Next Memory Bank Select</p>
<ul>
<li><p>bits 7-4 = Reserved, must be 0</p></li>
<li><p>bits 3-0 = MSB of bank number for slot 4 (LSB is in Port $7FFD)</p></li>
</ul>
<p>Port $DFFE () Keyboard 6 (read only)</p>
<ul>
<li><p>bit 0 = ’Y’</p></li>
<li><p>bit 1 = ’U’</p></li>
<li><p>bit 2 = ’I’</p></li>
<li><p>bit 3 = ’O’</p></li>
<li><p>bit 4 = ’P’</p></li>
</ul>
<p>Port $EFF7 () Pentagon 1024 paging</p>
<ul>
<li><p>bit 3 = 1 to overlay the bottom 16k with ram from 16k bank 0</p></li>
<li><p>bit 2 = 0 to enable Pentagon 1024 mapping and disable bit 5 port 0x7ffd locking, 1 to select standard zx128 mapping **</p></li>
<li><p>** Applies only when pentagon 1024 mapping mode is enabled via nextreg 0x8f.</p></li>
</ul>
<p>Port $EFFE () Keyboard 5 (read only)</p>
<ul>
<li><p>bit 0 = ‘6’</p></li>
<li><p>bit 1 = ‘7’</p></li>
<li><p>bit 2 = ‘8’</p></li>
<li><p>bit 3 = ‘9’</p></li>
<li><p>bit 4 = ‘0’</p></li>
</ul>
<p>Port $F7FE () Keyboard 4 (read only)</p>
<ul>
<li><p>bit 0 = ‘5’</p></li>
<li><p>bit 1 = ‘4’</p></li>
<li><p>bit 2 = ‘3’</p></li>
<li><p>bit 3 = ‘2’</p></li>
<li><p>bit 4 = ‘1’</p></li>
</ul>
<p>Port $FADF () Kempston Mouse Buttons</p>
<ul>
<li><p>bits 7-4 = Wheel delta since last read</p></li>
<li><p>bit 3 = fourth button</p></li>
<li><p>bit 2 = middle button</p></li>
<li><p>bit 1 = left button</p></li>
<li><p>bit 0 = right button</p></li>
</ul>
<p>Port $FBDF () Kempston Mouse X</p>
<ul>
<li><p>bits 7-0 = X coordinate of mouse</p></li>
</ul>
<p>Port $FBFE () Keyboard 3 (read only)</p>
<ul>
<li><p>bit 0 = ‘T’</p></li>
<li><p>bit 1 = ‘R’</p></li>
<li><p>bit 2 = ‘E’</p></li>
<li><p>bit 3 = ‘W’</p></li>
<li><p>bit 4 = ‘Q’</p></li>
</ul>
<p>Port $FDFE () Keyboard 2 (read only)</p>
<ul>
<li><p>bit 0 = ‘G’</p></li>
<li><p>bit 1 = ‘F’</p></li>
<li><p>bit 2 = ‘D’</p></li>
<li><p>bit 3 = ‘S’</p></li>
<li><p>bit 4 = ‘A’</p></li>
</ul>
<p>Port $FEFE () Keyboard 1 (read only)</p>
<ul>
<li><p>bit 0 = ‘V’</p></li>
<li><p>bit 1 = ‘C’</p></li>
<li><p>bit 2 = ‘X’</p></li>
<li><p>bit 3 = ‘Z’</p></li>
<li><p>bit 4 = Caps Shift</p></li>
</ul>
<p>Port $FF3B () ULAplus data</p>
<ul>
<li><p>If palette group, 8-bit (RRRGGGBB) value for current index</p></li>
<li><p>If mode group, bit 1 = enable ULAplus</p></li>
</ul>
<p>Port $FFDF () Kempston Mouse Y</p>
<ul>
<li><p>bits 7-0 = Y coordinate of mouse (0-192)</p></li>
</ul>
<p>Port $FFFD () AY Control and AY register Select (3.01.09)<br />
Read</p>
<ul>
<li><p>bits 7-0 = data in selected register of active AY chip</p></li>
</ul>
<p>Select Chip</p>
<ul>
<li><p>bit 7 = 1</p></li>
<li><p>bit 6 = Enable left</p></li>
<li><p>bit 5 = Enable Right</p></li>
<li><p>bits 4-2 = Reserved, must be 1</p></li>
<li><p>bits 1-0 = AY chip select</p>
<ul>
<li><p>00 = Unused</p></li>
<li><p>01 = AY 2</p></li>
<li><p>10 = AY 1</p></li>
<li><p>11 = AY 0</p></li>
</ul></li>
</ul>
<p>Select Register</p>
<ul>
<li><p>bit 7 = 0</p></li>
<li><p>bits 6-5 = Reserved, must be 0</p></li>
<li><p>bits 4-0 = Register Number</p></li>
</ul>
<h1 id="registers">Registers</h1>
<h2 id="zx-spectrum-next-registers">ZX Spectrum Next Registers</h2>
<p>The ZX Next stores configuration state in a field of registers. These registers are accessible via two I/O ports or via the special nextreg instructions.</p>
<p>Port $243B (9275) is used to set the register number, listed below.</p>
<p>Port $253B (9531) is used to access the register value.</p>
<p>Some registers are accessible only during the initialization process.</p>
<p>Register (R) $00 () <span class="math inline">⇒</span> Machine ID</p>
<ul>
<li><p>00000001 = DE1A</p></li>
<li><p>00000010 = DE2A</p></li>
<li><p>00000101 = FBLABS</p></li>
<li><p>00000110 = VTRUCCO</p></li>
<li><p>00000111 = WXEDA</p></li>
<li><p>00001000 = EMULATORS</p></li>
<li><p>00001010 = ZX Spectrum Next</p></li>
<li><p>00001011 = Multicore</p></li>
<li><p>10101010 = ZX Spectrum Next Core on unAmiga</p></li>
<li><p>10111010 = ZX Spectrum Next Core on SiDi</p></li>
<li><p>11001010 = ZX Spectrum Next Core on MIST</p></li>
<li><p>11011010 = ZX Spectrum Next Core on MiSTer</p></li>
<li><p>11011010 = ZX Spectrum Next Core on unAmiga Reloaded</p></li>
<li><p>11101010 = ZX Spectrum Next Core on ZX-DOS</p></li>
<li><p>11111010 = ZX Spectrum Next Anti-brick</p></li>
</ul>
<p>Register (R) $01 () <span class="math inline">⇒</span> Core Version</p>
<ul>
<li><p>bits 7-4 = Major version number</p></li>
<li><p>bits 3-0 = Minor version number</p></li>
<li><p>See register $0E for sub minor version number</p></li>
</ul>
<p>Register (R/W) $02 () <span class="math inline">⇒</span> Reset<br />
Read</p>
<ul>
<li><p>bit 7 = Expansion bus <span class="math inline">$\overline{\hbox{RESET}}$</span> Asserted</p></li>
<li><p>bits 6-4 = Reserved</p></li>
<li><p>bit 3 = Indicates multiface NMI was generated by this nextreg (3.01.09)</p></li>
<li><p>bit 2 = Indicates divmmc NMI was generated by this nextreg (3.01.09)</p></li>
<li><p>bit 1 = Last reset was Hard reset</p></li>
<li><p>bit 0 = Last reset was Soft reset</p></li>
</ul>
<p>Write</p>
<ul>
<li><p>bit 7 = Hold Expansion bus and ESP <span class="math inline">$\overline{\hbox{RESET}}$</span></p></li>
<li><p>bits 6-4 = Reserved, must be 0</p></li>
<li><p>bit 3 = Generate multiface NMI (write zero to clear)(3.01.09)</p></li>
<li><p>bit 2 = Generate divmmc NMI (write zero to clear)(3.01.09)</p></li>
<li><p>bit 1 = generate Hard reset (reboot)</p></li>
<li><p>bit 0 = generate Soft reset</p></li>
</ul>
<p>Register (R/W) $03 () <span class="math inline">⇒</span> Machine Type<br />
A write to this register disables the boot rom in config mode<br />
bits 2-0 select machine type when in config mode</p>
<ul>
<li><p>bit 7 = (W) Display Timing change enable (allow changes to bits 6-4) (0 on hard reset)</p></li>
<li><p>bits 6-4 = Display Timing</p></li>
<li><p>bit 3 = Display Timing user lock control</p></li>
<li><p>Read</p>
<ul>
<li><p>0 = No user lock on display timing</p></li>
<li><p>1 = User lock on display timing</p></li>
</ul></li>
<li><p>Write</p>
<ul>
<li><p>1 = Apply user lock on display timing (0 on hard reset)</p></li>
</ul></li>
<li><p>bits 2-0 = Machine Type (config mode only)<br />
determines roms loaded</p></li>
<li><p>Machine Types/Display Timings</p>
<ul>
<li><p>000 or 001 = ZX 48K</p></li>
<li><p>010 = ZX 128K/+2 (Grey)</p></li>
<li><p>011 = ZX +2A-B/+3e/Next Native</p></li>
<li><p>100 = Pentagon 128K</p></li>
</ul></li>
</ul>
<p>Register (W) $04 () <span class="math inline">⇒</span> Configuration Mapping</p>
<ul>
<li><p>bits 7 = Reserved, must be 0</p></li>
<li><p>bits 6-0 = 16k SRAM bank mapping* ($00 on hard reset)</p></li>
<li><p>* Maps a 16k SRAM bank over the bottom 16k. Applies only in config mode when the bootrom is disabled</p></li>
<li><p>** Odd multiples of 256k are unreliable if storing data in sram for the mext core started.</p></li>
<li><p>*** number of useful bits changed from 5 to 7 in coure 3.01.06</p></li>
</ul>
<p>Register (R/W) $05 () <span class="math inline">⇒</span> Peripheral 1 Settings</p>
<ul>
<li><p>bits 7-6 = joystick 1 mode (MSB)</p></li>
<li><p>bits 5-4 = joystick 2 mode (MSB)</p></li>
<li><p>bit 3 = joystick 1 mode (LSB)</p></li>
<li><p>bit 2 = 50/60 Hz mode (0 = 50Hz, 1 = 60Hz)</p></li>
<li><p>bit 1 = joystick 2 mode (LSB)</p></li>
<li><p>bit 0 = Enable Scandoubler</p></li>
</ul>
<p>Joystick modes</p>
<ul>
<li><p>000 = Sinclair 2 (67890)</p></li>
<li><p>001 = Kempston 2 (port $37)</p></li>
<li><p>010 = Kempston 1 (port $1F)</p></li>
<li><p>011 = Megadrive 1 (port $1F)</p></li>
<li><p>100 = Cursor</p></li>
<li><p>101 = Megadrive 2 (port $37)</p></li>
<li><p>110 = Sinclair 1 (12345)</p></li>
<li><p>111 = I/O Mode (3.01.04) Both joysticks are places in I/O Mode if either is set to I/O Mode. The underlying joystick type is not changed and reads of this register will continue to return the last joystick type. Ehether the joystick is in io mode or not is invisible but this state can be cleared either through reset or by re-writing the gegister with joystick type not equal to 111. Recovery time for a normal joystick read after leaving I/O Mode is at most 64 scan lines.</p></li>
</ul>
<p>Register (R/W) $06 () <span class="math inline">⇒</span> Peripheral 2 Settings</p>
<ul>
<li><p>bit 7 = F8 CPU Speed Hotkey Enable (1 on reset)</p></li>
<li><p>bit 6 = Enable classic audio mode (beep and tape to internal speaker, other audio to ear and HDMI, 3.01.02)</p></li>
<li><p>bit 5 = F3 50Hz/60Hz Hotkey Enable (1 on reset)</p></li>
<li><p>bit 4 = divMMC Automap/NMI Enable (0 on hard reset)</p></li>
<li><p>bit 3 = NMI Button Enable (0 on hard reset)</p></li>
<li><p>bit 2 = PS/2 Mode (0 = keyboard, 1 = mouse)</p></li>
<li><p>bits 1-0 = PSG Mode (00 = YM, 01 = AY, 11 = hold all PSGs in Reset)</p></li>
</ul>
<p>Register (R/W) $07 () <span class="math inline">⇒</span> Turbo mode<br />
Read</p>
<ul>
<li><p>bits 7-6 = Reserved</p></li>
<li><p>bits 5-4 = Current Actual CPU Speed</p></li>
<li><p>bits 3-2 = Reserved</p></li>
<li><p>bits 1-0 = Current Selected CPU Speed (00 on reset)</p></li>
</ul>
<p>Write</p>
<ul>
<li><p>bits 7-2 = Reserved, must be 0</p></li>
<li><p>bits 1-0 = Select CPU Speed</p></li>
</ul>
<p>CPU Speeds</p>
<ul>
<li><p>00 = 3.5MHz</p></li>
<li><p>01 = 7MHz</p></li>
<li><p>10 = 14MHz</p></li>
<li><p>11 = 28MHz</p></li>
</ul>
<p>Register (R/W) $08 () <span class="math inline">⇒</span> Peripheral 3 Settings</p>
<ul>
<li><p>bit 7 = 128K Banking Unlock (inverse of port $7FFD, bit 5) (0 on reset)</p></li>
<li><p>bit 6 = Disable RAM and Port Contention (0 on reset)</p></li>
<li><p>bit 5 = PSG Stereo Mode Control (0 = ABC, 1 = ACB) (0 on hard reset)</p></li>
<li><p>bit 4 = Enable internal speaker (1 on hard reset)</p></li>
<li><p>bit 3 = Enable DACs (0 on hard reset)</p></li>
<li><p>bit 2 = Enable read of port $FF (Timex) (0 on hard reset)</p></li>
<li><p>bit 1 = Enable Multiple PSGs (0 on hard reset)</p></li>
<li><p>bit 0 = Enable Issue 2 Keyboard</p></li>
</ul>
<p>Register (R/W) $09 () <span class="math inline">⇒</span> Peripheral 4 setting:</p>
<ul>
<li><p>bit 7 = PSG 2 Mono Enable (0 on hard reset)</p></li>
<li><p>bit 6 = PSG 1 Mono Enable (0 on hard reset)</p></li>
<li><p>bit 5 = PSG 0 Mono Enable (0 on hard reset)</p></li>
<li><p>bit 4 = Sprite ID lockstep enable (1 = Nextreg $34 and IO Port $303B are in lockstep, 0 on reset)</p></li>
<li><p>bit 3 = divMMC mapRAM bit Control (reset bit 7 of port $E3)</p></li>
<li><p>bit 2 = HDMI audio mute (0 on hard reset)</p></li>
<li><p>bits 1-0 = scanlines</p>
<ul>
<li><p>00 = scanlines off</p></li>
<li><p>01 = scanlines 12.5%</p></li>
<li><p>10 = scanlines 25%</p></li>
<li><p>11 = scanlines 50%</p></li>
</ul></li>
<li><p>In Sprite lockstep, NextREG $34 and Port $303B are in lockstep</p></li>
</ul>
<p>Register (R/W) $0A () <span class="math inline">⇒</span> Peripheral 5 setting:</p>
<ul>
<li><p>bits 7-6 = Multiface type (00 on hard reset)</p>
<ul>
<li><p>00 = Multiface +3 (enable port 0x3F, disable port 0xBF)</p></li>
<li><p>01 = Multiface 128 v87.2 (enable port 0xBF, disable port 0x3F)</p></li>
<li><p>10 = Multiface 128 v87.12 (enable port 0x9F, disable port 0x1F)</p></li>
<li><p>11 = Multiface 1 (enable port 0x9F, disable port 0x1F)</p></li>
</ul></li>
<li><p>bits 5-4 = Reserved, must be zero</p></li>
<li><p>bit 3 = 1 to reverse left and right mouse buttons (3.01.07)</p></li>
<li><p>bit 2 = Reserved, must be 0</p></li>
<li><p>bits 1-0 = mouse dpi (00 on hard reset) (3.01.05)</p>
<ul>
<li><p>00 = low dpi</p></li>
<li><p>01 = default</p></li>
<li><p>10 = medium dpi</p></li>
<li><p>11 = high dpi</p></li>
</ul></li>
</ul>
<p>Register (R) $0E () <span class="math inline">⇒</span> Core Version (sub minor number)</p>
<ul>
<li><p>bits 7-0 = Core sub minor version number</p></li>
<li><p>(see register $01 for the major and minor version number)</p></li>
</ul>
<p>Register (R/W) $10 () <span class="math inline">⇒</span> Core Boot<br />
Read</p>
<ul>
<li><p>bits 7-2 = Reserved</p></li>
<li><p>bit 1 = Drive button pressed</p></li>
<li><p>bit 0 = NMI button pressed</p></li>
</ul>
<p>Write</p>
<ul>
<li><p>bit 7 = Reboot FPGA using selected core (0 on reset)</p></li>
<li><p>bits 6-5 = Reserved, must be 0</p></li>
<li><p>bits 4-0 = Core ID</p></li>
<li><p>Core ID with bits 4-0 can only be set in configuration mode</p></li>
</ul>
<p>Register (R/W) $11 () <span class="math inline">⇒</span> Video Timing (writable in config mode only)</p>
<ul>
<li><p>bits 7-3 = Reserved, must be 0</p></li>
<li><p>bits 2-0 = Mode (VGA = 0..6, HDMI = 7)</p>
<ul>
<li><p>000 = Base VGA timing, clk28 = 28000000</p></li>
<li><p>001 = VGA setting 1, clk28 = 28571429</p></li>
<li><p>010 = VGA setting 2, clk28 = 29464286</p></li>
<li><p>011 = VGA setting 3, clk28 = 30000000</p></li>
<li><p>100 = VGA setting 4, clk28 = 31000000</p></li>
<li><p>101 = VGA setting 5, clk28 = 32000000</p></li>
<li><p>110 = VGA setting 6, clk28 = 33000000</p></li>
<li><p>111 = HDMI, clk28 = 27000000</p></li>
</ul></li>
<li><p>50/60Hz selection depends on bit 2 of register $05</p></li>
<li><p>Only writable in config mode</p></li>
</ul>
<p>Register (R/W) $12 () <span class="math inline">⇒</span> Layer 2 Active RAM bank</p>
<ul>
<li><p>bits 7-6 = Reserved, must be 0</p></li>
<li><p>bits 5-0 = RAM bank (point to bank 8 after a Reset, NextZXOS modifies to 9)</p></li>
</ul>
<p>Register (R/W) $13 () <span class="math inline">⇒</span> Layer 2 Shadow RAM bank</p>
<ul>
<li><p>bits 7-6 = Reserved, must be 0</p></li>
<li><p>bits 5-0 = RAM bank (point to bank 11 after a Reset, NextZXOS modifies to 12)</p></li>
</ul>
<p>Register (R/W) $14 () <span class="math inline">⇒</span> Global transparency color</p>
<ul>
<li><p>bits 7-0 = Transparency color value ($E3 after a reset)</p></li>
</ul>
<p>(Note: this value is 8-bit, so the transparency is compared against only by the MSB bits of the final 9-bit colour)<br />
(Note2: this only affects Layer 2, ULA and LoRes. Sprites use register $4B for transparency and tilemap uses nextreg $4C)</p>
<p>Register (R/W) $15 () <span class="math inline">⇒</span> Sprite and Layer System Setup</p>
<ul>
<li><p>bit 7 = LoRes mode (0 on reset)</p></li>
<li><p>bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on top) (0 on reset)</p></li>
<li><p>bit 5 = Enable sprite clipping in over border mode (0 on reset)</p></li>
<li><p>bits 4-2 = set layers priorities (000 on reset)</p>
<ul>
<li><p>000 - S L U</p></li>
<li><p>001 - L S U</p></li>
<li><p>010 - S U L</p></li>
<li><p>011 - L U S</p></li>
<li><p>100 - U S L</p></li>
<li><p>101 - U L S</p></li>
<li><p>110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7</p></li>
<li><p>111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]</p></li>
</ul></li>
<li><p>bit 1 = Enable Sprites Over border (0 on reset)</p></li>
<li><p>bit 0 = Enable Sprites (0 on reset)</p></li>
</ul>
<p>Register (R/W) $16 () <span class="math inline">⇒</span> Layer 2 Horizontal Scroll Control</p>
<ul>
<li><p>bits 7-0 = X Offset (0-255)(0 on reset)</p></li>
</ul>
<p>Register (R/W) $17 () <span class="math inline">⇒</span> Layer 2 Vertical Scroll Control</p>
<ul>
<li><p>bits 7-0 = Y Offset (0-191)(0 on reset)</p></li>
</ul>
<p>Register (R/W) $18 () <span class="math inline">⇒</span> Layer 2 Clip Window Definition</p>
<ul>
<li><p>bits 7-0 = Coords of the clip window</p>
<ul>
<li><p>1st write - X1 position</p></li>
<li><p>2nd write - X2 position</p></li>
<li><p>3rd write - Y1 position</p></li>
<li><p>4rd write - Y2 position</p></li>
</ul></li>
</ul>
<p>Reads do not advance the clip position<br />
The values are 0,255,0,191 after a Reset</p>
<p>Register (R/W) $19 () <span class="math inline">⇒</span> Sprite Clip Window Definition</p>
<ul>
<li><p>bits 7-0 = Cood. of the clip window</p>
<ul>
<li><p>1st write - X1 position</p></li>
<li><p>2nd write - X2 position</p></li>
<li><p>3rd write - Y1 position</p></li>
<li><p>4rd write - Y2 position</p></li>
</ul></li>
</ul>
<p>The values are 0,255,0,191 after a Reset<br />
Reads do not advance the clip position</p>
<p>When the clip window is enabled for sprites in "over border" mode, the X coords are internally doubled and the clip window origin is moved to the sprite origin inside the border.</p>
<p>Register (R/W) $1A () <span class="math inline">⇒</span> Layer 0 (ULA/LoRes) Clip Window Definition</p>
<ul>
<li><p>bits 7-0 = Coord. of the clip window</p>
<ul>
<li><p>1st write = X1 position</p></li>
<li><p>2nd write = X2 position</p></li>
<li><p>3rd write = Y1 position</p></li>
<li><p>4rd write = Y2 position</p></li>
</ul></li>
</ul>
<p>The values are 0,255,0,191 after a Reset<br />
Reads do not advance the clip position</p>
<p>Register (R/W) $1B () <span class="math inline">⇒</span> Layer 3 (Tilemap) Clip Window Definition</p>
<ul>
<li><p>bits 7-0 = Coord. of the clip window</p>
<ul>
<li><p>1st write = X1 position</p></li>
<li><p>2nd write = X2 position</p></li>
<li><p>3rd write = Y1 position</p></li>
<li><p>4rd write = Y2 position</p></li>
</ul></li>
</ul>
<p>The values are 0,159,0,255 after a Reset<br />
Reads do not advance the clip position<br />
The X coords are internally doubled.</p>
<p>Register (R/W) $1C () <span class="math inline">⇒</span> Clip Window Control<br />
Read</p>
<ul>
<li><p>bits 7-6 = Layer 3 Clip Index</p></li>
<li><p>bits 5-4 = Layer 0/1 Clip Index</p></li>
<li><p>bits 3-2 = Sprite clip index</p></li>
<li><p>bits 1-0 = Layer 2 Clip Index</p></li>
</ul>
<p>Write</p>
<ul>
<li><p>bits 7-4 = Reserved, must be 0</p></li>
<li><p>bit 3 - reset Layer 3 clip index</p></li>
<li><p>bit 2 - reset Layer 0/1 clip index</p></li>
<li><p>bit 1 - reset sprite clip index.</p></li>
<li><p>bit 0 - reset Layer 2 clip index.</p></li>
</ul>
<p>Register (R) $1E () <span class="math inline">⇒</span> Active video line (MSB)</p>
<ul>
<li><p>bits 7-1 = Reserved</p></li>
<li><p>bit 0 = Active line MSB</p></li>
</ul>
<p>Register (R) $1F () <span class="math inline">⇒</span> Active video line (LSB)</p>
<ul>
<li><p>bits 7-0 = Active line LSB (0-255)</p></li>
</ul>
<p>Register (R/W) $22 () <span class="math inline">⇒</span> Line Interrupt control</p>
<ul>
<li><p>bit 7 = (R) ULA asserting interrupt</p></li>
<li><p>bit 7 = (W) Reserved, must be 0</p></li>
<li><p>bits 6-3 = Reserved, must be 0</p></li>
<li><p>bit 2 = Disable ULA Interrupt (0 on reset)</p></li>
<li><p>bit 1 = Enable Line Interrupt (0 on reset)</p></li>
<li><p>bit 0 = MSB of Line Interrupt line value (0 on reset)</p></li>
</ul>
<p>Register (R/W) $23 () <span class="math inline">⇒</span> Line Interrupt value LSB</p>
<ul>
<li><p>bits 7-0 = Line Interrupt line value LSB (0-255)(0 on reset)</p></li>
</ul>
<p>Register (R/W) $26 () <span class="math inline">⇒</span> ULA Horizontal Scroll Control</p>
<ul>
<li><p>bits 7-0 = ULA X Offset (0-255) (0 on reset)</p></li>
</ul>
<p>Register (R/W) $27 () <span class="math inline">⇒</span> ULA Vertical Scroll Control</p>
<ul>
<li><p>bits 7-0 = ULA Y Offset (0-191) (0 on reset)</p></li>
</ul>
<p>Register (R/W) $28 () <span class="math inline">⇒</span> Stored Palette Value and PS/2 Keymap Address MSB<br />
Read</p>
<ul>
<li><p>bits 7-0 = Stored palette value (see NextREG $44)</p></li>
</ul>
<p>Write</p>
<ul>
<li><p>bits 7-1 = Reserved, must be 0</p></li>
<li><p>bit 0 = PS/2 Keymap Address MSB</p></li>
</ul>
<p>Register (W) $29 () <span class="math inline">⇒</span> PS/2 Keymap Address LSB</p>
<ul>
<li><p>bits 7-0 = PS/2 Keymap Address LSB</p></li>
</ul>
<p>Register (W) $2A () <span class="math inline">⇒</span> PS/2 Keymap Data MSB</p>
<ul>
<li><p>bits 7-1 = Reserved, must be 0</p></li>
<li><p>bit 0 = PS/2 Keymap Data MSB</p></li>
</ul>
<p>Register (W) $2B () <span class="math inline">⇒</span> PS/2 Keymap Data LSB</p>
<ul>
<li><p>bits 7-0 = PS/2 Keymap Data LSB</p></li>
</ul>
<p>(writing this register auto-increments the address)</p>
<p>Register (R/W) $2C () <span class="math inline">⇒</span> DAC B Mirror (Left)/ I<sup>2</sup>S Left Sample MSB<br />
Read</p>
<ul>
<li><p>bits 7-0 = I<sup>2</sup>S Left Sample MSB</p></li>
</ul>
<p>Write</p>
<ul>
<li><p>bits 7-0 = 8-bit sample left DAC ($80 on reset)</p></li>
</ul>
<p>Register (R/W) $2D () <span class="math inline">⇒</span> DAC A+D Mirror (mono/ I<sup>2</sup>S Sample LSB<br />
Read</p>
<ul>
<li><p>bits 7-0 = I<sup>2</sup>S Last Sample LSB</p></li>
</ul>
<p>Write</p>
<ul>
<li><p>bits 7-0 = 8-bit sample DACs A + D ($80 on reset)</p></li>
</ul>
<p>Register (R/W) $2E () <span class="math inline">⇒</span> DAC C Mirror (Right/ I<sup>2</sup>S Risht Sample MSB<br />
Read</p>
<ul>
<li><p>bits 7-0 = I<sup>2</sup>S Right Sameple MSB</p></li>
</ul>
<p>Write</p>
<ul>
<li><p>bits 7-0 = 8-bit sample Right DACs C ($80 on reset)</p></li>
</ul>
<p>Register (R/W) $2F () <span class="math inline">⇒</span> Layer 3 (Tilemap) Horizontal Scroll Control MSB</p>
<ul>
<li><p>bits 7-2 = Reserved, must be 0</p></li>
<li><p>bits 1-0 = X Offset MSB ($00 on reset)</p></li>
</ul>
<p>Meaningful Range is 0-319 in 40 char mode, 0-639 in 80 char mode</p>
<p>Register (R/W) $30 () <span class="math inline">⇒</span> Layer 3 (Tilemap) Horizontal Scroll Control LSB</p>
<ul>
<li><p>bits 7-0 = X Offset LSB ($00 on reset)</p></li>
</ul>
<p>Meaningful range is 0-319 in 40 char mode, 0-639 in 80 char mode</p>
<p>Register (R/W) $31 () <span class="math inline">⇒</span> Layer 3 (Tilemap) Vertical Scroll Control</p>
<ul>
<li><p>bits 7-0 = Y Offset (0-255) )$00 on reset)</p></li>
</ul>
<p>Register (R/W) $32 () <span class="math inline">⇒</span> Layer 1,0 (LoRes) Horizontal Scroll Control)</p>
<ul>
<li><p>bits 7-0 = X Offset (0-255) ($00 on reset)</p></li>
</ul>
<p>Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and smoothness as Layer 2.</p>
<p>Register (R/W) $33 () <span class="math inline">⇒</span> Layer 1,0 (LoRes) Vertical Scroll Control)</p>
<ul>
<li><p>bits 7-0 = Y Offset (0-191) ($00 on reset)</p></li>
</ul>
<p>Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and smoothness as Layer 2.</p>
<p>Register (R/W) $34 () <span class="math inline">⇒</span> Sprite Number<br />
Lockstep (NextReg $09 bit 4 set)</p>
<ul>
<li><p>bit 7 = Pattern address offset (Add 128 to pattern address)</p></li>
<li><p>bits 6-0 = Sprite number 0-127, Pattern number 0-63</p></li>
<li><p>effectively performs an out to port $303B</p></li>
</ul>
<p>No Lockstep (NextReg $09 bit 4 clear)</p>
<ul>
<li><p>bit 7 = Reserved, must be 0</p></li>
<li><p>bits 6-0 = Sprite number 0-127</p></li>
</ul>
<p>This register selects which sprite has its attributes connected to the sprite attribute registers</p>
<p>Register (W) $35 () <span class="math inline">⇒</span> Sprite Attribute 0</p>
<ul>
<li><p>bits 7-0 = Sprite X coordinate LSB (MSB in NextReg $37)</p></li>
</ul>
<p>Register (W) $36 () <span class="math inline">⇒</span> Sprite Attribute 1</p>
<ul>
<li><p>bits 7-0 = Sprite Y coordinate LSB (MSB in NextReg $39)</p></li>
</ul>
<p>Register (W) $37 () <span class="math inline">⇒</span> Sprite Attribute 2</p>
<ul>
<li><p>bits 7-4 = 4-bit Palette offset</p></li>
<li><p>bit 3 = Enable horizontal mirror (reverse)</p></li>
<li><p>bit 2 = Enable vertical mirror (reverse)</p></li>
<li><p>bit 1 = Enable 90<span class="math inline"><sup><em>O</em></sup></span> Clockwise Rotation</p></li>
</ul>
<p>Normal Sprites</p>
<ul>
<li><p>bit 0 = X coordinate MSB</p></li>
</ul>
<p>Relative Sprites</p>
<ul>
<li><p>bit 0 = Palette offset is relative to anchor sprite</p></li>
</ul>
<p>Rotation is applied before mirroring</p>
<p>Register (W) $38 () <span class="math inline">⇒</span> Sprite Attribute 3</p>
<ul>
<li><p>bit 7 = Enable Visiblity</p></li>
<li><p>bit 6 = Enable Attribute 4 (0 = Attribute 4 effectively $00)</p></li>
<li><p>bits 5-0 = Sprite Pattern Number</p></li>
</ul>
<p>Register (W) $39 () <span class="math inline">⇒</span> Sprite Attribute 4<br />
Normal Sprites</p>
<ul>
<li><p>bit 7 = 4-bit pattern switch (0 = 8-bit sprite, 1 = 4-bit sprite)</p></li>
<li><p>bit 6 = Pattern number bit-7 for 4-bit, 0 for 8-bit</p></li>
<li><p>bit 5 = Type of attached relative sprites (0 = Composite, 1 = Unified)</p></li>
<li><p>bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)</p></li>
<li><p>bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)</p></li>
<li><p>bit 0 = MSB of Y coordinate</p></li>
</ul>
<p>Relative, Composite Sprites</p>
<ul>
<li><p>bit 7-6 = 01</p></li>
<li><p>bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit</p></li>
<li><p>bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)</p></li>
<li><p>bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)</p></li>
<li><p>bit 0 = Pattern number is relative to anchor</p></li>
</ul>
<p>Relative, Unified Sprites</p>
<ul>
<li><p>bit 7-6 = 01</p></li>
<li><p>bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit</p></li>
<li><p>bits 4-1 = 0000</p></li>
<li><p>bit 0 = Pattern number is relative to anchor</p></li>
</ul>
<p>Register (R/W) $40 () <span class="math inline">⇒</span> Palette Index Select</p>
<ul>
<li><p>bits 7-0 = Palette Index Number</p></li>
</ul>
<p>Selects the palette index to change the associated colour</p>
<p>For ULA only, INKs are mapped to indices 0 through 7, BRIGHT INKs to indices 8 through 15, PAPERs to indices 16 through 23 and BRIGHT PAPERs to indices 24 through 31. In EnhancedULA mode, INKs come from a subset of indices from 0 through 127 and PAPERs from a subset of indices from 128 through 255.</p>
<p>The number of active indices depends on the number of attribute bits assigned to INK and PAPER out of the attribute byte.</p>
<p>In ULAplus mode, the last 64 entries (indices 192 to 255) hold the ULAplus palette. The ULA always takes border colour from PAPER for standard ULA and Enhanced ULA</p>
<p>Register (R/W) $41 () <span class="math inline">⇒</span> 8-bit Palette Data</p>
<ul>
<li><p>bits 7-0 = Colour Entry in RRRGGGBB format</p></li>
</ul>
<p>The lower blue bit of the 9-bit internal colour will be the logical or of bits 0 and 1 of the 8-bit entry. After each write, the palette index auto-increments if aut-increment has been enabled (NextReg $43 bit 7), Reads do not auto-increment.</p>
<p>Register (R/W) $42 () <span class="math inline">⇒</span> ULANext Attribute Byte Format</p>
<ul>
<li><p>bits 7-0 = Attribute byte’s INK representation mask (7 on reset)</p></li>
</ul>
<p>The mask can only indicate a solid sequence of bits on the right side of the attribute byte (1, 3, 7, 15, 31, 63, 127 or 255).</p>
<p>INKs are mapped to base index 0 in the palette and PAPERs and border are mapped to base index 128 in the palette.</p>
<p>The 255 value enables the full ink colour mode making all the palette entries INK. PAPER and border both take on the fallback colour (nextreg $4A) in this mode.</p>
<p>Register (R/W) $43 () <span class="math inline">⇒</span> Palette Control</p>
<ul>
<li><p>bit 7 = Disable palette write auto-increment.</p></li>
<li><p>bits 6-4 = Select palette for reading or writing:</p>
<ul>
<li><p>000 = ULA first palette</p></li>
<li><p>100 = ULA second palette</p></li>
<li><p>001 = Layer 2 first palette</p></li>
<li><p>101 = Layer 2 second palette</p></li>
<li><p>010 = Sprite first palette</p></li>
<li><p>110 = Sprite second palette</p></li>
<li><p>011 = Layer 3 first palette</p></li>
<li><p>111 = Layer 3 second palette</p></li>
</ul></li>
<li><p>bit 3 = Select Sprite palette (0 = first palette, 1 = second palette)</p></li>
<li><p>bit 2 = Select Layer 2 palette (0 = first palette, 1 = second palette)</p></li>
<li><p>bit 1 = Select ULA palette (0 = first palette, 1 = second palette)</p></li>
<li><p>bit 0 = Enable EnhancedULA mode if 1. (0 after a reset)</p></li>
</ul>
<p>Register (R/W) $44 () <span class="math inline">⇒</span> 9-bit Palette Data<br />
Non Level 2</p>
<ul>
<li><p>1st write</p></li>
<li><p>bits 7-0 = MSB (RRRGGGBB)</p></li>
<li><p>2nd write</p></li>
<li><p>bits 7-1 = Reserved, must be 0</p></li>
<li><p>bit 0 = LSB (B)</p></li>
</ul>
<p>Level 2</p>
<ul>
<li><p>1st write</p></li>
<li><p>bits 7-0 = MSB (RRRGGGBB)</p></li>
<li><p>2nd write</p></li>
<li><p>bit 7 = Priority</p></li>
<li><p>bits 6-1 = Reserved, must be 0</p></li>
<li><p>bit 0 = LSB (B)</p></li>
</ul>
<p>9-bit Palette Data is entered in two consecutive writes; the second write autoincrements the palette index if auto-increment is enabled in NextREG $43 bit 7</p>
<p>If writing an L2 palette, the second write’s D7 holds the L2 priority bit which if set (1) brings the colour defined at that index on top of all other layers. If you also need the same colour in regular priority (for example: for enviromental masking) you will have to set it up again, this time with no priority.</p>
<p>Reads return the second byte and do not autoincrement. Writes to nextreg $40, $41, $41, or $43 reset to the first write.</p>
<p>Register (R/W) $4A () <span class="math inline">⇒</span> Fallback Colour Value</p>
<ul>
<li><p>bits 7-0 = 8-bit colour if all layers are transparent ($E3 on reset)</p></li>
</ul>
<p>(black on reset = 0)</p>
<p>Register (R/W) $4B () <span class="math inline">⇒</span> Sprite Transparency Index</p>
<ul>
<li><p>bits 7-0 = Index value ($E3 if reset)</p></li>
</ul>
<p>For 4-bit sprites only the bottom 4-bits are relevant.</p>
<p>Register (R/W) $4C () <span class="math inline">⇒</span> Level 3 Transparency Index</p>
<ul>
<li><p>bits 7-4 = Reserved, must be 0</p></li>
<li><p>bits 3-0 = Index value ($0F on reset)</p></li>
</ul>
<p>Register (R/W) $50 () <span class="math inline">⇒</span> MMU Slot 0 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $0000 to $1FFF ($ff on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.<br />
A 255 value causes the ROM to become visible.</p>
<p>Register (R/W) $51 () <span class="math inline">⇒</span> MMU Slot 1 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $2000 to $3FFF ($ff on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.<br />
A 255 value causes the ROM to become visible.</p>
<p>Register (R/W) $52 () <span class="math inline">⇒</span> MMU Slot 2 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $4000 to $5FFF ($0A on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.</p>
<p>Register (R/W) $53 () <span class="math inline">⇒</span> MMU Slot 3 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $6000 to $7FFF ($0B on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.</p>
<p>Register (R/W) $54 () <span class="math inline">⇒</span> MMU Slot 4 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $8000 to $9FFF ($04 on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.</p>
<p>Register (R/W) $55 () <span class="math inline">⇒</span> MMU Slot 5 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $A000 to $BFFF ($05 on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.</p>
<p>Register (R/W) $56 () <span class="math inline">⇒</span> MMU Slot 6 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $C000 to $DFFF ($00 on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.</p>
<p>Register (R/W) $57 () <span class="math inline">⇒</span> MMU Slot 7 Control</p>
<ul>
<li><p>bits 7-0 = 8k RAM page at position $E000 to $FFFF ($01 on reset)</p></li>
</ul>
<p>Pages can be from 0 to 223 on a fully expanded Next.</p>
<p>Writing to ports $1FFD, $7FFD and $DFFD writes $FF to MMU0 and MMU1 and writes appropriate values to MMU6 and MMU7 to map in the selected 16k bank.</p>
<p>+3 special modes override the MMUs if used.</p>
<p>Register (W) $60 () <span class="math inline">⇒</span> Copper Data 8-bit Write</p>
<ul>
<li><p>bits 7-0 = Byte to write to copper instruction memory</p></li>
</ul>
<p>Note that each copper instruction is two bytes long, after a write, the coppen address is auto-incremented to the next memory position.</p>
<p>After a write, the index is auto-incremented to the next memory position.</p>
<p>Register (W) $61 () <span class="math inline">⇒</span> Copper Address LSB</p>
<ul>
<li><p>bits 7-0 = Copper instruction memory address LSB (0 on reset)</p></li>
</ul>
<p>Register (W) $62 () <span class="math inline">⇒</span> Copper Control</p>
<ul>
<li><p>bits 7-6 = Start Control</p>
<ul>
<li><p>00 = Copper fully stopped</p></li>
<li><p>01 = Copper start, execute the list from index 0, and loop to the start</p></li>
<li><p>10 = Copper start, execute the list from last point, and loop to the start</p></li>
<li><p>11 = Copper start, execute the list from index 0, and restart the list when the raster reaches position (0,0)</p></li>
</ul></li>
<li><p>bits 2-0 = Copper instruction memory address (MSB) (0 on reset)</p></li>
</ul>
<p>Register (W) $63 () <span class="math inline">⇒</span> Copper Data 16-bit Write</p>
<ul>
<li><p>bits 7-0 = Byte to write to copper instruction memory</p></li>
</ul>
<p>The 16-bit value is written in pairs. The first 8-bits are the MSB and are destined for an even copper instruction address. The sesond 8-bits are the LSB and are destined for an odd copper instruction address.</p>
<p>After each write, the copper address is auto-incremented to the next memory position.</p>
<p>After a write to an odd address, the all 16-bits are written to copper memory at once.</p>
<p>Register (R/W) $64 () <span class="math inline">⇒</span> Vertical Line Count Offset (3.01.05)</p>
<ul>
<li><p>bits 7-0 = Offset added to the vertical line counter</p></li>
<li><p>affects copper, line interrupt and active line count.<br />
Normally the ula’s pixel row 0 aligns with vertical line count 0. With a non-zero offset, the ula’s pixel row 0 will align with the vertical line offset.<br />
Eg, if the offset is 32 then vertical line 32 will correspond to the first pixel row in the ula and vertical line 0 will align with the first pixel row of the tilemap and sprites.</p></li>
</ul>
<p>* Since a change in offset takes effect when the ula reaches row 0, the change can take up to one frame to occur.</p>
<p>Register (R/W) $68 () <span class="math inline">⇒</span> ULA Control</p>
<ul>
<li><p>bit 7 = Disable ULA output (0 on reset)</p></li>
<li><p>bit 6-5 = Color blending control for layering modes 6 &amp; 7 (3.01.01)</p>
<ul>
<li><p>00 = ULA as blend colour</p></li>
<li><p>01 = No blending</p></li>
<li><p>10 = ULA/Tilemap mix result as blend colour</p></li>
<li><p>11 = Tilemap as blend colour</p></li>
</ul></li>
<li><p>bit 4 = Cancel entries in 8x5 matrix for extended keys (3.01.04)</p></li>
<li><p>bit 3 = Enable ULAplus (0 on reset)</p></li>
<li><p>bit 2 = Enable ULA half pixel scroll (0 on reset)</p></li>
<li><p>may change</p></li>
<li><p>bit 1 = Reserved (must be 0)</p></li>
<li><p>bit 0 = Enable stencil mode (0 on reset)</p></li>
<li><p>When ULA and Layer 3 are enabled, if either are transparent, the result is transparent, otherwise the result is the logical AND of both colours.</p></li>
</ul>
<p>Register (R/W) $69 () <span class="math inline">⇒</span> Display Control 1</p>
<ul>
<li><p>bit 7 = Layer 2 Enable (Port $123B bit 1 alias)</p></li>
<li><p>bit 6 = ULA Shadow display enable (Port $7FFD bit 3 alias)</p></li>
<li><p>bits 5-0 = Timex alias (Port $FF alias)</p></li>
</ul>
<p>Register (R/W) $6A () <span class="math inline">⇒</span> Layer 1,0 (LoRes) Control</p>
<ul>
<li><p>bits 7-6 = reserved, must be 0</p></li>
<li><p>bit 5 = Enable Radistan (16-colour) (0 on reset)</p></li>
<li><p>bit 4 = Radistan DFILE switch (xor with bit 0 of port $ff) (0 on reset)</p></li>
<li><p>bits 3-0 = Radistsan palette offset (0 on reset)</p></li>
<li><p>bits 1-0 = ULAplus palette offset (0 on reset)</p></li>
</ul>
<p>Register (R/W) $6B () <span class="math inline">⇒</span> Layer 3 (Tilemap) Control</p>
<ul>
<li><p>bit 7 = Layer 3 Enable (0 on reset)</p></li>
<li><p>bit 6 = Layer 3 Size control (0 on reset)</p>
<ul>
<li><p>0 = 40x32</p></li>
<li><p>1 = 80x32</p></li>
</ul></li>
<li><p>bit 5 = Disable Arrtibute Entry (0 on reset)</p></li>
<li><p>bit 4 = palette select (0 on reset)</p></li>
<li><p>bit 3 = Enable Text mode (1-bit tilemap) (0 on reset)</p></li>
<li><p>bit 2 = Reserved, must be 0</p></li>
<li><p>bit 1 = Activate 512 tile mode (0 on reset)</p></li>
<li><p>bit 0 = Enable Layer 3 on top of ULA (0 on reset)</p></li>
</ul>
<p>Register (R/W) $6C () <span class="math inline">⇒</span> Default Layer 3 Attribute*</p>
<ul>
<li><p>bits 7-4 = Palette Offset ($00 on reset)</p></li>
<li><p>bit 3 = X mirror (0 on reset)</p></li>
<li><p>bit 2 = Y mirror (0 on reset)</p></li>
<li><p>bit 1 = Rotate (0 on reset)</p></li>
<li><p>bit 0 = Bit 8 of the tile number (512 tile mode) (0 on reset)</p></li>
<li><p>bit 0 = ULA over tilemap (256 tile mode) (0 on reset)</p></li>
</ul>
<p>*Active tile attribute if bit 5 of nextreg $6B is set.</p>
<p>Register (R/W) $6E () <span class="math inline">⇒</span> Layer 3 Tilemap Base Address</p>
<ul>
<li><p>bit 7 = Bank Select (3.01.08)</p>
<ul>
<li><p>0 = Bank 5</p></li>
<li><p>1 = Bank 7</p></li>
</ul></li>
<li><p>bit 6 = Reserved, must be 0</p></li>
<li><p>bits 5-0 = MSB of address of the tilemap in Bank 5 (16k) or 7 (8k) ($2C on reset)</p></li>
</ul>
<p>Soft Reset default $2C - This is because the address is $6C00 so the MSB is $6C. But the stored value is only the lower 6 bits so it’s an offset into the 16k Bank 5. To calculate therefore subtract $40 leaving you with $2C.</p>
<p>The value written is an offset into the 16k Bank 5 or the 8k lower half of Bank 7 allowinf the tilemap to be placed at any multiple of 256 bytes.</p>
<p>Register (R/W) $6F () <span class="math inline">⇒</span> Layer 3 Tile Definitions Base Address</p>
<ul>
<li><p>bit 7 = Select bank (3.01.08)</p>
<ul>
<li><p>0 = Bank 5</p></li>
<li><p>1 = Bank 7</p></li>
</ul></li>
<li><p>bit 6 = Reserved, must be 0</p></li>
<li><p>bits 5-0 = MSB of address of the tile definitions in Bank 5 (16k) or 7 (8k) ($0C on reset)</p></li>
</ul>
<p>Soft Reset default $0C - This is because the address is $4C00 so the MSB is $4C. But the stored value is only the lower 6 bits so it’s an offset into the 16k Bank 5. To calculate therefore subtract $40 leaving you with $0C.</p>
<p>The value written is an offset into the 16k Bank 5 or the 8k lower half of Bank 7 allowing the tilemap to be placed at any multiple of 256 bytes.</p>
<p>Register (R/W) $70 () <span class="math inline">⇒</span> Layer 2 Control</p>
<ul>
<li><p>bits 7-6 = Reserved, must be 0</p></li>
<li><p>bits 5-4 = Resolution (00 on soft reset)</p>
<ul>
<li><p>00 = <span class="math inline">256 × 192 × 256</span></p></li>
<li><p>01 = <span class="math inline">320 × 256 × 256</span></p></li>
<li><p>10 = <span class="math inline">640 × 256 × 16</span></p></li>
<li><p>11 = Do not use</p></li>
</ul></li>
<li><p>bits 3-0 = Palette offset ($0 on soft reset)</p></li>
</ul>
<p>Register (R/W) $71 () <span class="math inline">⇒</span> Layer 2 X Scroll MSB</p>
<ul>
<li><p>bits 7-1 = Reserved, must be 0</p></li>
<li><p>bits 0 = MSB of X Offset</p></li>
</ul>
<p>Register (W) $75 () <span class="math inline">⇒</span> Sprite Attribute 0 (Auto-incrementing)<br />
See nextreg $35</p>
<p>Register (W) $76 () <span class="math inline">⇒</span> Sprite Attribute 1 (Auto-incrementing)<br />
See nextreg $36</p>
<p>Register (W) $77 () <span class="math inline">⇒</span> Sprite Attribute 2 (Auto-incrementing)<br />
See nextreg $37</p>
<p>Register (W) $78 () <span class="math inline">⇒</span> Sprite Attribute 3 (Auto-incrementing)<br />
See nextreg $38</p>
<p>Register (W) $79 () <span class="math inline">⇒</span> Sprite Attribute 4 (Auto-incrementing)<br />
See nextreg $39</p>
<p>Register (R/W) $7F () <span class="math inline">⇒</span> User Register 0</p>
<ul>
<li><p>bits 7-0 = User Register ($FF on hard reset)</p></li>
</ul>
<p>Caution NextReg numbers above $7F are inaccessible to the Copper</p>
<p>Register (R/W) $80 () <span class="math inline">⇒</span> Expansion Bus Enable<br />
Immediate</p>
<ul>
<li><p>bit 7 = Expansion Bus Enable (0 on hard reset)(3.01.07)</p></li>
<li><p>bit 6 = Enable ROMCS ROM replacement from divmmc banks 14/15 (experimental, 3.01.03)</p></li>
<li><p>bit 5 = I/O cycle Disable/Ignore <span class="math inline">$\overline{\hbox{IORQULA}}$</span> (0 on hard reset)</p></li>
<li><p>bit 4 = Memory cycle Disable/Ignore <span class="math inline">$\overline{\hbox{ROMCS}}$</span> (0 on hard reset)</p></li>
</ul>
<p>After Soft Reset (Copied into bits 7-4)</p>
<ul>
<li><p>bit 3 = Expansion Bus Enable (0 on hard reset)</p></li>
<li><p>bit 2 = Enable ROMCS ROM replacement from divmmc banks 14/15 (experimental, 3.01.03)</p></li>
<li><p>bit 1 = I/O cycle Disable/Ignore <span class="math inline">$\overline{\hbox{IORQULA}}$</span> (0 on hard reset)</p></li>
<li><p>bit 0 = Memory cycle Disable/Ignore <span class="math inline">$\overline{\hbox{ROMCS}}$</span> (0 on hard reset)</p></li>
</ul>
<p>Register (R/W) $81 () <span class="math inline">⇒</span> Expansion Bus Control</p>
<ul>
<li><p>bit 7 = (R) Expansion bus <span class="math inline">$\overline{\hbox{ROMCS}}$</span> asserted</p></li>
<li><p>bit 6 = Allow peripherials to override the ULA on some even port reads ($00-$0E)(Rotoronics Wafadrive)(3.01.07)</p></li>
<li><p>bit 5 = Disable expansion bus NMI debounce (Opus Discovery)(3.01.07)</p></li>
<li><p>bit 4 = (W) Propagate max CPU clock at all times (0 on hard reset)</p></li>
<li><p>bits 3-2 = Reserved, must be 0</p></li>
<li><p>bits 1-0 = Max CPU Speed when Expansion Bus is enabled ($00 on hard reset, currently fixed at $00)</p>
<ul>
<li><p>00 = 3.5 MHz</p></li>
<li><p>01 = 7 MHz</p></li>
<li><p>10 = 14 MHz</p></li>
<li><p>11 = 28 MHz</p></li>
</ul></li>
</ul>
<p>Register (R/W) $82 () <span class="math inline">⇒</span> Internal Port decoding control 1/4</p>
<ul>
<li><p>bit 7 = Enable Kempston Port 2 (Port $37) (1 on reset)</p></li>
<li><p>bit 6 = Enable Kempston Port 1 (Port $1F) (1 on reset)</p></li>
<li><p>bit 5 = Enable DMA (Port $6B) (1 on reset)</p></li>
<li><p>bit 4 = Enable +3 Floating Bus (1 on reset)</p></li>
<li><p>bit 3 = Enable +3 Paging (Port $1FFD) (1 on reset)</p></li>
<li><p>bit 2 = Enable Next Memory Paging (Port $DFFD) (1 on reset)</p></li>
<li><p>bit 1 = Enable Paging (Port $7FFD) (1 on reset)</p></li>
<li><p>bit 0 = Enable Timex (Port $FF) (1 on reset)</p></li>
</ul>
<p>Register (R/W) $83 () <span class="math inline">⇒</span> Internal Port decoding control 2/4</p>
<ul>
<li><p>bit 7 = Enable Layer 2 (Port $123B) (1 on reset)</p></li>
<li><p>bit 6 = Enable Sprites (Ports $57, $5B, $303B) (1 on reset)</p></li>
<li><p>bit 5 = Enable Kempston Mouse (Ports $FADF, $FBDF, $FFDF) (1 on reset)</p></li>
<li><p>bit 4 = Enable UART (Ports $133B, $143B, $153B) (1 on reset)</p></li>
<li><p>bit 3 = Enable SPI (Ports $E7, $EB) (1 on reset)</p></li>
<li><p>bit 2 = Enable I<sup>2</sup>C (Ports $103B, $113B) (1 on reset)</p></li>
<li><p>bit 1 = Enable Multiface (two variable ports) (1 on reset)</p></li>
<li><p>bit 0 = Enable divMMC (Port $E3) (1 on reset)</p></li>
</ul>
<p>Register (R/W) $84 () <span class="math inline">⇒</span> Internal Port decoding control 3/4</p>
<ul>
<li><p>bit 7 = Enable SPECdrum Mono DAC (Port $DF) (1 on reset)</p></li>
<li><p>bit 6 = Enable Covox/GS Mono DAC (Port $B3) (1 on reset)</p></li>
<li><p>bit 5 = Enable Pentagon/ATM DAC (Port $FB) (1 on reset)</p></li>
<li><p>bit 4 = Enable Covox Stereo DAC (Ports $0F, $4F) (1 on reset)</p></li>
<li><p>bit 3 = Enable Profi/Covox Stereo DAC (Ports $3F, $5F) (1 on reset)</p></li>
<li><p>bit 2 = Enable Soundrive DAC Mode 2 (Ports $F1, $F3, $F9, $FB) (1 on reset)</p></li>
<li><p>bit 1 = Enable Soundrive DAC Mode 1 (Ports $0F, $1F, $4F, $5F) (1 on reset)</p></li>
<li><p>bit 0 = Enable AY (Ports $FFFD, $BFFD) (1 on reset)</p></li>
</ul>
<p>Register (R/W) $85 () <span class="math inline">⇒</span> Internal Port decoding control 4/4</p>
<ul>
<li><p>bit 7 = Enable configuration of port decoding on soft reset (3.01.01)</p></li>
<li><p>bits 6-4 = Reserved</p></li>
<li><p>bit 3 = Enable Z80 CTC ports $183B, $193B, $1A3B, $1B3B, $1C3B, $1D3B, $1E3B, and $1F3B</p></li>
<li><p>bit 2 = Enable Pentagon 1024 memory port $EFF7</p></li>
<li><p>bit 1 = Enable DMA port $0B (3.01.02)</p></li>
<li><p>bit 0 = Enable ULAplus (Ports $BF3B, $FF3B) (1 on reset)</p></li>
</ul>
<p>Register (R/W) $86 () <span class="math inline">⇒</span> Expansion Port decoding control 1/4</p>
<ul>
<li><p>bit 7 = Enable Kempston Port 2 (Port $37) (1 on reset)</p></li>
<li><p>bit 6 = Enable Kempston Port 1 (Port $1F) (1 on reset)</p></li>
<li><p>bit 5 = Enable DMA (Port $6B) (1 on reset)</p></li>
<li><p>bit 4 = Enable +3 Floating Bus (1 on reset)</p></li>
<li><p>bit 3 = Enable +3 Paging (Port $1FFD) (1 on reset)</p></li>
<li><p>bit 2 = Enable Next Memory Paging (Port $DFFD) (1 on reset)</p></li>
<li><p>bit 1 = Enable Paging (Port $7FFD) (1 on reset)</p></li>
<li><p>bit 0 = Enable Timex (Port $FF) (1 on reset)</p></li>
</ul>
<p>Register (R/W) $87 () <span class="math inline">⇒</span> Expansion Port decoding control 2/4</p>
<ul>
<li><p>bit 7 = Enable Layer 2 (Port $123B) (1 on reset)</p></li>
<li><p>bit 6 = Enable Sprites (Ports $57, $5B, $303B) (1 on reset)</p></li>
<li><p>bit 5 = Enable Kempston Mouse (Ports $FADF, $FBDF, $FFDF) (1 on reset)</p></li>
<li><p>bit 4 = Enable UART (Ports $133B, $143B, $153B) (1 on reset)</p></li>
<li><p>bit 3 = Enable SPI (Ports $E7, $EB) (1 on reset)</p></li>
<li><p>bit 2 = Enable I<sup>2</sup>C (Ports $103B, $113B) (1 on reset)</p></li>
<li><p>bit 1 = Enable Multiface (two variable ports) (1 on reset)</p></li>
<li><p>bit 0 = Enable divMMC (Port $E3) (1 on reset)</p></li>
</ul>
<p>Register (R/W) $88 () <span class="math inline">⇒</span> Expansion Port decoding control 3/4</p>
<ul>
<li><p>bit 7 = Enable SPECdrum Mono DAC (Port $DF) (1 on reset)</p></li>
<li><p>bit 6 = Enable Covox/GS Mono DAC (Port $B3) (1 on reset)</p></li>
<li><p>bit 5 = Enable Pentagon/ATM DAC (Port $FB) (1 on reset)</p></li>
<li><p>bit 4 = Enable Covox Stereo DAC (Ports $0F, $4F) (1 on reset)</p></li>
<li><p>bit 3 = Enable Profi/Covox Stereo DAC (Ports $3F, $5F) (1 on reset)</p></li>
<li><p>bit 2 = Enable Soundrive DAC Mode 2 (Ports $F1, $F3, $F9, $FB) (1 on reset)</p></li>
<li><p>bit 1 = Enable Soundrive DAC Mode 1 (Ports $0F, $1F, $4F, $5F) (1 on reset)</p></li>
<li><p>bit 0 = Enable AY (Ports $FFFD, $BFFD) (1 on reset)</p></li>
</ul>
<p>Register (R/W) $89 () <span class="math inline">⇒</span> Expansion Port decoding control 4/4</p>
<ul>
<li><p>bit 7 = Enable configuration of port decoding on soft reset (3.01.01)</p></li>
<li><p>bits 6-4 = Reserved</p></li>
<li><p>bit 3 = Enable Z80 CTC ports $183B, $193B, $1A3B, $1B3B, $1C3B, $1D3B, $1E3B, and $1F3B</p></li>
<li><p>bit 2 = Enable Pentagon 1024 memory port $EFF7</p></li>
<li><p>bit 1 = Enable DMA port $0B (3.01.02)</p></li>
<li><p>bit 0 = Enable ULAplus (Ports $BF3B, $FF3B) (1 on reset)</p></li>
</ul>
<p>The Internal Port Decoding Enables always apply.</p>
<p>When the Expansion Bus is enabled, the Expansion Bus Port Decoding Enables are logically ANDed with the Internal Enables. A result of 0 for the corresponding bit indicates the internal device is <em>disabled</em>. If the Expansion Bus is enabled, this allows I/O cycles for disabled ports to propagate to the Expansion Bus, otherwise corresponding I/O cycles to the Expansion Bus are filtered.</p>
<p>Register (R/W) $8A () <span class="math inline">⇒</span> Expansion Bus I/O Propagate Control</p>
<ul>
<li><p>bits 7-3 = Reserved, must be 0</p></li>
<li><p>bit 4 = Propagate port $FF I/O Cycles (0 on hard reset, 3.01.02)</p></li>
<li><p>bit 3 = Propagate port $1FFD I/O Cycles (0 on hard reset)</p></li>
<li><p>bit 2 = Propagate port $DFFD I/O Cycles (0 on hard reset)</p></li>
<li><p>bit 1 = Propagate port $7FFD I/O Cycles (0 on hard reset)</p></li>
<li><p>bit 0 = Propagate port $FE I/O Cycles (1 on hard reset, 3.01.03: 0 on hard reset)</p></li>
</ul>
<p>Register (R/W) $8C () <span class="math inline">⇒</span> Alternate ROM<br />
Immediate</p>
<ul>
<li><p>bit 7 = Alt ROM Enable (0 on hard reset)</p></li>
<li><p>bit 6 = Alt ROM visible ONLY during writes (0 on hard reset)</p></li>
<li><p>bit 5 = Reserved, must be 0</p></li>
<li><p>bit 4 = 48k ROM Lock (0 on hard reset)</p></li>
</ul>
<p>After Soft Reset (copied into bits 7-4)</p>
<ul>
<li><p>bit 3 = Alt ROM Enable (0 on hard reset)</p></li>
<li><p>bit 2 = Alt ROM visible ONLY during writes (0 on hard reset)</p></li>
<li><p>bit 1 = Reserved, must be 0</p></li>
<li><p>bit 0 = 48k ROM Lock (0 on hard reset)</p></li>
</ul>
<p>Register (R/W) $8E () <span class="math inline">⇒</span> Spectrum 128k Memory Mapping (3.01.01)</p>
<ul>
<li><p>bit 7 = Bank number bit 3 (port $dffd bit 0)</p></li>
<li><p>bit 6-4 = Bank number bits 2-0 (port $7ffd bits 2-0)</p></li>
<li><p>bit 3 = Enable change ram page (read as 1)</p></li>
<li><p>bit 2 = Paging mode (port $1ffd bit 0)</p>
<ul>
<li><p>0 = Normal paging mode</p></li>
<li><p>1 = Special paging mode (lot bit of memory configuration)</p></li>
</ul></li>
<li><p>Normal Paging Mode</p></li>
<li><p>bits 1-0 = ROM selection (port $1ffd bit 1 and $7ffd bit 4)</p></li>
<li><p>Special (all RAM) Paging Mode</p></li>
<li><p>bits 1-0 = RAM configuration selection (port $1ffd bits 2-1)</p></li>
</ul>
<p>Writes can affect all ports $7ffd, $dffd, and $1ffd<br />
Writes can always change the ROM/allRAM mapping<br />
Writes immediately change the current MMU mapping as if by port write.</p>
<p>Register (R/W) $8F () <span class="math inline">⇒</span> Memory Mapping Mode (3.01.06)</p>
<ul>
<li><p>bits 7-2 = Reserved, must be zero</p></li>
<li><p>bits 1-0 = Mapping mode applied</p>
<ul>
<li><p>00 = Standard ZX 128k +3</p></li>
<li><p>01 = Profi (removed in 3.01.09)</p></li>
<li><p>10 = Pentagon 512k</p></li>
<li><p>11 = Pentagon 1024k (limited to 768k on 1MB machines)</p></li>
</ul></li>
</ul>
<p>* Standard ZX 128k +3 = principally ports $7FFD, $DFFD, and $1FFD<br />
* Pentagon 512k = principally port $7FFD<br />
* Pentagon 1024k = principally ports $7FFD and $EFF7<br />
** The mapping modes affect how ports $7FFD, $DFFD, $1FFD, and $EFF7 carry out memory paging, see ports</p>
<p>Register (R/W) $90 () <span class="math inline">⇒</span> Pi GPIO output enable 1/4</p>
<ul>
<li><p>bit 7 = Enable Pin 7 (0 on reset)</p></li>
<li><p>bit 6 = Enable Pin 6 (0 on reset)</p></li>
<li><p>bit 5 = Enable Pin 5 (0 on reset)</p></li>
<li><p>bit 4 = Enable Pin 4 (0 on reset)</p></li>
<li><p>bit 3 = Enable Pin 3 (0 on reset)</p></li>
<li><p>bit 2 = Enable Pin 2 (0 on reset)</p></li>
<li><p>bit 1 = Enable Pin 1 (cannot be enabled) (0 on reset)</p></li>
<li><p>bit 0 = Enable Pin 0 (cannot be enabled) (0 on reset)</p></li>
</ul>
<p>Register (R/W) $91 () <span class="math inline">⇒</span> Pi GPIO output enable 2/4</p>
<ul>
<li><p>bit 7 = Enable Pin 15 (0 on reset)</p></li>
<li><p>bit 6 = Enable Pin 14 (0 on reset)</p></li>
<li><p>bit 5 = Enable Pin 13 (0 on reset)</p></li>
<li><p>bit 4 = Enable Pin 12 (0 on reset)</p></li>
<li><p>bit 3 = Enable Pin 11 (0 on reset)</p></li>
<li><p>bit 2 = Enable Pin 10 (0 on reset)</p></li>
<li><p>bit 1 = Enable Pin 9 (0 on reset)</p></li>
<li><p>bit 0 = Enable Pin 8 (0 on reset)</p></li>
</ul>
<p>Register (R/W) $92 () <span class="math inline">⇒</span> Pi GPIO output enable 3/4</p>
<ul>
<li><p>bit 7 = Enable Pin 23 (0 on reset)</p></li>
<li><p>bit 6 = Enable Pin 22 (0 on reset)</p></li>
<li><p>bit 5 = Enable Pin 21 (0 on reset)</p></li>
<li><p>bit 4 = Enable Pin 20 (0 on reset)</p></li>
<li><p>bit 3 = Enable Pin 19 (0 on reset)</p></li>
<li><p>bit 2 = Enable Pin 18 (0 on reset)</p></li>
<li><p>bit 1 = Enable Pin 17 (0 on reset)</p></li>
<li><p>bit 0 = Enable Pin 16 (0 on reset)</p></li>
</ul>
<p>Register (R/W) $93 () <span class="math inline">⇒</span> Pi GPIO output enable 4/4</p>
<ul>
<li><p>bits 7-4 = Reserved</p></li>
<li><p>bit 3 = Enable Pin 27 (0 on reset)</p></li>
<li><p>bit 2 = Enable Pin 26 (0 on reset)</p></li>
<li><p>bit 1 = Enable Pin 25 (0 on reset)</p></li>
<li><p>bit 0 = Enable Pin 24 (0 on reset)</p></li>
</ul>
<p>Register (R/W) $98 () <span class="math inline">⇒</span> Pi GPIO Pin State 1/4</p>
<ul>
<li><p>bit 7 = Pin 7 Data (1 on reset)</p></li>
<li><p>bit 6 = Pin 6 Data (1 on reset)</p></li>
<li><p>bit 5 = Pin 5 Data (1 on reset)</p></li>
<li><p>bit 4 = Pin 4 Data (1 on reset)</p></li>
<li><p>bit 3 = Pin 3 Data (1 on reset)</p></li>
<li><p>bit 2 = Pin 2 Data (1 on reset)</p></li>
<li><p>bit 1 = Pin 1 Data (1 on reset)</p></li>
<li><p>bit 0 = Pin 0 Data (1 on reset)</p></li>
</ul>
<p>Register (R/W) $99 () <span class="math inline">⇒</span> Pi GPIO Pin State 2/4</p>
<ul>
<li><p>bit 7 = Pin 15 Data (1 on reset)</p></li>
<li><p>bit 6 = Pin 14 Data (1 on reset)</p></li>
<li><p>bit 5 = Pin 13 Data (1 on reset)</p></li>
<li><p>bit 4 = Pin 12 Data (1 on reset)</p></li>
<li><p>bit 3 = Pin 11 Data (1 on reset)</p></li>
<li><p>bit 2 = Pin 10 Data (1 on reset)</p></li>
<li><p>bit 1 = Pin 9 Data (1 on reset)</p></li>
<li><p>bit 0 = Pin 8 Data (1 on reset)</p></li>
</ul>
<p>Register (R/W) $9A () <span class="math inline">⇒</span> Pi GPIO Pin State 3/4</p>
<ul>
<li><p>bit 7 = Pin 23 Data (1 on reset)</p></li>
<li><p>bit 6 = Pin 22 Data (1 on reset)</p></li>
<li><p>bit 5 = Pin 21 Data (1 on reset)</p></li>
<li><p>bit 4 = Pin 20 Data (1 on reset)</p></li>
<li><p>bit 3 = Pin 19 Data (1 on reset)</p></li>
<li><p>bit 2 = Pin 18 Data (1 on reset)</p></li>
<li><p>bit 1 = Pin 17 Data (1 on reset)</p></li>
<li><p>bit 0 = Pin 16 Data (1 on reset)</p></li>
</ul>
<p>Register (R/W) $9B () <span class="math inline">⇒</span> Pi GPIO Pin State 4/4</p>
<ul>
<li><p>bits 7-4 = Reserved</p></li>
<li><p>bit 3 = Pin 27 Data (1 on reset)</p></li>
<li><p>bit 2 = Pin 26 Data (1 on reset)</p></li>
<li><p>bit 1 = Pin 25 Data (1 on reset)</p></li>
<li><p>bit 0 = Pin 24 Data (1 on reset)</p></li>
</ul>
<p>Register (R/W) $A0 () <span class="math inline">⇒</span> Pi Peripheral Enable</p>
<ul>
<li><p>bits 7-6 = Reserved, must be 0</p></li>
<li><p>bit 5 = Enable UART on GPIO 14, 15 (0 on reset)*</p></li>
<li><p>bit 4 = Communication Type (0 on reset)</p>
<ul>
<li><p>0 = Rx to GPIO 15, Tx to GPIO 14 (Pi)</p></li>
<li><p>1 = Rx to GPIO 14, Tx to GPIO 15 (Pi Hats)</p></li>
</ul></li>
<li><p>bit 3 = Enable I<sup>2</sup>C on GPIO 2, 3 (0 on reset)*</p></li>
<li><p>bits 2-1 = Reserved, must be 0</p></li>
<li><p>bit 0 = Enable SPI on GPIO 7, 8, 9, 10, 11 (0 on reset)*</p></li>
</ul>
<p>*Overrides GPIO Enables</p>
<p>Register (R/W) $A2 () <span class="math inline">⇒</span> Pi I<sup>2</sup>S Audio Control</p>
<ul>
<li><p>bits 7-6 = I<sup>2</sup>S State ($00 on reset)</p>
<ul>
<li><p>00 = I<sup>2</sup>S Disabled</p></li>
<li><p>01 = I<sup>2</sup>S is mono, source R</p></li>
<li><p>10 = I<sup>2</sup>S is mono, source L</p></li>
<li><p>11 = I<sup>2</sup>S is stereo</p></li>
</ul></li>
<li><p>bit 5 = Reserved, must be 0</p></li>
<li><p>bit 4 = Audio Flow Direction (0 on reset)</p>
<ul>
<li><p>0 = PCM_DOUT to Pi, PCM_DIN from Pi (Hats)</p></li>
<li><p>1 = PCM_DOUT from Pi, PCM_DIN to Pi (Pi)</p></li>
</ul></li>
<li><p>bit 3 = Mute left (0 on reset)</p></li>
<li><p>bit 2 = Mute right (0 on reset)</p></li>
<li><p>bit 1 = Slave mode, Reserved must be 1 (remove in 3.01.05)</p></li>
<li><p>bit 0 = Direct I<sup>2</sup>S audio to EAR on port $FE (0 on reset)</p></li>
</ul>
<p>Register (R/W) $A3 () <span class="math inline">⇒</span> Pi I<sup>2</sup>S Clock Divide (Master Mode) (removed in 3.01.05)</p>
<ul>
<li><p>bits 7-0 = Clock divide value ($0B on reset)</p></li>
</ul>
<p><span class="math inline">$\hbox{Divider}=\frac{538461}{\hbox{Rate}}-1$</span> or <span class="math inline">$\hbox{Rate}=\frac{538461}{\hbox{Divider}+1}$</span></p>
<p>Register (R/W) $A8 () <span class="math inline">⇒</span> ESP WiFi GPIO Output Enable</p>
<ul>
<li><p>bits 7-3 = Reserved, must be sero</p></li>
<li><p>bit 2 = GPIO2 output enable (fixed at 0, GPIO2 is read-only)</p></li>
<li><p>bit 1 = Reserved, must be zero</p></li>
<li><p>bit 0 = GPIO0 output enable (fixed at 0, GPIO2 is read-only)</p></li>
</ul>
<p>Register (R/W) $A9 () <span class="math inline">⇒</span> ESP WiFi GPIO</p>
<ul>
<li><p>bits 7-3 = Reserved, must be sero</p></li>
<li><p>bit 2 = Read/Write GPIO2 (reset = 1)</p></li>
<li><p>bit 1 = Reserved, must be zero</p></li>
<li><p>bit 0 = Read/Write GPIO0 (reset = 1)</p></li>
</ul>
<p>Register (R) $B0 () <span class="math inline">⇒</span> Extended Keys 0 (3.01.04)</p>
<ul>
<li><p>bit 7 = 1 if ; pressed</p></li>
<li><p>bit 6 = 1 if p̈ressed</p></li>
<li><p>bit 5 = 1 if , pressed</p></li>
<li><p>bit 4 = 1 if . pressed</p></li>
<li><p>bit 3 = 1 if UP pressed</p></li>
<li><p>bit 2 = 1 if DOWN pressed</p></li>
<li><p>bit 1 = 1 if LEFT pressed</p></li>
<li><p>bit 0 = 1 if RIGHT pressed</p></li>
</ul>
<p>Register (R) $B1 () <span class="math inline">⇒</span> Extended Keys 1 (3.01.04)</p>
<ul>
<li><p>bit 7 = 1 if DELETE pressed</p></li>
<li><p>bit 6 = 1 if EDIT pressed</p></li>
<li><p>bit 5 = 1 if BREAK pressed</p></li>
<li><p>bit 4 = 1 if INV VIDEO pressed</p></li>
<li><p>bit 3 = 1 if TRUE VIDEO pressed</p></li>
<li><p>bit 2 = 1 if GRAPH pressed</p></li>
<li><p>bit 1 = 1 if CAPS LOCK pressed</p></li>
<li><p>bit 0 = 1 if EXTEND pressed</p></li>
</ul>
<p>Register (R/W) $C0 () <span class="math inline">⇒</span> Interrupt Control (3.01.09)<br />
($00 on reset)</p>
<ul>
<li><p>bits 7-5 = Programmable portion of IM2 vector *</p></li>
<li><p>bit 4 = Reserved, must be 0</p></li>
<li><p>bit 3 = Enable stackless <span class="math inline">$\overline{\hbox{NMI}}$</span> response</p></li>
<li><p>bits 2-1 = Reserved, must be 0</p></li>
<li><p>bit 0 = Maskable interrupt mode</p>
<ul>
<li><p>0 - pulse</p></li>
<li><p>1 - IM2</p></li>
</ul></li>
</ul>
<p>* In IM2 mode vector generated is:</p>
<ul>
<li><p>bits 7-5 = nextreg $C0 bits 7-5</p></li>
<li><p>bits 4-1 = Interrupt source</p>
<ul>
<li><p>0 - line interrupt (highest priority)</p></li>
<li><p>1 - UART 0 Rx</p></li>
<li><p>2 - UART 1 Rx</p></li>
<li><p>3–10 - CTC channels 0-7</p></li>
<li><p>11 - ULA</p></li>
<li><p>12 - UART 0 Tx</p></li>
<li><p>13 - UART 1 Tx (lowest priority)</p></li>
</ul></li>
<li><p>bit 0 = 0</p></li>
</ul>
<p>Register (R/W) $C2 () <span class="math inline">⇒</span> <span class="math inline">$\overline{\hbox{NMI}}$</span> Return Address LSB (3.01.09)<br />
($00 on reset)</p>
<p>Register (R/W) $C3 () <span class="math inline">⇒</span> <span class="math inline">$\overline{\hbox{NMI}}$</span> Return Address MSB (3.01.09)<br />
($00 on reset)</p>
<p>Register (R/W) $C4 () <span class="math inline">⇒</span> Interrupt Enable 0 (3.01.08)<br />
($83 on reset)</p>
<ul>
<li><p>bit 7 = Expansion bus <span class="math inline">$\overline{\hbox{INT}}$</span></p></li>
<li><p>bits 6-2 = Reserved must be zero</p></li>
<li><p>bit 1 = Line</p></li>
<li><p>bit 0 = ULA</p></li>
</ul>
<p>Register (R/W) $C5 () <span class="math inline">⇒</span> Interrupt Enable 1 (3.01.08)<br />
($00 on reset)</p>
<ul>
<li><p>bit 7 = ctc channel 7 zc/to</p></li>
<li><p>bit 6 = ctc channel 6 zc/to</p></li>
<li><p>bit 5 = ctc channel 5 zc/to</p></li>
<li><p>bit 4 = ctc channel 4 zc/to</p></li>
<li><p>bit 3 = ctc channel 3 zc/to</p></li>
<li><p>bit 2 = ctc channel 2 zc/to</p></li>
<li><p>bit 1 = ctc channel 1 zc/to</p></li>
<li><p>bit 0 = ctc channel 0 zc/to</p></li>
</ul>
<p>Register (W) $C6 () <span class="math inline">⇒</span> Interrupt Enable 2 (3.01.08)<br />
($00 on reset)</p>
<ul>
<li><p>bit 7 = Reserved, must be 0</p></li>
<li><p>bit 6 = UART1 Tx empty</p></li>
<li><p>bit 5 = UART1 Rx half full *</p></li>
<li><p>bit 4 = UART1 Rx available *</p></li>
<li><p>bit 3 = Reserved, must be 0</p></li>
<li><p>bit 2 = UART0 Tx empty</p></li>
<li><p>bit 1 = UART0 Rx half full *</p></li>
<li><p>bit 0 = UART0 Rx available *</p></li>
</ul>
<p>* For each UART, Rx half full and Rx available are shared interrupts</p>
<p>Register (W) $C7 () <span class="math inline">⇒</span> Reserved (3.01.09)</p>
<p>Register (R/W) $C8 () <span class="math inline">⇒</span> Interrupt Status 0 (3.01.09)<br />
($00 on reset)</p>
<ul>
<li><p>bits 7-2 = Reserved, must be zero</p></li>
<li><p>bit 1 = Line</p></li>
<li><p>bit 0 = ULA</p></li>
</ul>
<p>* Set bits indicate the device generated an interrupt in the past * Writes clear bits where bits are set except in IM2 mode</p>
<p>Register (R/W) $C9 () <span class="math inline">⇒</span> Interrupt Status 1 (3.01.09)</p>
<ul>
<li><p>bit 7 = ctc channel 7 zc/to</p></li>
<li><p>bit 6 = ctc channel 6 zc/to</p></li>
<li><p>bit 5 = ctc channel 5 zc/to</p></li>
<li><p>bit 4 = ctc channel 4 zc/to</p></li>
<li><p>bit 3 = ctc channel 3 zc/to</p></li>
<li><p>bit 2 = ctc channel 2 zc/to</p></li>
<li><p>bit 1 = ctc channel 1 zc/to</p></li>
<li><p>bit 0 = ctc channel 0 zc/to</p></li>
</ul>
<p>* Set bits indicate the device generated an interrupt in the past * Writes clear bits where bits are set except in IM2 mode</p>
<p>Register (R/W) $CA () <span class="math inline">⇒</span> Interrupt Status 2 (3.01.09) ($00 on reset)</p>
<ul>
<li><p>bit 7 = Reserved, must be zero</p></li>
<li><p>bit 6 = UART1 Tx empty</p></li>
<li><p>bit 5 = UART1 Rx almost full *</p></li>
<li><p>bit 4 = UART1 Rx available *</p></li>
<li><p>bit 3 = Reserved must be zero</p></li>
<li><p>bit 2 = UART0 Tx empty</p></li>
<li><p>bit 1 = UART0 Rx almost full *</p></li>
<li><p>bit 0 = UART0 Rx available *</p></li>
</ul>
<p>* For each UART Rx half full and Rx available are shared interrupts ** Set bits indicate the device generated an interrupt in the past ** Writes clear bits where bits are set except in IM2 mode</p>
<p>Register (W) $CB () <span class="math inline">⇒</span> Reserved (3.01.09)</p>
<p>Register (R/W) $CC () <span class="math inline">⇒</span> DMA Interrupt Enable 0 (3.01.09) ($00 on reset)</p>
<ul>
<li><p>bits 7-2 = Reserved, must be 0</p></li>
<li><p>bit 1 = Line</p></li>
<li><p>bit 0 = ULA</p></li>
</ul>
<p>* Set bits indicate the specified interrupt will interrupt a DMA operation when in IM2 mode</p>
<p>Register (R/W) $CD () <span class="math inline">⇒</span> DMA Interrupt Enable 1 (3.01.09) ($00 on reset)</p>
<ul>
<li><p>bit 7 = CTC channel 7 zc/to</p></li>
<li><p>bit 6 = CTC channel 6 zc/to</p></li>
<li><p>bit 5 = CTC channel 5 zc/to</p></li>
<li><p>bit 4 = CTC channel 4 zc/to</p></li>
<li><p>bit 3 = CTC channel 3 zc/to</p></li>
<li><p>bit 2 = CTC channel 2 zc/to</p></li>
<li><p>bit 1 = CTC channel 1 zc/to</p></li>
<li><p>bit 0 = CTC channel 0 zc/to</p></li>
</ul>
<p>* Set bits indicate the corresponding interrupt will interrupt a DMA operation when in IM2 mode</p>
<p>Register (R/W) $CE () <span class="math inline">⇒</span> DMA Interrupt Enable 2 (3.01.09) ($00 on reset)</p>
<ul>
<li><p>bit 7 = Reserved, must be 0</p></li>
<li><p>bit 6 = UART1 Tx empty</p></li>
<li><p>bit 5 = UART1 Rx half full</p></li>
<li><p>bit 4 = UART1 Rx available</p></li>
<li><p>bit 3 = Reserved, must be 0</p></li>
<li><p>bit 2 = UART0 Tx empty</p></li>
<li><p>bit 1 = UART0 Tx half full</p></li>
<li><p>bit 0 = UART0 Tx available</p></li>
</ul>
<p>* Set bits indicate the corresponding interrupt will interrupt a DMA operation when in IM2 mode.</p>
<p>Register (W) $CF () <span class="math inline">⇒</span> Reserved (3.01.09)</p>
<p>Register (W) $FF () <span class="math inline">⇒</span> Debug LEDs (DE-1, DE-2 am Multicore only)</p>
<h2 id="ay-3-8912">AY-3-8912</h2>
<p>(R/W) $00 (0) <span class="math inline">⇒</span> Channel A fine tune</p>
<ul>
<li><p>bits 7-0 = Channel A frequency bits 7-0</p></li>
</ul>
<p>(R/W) $01 (1) <span class="math inline">⇒</span> Channel A coarse tune</p>
<ul>
<li><p>bits 7-4 = Reserved</p></li>
<li><p>bits 4-0 = Channel A frequency bits 11-8</p></li>
</ul>
<p>(R/W) $02 (0) <span class="math inline">⇒</span> Channel B fine tune</p>
<ul>
<li><p>bits 7-0 = Channel A frequency bits 7-0</p></li>
</ul>
<p>(R/W) $03 (1) <span class="math inline">⇒</span> Channel B coarse tune</p>
<ul>
<li><p>bits 7-4 = Reserved</p></li>
<li><p>bits 4-0 = Channel A frequency bits 11-8</p></li>
</ul>
<p>(R/W) $04 (0) <span class="math inline">⇒</span> Channel C fine tune</p>
<ul>
<li><p>bits 7-0 = Channel A frequency bits 7-0</p></li>
</ul>
<p>(R/W) $05 (1) <span class="math inline">⇒</span> Channel C coarse tune</p>
<ul>
<li><p>bits 7-4 = Reserved</p></li>
<li><p>bits 4-0 = Channel A frequency bits 11-8</p></li>
</ul>
<p>(R/W) $06 (6) <span class="math inline">⇒</span> Noise period</p>
<ul>
<li><p>bits 7-5 = Reserved</p></li>
<li><p>bits 4-0 = Noise period to noise generator</p></li>
</ul>
<p>(R/W) $07 (7) <span class="math inline">⇒</span> Mixer control I/O Enable</p>
<ul>
<li><p>Active low (0=enable, 1= disable)</p></li>
<li><p>bit 7-6: Reserved</p></li>
<li><p>bit 5: Channel C noise enable</p></li>
<li><p>bit 4: Channel B noise enable</p></li>
<li><p>bit 3: Channel A noise enable</p></li>
<li><p>bit 2: Channel C tone enable</p></li>
<li><p>bit 1: Channel B tone enable</p></li>
<li><p>bit 0: Channel A tone enable</p></li>
</ul>
<p>(R/W) $0A (10) <span class="math inline">⇒</span> Channel A amplitude</p>
<ul>
<li><p>bits 7-5 = Reserved</p></li>
<li><p>bit 4 = Amplitude mode</p>
<ul>
<li><p>0=fixed amplitude</p></li>
<li><p>1=use envelope generator (bits 0-3 ignored)</p></li>
</ul></li>
<li><p>bits 0-3 = value of fixed amplitude</p></li>
</ul>
<p>(R/W) $0B (11) <span class="math inline">⇒</span> Channel B amplitude</p>
<ul>
<li><p>like channel A amplitude</p></li>
</ul>
<p>(R/W) $0C (12) <span class="math inline">⇒</span> Channel C amplitude</p>
<ul>
<li><p>like channel A amplitude</p></li>
</ul>
<p>(R/W) $0D (13) <span class="math inline">⇒</span> Envelope period fine</p>
<ul>
<li><p>bits 7-0 = Envelop period LSB</p></li>
</ul>
<p>(R/W) $0E (14) <span class="math inline">⇒</span> Envelope period coarse</p>
<ul>
<li><p>bits 7-0 = Envelop period MSB</p></li>
</ul>
<p>(R/W) $0F (15) <span class="math inline">⇒</span> Envelope shape</p>
<ul>
<li><p>bits 7-4 = Reserved</p></li>
<li><p>bit 3 = Continue</p>
<ul>
<li><p>0=drop to amplitude 0 after 1 cycle</p></li>
<li><p>1=use ‘Hold’ value</p></li>
</ul></li>
<li><p>bit 2 = Attack</p>
<ul>
<li><p>0=generator counts down</p></li>
<li><p>1=generator counts up</p></li>
</ul></li>
<li><p>bit 1-0 = Alternate &amp; Hold</p>
<ul>
<li><p>00=generator resets after each cycle</p></li>
<li><p>01=hold final value</p></li>
<li><p>10=generator reverses direction each cycle</p></li>
<li><p>11=hold initial value</p></li>
</ul></li>
</ul>
<h2 id="zxdma">zxDMA</h2>
<h1 id="extended-opcodes-to-mnemonics">Extended Opcodes to Mnemonics</h1>
<h2 id="single-byte-opcodes">Single Byte Opcodes</h2>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<h2 id="cbxx-bit-operations">$CBxx Bit Operations</h2>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<h2 id="ddxx-ix">$DDxx IX</h2>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<h2 id="edxx-blockport">$EDxx Block/Port</h2>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p>* ZX Spectrum Next extension</p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p>* ZX Spectrum Next extension</p>
<h2 id="fdxx-iy">$FDxx IY</h2>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<h2 id="ddcbxx-ix-bit-operations">$DDCBxx IX Bit Operations</h2>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<h2 id="fdcbxx-iy-bit-operations">$FDCBxx IY Bit Operations</h2>
<p><span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span></p>
<h1 id="mnemonics-to-extended-opcodes">Mnemonics to Extended Opcodes</h1>
<h1 id="file-formats">File Formats</h1>
<h2 id="aky">AKY</h2>
<p>Music file</p>
<h2 id="bas">BAS</h2>
<p>Basic file</p>
<h2 id="bmp">BMP</h2>
<p>Windows bitmap. On the ZX Spectrum next, these must be uncompressed and 8 bpp.</p>
<h2 id="dsk">DSK</h2>
<p>Disk image</p>
<h2 id="esp">ESP</h2>
<p>Update file for Wi-Fi module</p>
<h2 id="gde">GDE</h2>
<p>ZX Spectrum Next Guide hypertext file</p>
<h2 id="mc">MC</h2>
<p>A Timex hi-color image. Like .shc, but the bitmap and colour map are stored in display order.</p>
<h2 id="mlt">MLT</h2>
<p>A Timex hi-color image. Like .shc, but the colour map is stored in display order.</p>
<h2 id="mod">MOD</h2>
<p>Modtracker music file (requires Pi accelerator to play).</p>
<h2 id="ndr">NDR</h2>
<p>Nexdaw music file</p>
<h2 id="nex">NEX</h2>
<p>ZX Spectrum Next executable file.</p>
<h2 id="nxi">NXI</h2>
<p>A version of a 256x192x8 layer 2 image.</p>
<ul>
<li><p>bytes 0-511 - palette data</p></li>
<li><p>bytes 512-49663 - image data</p></li>
</ul>
<h2 id="o">O</h2>
<p>ZX-80 executable file</p>
<h2 id="p3d">P3D</h2>
<p>Disk image file</p>
<h2 id="pt3">PT3</h2>
<p>Protracker 3 music file</p>
<h2 id="p">P</h2>
<p>ZX-81 executable file</p>
<h2 id="sdh">SDH</h2>
<p>Music file (requires Pi accelerator to play)</p>
<h2 id="sid">SID</h2>
<p>Commodore 64 SID music file (requires Pi accelerator to play)</p>
<h2 id="scr">SCR</h2>
<p>ZX Spectrum screen dump</p>
<p>In basic form a 6912 byte file containing the bitmap and colour map for a standard spectrum image. May have ULAPlus or ULANext color data appended.</p>
<p>ULAplus</p>
<ul>
<li><p>bytes 0-6143 - bitmap: memory order</p></li>
<li><p>bytes 6144-6911 - colour map: memory order</p></li>
<li><p>bytes 6912-6975 - ULAPlus palette data</p></li>
</ul>
<p>ULANext</p>
<ul>
<li><p>bytes 0-6143 - bitmap: memory order</p></li>
<li><p>bytes 6144-6911 - colour map: memory order</p></li>
<li><p>byte 6912 - ULANext mode</p></li>
<li><p>bytes 6913-between 6228 and 7426 - ULANext palette data, size is dependent on specific ULANext mode and 8 or 9 bit palette entries.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">mode</td>
<td style="text-align: right;">ink</td>
<td style="text-align: right;">paper</td>
<td style="text-align: right;">8-bit</td>
<td style="text-align: right;">9-bit</td>
</tr>
<tr class="even">
<td style="text-align: left;">$01</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">128</td>
<td style="text-align: right;">130</td>
<td style="text-align: right;">260</td>
</tr>
<tr class="odd">
<td style="text-align: left;">$03</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">64</td>
<td style="text-align: right;">68</td>
<td style="text-align: right;">136</td>
</tr>
<tr class="even">
<td style="text-align: left;">$07</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">32</td>
<td style="text-align: right;">40</td>
<td style="text-align: right;">80</td>
</tr>
<tr class="odd">
<td style="text-align: left;">$0F</td>
<td style="text-align: right;">16</td>
<td style="text-align: right;">16</td>
<td style="text-align: right;">32</td>
<td style="text-align: right;">64</td>
</tr>
<tr class="even">
<td style="text-align: left;">$1F</td>
<td style="text-align: right;">32</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">40</td>
<td style="text-align: right;">80</td>
</tr>
<tr class="odd">
<td style="text-align: left;">$3F</td>
<td style="text-align: right;">64</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">68</td>
<td style="text-align: right;">136</td>
</tr>
<tr class="even">
<td style="text-align: left;">$7F</td>
<td style="text-align: right;">128</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">130</td>
<td style="text-align: right;">260</td>
</tr>
<tr class="odd">
<td style="text-align: left;">$FF</td>
<td style="text-align: right;">256</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">257</td>
<td style="text-align: right;">514</td>
</tr>
</tbody>
</table></li>
</ul>
<h2 id="shc">SHC</h2>
<p>Timex hi-color screen dump</p>
<p>In basic form the 12,288 byte file containing the bitmap and colour map for a Timex hi-color image. May have ULAPlus or ULANext color data appended.</p>
<p>ULAplus</p>
<ul>
<li><p>bytes 0-6143 - bitmap: memory order</p></li>
<li><p>bytes 6144-12287 - colour map: memory order</p></li>
<li><p>bytes 12288-12351 - ULAPlus palette data</p></li>
</ul>
<p>ULANext</p>
<ul>
<li><p>bytes 0-6143 - bitmap: memory order</p></li>
<li><p>bytes 6144-12287 - colour map: memory order</p></li>
<li><p>byte 12288 - ULANext mode</p></li>
<li><p>bytes 12289-between 12304 and 12802 - ULANext palette data, size is dependent on specific ULANext mode and 8 or 9 bit palette entries.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">mode</td>
<td style="text-align: right;">ink</td>
<td style="text-align: right;">paper</td>
<td style="text-align: right;">8-bit</td>
<td style="text-align: right;">9-bit</td>
</tr>
<tr class="even">
<td style="text-align: left;">$01</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">128</td>
<td style="text-align: right;">130</td>
<td style="text-align: right;">260</td>
</tr>
<tr class="odd">
<td style="text-align: left;">$03</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">64</td>
<td style="text-align: right;">68</td>
<td style="text-align: right;">136</td>
</tr>
<tr class="even">
<td style="text-align: left;">$07</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">32</td>
<td style="text-align: right;">40</td>
<td style="text-align: right;">80</td>
</tr>
<tr class="odd">
<td style="text-align: left;">$0F</td>
<td style="text-align: right;">16</td>
<td style="text-align: right;">16</td>
<td style="text-align: right;">32</td>
<td style="text-align: right;">64</td>
</tr>
<tr class="even">
<td style="text-align: left;">$1F</td>
<td style="text-align: right;">32</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">40</td>
<td style="text-align: right;">80</td>
</tr>
<tr class="odd">
<td style="text-align: left;">$3F</td>
<td style="text-align: right;">64</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">68</td>
<td style="text-align: right;">136</td>
</tr>
<tr class="even">
<td style="text-align: left;">$7F</td>
<td style="text-align: right;">128</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">130</td>
<td style="text-align: right;">260</td>
</tr>
<tr class="odd">
<td style="text-align: left;">$FF</td>
<td style="text-align: right;">256</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">257</td>
<td style="text-align: right;">514</td>
</tr>
</tbody>
</table></li>
</ul>
<h2 id="shr">SHR</h2>
<p>Timex hi-resolution screen dump.</p>
<p>A 12,288 or 12,289 byte file containing a memory dump of the two 6k screen areas used by Timex hi-resolution mode in memory order with an optional byte indicating teh colours used.</p>
<h2 id="sl2">SL2</h2>
<p>ZX Spectrum Next layer 2 screen dump</p>
<p>In its most basic standard form, this is a 49,152 byte file contaning the memory for the image data.</p>
<p>256x192x8</p>
<ul>
<li><p>bytes 0-49151 - image data: row dominant</p></li>
<li><p>optional bytes 49152-49407 or 49663 - palette data (256 bytes for 8-bit entries, 512 bytes for 9-bit entries)</p></li>
</ul>
<p>320x256x8</p>
<ul>
<li><p>bytes 0-81919 - image data: column dominant</p></li>
<li><p>optional bytes 81920-82175 or 82431 - palette data (256 bytes for 8-bit entries, 512 bytes for 9-bit entries)</p></li>
</ul>
<p>640x256x4</p>
<ul>
<li><p>bytes 0-81919 - image data: column dominant, nybbles in adjacent columns</p></li>
<li><p>optional bytes 81920-81935 or 81951 - palette data (16 bytes for 8-bit entries, 32 bytes for 9-bit entries)</p></li>
</ul>
<h2 id="slr">SLR</h2>
<p>ZX Spectrum Next low-resolution screen dump.</p>
<p>Basic standard form 12,288 byte file contaning the memory for the two 6k areas for 128x96x8 image files</p>
<p>192x96x8</p>
<ul>
<li><p>bytes 0-12287 - image data: row dominant</p></li>
<li><p>optional bytes 12288-12543 or 12799 - palette data (256 bytes for 8-bit entries, 512 bytes for 9-bit entries)</p></li>
</ul>
<p>192x96x4 (Radistan)</p>
<ul>
<li><p>bytes 0-6143 - image data: row dominant</p></li>
<li><p>optional bytes 6144-6159 or 6175 - palette data (16 bytes for 8-bit entries, 32 bytes for 9-bit entries)</p></li>
</ul>
<h2 id="sna">SNA</h2>
<p>ZX Spectrum memory snapshot</p>
<h2 id="snd">SND</h2>
<p>Music file (requires Pi accelerator to play)</p>
<h2 id="snx">SNX</h2>
<p>Extended ZX Spectrum memory snapshot to be run in ZX Spectrum Next mode</p>
<h2 id="spr">SPR</h2>
<p>Sprite file</p>
<h2 id="tap">TAP</h2>
<p>ZX Spectrum tape image</p>
<h2 id="txtdocasminicfgmd">TXT,DOC,ASM,INI,CFG,MD</h2>
<p>Text files</p>
<h2 id="tzx">TZX</h2>
<p>ZX Spectrum tape image (able to handle custom tape formats). Requires Pi accelerator to load.</p>
<h2 id="wav">WAV</h2>
<p>PCM audio file</p>
<h2 id="xm">XM</h2>
<p>XM tracker music file (requires Pi accelerator to play)</p>
<h2 id="z3-to-z8">Z3 to Z8</h2>
<p>Inform interactive fiction files</p>
<h2 id="z80">Z80</h2>
<p>ZX Spectrum memory snapshot</p>
<h2 id="zip">ZIP</h2>
<p>Zip compressed file</p>
<h1 id="call-tables">Call Tables</h1>
<h2 id="bdos-call-table">BDOS Call Table</h2>
<h2 id="bios-call-table">BIOS Call Table</h2>
<h2 id="nextzxos-calls">NextZXOS Calls</h2>
<h3 id="dos-compatible-calls">+3DOS Compatible Calls</h3>
<p><strong>Filesystem Calls</strong></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">DOS_VERSION</td>
<td style="text-align: left;">$0103 ()</td>
<td style="text-align: left;">Get +3DOS issue and version numbers</td>
</tr>
<tr class="even">
<td style="text-align: left;">*DOS_OPEN</td>
<td style="text-align: left;">$0106 ()</td>
<td style="text-align: left;">Create and/or open a file</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DOS_CLOSE</td>
<td style="text-align: left;">$0109 ()</td>
<td style="text-align: left;">Close a file</td>
</tr>
<tr class="even">
<td style="text-align: left;">DOS_ABANDON</td>
<td style="text-align: left;">$010C ()</td>
<td style="text-align: left;">Abandon a file</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DOS_REF_HEAD</td>
<td style="text-align: left;">$010F ()</td>
<td style="text-align: left;">Point at the header data for this file</td>
</tr>
<tr class="even">
<td style="text-align: left;">DOS_READ</td>
<td style="text-align: left;">$0112 ()</td>
<td style="text-align: left;">Read bytes into memory</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DOS_WRITE</td>
<td style="text-align: left;">$0115 ()</td>
<td style="text-align: left;">Write bytes from memory</td>
</tr>
<tr class="even">
<td style="text-align: left;">DOS_BYTE_READ</td>
<td style="text-align: left;">$0118 ()</td>
<td style="text-align: left;">Read a byte</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DOS_BYTE_WRITE</td>
<td style="text-align: left;">$011B ()</td>
<td style="text-align: left;">Write a byte</td>
</tr>
<tr class="even">
<td style="text-align: left;">*DOS_CATALOG</td>
<td style="text-align: left;">$011E ()</td>
<td style="text-align: left;">Catalog disk directory</td>
</tr>
<tr class="odd">
<td style="text-align: left;">*DOS_FREE_SPACE</td>
<td style="text-align: left;">$0121 ()</td>
<td style="text-align: left;">Free space on disk</td>
</tr>
<tr class="even">
<td style="text-align: left;">DOS_DELETE</td>
<td style="text-align: left;">$0124 ()</td>
<td style="text-align: left;">Delete a file</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DOS_RENAME</td>
<td style="text-align: left;">$0127 ()</td>
<td style="text-align: left;">Rename a file</td>
</tr>
<tr class="even">
<td style="text-align: left;">DOS_BOOT</td>
<td style="text-align: left;">$012A ()</td>
<td style="text-align: left;">Boot an operating system or other program</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DOS_SET_DRIVE</td>
<td style="text-align: left;">$012D ()</td>
<td style="text-align: left;">Set/get default drive</td>
</tr>
<tr class="even">
<td style="text-align: left;">DOS_SET_USER</td>
<td style="text-align: left;">$0130 ()</td>
<td style="text-align: left;">Set/get default user number</td>
</tr>
<tr class="odd">
<td style="text-align: left;">*DOS_GET_POSITION</td>
<td style="text-align: left;">$0133 ()</td>
<td style="text-align: left;">Get file pointer for random access</td>
</tr>
<tr class="even">
<td style="text-align: left;">DOS_SET_POSITION</td>
<td style="text-align: left;">$0136 ()</td>
<td style="text-align: left;">Set file pointer for random access</td>
</tr>
<tr class="odd">
<td style="text-align: left;">*DOS_GET_EOF</td>
<td style="text-align: left;">$0139 ()</td>
<td style="text-align: left;">Get end of file position for random access</td>
</tr>
<tr class="even">
<td style="text-align: left;">DOS_GET_1346</td>
<td style="text-align: left;">$013C ()</td>
<td style="text-align: left;">Get memory usage in pages 1, 3, 4, 6</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DOS_SET_1346</td>
<td style="text-align: left;">$013F ()</td>
<td style="text-align: left;">Re-allocate memory usage in pages 1, 3, 4, 6</td>
</tr>
<tr class="even">
<td style="text-align: left;">DOS_FLUSH</td>
<td style="text-align: left;">$0142 ()</td>
<td style="text-align: left;">Bring disk up to date</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DOS_SET_ACCESS</td>
<td style="text-align: left;">$0145 ()</td>
<td style="text-align: left;">Change open file’s access mode</td>
</tr>
<tr class="even">
<td style="text-align: left;">DOS_SET_ATTRIBUTES</td>
<td style="text-align: left;">$0148 ()</td>
<td style="text-align: left;">Change a file’s attributes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DOS_SET_MESSAGE</td>
<td style="text-align: left;">$014E ()</td>
<td style="text-align: left;">Enable/disable error messages</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">DD_L_XDPB</td>
<td style="text-align: left;">$0187 ()</td>
<td style="text-align: left;">Initialise an XDPB from a disk specification</td>
</tr>
<tr class="even">
<td style="text-align: left;">DD_L_DPB</td>
<td style="text-align: left;">$018A ()</td>
<td style="text-align: left;">Initialise a DPB from a disk specification</td>
</tr>
</tbody>
</table>
<p><strong>System Calls</strong></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">DOS_INITIALISE</td>
<td style="text-align: left;">$0100 ()</td>
<td style="text-align: left;">Initialise +3DOS</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">IDE_INTERFACE</td>
<td style="text-align: left;">$00A3 ()</td>
<td style="text-align: left;">Initialise card interfaces</td>
</tr>
<tr class="even">
<td style="text-align: left;">IDE_INIT</td>
<td style="text-align: left;">$00A6 ()</td>
<td style="text-align: left;">Initialise IDEDOS</td>
</tr>
<tr class="odd">
<td style="text-align: left;">IDE_DRIVE</td>
<td style="text-align: left;">$00A9 ()</td>
<td style="text-align: left;">Get unit handle</td>
</tr>
<tr class="even">
<td style="text-align: left;">*IDE_SECTOR_READ</td>
<td style="text-align: left;">$00AC ()</td>
<td style="text-align: left;">Low-level sector read</td>
</tr>
<tr class="odd">
<td style="text-align: left;">*IDE_SECTOR_WRITE</td>
<td style="text-align: left;">$00AF ()</td>
<td style="text-align: left;">Low-level sector write</td>
</tr>
<tr class="even">
<td style="text-align: left;">IDE_PARTITON_READ</td>
<td style="text-align: left;">$00C4 ()</td>
<td style="text-align: left;">Read a partition entry</td>
</tr>
<tr class="odd">
<td style="text-align: left;">IDE_PARTITION_OPEN</td>
<td style="text-align: left;">$00CD ()</td>
<td style="text-align: left;">Open a partition</td>
</tr>
<tr class="even">
<td style="text-align: left;">IDE_PARTITION_CLOSE</td>
<td style="text-align: left;">$00D0 ()</td>
<td style="text-align: left;">Close a partition</td>
</tr>
<tr class="odd">
<td style="text-align: left;">IDE_PARTITIONS</td>
<td style="text-align: left;">$01A5 ()</td>
<td style="text-align: left;">Get number of open partitions</td>
</tr>
</tbody>
</table>
<p><strong>Unimplemented Calls</strong></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">DOS_OPEN_DRIVE</td>
<td style="text-align: left;">$014B ()</td>
<td style="text-align: left;">Open a drive as a single file</td>
</tr>
<tr class="even">
<td style="text-align: left;">DOS_MAP_B</td>
<td style="text-align: left;">$0154 ()</td>
<td style="text-align: left;">Map B: onto unit 0 or 1</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">DD_INTERFACE</td>
<td style="text-align: left;">$0157 ()</td>
<td style="text-align: left;">Is the floppy disk driver interface present?</td>
</tr>
<tr class="even">
<td style="text-align: left;">DD_INIT</td>
<td style="text-align: left;">$015A ()</td>
<td style="text-align: left;">Initialise disk driver</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DD_SETUP</td>
<td style="text-align: left;">$015D ()</td>
<td style="text-align: left;">Specify drive parameters</td>
</tr>
<tr class="even">
<td style="text-align: left;">DD_SET_RETRY</td>
<td style="text-align: left;">$0160 ()</td>
<td style="text-align: left;">Set try/retry count</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DD_READ_SECTOR</td>
<td style="text-align: left;">$0163 ()</td>
<td style="text-align: left;">Read a sector</td>
</tr>
<tr class="even">
<td style="text-align: left;">DD_WRITE_SECTOR</td>
<td style="text-align: left;">$0166 ()</td>
<td style="text-align: left;">Write a sector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DD_CHECK_SECTOR</td>
<td style="text-align: left;">$0169 ()</td>
<td style="text-align: left;">Check a sector</td>
</tr>
<tr class="even">
<td style="text-align: left;">DD_FORMAT</td>
<td style="text-align: left;">$016C ()</td>
<td style="text-align: left;">Format a track</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DD_READ_ID</td>
<td style="text-align: left;">$016F ()</td>
<td style="text-align: left;">Read a sector identifier</td>
</tr>
<tr class="even">
<td style="text-align: left;">DD_TEST_UNSUITABLE</td>
<td style="text-align: left;">$0172 ()</td>
<td style="text-align: left;">Test media suitability</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DD_LOGIN</td>
<td style="text-align: left;">$0175 ()</td>
<td style="text-align: left;">Log in disk, initialise XDPB</td>
</tr>
<tr class="even">
<td style="text-align: left;">DD_SEL_FORMAT</td>
<td style="text-align: left;">$0178 ()</td>
<td style="text-align: left;">Pre-initialise XDPB for DD FORMAT</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DD_ASK_1</td>
<td style="text-align: left;">$017B ()</td>
<td style="text-align: left;">Is unit 1 &amp; external drive &amp; present?</td>
</tr>
<tr class="even">
<td style="text-align: left;">DD_DRIVE_STATUS</td>
<td style="text-align: left;">$017E ()</td>
<td style="text-align: left;">Fetch drive status</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DD_EQUIPMENT</td>
<td style="text-align: left;">$0181 ()</td>
<td style="text-align: left;">What type of drive?</td>
</tr>
<tr class="even">
<td style="text-align: left;">DD_ENCODE</td>
<td style="text-align: left;">$0184 ()</td>
<td style="text-align: left;">Set intercept routine for copy protection</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DD_L_SEEK</td>
<td style="text-align: left;">$018D ()</td>
<td style="text-align: left;">uPD765A seek driver</td>
</tr>
<tr class="even">
<td style="text-align: left;">DD_L_READ</td>
<td style="text-align: left;">$0190 ()</td>
<td style="text-align: left;">uPD765A read driver</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DD_L_WRITE</td>
<td style="text-align: left;">$0193 ()</td>
<td style="text-align: left;">uPD765A write driver</td>
</tr>
<tr class="even">
<td style="text-align: left;">DD_L_ON_MOTOR</td>
<td style="text-align: left;">$0196 ()</td>
<td style="text-align: left;">Motor on, wait for motor-on time</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DD_L_T_OFF_MOTOR</td>
<td style="text-align: left;">$0199 ()</td>
<td style="text-align: left;">Start the motor-off ticker</td>
</tr>
<tr class="even">
<td style="text-align: left;">DD_L_OFF_MOTOR</td>
<td style="text-align: left;">$019C ()</td>
<td style="text-align: left;">Turn the motor off</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">IDE_FORMAT</td>
<td style="text-align: left;">$00B2 ()</td>
<td style="text-align: left;">Format a partition</td>
</tr>
<tr class="even">
<td style="text-align: left;">IDE_PARTITION_NEW</td>
<td style="text-align: left;">$00B8 ()</td>
<td style="text-align: left;">Create partition</td>
</tr>
<tr class="odd">
<td style="text-align: left;">IDE_PARTITION_INIT</td>
<td style="text-align: left;">$00BB ()</td>
<td style="text-align: left;">Initialise partition</td>
</tr>
<tr class="even">
<td style="text-align: left;">IDE_PARTITION_ERASE</td>
<td style="text-align: left;">$00BE ()</td>
<td style="text-align: left;">Delete a partition</td>
</tr>
<tr class="odd">
<td style="text-align: left;">IDE_PARTITION_RENAME</td>
<td style="text-align: left;">$00C1 ()</td>
<td style="text-align: left;">Rename a partition</td>
</tr>
<tr class="even">
<td style="text-align: left;">IDE_PARTITION_WRITE</td>
<td style="text-align: left;">$00C7 ()</td>
<td style="text-align: left;">Write a partition entry</td>
</tr>
<tr class="odd">
<td style="text-align: left;">IDE_PARTITION_WINFO</td>
<td style="text-align: left;">$00CA ()</td>
<td style="text-align: left;">Write type-specific partition information</td>
</tr>
<tr class="even">
<td style="text-align: left;">IDE_PARTITION_GETINFO</td>
<td style="text-align: left;">$00D3 ()</td>
<td style="text-align: left;">Get byte from type-specific partition information</td>
</tr>
<tr class="odd">
<td style="text-align: left;">IDE_PARTITION_SETINFO</td>
<td style="text-align: left;">$00D6 ()</td>
<td style="text-align: left;">Set byte in type-specific partition information</td>
</tr>
<tr class="even">
<td style="text-align: left;">IDE_DOS_UNPERMANENT</td>
<td style="text-align: left;">$00FA ()</td>
<td style="text-align: left;">Remove permanent drive mapping</td>
</tr>
<tr class="odd">
<td style="text-align: left;">IDE_IDENTIFY</td>
<td style="text-align: left;">$01A2 ()</td>
<td style="text-align: left;">Return IDE drive identity information</td>
</tr>
</tbody>
</table>
<h3 id="dos-compatible-error-codes">+3DOS compatible error codes</h3>
<p><strong>Recoverable disk errors</strong></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">rc_ready</td>
<td style="text-align: left;">Drive not ready</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">rc_wp</td>
<td style="text-align: left;">Disk is write protected</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2</td>
<td style="text-align: left;">rc_seek</td>
<td style="text-align: left;">Seek fail</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: left;">rc_crc</td>
<td style="text-align: left;">CRC data error</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;">rc_nodata</td>
<td style="text-align: left;">No data</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td style="text-align: left;">rc_mark</td>
<td style="text-align: left;">Missing address mark</td>
</tr>
<tr class="odd">
<td style="text-align: left;">6</td>
<td style="text-align: left;">rc_unrecog</td>
<td style="text-align: left;">Unrecognised disk format</td>
</tr>
<tr class="even">
<td style="text-align: left;">7</td>
<td style="text-align: left;">rc_unknown</td>
<td style="text-align: left;">Unknown disk error</td>
</tr>
<tr class="odd">
<td style="text-align: left;">8</td>
<td style="text-align: left;">rc_diskchg</td>
<td style="text-align: left;">Disk changed whilst +3DOS was using it</td>
</tr>
<tr class="even">
<td style="text-align: left;">9</td>
<td style="text-align: left;">rc_unsuit</td>
<td style="text-align: left;">Unsuitable media for drive</td>
</tr>
</tbody>
</table>
<p><strong>Non-recoverable errors</strong></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">20</td>
<td style="text-align: left;">rc_badname</td>
<td style="text-align: left;">Bad filename</td>
</tr>
<tr class="even">
<td style="text-align: left;">21</td>
<td style="text-align: left;">rc_badparam</td>
<td style="text-align: left;">Bad parameter</td>
</tr>
<tr class="odd">
<td style="text-align: left;">22</td>
<td style="text-align: left;">rc_nodrive</td>
<td style="text-align: left;">Drive not found</td>
</tr>
<tr class="even">
<td style="text-align: left;">23</td>
<td style="text-align: left;">rc_nofile</td>
<td style="text-align: left;">File not found</td>
</tr>
<tr class="odd">
<td style="text-align: left;">24</td>
<td style="text-align: left;">rc_exists</td>
<td style="text-align: left;">File already exists</td>
</tr>
<tr class="even">
<td style="text-align: left;">25</td>
<td style="text-align: left;">rc_eof</td>
<td style="text-align: left;">End of file</td>
</tr>
<tr class="odd">
<td style="text-align: left;">26</td>
<td style="text-align: left;">rc_diskfull</td>
<td style="text-align: left;">Disk full</td>
</tr>
<tr class="even">
<td style="text-align: left;">27</td>
<td style="text-align: left;">rc_dirfull</td>
<td style="text-align: left;">Directory full</td>
</tr>
<tr class="odd">
<td style="text-align: left;">28</td>
<td style="text-align: left;">rc_ro</td>
<td style="text-align: left;">Read-only file</td>
</tr>
<tr class="even">
<td style="text-align: left;">29</td>
<td style="text-align: left;">rc_number</td>
<td style="text-align: left;">File number not open (or open with wrong access)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">30</td>
<td style="text-align: left;">rc_denied</td>
<td style="text-align: left;">Access denied</td>
</tr>
<tr class="even">
<td style="text-align: left;">31</td>
<td style="text-align: left;">rc_norename</td>
<td style="text-align: left;">Cannot rename between drives</td>
</tr>
<tr class="odd">
<td style="text-align: left;">32</td>
<td style="text-align: left;">rc_extent</td>
<td style="text-align: left;">Extent missing</td>
</tr>
<tr class="even">
<td style="text-align: left;">33</td>
<td style="text-align: left;">rc_uncached</td>
<td style="text-align: left;">Uncached</td>
</tr>
<tr class="odd">
<td style="text-align: left;">34</td>
<td style="text-align: left;">rc_toobig</td>
<td style="text-align: left;">File too big</td>
</tr>
<tr class="even">
<td style="text-align: left;">35</td>
<td style="text-align: left;">rc_notboot</td>
<td style="text-align: left;">Disk not bootable</td>
</tr>
<tr class="odd">
<td style="text-align: left;">36</td>
<td style="text-align: left;">rc_inuse</td>
<td style="text-align: left;">Drive in use</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">56</td>
<td style="text-align: left;">rc_invpartition</td>
<td style="text-align: left;">Invalid partition</td>
</tr>
<tr class="even">
<td style="text-align: left;">57</td>
<td style="text-align: left;">rc_partexist</td>
<td style="text-align: left;">Partition already exists</td>
</tr>
<tr class="odd">
<td style="text-align: left;">58</td>
<td style="text-align: left;">rc_notimp</td>
<td style="text-align: left;">Not implemented</td>
</tr>
<tr class="even">
<td style="text-align: left;">59</td>
<td style="text-align: left;">rc_partopen</td>
<td style="text-align: left;">Partition open</td>
</tr>
<tr class="odd">
<td style="text-align: left;">60</td>
<td style="text-align: left;">rc_nohandle</td>
<td style="text-align: left;">Out of handles</td>
</tr>
<tr class="even">
<td style="text-align: left;">61</td>
<td style="text-align: left;">rc_notswap</td>
<td style="text-align: left;">Not a swap partition</td>
</tr>
<tr class="odd">
<td style="text-align: left;">62</td>
<td style="text-align: left;">rc_mapped</td>
<td style="text-align: left;">Drive already mapped</td>
</tr>
<tr class="even">
<td style="text-align: left;">63</td>
<td style="text-align: left;">rc_noxdpb</td>
<td style="text-align: left;">No XDPB</td>
</tr>
<tr class="odd">
<td style="text-align: left;">64</td>
<td style="text-align: left;">rc_noswap</td>
<td style="text-align: left;">No suitable swap partition</td>
</tr>
<tr class="even">
<td style="text-align: left;">65</td>
<td style="text-align: left;">rc_invdevice</td>
<td style="text-align: left;">Invalid device</td>
</tr>
<tr class="odd">
<td style="text-align: left;">67</td>
<td style="text-align: left;">rc_cmdphase</td>
<td style="text-align: left;">Command phase error</td>
</tr>
<tr class="even">
<td style="text-align: left;">68</td>
<td style="text-align: left;">rc_dataphase</td>
<td style="text-align: left;">Data phase error</td>
</tr>
<tr class="odd">
<td style="text-align: left;">69</td>
<td style="text-align: left;">rc_notdir</td>
<td style="text-align: left;">Not a directory</td>
</tr>
<tr class="even">
<td style="text-align: left;">74</td>
<td style="text-align: left;">rc_fragmented</td>
<td style="text-align: left;">File is fragmented, use .DEFRAG</td>
</tr>
</tbody>
</table>
<h3 id="esxdos-compatible-calls">esxDOS Compatible Calls</h3>
<p><strong>Low-level calls</strong></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">disk_filemap</td>
<td style="text-align: left;">$85 ()</td>
<td style="text-align: left;">obtain file allocation map</td>
</tr>
<tr class="even">
<td style="text-align: left;">disk_strmstart</td>
<td style="text-align: left;">$86 ()</td>
<td style="text-align: left;">start streaming operation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">disk_strmend</td>
<td style="text-align: left;">$87 ()</td>
<td style="text-align: left;">end streaming operation</td>
</tr>
</tbody>
</table>
<p><strong>Miscellaneous calls</strong></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">m_dosversion</td>
<td style="text-align: left;">$88 ()</td>
<td style="text-align: left;">get NextZXOS version/mode information</td>
</tr>
<tr class="even">
<td style="text-align: left;">m_getsetdrv</td>
<td style="text-align: left;">$89 ()</td>
<td style="text-align: left;">get/set default drive</td>
</tr>
<tr class="odd">
<td style="text-align: left;">m_tapein</td>
<td style="text-align: left;">$8B ()</td>
<td style="text-align: left;">tape redirection control (input)</td>
</tr>
<tr class="even">
<td style="text-align: left;">m_tapeout</td>
<td style="text-align: left;">$8C ()</td>
<td style="text-align: left;">tape redirection control (output)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">m_gethandle</td>
<td style="text-align: left;">$8D ()</td>
<td style="text-align: left;">get handle for current dot command</td>
</tr>
<tr class="even">
<td style="text-align: left;">m_getdate</td>
<td style="text-align: left;">$8E ()</td>
<td style="text-align: left;">get current date/time</td>
</tr>
<tr class="odd">
<td style="text-align: left;">m_execcmd</td>
<td style="text-align: left;">$8F ()</td>
<td style="text-align: left;">execute a dot command</td>
</tr>
<tr class="even">
<td style="text-align: left;">m_setcaps</td>
<td style="text-align: left;">$91 ()</td>
<td style="text-align: left;">set additional capabilities</td>
</tr>
<tr class="odd">
<td style="text-align: left;">m_drvapi</td>
<td style="text-align: left;">$92 ()</td>
<td style="text-align: left;">access API for installable drivers</td>
</tr>
<tr class="even">
<td style="text-align: left;">m_geterr</td>
<td style="text-align: left;">$93 ()</td>
<td style="text-align: left;">get or generate error message</td>
</tr>
<tr class="odd">
<td style="text-align: left;">m_p3dos</td>
<td style="text-align: left;">$94 ()</td>
<td style="text-align: left;">execute +3DOS/IDEDOS/NextZXOS call</td>
</tr>
<tr class="even">
<td style="text-align: left;">m_errh</td>
<td style="text-align: left;">$95 ()</td>
<td style="text-align: left;">register dot command error handler</td>
</tr>
</tbody>
</table>
<p><strong>File calls</strong></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">f_open</td>
<td style="text-align: left;">$9A ()</td>
<td style="text-align: left;">open file</td>
</tr>
<tr class="even">
<td style="text-align: left;">f_close</td>
<td style="text-align: left;">$9B ()</td>
<td style="text-align: left;">close file</td>
</tr>
<tr class="odd">
<td style="text-align: left;">f_sync</td>
<td style="text-align: left;">$9C ()</td>
<td style="text-align: left;">sync file changes to disk</td>
</tr>
<tr class="even">
<td style="text-align: left;">f_read</td>
<td style="text-align: left;">$9D ()</td>
<td style="text-align: left;">read file</td>
</tr>
<tr class="odd">
<td style="text-align: left;">f_write</td>
<td style="text-align: left;">$9E ()</td>
<td style="text-align: left;">write file</td>
</tr>
<tr class="even">
<td style="text-align: left;">f_seek</td>
<td style="text-align: left;">$9F ()</td>
<td style="text-align: left;">set file position</td>
</tr>
<tr class="odd">
<td style="text-align: left;">f_fgetpos</td>
<td style="text-align: left;">$A0 ()</td>
<td style="text-align: left;">get file position</td>
</tr>
<tr class="even">
<td style="text-align: left;">f_fstat</td>
<td style="text-align: left;">$A1 ()</td>
<td style="text-align: left;">get open file information</td>
</tr>
<tr class="odd">
<td style="text-align: left;">f_ftruncate</td>
<td style="text-align: left;">$A2 ()</td>
<td style="text-align: left;">truncate/extend open file</td>
</tr>
<tr class="even">
<td style="text-align: left;">f_opendir</td>
<td style="text-align: left;">$A3 ()</td>
<td style="text-align: left;">open directory for reading</td>
</tr>
<tr class="odd">
<td style="text-align: left;">f_readdir</td>
<td style="text-align: left;">$A4 ()</td>
<td style="text-align: left;">read directory entry</td>
</tr>
<tr class="even">
<td style="text-align: left;">f_telldir</td>
<td style="text-align: left;">$A5 ()</td>
<td style="text-align: left;">get directory position</td>
</tr>
<tr class="odd">
<td style="text-align: left;">f_seekdir</td>
<td style="text-align: left;">$A6 ()</td>
<td style="text-align: left;">set directory position</td>
</tr>
<tr class="even">
<td style="text-align: left;">f_rewinddir</td>
<td style="text-align: left;">$A7 ()</td>
<td style="text-align: left;">rewind to start of directory</td>
</tr>
<tr class="odd">
<td style="text-align: left;">f_getcwd</td>
<td style="text-align: left;">$A8 ()</td>
<td style="text-align: left;">get current working directory</td>
</tr>
<tr class="even">
<td style="text-align: left;">f_chdir</td>
<td style="text-align: left;">$A9 ()</td>
<td style="text-align: left;">change directory</td>
</tr>
<tr class="odd">
<td style="text-align: left;">f_mkdir</td>
<td style="text-align: left;">$AA ()</td>
<td style="text-align: left;">make directory</td>
</tr>
<tr class="even">
<td style="text-align: left;">f_rmdir</td>
<td style="text-align: left;">$AB ()</td>
<td style="text-align: left;">remove directory</td>
</tr>
<tr class="odd">
<td style="text-align: left;">f_stat</td>
<td style="text-align: left;">$AC ()</td>
<td style="text-align: left;">get unopen file information</td>
</tr>
<tr class="even">
<td style="text-align: left;">f_unlink</td>
<td style="text-align: left;">$AD ()</td>
<td style="text-align: left;">delete file</td>
</tr>
<tr class="odd">
<td style="text-align: left;">f_truncate</td>
<td style="text-align: left;">$AE ()</td>
<td style="text-align: left;">truncate/extend unopen file</td>
</tr>
<tr class="even">
<td style="text-align: left;">f_chmod</td>
<td style="text-align: left;">$AF ()</td>
<td style="text-align: left;">change file attributes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">f_rename</td>
<td style="text-align: left;">$B0 ()</td>
<td style="text-align: left;">rename/move file</td>
</tr>
<tr class="even">
<td style="text-align: left;">f_getfree</td>
<td style="text-align: left;">$B1 ()</td>
<td style="text-align: left;">get free space</td>
</tr>
</tbody>
</table>
</body>
</html>
