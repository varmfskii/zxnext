@author Theodore (Alex) Evans
@date 10 Dec 2020
@index INDEX
@title ZX Spectrum Next Programming Notes
@version 201204
@------------------------------------------------------------------------------
@node MAIN
@next COPPER
@{c}@{h1}ZX Spectrum Next Programming Notes

@{c}@{h2}Theodore (Alex) Evans

@{c}@{h2}4 December 2020

@------------------------------------------------------------------------------
@node INDEX
@{r}ZX Spectrum Next Programming Notes

Chapters
 1 Introduction
 2 Video
 3 Audio
 4 Memory
 5 zxnDMA
 6 @{" Copper " LINK COPPER}
 7 @{" Interrupts " LINK INTERRUPTS}
 8 @{" Serial Communications " LINK SERIAL}
 9 @{" Pi0 Acceleration " LINK PI0}
10 System Software

Appendices
 A Ports
 B Registers
 C Extended Opcodes to Mnemonics
 D Mnemonics to Extended Opcodes
 E File Formats
 F Call Tables

@------------------------------------------------------------------------------
@node COPPER
@next INTERRUPTS
@{r}ZX Spectrum Next Programming Notes
@{h1}Copper and Display Timing

From: KevB (aka 9bitcolour)

Introduction

The ZX Spectrum Next includes a co-processor named "COPPER". It functions in a
similar way to the Copper found in the Commodore Amiga Agnus custom chip. It's
role is to free the Z80 of tasks that require the writing of hardware registers
at precise pixel co-ordinates.

Overview

The ZX Spectrum Next COPPER has three instructions: NOOP, MOVE, WAIT.

NOOP is used to fine tune timing. MOVE writes data to a specific range of
hardware registers. WAIT waits for a pixel position on the video display.

These instructions are stored in 2k (2048 BYTES) of dedicated write-only
program RAM also known as a "Copper list".

Each instruction is 16 bits (WORD) in size allowing for a maximum of 1024
instructions to be stored in the program RAM. The COPPER uses an internal 10
bit program counter (PC) which wraps to zero at the end of the list. The PC can
be reset to zero, this is the default value after a hard/soft reset.

The instructions are stored in big endian format and transferred to the 2k
program RAM using the Z80 or DMA (bits 15..8 followed by bits 7..0).

Three write-only hardware registers control access to the program RAM as well
as the operating modes.

System performance is not affected when the COPPER is executing instructions.

The hardware registers and COPPER program RAM are not connected to the main
memory BUS. The overall design of this system together with the use of
alternate clock edges means that contention between the COPPER, Z80 and DMA has
been eliminated.

The COPPER has a base clock speed of 13.5Mhz for HDMI and 14Mhz for VGA.

The bandwidth is around 14 million single cycle NOOP/WAIT instructions and 7
million two cycle MOVE instructions per second.

Timing

To fully understand the COPPER, you must first understand the display timing
for each of the machines and video modes found in the ZX Spectrum Next.

There are several display timing configurations due to the four machine types,
two refresh rates, two video systems (VGA/HDMI) and Timex HIRES mode.

Details of these timings are outlined in this chapter.

Machines

The ZX Spectrum Next has four machine types (48k, 128k, Pentagon, and HDMI).
The machine timing and HDMI determine the number of T-states per line which
determines the base dot clock frequency and Z80/DMA clock speed.

This guide groups machine types by their timing for convenience. The HDMI video
mode overrides the default machine timing so it is included as an extra machine
type which does not exist in the official documentation.

Display

The ZX Spectrum Next doesn't have video modes based on resolution that you
would expect to find on graphics card based hardware. There is one fixed
resolution of 256 x 192 which can be doubled to 512 x 192 in Timex HIRES mode.
What it does have is the ability to set the refresh rate from 50Hz to 60Hz and
horizontal dot clock. This in turn together with the VGA and HDMI timing
affects the vertical line count giving several combinations in total.

VGA modes 0..6 are included as one single VGA mode as the internal machine
timing is constant across those seven refresh rate steps.

More details can be found in Video modes.

Resolution

There are two main horizontal resolutions: standard 256 x 192 and Timex HIRES
512 x 192. Details of LORES 128 x 96 are not included to simplify this guide.

The frame buffer height is fixed at 192 pixels and surrounded by a large border
and overscan as well as horizontal and vertical blanking periods.

There are five vertical line counts: 261, 262, 311, 312, 320. Several pixels
are hidden in the overscan and blanking periods beyond the visible border.

The result is 256 x 192 and 512 x 192 pixel resolutions with a large border.

The colour of the visible border beyond the frame buffer can be manipulated.
Visual changes will not show during the overscan and blanking periods.

Dot Clock

The dot clock on the ZX Spectrum Next runs at 13.5Mhz for HDMI and around 14Mhz
for VGA. The COPPER clock runs at the same frequency as the dot clock. For
v3.00 the copper runs at twice the frequency of the dot clock.

The number of dot clocks per line is calculated by multiplying the number of
3.5Mhz Z80 T-states per line by four. Example: 228Ts * 4 = 912 dot clocks.

The number of dot clocks per second is calculated by the following:

T-states per line * 4 * line count * refresh rate

In standard 256 x 192 resolution the duration of one pixel is two dot clocks.
In Timex HIRES 512 x 192 resolution the duration of one pixel is one dot clock.

Details of the dot clock counts can be found in tables 5.1 and 5.2.

Coordinates

The top left pixel of the frame buffer is line 0 and horizontal dot clock 0.
This is also known as "0,0".

The bottom right pixel of the frame buffer in standard 256 x 192 resolution is
line 191 and horizontal dot clocks 510+511.

The bottom right pixel of the frame buffer in Timex HIRES 512 x 192 resolution
is line 191 and horizontal dot clock 511.

The line one pixel above the frame buffer is the last line of the video frame
and equal to the total line count minus one (312-1 for example).

The line one pixel below the frame buffer is line 192.

The COPPER horizontal dot clock compare is locked to every eight pixels in
standard 256 x 192 resolution and every sixteen pixels in Timex HIRES 512 x 192
resolution. The NOOP instruction can be used to fine tune timing in single dot
clock steps.

Compare

The COPPER uses a 9 bit vertical line compare allowing it to handle the various
line counts.

The COPPER horizontal compare is 6 bits meaning that it can wait for 64
positions across each line. The range of this value is limited by the machine
timing as that determines the number of dot clocks per line.

Each horizontal compare is in steps of 16 dot clocks to cover the full range
across a raster line.

16 dot clocks = 4 pixels in lo 128 x 96 resolution

16 dot clocks = 8 pixels in standard 256 x 192 resolution

16 dot clocks = 16 pixels in high 512 x 192 resolution

There is some slack to consider after the maximum horizontal compare value. The
slack is calculated using the following:

dot clocks per line - maximum horizontal compare * 16

Table 5.5 provides details of the horizontal display, left/right border,
blanking and COPPER dot clock/pixel position compare values:

- Dot clock compare is out of range.

Table 5.6 provides a detailed list of vertical display, top/bottom border and
blanking as well as maximum COPPER line compare. It also provides the ULA
VBLANK interrupt line number.

- Line compare is out of range

* ULA VBLANK interrupt.

Note: The HDMI overscan and blanking period is larger than that of a VGA
monitor which can auto-adjust alignment. The following data is based on visible
results from various monitors thus subject to refinement.

Pixels are visible during DISPLAY/BORDER and hidden during BLANKING.

Overscan

The visible area of the display can extend to resolutions exceeding 256 x 192.

The 50/60 Hz refresh rate mode dictates the vertical limit.

VGA and HDMI differ with VGA providing more visible pixels beyond the range of
HDMI. Table 5.7 provides ideal extended pixel resolutions:

Maximum Extended VGA Resolutions

50Hz = 352 x 288 (standard 256 resolution)

60Hz = 352 x 240 (standard 256 resolution)

Table 5.8 provides COPPER horizontal position and vertical line compare
parameters for ideal extended resolutions:

TOP: Initial line of the extended top border area - see notes below*

BOT: Last line of the extended bottom border area - see notes below*

LEFT: First pixel of the extended left border area - see notes below**

RIGHT: Last pixel of the extended right border area - see notes below**

* Line compare value for MOVE (bits 8..0).

** The integer part is the horizontal value for MOVE (bits 14..9).

** The fractional part is specified in dot clocks (NOOP instructions).

Instructions

This section describes the behaviour of the COPPER instructions as well as the
bit definitions and execution time.

The three 16 bit COPPER instructions are comprised of the following bit
definitions:

H 6 bit horizontal dot clock compare

V 9 bit vertical line compare

R 7 bit Next register 0x00..0x7F

D 8 bit data

NOOP

NOOP (no-operation) executes in one dot clock. It is useful for fine tuning
timing, initialising COPPER RAM and 'NOP' out COPPER program instructions.

It can be used to align colour and display changes to half pixel positions in
standard 256 x 192 resolution. Its duration is equal to one Timex HIRES pixel.

This guide uses the name 'NOOP' to avoid confusion with the Z80 opcode NOP.

MOVE

MOVE executes in two dot clocks. It moves 8 bits of data into any of the Next
hardware registers in the range $00 (0) .. $7F (127).

The WORD value $0000 is reserved for the NOOP instruction so no register access
is carried out for that special case. Register $00 is read-only so not affected
by the restriction of not being able to write zero to it.

This instruction can perform 7 million register writes per second for VGA and
6.75 million register writes per second for HDMI.

WAIT

WAIT executes in one dot clock. It performs a compare with the current vertical
line number and the current horizontal dot clock.

WAIT will hold until the current raster line matches the 9 bit value stored in
bits 8..0. When the line compare matches, WAIT will still hold if the current
horizontal dot clock is less than the value in bits 14..9.

This compare logic means that out of order vertical line compares will cause
the COPPER to wait until the next video frame as the test is for an exact match
of the line number. The COPPER will continue to the next instruction after an
out of order horizontal pixel position compare as the test checks for the
current dot clock being greater than or equal to the compare value.

WAIT will stop the COPPER when a compare is made against an out of range
vertical line or horizontal dot clock position as they will never occur

A standard way to terminate a COPPER program is to wait for line 511 and
horizontal position 63. This encodes into the instruction WORD $FFFF.

The horizontal dot clock position compare includes an adjustment meaning that
the compare completes three dot clocks early in standard 256 x 192 resolution
and two dot clocks early in Timex HIRES 512 x 192 resolution. In practice, a
pixel position can be specified with clocks to spare to write a register value
before the pixel is displayed. This saves software having to auto-adjust
positions to arrive early. It also means that a wait for 0,0 can affect the
first pixel of the frame buffer before it is displayed and set the scroll
registers without visual artefacts.

Example

The following example provides a simple COPPER program to move data to a
hardware register at two specific pixel positions. The BYTES for the program
are listed in the left column:

             PAL8 equ   0x41           ; 8 bit palette hardware register

    $80,$00       WAIT  0,0            ; wait for pixel position 0,0 (H,V)
    $00,$00       NOOP                 ; fine tune timing by one dot clock
    $41,$E0       MOVE  PAL8,11100000b ; write RED to palette register

    $C0,$BF       WAIT  32,191         ; wait for pixel position 256,191
    $00,$00       NOOP                 ; fine tune timing by one dot clock
    $41,$00       MOVE  PAL8,00000000b ; write BLACK to palette register

    $FF,$FF       WAIT  63,511         ; wait for an out of range position

Control

The COPPER is controlled by the following three write-only registers:

-   $60 (96) Copper data
-   $61 (97) Copper control LO BYTE
-   $62 (98) Copper control HI BYTE

The COPPER instructions are written one BYTE at a time to the program RAM using
register $60 (Copper data).

An index system is used to select the destination write address within the 2K
program RAM. Eleven bits are needed to represent the index. Registers $61 and
$62 hold this 11 bit index.

The index increments each time one BYTE is written to register $60. The index
wraps to zero when the last BYTE of program RAM is written.

The instruction data is normally written in big endian format although there is
no rule stating that partial instruction BYTES cannot be written. It is safe to
write to the COPPER program RAM while the COPPER is executing as long the
instruction data written does not create a mall formed instruction which
comprises of one half of the current executing instruction and one half the new
instruction - this could result in unexpected behaviour.

The Z80 and DMA can be used to write the instruction data.

Writing to program RAM while the COPPER is running has no impact on system
performance as the RAM is contention free. COPPER timing is not affected by the
Z80 or DMA writing to the program RAM. Program RAM is write-only.

The contents of the 2k program RAM are preserved during a hard/soft reset.

Register $61 holds the lower 8 bits of the index. Register $62 holds the upper
3 bits of the index as well as two control bits which set the COPPER operating
mode.

D 8 bit data

I 11 bit index

C 2 bit control

The COPPER has an internal 10 bit program counter (PC). Each instruction
advances the program counter by one after completion. The program counter wraps
to zero after the last instruction at location 1023. This causes the copper
list to loop.

The program counter defaults to zero during a hard/soft reset.

The control bits require a change to update the operating mode. This feature
preserves COPPER operation when setting the program RAM index address.

The program counter is preserved when stopping the COPPER. Two of the four
control settings reset the internal PC to zero.

Table 5.11 describes the control bits:

The control mode names used in this guide differ from the official names.

Here is a detailed description of the control bits:

STOP

This is the default operating mode set during a hard/soft reset. The COPPER is
idle in this state and will STOP if currently executing when entering this
mode. It is safe to write to any location within the 2K program RAM when the
COPPER is stopped.

Entering STOP mode preserves the internal program counter so that the COPPER
may continue when restarted.

RESET

The program counter is RESET to zero when entering this mode. The COPPER is
started if idle otherwise entering this mode acts as a jump to location zero
when the COPPER is running.

START

Entering this mode causes an idle COPPER to start executing instructions from
the current program counter. Entering this mode while the COPPER is running has
no effect other than to disable FRAME mode if active.

FRAME

The program counter is RESET to zero when entering this mode. The COPPER is
started if idle otherwise entering this mode acts as a jump to location zero
when the COPPER is running.

Entering this state enables FRAME mode. The program counter will be reset to
zero each frame at 0,0.

Configuration

Hardware registers provide timing and configuration data allowing software to
build and configure COPPER programs that function correctly across the various
video modes and machine types. It is not essential to detect the machine type
but it should be noted that software should not assume that it is running on a
specific machine as the COPPER hardware is available across all four machine
types.

Three registers can be read to determine the machine configuration for Ts per
line, dot clocks, refresh rate, line count and maximum horizontal dot
clock/pixel position compare.

Refresh Rate

The refresh rate must be taken into account and can change real-time so should
be monitored and auto-configured when the COPPER is active as the line count
will change with the refresh rate. This could lead to the COPPER waiting for
lines that never occur.

Register (R/W) $05 () => Peripheral 1 Settings

-   bits 7-6 = joystick 1 mode (MSB)
-   bits 5-4 = joystick 2 mode (MSB)
-   bit 3 = joystick 1 mode (LSB)
-   bit 2 = 50/60 Hz mode (0 = 50Hz, 1 = 60Hz)
-   bit 1 = joystick 2 mode (LSB)
-   bit 0 = Enable Scandoubler

Joystick modes

-   000 = Sinclair 2 (67890)
-   001 = Kempston 2 (port $37)
-   010 = Kempston 1 (port $1F)
-   011 = Megadrive 1 (port $1F)
-   100 = Cursor
-   101 = Megadrive 2 (port $37)
-   110 = Sinclair 1 (12345)
-   111 = I/O Mode (3.01.04) Both joysticks are places in I/O Mode if either is
    set to I/O Mode. The underlying joystick type is not changed and reads of
    this register will continue to return the last joystick type. Ehether the
    joystick is in io mode or not is invisible but this state can be cleared
    either through reset or by re-writing the gegister with joystick type not
    equal to 111. Recovery time for a normal joystick read after leaving I/O
    Mode is at most 64 scan lines.

Video Modes

The video mode can only be changed during the boot process so one initial read
is required of this register during software start up phase.

The machine timing is identical for the seven VGA modes although the physical
refresh rate of the video output speeds up for each mode in turn by roughly
1Hz. The internal timing of the machine remains constant and as close to the
original hardware as possible. VGA is a perfect Amstrad ZX Spectrum 128k +3 for
example as far as timing is concerned across the seven VGA modes.

The effect of this speed up means that mode 0 will execute in one second of
time whereas mode 6 will execute in a shorter time period. Mode 0 is as close
to 50/60 Hz as possible where mode 6 is closer to 60/70 Hz. That would mean
that one second of machine time for mode 6 will execute in 0.83 seconds of
human time when running 50 frames per second at 60Hz.

The eighth mode (mode 7) is used for HDMI timing. Machine configuration is
forced for this mode. Line counts, Ts and various other settings are set to
meet the rigid HDMI timing specification. For mode 7, 50/60 Hz are rock solid
but the original hardware timing loses Ts across all machines to meet HDMI
display requirements.

Software that was previously written for specific hardware with hard-coded
software timing loops may fail. This is one of the risks of coding timing loops
counting Ts. We saw evidence of this with the release of the 1985 Sinclair ZX
Spectrum 128k+ and the later Amstrad models as previous software written for
the ZX Spectrum 48k/48k+ would fail when trying to display colour attribute and
border effects as the number of Ts per line was changed from 224Ts (1982
original 48k) to 228Ts (128k models). The ZX Spectrum Next runs slower in HDMI
mode. Demos may fail to display correctly and games may slow down although
setting the Z80 to 7Mhz can solve the game slow down, demos should be run in
VGA mode for maximum compatibility.

Video timing also affects audio output as the sample rate can vary depending on
the output timing method.

The following register allows software to read the video timing mode:

Register (R/W) $11 () => Video Timing (writable in config mode only)

-   bits 7-3 = Reserved, must be 0
-   bits 2-0 = Mode (VGA = 0..6, HDMI = 7)
    -   000 = Base VGA timing, clk28 = 28000000
    -   001 = VGA setting 1, clk28 = 28571429
    -   010 = VGA setting 2, clk28 = 29464286
    -   011 = VGA setting 3, clk28 = 30000000
    -   100 = VGA setting 4, clk28 = 31000000
    -   101 = VGA setting 5, clk28 = 32000000
    -   110 = VGA setting 6, clk28 = 33000000
    -   111 = HDMI, clk28 = 27000000

-   50/60Hz selection depends on bit 2 of register $05
-   Only writable in config mode

Machine Type

The machine type register can be used to provide the number of Ts per line,
line count, dot clock and maximum horizontal COPPER wait.

The dot clock (DC) is the number of Ts per line * 4.

The maximum horizontal COPPER wait (H) is in multiples of 16 clocks.

Video mode 7 (HMDI) overrides the timing.

The following list shows the various parameters that can be gained from reading
the machine register combined with the refresh register and video mode bits:

Register (R/W) $03 () => Machine Type
A write to this register disables the boot rom in config mode
bits 2-0 select machine type when in config mode

-   bit 7 = (W) Display Timing change enable (allow changes to bits 6-4) (0 on
    hard reset)
-   bits 6-4 = Display Timing
-   bit 3 = Display Timing user lock control

-   Read
    -   0 = No user lock on display timing
    -   1 = User lock on display timing

-   Write
    -   1 = Apply user lock on display timing (0 on hard reset)

-   bits 2-0 = Machine Type (config mode only)
    determines roms loaded

-   Machine Types/Display Timings
    -   000 or 001 = ZX 48K
    -   010 = ZX 128K/+2 (Grey)
    -   011 = ZX +2A-B/+3e/Next Native
    -   100 = Pentagon 128K

Summary

Table 5.13 provides a full list of video timing configuration data:

@------------------------------------------------------------------------------
@node INTERRUPTS
@next SERIAL
@prev COPPER
@{r}ZX Spectrum Next Programming Notes
@{h1}Interrupts

Interrupt Types

The Z80 has three different hardware interrupt signals: /RESET, /NMI,
and /INT.

/RESET

/RESET is used to return the CPU to a known state. When the /RESET line is
pulled low, a /RESET is generated. The CPU then does several things. I, and R
are set to $00. PC is set to $0000. SP becomes $FFFF. A and F are set to
$FF. The interrupt mode is set to 0. And (maskable) interrupts are disabled by
clearing IFF1 and IFF2.

/NMI

/NMI is the non-maskable interrupt. Upon receiving a non-maskable interrupt
(/NMI being pulled low) one of two sequences occur depending on the calue of
bit 3 of the interrupt control register (nextreg $C0).

Register (R/W) $C0 () => Interrupt Control (3.01.09)
($00 on reset)

-   bits 7-5 = Programmable portion of IM2 vector *
-   bit 4 = Reserved, must be 0
-   bit 3 = Enable stackless /NMI response
-   bits 2-1 = Reserved, must be 0
-   bit 0 = Maskable interrupt mode
    -   0 - pulse
    -   1 - IM2

* In IM2 mode vector generated is:

-   bits 7-5 = nextreg $C0 bits 7-5
-   bits 4-1 = Interrupt source
    -   0 - line interrupt (highest priority)
    -   1 - UART 0 Rx
    -   2 - UART 1 Rx
    -   3-10 - CTC channels 0-7
    -   11 - ULA
    -   12 - UART 0 Tx
    -   13 - UART 1 Tx (lowest priority)
-   bit 0 = 0

If bit 3 is clear (0) PC is pushed on the stack, IFF1 is copied to IFF2, IFF1
is cleared (inhibiting maskable interrupts). The /NMI should end with RETN
which copies the contents of IFF2 to IFF1 (returning the interrupt state to
what it was before the /NMI) and PC is popped off the stack.

If bit 3 is set (1) PC is stored in the /NMI return address registers (nextregs
$C2 and $C3), IFF1 is copied to IFF2, IFF1 is cleared (inhibiting maskable
interrupts). The /NMI should end with RETN which copies the contents of IFF2 to
IFF1 (returning the interrupt state to what it was before the /NMI) and PC is
compied from the /NMI return address registers.

Register (R/W) $C2 () => /NMI Return Address LSB (3.01.09) ($00 on reset)

Register (R/W) $C3 () => /NMI Return Address MSB (3.01.09) ($00 on reset)

/INT

The interrupt generally of most interest to programmers is /INT. So much so
that if programmers talk about interrupts on the Z80, they are probebly only
talking about /INT. The processing of /INT is controlled by IFF1 and IFF2 which
are set using EI to enable interrupts and reset using DI to disable interrupts.
Interrupts can happen at any time and should preserve register contents. If
none of your code uses the alternate registers the EXX and EX AF,AF'
instructions can make this faster and easier. Interrupt routined should end
with EI and RETI to reenable interrupts, potentially inform the interrupting
device that its interrupt has been serviced, and return from the interrupt
routine. In general the Spectrum machines do not make any distingtion between
RET and RETI, but future developments in the ZX Spectrum Next may make the
distinction important.

The ZX Spectrum Next has 14 internal sources for /INT signals. This can be
enabled and disabled using nextregs $C4 - $C6. Which signals have been received
can be read/cleared using nexregs $C8 - $CA.

Interrupt Enable

Register (R/W) $C4 () => Interrupt Enable 0 (3.01.08)
($83 on reset)

-   bit 7 = Expansion bus $\overline{\hbox{INT}}$
-   bits 6-2 = Reserved must be zero
-   bit 1 = Line
-   bit 0 = ULA

Register (R/W) $C5 () => Interrupt Enable 1 (3.01.08)
($00 on reset)

-   bit 7 = ctc channel 7 zc/to
-   bit 6 = ctc channel 6 zc/to
-   bit 5 = ctc channel 5 zc/to
-   bit 4 = ctc channel 4 zc/to
-   bit 3 = ctc channel 3 zc/to
-   bit 2 = ctc channel 2 zc/to
-   bit 1 = ctc channel 1 zc/to
-   bit 0 = ctc channel 0 zc/to

Register (W) $C6 () => Interrupt Enable 2 (3.01.08)
($00 on reset)

-   bit 7 = Reserved, must be 0
-   bit 6 = UART1 Tx empty
-   bit 5 = UART1 Rx half full *
-   bit 4 = UART1 Rx available *
-   bit 3 = Reserved, must be 0
-   bit 2 = UART0 Tx empty
-   bit 1 = UART0 Rx half full *
-   bit 0 = UART0 Rx available *

* For each UART, Rx half full and Rx available are shared interrupts

Interupt Status

Register (R/W) $C8 () => Interrupt Status 0 (3.01.09)
($00 on reset)

-   bits 7-2 = Reserved, must be zero
-   bit 1 = Line
-   bit 0 = ULA

* Set bits indicate the device generated an interrupt in the past * Writes
clear bits where bits are set except in IM2 mode

Register (R/W) $C9 () => Interrupt Status 1 (3.01.09)

-   bit 7 = ctc channel 7 zc/to
-   bit 6 = ctc channel 6 zc/to
-   bit 5 = ctc channel 5 zc/to
-   bit 4 = ctc channel 4 zc/to
-   bit 3 = ctc channel 3 zc/to
-   bit 2 = ctc channel 2 zc/to
-   bit 1 = ctc channel 1 zc/to
-   bit 0 = ctc channel 0 zc/to

* Set bits indicate the device generated an interrupt in the past * Writes
clear bits where bits are set except in IM2 mode

Register (R/W) $CA () => Interrupt Status 2 (3.01.09) ($00 on reset)

-   bit 7 = Reserved, must be zero
-   bit 6 = UART1 Tx empty
-   bit 5 = UART1 Rx almost full *
-   bit 4 = UART1 Rx available *
-   bit 3 = Reserved must be zero
-   bit 2 = UART0 Tx empty
-   bit 1 = UART0 Rx almost full *
-   bit 0 = UART0 Rx available *

* For each UART Rx half full and Rx available are shared interrupts ** Set bits
indicate the device generated an interrupt in the past ** Writes clear bits
where bits are set except in IM2 mode

Internal Interrupt Sources

-   0 = Line (highest priority)
-   1 = UART 0 Rx
-   2 = UART 1 Rx
-   3-10 = CTC channels 0-7
-   11 = ULA
-   12 = UART 0 Tx
-   13 = UART 1 Tx (lowest priority)

Interrupt Modes

IM0

When an interrupt is received by the CPU it disables interrupts and executes
the instruction placed on the bus by the interrupting device and (no known use
on the Next) It is enabled with the IM0 instruction and enabling interrupts
(EI).

IM1

When an interrupt is received, the CPU disables interrupts and jumps to an
interrupt handler at $0038 (normally in ROM). The ROM interrupt handler updates
the frame counter and scans the keyboard. This is the default interrupt
handling method for the ZX Spectrum and is probably the method to use if you
don't need the ROMs for anything. It is enabled using the IM1 instruction and
enabling interrupts.

IM2

The ZX Spectrum Next has both a legacy method for handling IM2 and an updated
one which makes better use of the capabilities of IM2 which was added in Core
3.01.09.

The ZX Spectrum Next has 14 interrupt devices which can all be given
independent interrupt vectors when using IM2. These interrupts are controlled
by nextregs $C0 - $CF. The address of the vector for a given interrupt is
created by composing the I register (bits 15-0), nextreg $C0 bits 7-5 (bits
7-5) and the interrupt number of the interrupt device (bits 4-1). This means
that even if you use all 14 internal interrupt sources, your interrupt vector
table is no more than 28 bytes which can be at any 32 byte boundry. It also
means that far less processing has to be done on interrupts which are received.
External interrupts are a little different. If no vector is supplied by a
device the implied LSB will be $FF.

While in IM2 mode, it is possible for interrupts to interrupt DMA transfers.
This capability is controlled by The DMA Interrupt enable registers (nextregs
$CC - $CE). When DMA is interrupted, one instruction of the main program will
be processed, then the interrupt will be taken. On return, DMA will continue.

Register (R/W) $CC () => DMA Interrupt Enable 0 (3.01.09) ($00 on reset)

-   bits 7-2 = Reserved, must be 0
-   bit 1 = Line
-   bit 0 = ULA

* Set bits indicate the specified interrupt will interrupt a DMA operation when
in IM2 mode

Register (R/W) $CD () => DMA Interrupt Enable 1 (3.01.09) ($00 on reset)

-   bit 7 = CTC channel 7 zc/to
-   bit 6 = CTC channel 6 zc/to
-   bit 5 = CTC channel 5 zc/to
-   bit 4 = CTC channel 4 zc/to
-   bit 3 = CTC channel 3 zc/to
-   bit 2 = CTC channel 2 zc/to
-   bit 1 = CTC channel 1 zc/to
-   bit 0 = CTC channel 0 zc/to

* Set bits indicate the corresponding interrupt will interrupt a DMA operation
when in IM2 mode

Register (R/W) $CE () => DMA Interrupt Enable 2 (3.01.09) ($00 on reset)

-   bit 7 = Reserved, must be 0
-   bit 6 = UART1 Tx empty
-   bit 5 = UART1 Rx half full
-   bit 4 = UART1 Rx available
-   bit 3 = Reserved, must be 0
-   bit 2 = UART0 Tx empty
-   bit 1 = UART0 Tx half full
-   bit 0 = UART0 Tx available

* Set bits indicate the corresponding interrupt will interrupt a DMA operation
when in IM2 mode.

In legacy mode, when the CPU receives an interrupt it disables interrupts and
jumps to an interrupt routine starting at the contents of the jump table at I.
The start of the interrupt routine is the contents of I*$100+bus and
I*$100+bus+1. Most devices that can supply interrupts on the ZX Spectrum leave
the data bus in a floating state. As a result the interpreted state of the data
bus while generally $FF is not entirely predictable. The solution to place your
interrupt routine at an address where the MSB and LSB are the same ($0101,
$0202, ... $FFFF) then place 257 copies of that value in a block starting at
I*$100 (you can set the value of the I register).

Code:

    ;; my program
    org $8000
    ;; enable interrupt mode im2
    ld i,$fe
    im2
    ei
    ;; program body
    ;; interrupt routine
    handler:
    ;; preserve registers used
    ;; handle interrupt
    ;; restore registers
    ei
    reti
    ;; jump to interrupt routine
    org $fdfd
    jp handler
    ;; im2 jump table
    org $fe00 ; not actually legal
    defs $101,$fd

Z80 CTC

(3.01.08) Untested, assuming it acts like two Z80 CTCs.

Eight independent CTC channels are available on ports $183B through $1F3B.
These perform counter/timer functions that can be used to generate timer
interrupts or to generate interrupts from physical signals.

The CTC is a standard Zilog part. Its datasheet can be found at
http://www.zilog.com/docs/z80/ps0181.pdf . The Zilog documentation is ambiguous
around how soft resets are treated so the following clarifies some points in
the Next's implementation.

1.  Hard reset requires both a control word and a time constant to be written
    to a channel even if bit 2 = 0 in the first control word.

2.  Soft reset with bit 2 = 0 causes the entire control register to be
    modified. Soft reset with bit 2 = 1 does not change the control register
    contents. In both cases a time constant must follow to resume operation.

3.  Changing the trigger edge selection in bit 4 while the channel is in
    operation counts as a clock edge. A pending timer trigger will be fired
    and, in counter mode, an edge will be received.

4.  ZC/TO is asserted for one clock cycle and not for the entire duration that
    the count is at zero.

At the moment, any interrupt generated by the CTC will assert the z80's /INT
line for 32 cpu cycles. This is the same way that the ULA and line interrupts
operate.

At the moment, the ZC/TO output of each channel is fed into the CLK/TRG input
of the succeeding channel so that time and count periods can be cascaded.

Programming

Initial values are set by a write of a channel control word followed by a time
constant. In timer mode, the counter decrements every time it is triggered. In
counter mode it decrements every time the prescaler counter reaches zero.

Channel Control Word

-   bit 7 = Enable Interrupt
-   bit 6 = Mode
    -   0 = Timer mode
    -   1 = Counter mode
-   bit 5 = Prescalar value (Timer mode only)
    -   0 = 16
    -   1 = 256
-   bit 4 = CLK/TRG edge selection
    -   0 = Falling Edge
    -   1 = Rising Edge
-   bit 3 = Timer Trigger (Timer mode only)
    -   0 = Starts on loading of time constant
    -   1 = Starts on CLK/TRG
-   bit 2 = Time constant follows
-   bit 1 = Software reset
-   bit 0 = 0 (Control Word)

If we are running at 28MHz (Mode 0) and wish to trigger an interrupt every 1
sec, that is 28 million T-States/cycles we could program CTC 5 as a counter
with a prescalar of 16 and a period of 175, CTC 6 as a counter with a prescalar
of 16 and a period of 125, and CTC 7 as a timer with a period of 5.

CTC 5 triggers ZC5 every 280 cycles or 10 usec.

CTC 6 triggers ZC6 every 560,000 cycles or 20 msec.

CTC 7 triggers ZC7 and an interrupt every 28,000,000 cycles or 1 sec.

    di
    ; set up interrupt routine
    im 2
    ld bc,$183B     ; CTC 0
    ld hl,$FFFA     ; address pointing to start of interrupt routine
    ld de,interrupt ; start of interrupt routine
    ld (hl),de
    ld i,$FF
    ld a,l          ; Vector to address at on this interrupt
    out (c),a
    ; set up CTC 5
    ld b,$1D        ; CTC 5
    ld a,$87
    out (c),a       ; Interrupt mode, timer mode, time constant, soft, control
    ld a,$05
    out (c),a       ; once every 5 times 
    ; set up CTC 6
    inc b           ; CTC 6
    ld a,$47
    out (c),a       ; 16x, counter mode, time constant, soft, control
    ld a,$7D        ; 125 = once every 2000 times
    out (c),a
    ; set up CTC 7
    inc b           ; CTC 7
    ld a,$47
    out (c),a       ; 16x, counter mode, time constant, soft, control
    ld a,$AF        ; 175 = once every 2800 times
    ei

@------------------------------------------------------------------------------
@node SERIAL
@next PI0
@prev INTERRUPTS
@{r}ZX Spectrum Next Programming Notes
@{h1}Serial Communication

The Spectrum Next has two independent fully featured UARTs. The UARTS share I/O
ports so it is important to select the correct one before communicating with
it. Each has its own 64 byte Tx buffer and 512 byte Rx buffer. One UART can be
connected to either the ESP of joystick port while the other can be connected
to the Raspberry Pi accelerator or joystick port. The UARTS are controlled
using ports $37, $133B, $143B, $153B, and $163B. The UARTs are connected to the
IM2 interrupt system. Nextreg $c6 allows interrupts to be enabled for the
status of each UART. UART interrupts correspond to interrupts 1, 2, 12, and 13
(see Interrupts).

Port $37 () Kempston/Mega Drive Joystick 2
Read

-   bit 7 = "start" button
-   bit 6 = A/X button
-   bit 5 = C/Z button
-   bit 4 = Fire/C/Y button
-   bit 3 = Up
-   bit 2 = Down
-   bit 1 = Left
-   bit 0 = Right

Disable with Nextreg $05
Write ($00 on reset, 3.01.04)

-   bits 7-6 = Select I/O Mode
    -   00 = Bit Bang
    -   01 = Clock
    -   10 = UART
    -   11 = Reserved (don't use)
-   bit 5 = Reserved, must be 0
-   bit 4 = Select Joystick Port for Read
    -   0 = Left
    -   1 = Right
-   bits 3-1 = Reserved, must be $00
-   bit 0 = Pin 7 state (both ports)
    -   Bit Bang - bit 0 on pin 7
    -   Clock - clock on pin 7
        0 = Slow clock (Fsys/2048 = 12.672 kHz)
        1 = Fast clock (Fsys/8 = 3.5 MHz)
    -   UART - Pin 7 = TX, Pin 9 = RX 0 = ESP
        1 = Pi

** A Runt clock may appear in the first cycle
The I/O mode should be set by writing this port first followed by enabling io
mo de on the joysticks with a write to nextreg 0x05.

Port $133B () UART tx
Read: UART Status

-   bits 7-4 = Reserved (0)
-   bit 3 = UART at least half full (3.01.09)
-   bit 2 = UART full
-   bit 1 = UART transmit busy
-   bit 0 = UART receive has data

Write: UART Transmit

Port $143B () UART rx
Read: UART Receive
Write: UART Prescalar

-   bit 7 = select prescalar part
    -   0 = Bits 6-0 of prescalar
    -   1 = Bits 13-7 of prescalar
-   bits 6-0 = Prescalar bits

Port $153B () UART select

-   bit 7 = Reserved (0)
-   bit 6 = UART select (0 on soft reset) **
    -   0 = ESP
    -   1 = Pi *
-   bit 5 = Reserved (0)
-   bit 4 = Prescalar valid in this write
-   bit 3 = Reserved (0)
-   bits 2-0 = Bits 16-14 of prescalar (0 on hard reset)

* Pi GPIO must be configured for UART, see nextreg $A0
** Either UART can be redirected to the joystick ports, see port $037

Port $153B () UART frame (upcoming)
($18 on hard reset)

-   bit 7 = Immediately reset Rx and Tx to idle and empty FIFOs
-   bit 6 = Assert break (Tx=0) when Tx reaches idle
-   bit 5 = Enable hardware flow control *
-   bits 4-3 = Number of bits in a frame
    -   00 = 5 bits
    -   01 = 6 bits
    -   10 = 7 bits
    -   11 = 8 bits
-   bit 2 = Enable parity
-   bit 1 = Parity
    -   0 = Even parity
    -   1 = Odd parity
-   bit 0 = Number of stop bits
    -   0 = 1 stop bit
    -   1 = 2 stop bits

Register (R/W) $C0 () => Interrupt Control (3.01.09)
($00 on reset)

-   bits 7-5 = Programmable portion of IM2 vector *
-   bit 4 = Reserved, must be 0
-   bit 3 = Enable stackless /NMI response
-   bits 2-1 = Reserved, must be 0
-   bit 0 = Maskable interrupt mode
    -   0 - pulse
    -   1 - IM2

* In IM2 mode vector generated is:

-   bits 7-5 = nextreg $C0 bits 7-5
-   bits 4-1 = Interrupt source
    -   0 - line interrupt (highest priority)
    -   1 - UART 0 Rx
    -   2 - UART 1 Rx
    -   3-10 - CTC channels 0-7
    -   11 - ULA
    -   12 - UART 0 Tx
    -   13 - UART 1 Tx (lowest priority)
-   bit 0 = 0

Register (W) $C6 () => Interrupt Enable 2 (3.01.08)
($00 on reset)

-   bit 7 = Reserved, must be 0
-   bit 6 = UART1 Tx empty
-   bit 5 = UART1 Rx half full *
-   bit 4 = UART1 Rx available *
-   bit 3 = Reserved, must be 0
-   bit 2 = UART0 Tx empty
-   bit 1 = UART0 Rx half full *
-   bit 0 = UART0 Rx available *

* For each UART, Rx half full and Rx available are shared interrupts

@------------------------------------------------------------------------------
@node PI0
@prev SERIAL
@{r}ZX Spectrum Next Programming Notes
@{h1}Raspberry Pi0 Acceleration

The Spectrum Next has a header (with male pins) which can be attached to a
Raspberry Pi Zero. There is a modified version of DietPi called NextPi which is
the standard distro for the Raspberry Pi0 accelerator. Software for the general
public should be written assuming that it will be interfacing with a Pi0
running this distro.

If you are more adventurous, you may choose to use another distro, or even
another accelerator that uses the Raspberry Pi style (40 pin) expansion bus.
Chief concers when doing this is that you have a console presented on the UART
that defaults to 115,200 bps, you don't need to login, the machine is
configured with a driver to treat the I2S interface as a sound card, and the
presence of the nextpi scripts.

The Raspberry Pi 0 has a Broadcom BCM2835 SoC with an ARMv6 core, a Videocore 4
GPU, and its own 512 MB memory and HDMI output. It has its own SD card from
which it boots. For this application the Pi 0 ships with a 1GB microSD card
containing NextPi a customized version of DietPi.

The Pi Zero, if installed, is a smart peripheral for the ZX Spectrum Next.
Available interfaces are: low level access to the GPIO pins, higher level
access to standardized I/O interfaces, and use of the Pi Zero as a sound card.

When using the low level GPIO interface Pi Zero GPIO pins 2-27 can be
configured as either inputs or outputs using nextregs $90-$93. If they are
outputs, the output state can be set by writing to nextregs $98-$9b. The
current status of the GPIO pins can be read from nextregs $98-$9b whether it is
the state driven by the ZX Spectrum Next or the state drive by some other
peripherial attached to the bus (normally the Raspberry Pi Zero).

Register (R/W) $90 () => Pi GPIO output enable 1/4

-   bit 7 = Enable Pin 7 (0 on reset)
-   bit 6 = Enable Pin 6 (0 on reset)
-   bit 5 = Enable Pin 5 (0 on reset)
-   bit 4 = Enable Pin 4 (0 on reset)
-   bit 3 = Enable Pin 3 (0 on reset)
-   bit 2 = Enable Pin 2 (0 on reset)
-   bit 1 = Enable Pin 1 (cannot be enabled) (0 on reset)
-   bit 0 = Enable Pin 0 (cannot be enabled) (0 on reset)

Register (R/W) $91 () => Pi GPIO output enable 2/4

-   bit 7 = Enable Pin 15 (0 on reset)
-   bit 6 = Enable Pin 14 (0 on reset)
-   bit 5 = Enable Pin 13 (0 on reset)
-   bit 4 = Enable Pin 12 (0 on reset)
-   bit 3 = Enable Pin 11 (0 on reset)
-   bit 2 = Enable Pin 10 (0 on reset)
-   bit 1 = Enable Pin 9 (0 on reset)
-   bit 0 = Enable Pin 8 (0 on reset)

Register (R/W) $92 () => Pi GPIO output enable 3/4

-   bit 7 = Enable Pin 23 (0 on reset)
-   bit 6 = Enable Pin 22 (0 on reset)
-   bit 5 = Enable Pin 21 (0 on reset)
-   bit 4 = Enable Pin 20 (0 on reset)
-   bit 3 = Enable Pin 19 (0 on reset)
-   bit 2 = Enable Pin 18 (0 on reset)
-   bit 1 = Enable Pin 17 (0 on reset)
-   bit 0 = Enable Pin 16 (0 on reset)

Register (R/W) $93 () => Pi GPIO output enable 4/4

-   bits 7-4 = Reserved
-   bit 3 = Enable Pin 27 (0 on reset)
-   bit 2 = Enable Pin 26 (0 on reset)
-   bit 1 = Enable Pin 25 (0 on reset)
-   bit 0 = Enable Pin 24 (0 on reset)

Register (R/W) $98 () => Pi GPIO Pin State 1/4

-   bit 7 = Pin 7 Data (1 on reset)
-   bit 6 = Pin 6 Data (1 on reset)
-   bit 5 = Pin 5 Data (1 on reset)
-   bit 4 = Pin 4 Data (1 on reset)
-   bit 3 = Pin 3 Data (1 on reset)
-   bit 2 = Pin 2 Data (1 on reset)
-   bit 1 = Pin 1 Data (1 on reset)
-   bit 0 = Pin 0 Data (1 on reset)

Register (R/W) $99 () => Pi GPIO Pin State 2/4

-   bit 7 = Pin 15 Data (1 on reset)
-   bit 6 = Pin 14 Data (1 on reset)
-   bit 5 = Pin 13 Data (1 on reset)
-   bit 4 = Pin 12 Data (1 on reset)
-   bit 3 = Pin 11 Data (1 on reset)
-   bit 2 = Pin 10 Data (1 on reset)
-   bit 1 = Pin 9 Data (1 on reset)
-   bit 0 = Pin 8 Data (1 on reset)

Register (R/W) $9A () => Pi GPIO Pin State 3/4

-   bit 7 = Pin 23 Data (1 on reset)
-   bit 6 = Pin 22 Data (1 on reset)
-   bit 5 = Pin 21 Data (1 on reset)
-   bit 4 = Pin 20 Data (1 on reset)
-   bit 3 = Pin 19 Data (1 on reset)
-   bit 2 = Pin 18 Data (1 on reset)
-   bit 1 = Pin 17 Data (1 on reset)
-   bit 0 = Pin 16 Data (1 on reset)

Register (R/W) $9B () => Pi GPIO Pin State 4/4

-   bits 7-4 = Reserved
-   bit 3 = Pin 27 Data (1 on reset)
-   bit 2 = Pin 26 Data (1 on reset)
-   bit 1 = Pin 25 Data (1 on reset)
-   bit 0 = Pin 24 Data (1 on reset)

Standardized I/O access with the Pi Zero can use the I2C , SPI, or UART
interfaces and is configured using nextreg $a0. Any enabled port will disable
low level (write) access to the corresponding GPIO pins.

Register (R/W) $A0 () => Pi Peripheral Enable

-   bits 7-6 = Reserved, must be 0
-   bit 5 = Enable UART on GPIO 14, 15 (0 on reset)*
-   bit 4 = Communication Type (0 on reset)
    -   0 = Rx to GPIO 15, Tx to GPIO 14 (Pi)
    -   1 = Rx to GPIO 14, Tx to GPIO 15 (Pi Hats)
-   bit 3 = Enable I2C on GPIO 2, 3 (0 on reset)*
-   bits 2-1 = Reserved, must be 0
-   bit 0 = Enable SPI on GPIO 7, 8, 9, 10, 11 (0 on reset)*

*Overrides GPIO Enables

The I2C interface is controlled using ports $103b (SCL) and $113b (SDA). This
is the same I2C interface that is used for the optional Real Time Clock.
Interfacing with the Pi Zero over I2C is complicated by the fact that it is a
master/slave interface, but both the ZX Spectrum Next and Pi Zero are
configured to be bus masters.

Port $103B () I2C SCL (rtc, rpi)

Port $113B () I2C SDA (rtc, rpi)

The SPI interface is controlled using ports $e7 (/CS) and $eb (/DATA). The SPI
interface is shared between the SD card(s), the flash memory, and the Pi Zero.
Interfacing with the Pi Zero over SPI is complicated by the fact it is a
master/slave interface and both the ZX Spectrum Next and Pi Zero are configured
to be bus masters.

Port $E7 () SPI /CS (SD card, flash, rpi)
Disable with bit 2 of Nextreg $09

Port $EB () SPI /DATA (SD card, flash, rpi)
Disable with bit 2 of Nextreg $09

The default means of communication between the ZX Next and the Pi is through
the UART interface (see serial communications chapter). In order to communicate
withe the Pi the Pi UART must be connected to the Pi by setting nextreg $a0
bits 5 and 4 to 1, selecting the Pi UART by setting port $153b bit 6 to 1 and
ensuring that both ends are using matching communication protocols (by default
115,200 bps, 8N1 and no flow control). On the Pi end the UART is connected to
the serial console.

    ;; enable UART connection with Pi Zero
       ld c,$3b
       ld b,$15 ; UART control
    ;; select Pi on UART control
       in a,(c)
       or $40
       out (c),a
       ld b,$24 ; Next Register Select
       ld a,$a0
       out (c),a
       inc b ; Next Register Data
    ;; Enable UART on GPIO and select Pi
       in a,(c)
       or $30
       out (c),a

The I2S sound interface between the ZX Spectrum Next and the Pi Zero is
controlled by nextregs $a2 and $a3. Normally, one would control the Pi through
some other channel such as the UART recieve audio from the Pi to either use as
a fulloy programmable sound card or to allow loading of tape files on the ZX
Spectrum Next.

Register (R/W) $A2 () => Pi I2S Audio Control

-   bits 7-6 = I2S State ($00 on reset)
    -   00 = I2S Disabled
    -   01 = I2S is mono, source R
    -   10 = I2S is mono, source L
    -   11 = I2S is stereo
-   bit 5 = Reserved, must be 0
-   bit 4 = Audio Flow Direction (0 on reset)
    -   0 = PCM_DOUT to Pi, PCM_DIN from Pi (Hats)
    -   1 = PCM_DOUT from Pi, PCM_DIN to Pi (Pi)
-   bit 3 = Mute left (0 on reset)
-   bit 2 = Mute right (0 on reset)
-   bit 1 = Slave mode, Reserved must be 1 (remove in 3.01.05)
-   bit 0 = Direct I2S audio to EAR on port $FE (0 on reset)

Register (R/W) $A3 () => Pi I2S Clock Divide (Master Mode) (removed in 3.01.05)

-   bits 7-0 = Clock divide value ($0B on reset)

Divider=538461/Rate-1 or
Rate=538461/(Divider+1)
