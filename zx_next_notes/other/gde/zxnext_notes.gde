@author Theodore (Alex) Evans
@date 10 Dec 2020
@index INDEX
@title ZX Spectrum Next Programming Notes
@version 201204
@------------------------------------------------------------------------------
@node MAIN
@next BDOS
@{c}@{h1}ZX Spectrum Next Programming Notes

@{c}@{h2}Theodore (Alex) Evans

@{c}@{h2}4 December 2020

@------------------------------------------------------------------------------
@node INDEX
@{r}ZX Spectrum Next Programming Notes

Chapters
 1 Introduction
 2 Video
 3 Audio
 4 Memory
 5 zxnDMA
 6 Copper
 7 Interrupts
 8 Serial Communications
 9 Pi0 Acceleration
10 @{" System Software " LINK SYSTEM}

Appendices
 A @{" Ports " LINK PORTS}
 B @{" Registers " LINK REGISTERS}
 C @{" Extended Opcodes to Mnemonics " LINK EO2MN}
 D @{" Mnemonics to Extended Opcodes " LINK MN2EO}
 E @{" File Formats " LINK FORMATS}
 F @{" Call Tables " LINK CALLS}

@------------------------------------------------------------------------------
@node BDOS
@next BIOS
@toc SYS_TOC
@{r}ZX Spectrum Next Programming Notes
@{h2}BDOS

From the CP/M 3 Programmers' Guide 1984

This section documents all BDOS system calls to include the parameters that
must be passes to them and the values that are returned to the calling program.

BDOS function 0: SYSTEM RESET

Entry Parameters:

-   C: $00

The System Reset function terminates the calling program and returns control to
the CCP via a warm start sequence. Calling this function has the same effect as
a jump to location $0000 of Page Zero.

Note that the disk subsystem is not reset by System Reset under CP/M 3. The
calling program can pass a return code to the CCP by calling Function 108,
Get/Set Program Return Code, prior to making a System Reset call or jumping to
location $0000.

BDOS function 1: CONSOLE INPUT

Entry Parameters:

-   C: $01

Returned Value:

-   A: ASCII Character

The Console Input function reads the next character from the logical console,
CONIN:, to register A. Graphic characters, along with carriage return,
line-feed, and backspace, CTRL-H, are echoed to the console. Tab characters,
CTR-L-1, are expanded in columns of 8 characters. CTRL-S, CTRL-Q, and CTRL-P
are normally intercepted as described below. All other non-graphic characters
are returned in register A but are not echoed to the console.

When the Console Mode is in the default state Function 1 intercepts the stop
scroll, CTRL-S, start scroll, CTRL-Q, and start/stop printer echo, CTRL-P,
characters. Any characters that are typed following a CTRL-S and preceding a
CTRL-Q are also intercepted. However, if start/stop scroll has been disabled by
the Console Mode, the CTRL-S, CTRL-Q, and CTRL-P characters are not
intercepted. Instead, they are returned in register A, but are not echoed to
the console.

If printer echo has been invoked, all characters that are echoed to the console
are also sent to the list device, LST:. Function 1 does not return control to
the calling program until a non-intercepted character is typed, thus suspending
execution if a character is not ready.

BDOS function 2: CONSOLE OUTPUT

Entry Parameters:

-   C: $02
-   E: ASCII Character

The Console Output function sends the ASCII character from register E to the
logical console device, CONOUT:. When the Console Mode is in the default state
(see Section 2.2.1), Function 2 expands tab characters, CTRL-1, in columns of 8
characters, checks for stop scroll, CTRL-S, start scroll, CTRL-Q, and echoes
characters to the logical list device, LST:, if printer echo, CTRL-P, has been
invoked.

BDOS function 3: AUXILIARY INPUT

Entry Parameters:

-   C: $03

Returned Value:

-   A: ASCII Character

The Auxiliary Input function reads the next character from the logical
auxiliary input device, AUXIN:, into register A. Control does not return to the
calling program 'I the character is read. unti

BDOS function 4: AUXILIARY OUTPUT

Entry Parameters:

-   C: $04
-   E: ASCII Character

The Auxiliary Output function sends the ASCII character from register E to the
logical auxiliary output device, AUXOUT:.

BDOS function 5: LIST OUTPUT

Entry Parameters:

-   C: $05
-   E: ASCII Character

The List Output function sends the ASCII character in register E to the logical
list device, LST:.

BDOS function 6: DIRECT CONSOLE I/O

Entry Parameters:

-   C: $06
-   E: function/data (see description)

Returned Value:

-   A: char/status/no value (see description)

CP/M 3 supports direct I/O to the logical console, CONIN:, for those
specialized applications where unadorned console input and output is required.
Use Direct Console I/O carefully because it bypasses all the normal control
character functions. Programs that perform direct I/O through the BIOS under
previous releases of CP/M should be changed to use direct I/O so that they can
be fully supported under future releases of MP/M and CP/M.

A program calls Function 6 by passing one of four different values in register
E.

-   $FF Console input/status command returns an input character; if no
    character is ready, a value of zero is returned.
-   $FE Console status command (On return, register A contains 00 if no
    character is ready; otherwise it contains $FF.)
-   $FD Console input command, returns an input character; this function will
    suspend the calling process until a character is ready.
-   ASCII Function 6 assumes that register E contains a valid ASCII chararacter
    and sends it to the console.

BDOS function 7: AUXILIARY INPUT STATUS

Entry Parameters:

-   C: $07

Returned Value:

-   A: Auxiliary Input Status

The Auxiliary Input Status function returns the value $FF in register A if a
character is ready for input from the logical auxiliary input device, AUXIN:.
If no character is ready for input, the value $00 is returned.

BDOS function 8: AUXILIARY OUTPUT STATUS

Entry Parameters:

-   C: $08

Returned Value:

-   A: Auxiliary Output Status

The Auxiliary Output Status function returns the value $FF in register A if the
logical auxiliary output device, AUXOUT:, is ready to accept a character for
output. If the device is not ready for output, the value $00 is returned.

BDOS function 9: PRINT STRING

Entry Parameters:

-   C: $09
-   DE: String Address

The Print String function sends the character string addressed by register pair
DE to the logical console, CONOUT:, until it encounters a delimiter in the
string. Usually the delimiter is a dollar sign, $, but it can be changed to any
other value by Function 110, Get/Set Output Delimiter. If the Console Mode is
in the default state, Function 9 expands tab characters, CTRL-I, in columns of
8 characters. It also checks for stop scroll, CTRL-S, start scroll, CTRL-Q, and
echoes to the logical list device, LST:, if printer echo, CTRL-P, has been
invoked.

BDOS function 10: READ CONSOLE BUFFER

Entry Parameters:

-   C: $0A
-   DE: Buffer Address

Returned Value:

-   Console Characters in Buffer

The Read Console Buffer function reads a line of edited console input from the
logical console, CONIN:, to a buffer that register pair DE addresses. It
terminates input and returns to the calling program when it encounters a
return, CTRL-M, or a line feed, CTRL-J, character. Function 10 also discards
all input characters after the input buffer is filled. In addition, it outputs
a bell character, CTRL-G, to the console when it discards a character to signal
the user that the buffer is full. The input buffer addressed by DE has the
following format:

where mx is the maximum number of characters which the buffer holds, and nc is
the number of characters placed in the buffer. The characters entered by the
operator follow the nc value. The value mx must be set prior to making a
Function 10 call and may range in value from 1 to 255. Setting mx to zero is
equivalent to setting mx to one. The value nc is returned to the calling
program and may range from zero to mx. If nc < mx, then uninitialized positions
follow the last character, denoted by ?? in the figure. Note that a terminating
return or line feed character is not placed in the buffer and not included in
the count nc.

If register pair DE is set to zero, Function 10 assumes that an initialized
input buffer is located at the current DMA address (see Function 26, Set DMA
Address). This allows a program to put a string on the screen for the user to
edit. To initialize the input buffer, set characters c1 through cn to the
initial value followed by a binary zero terminator.

When a program calls Function 10 with an initialized buffer, Function 10
operates as if the user had typed in the string. When Function 10 encounters
the binary zero terminator, it accepts input from the console. At this point,
the user can edit the initialized string or accept it as it is by pressing the
RETURN key. However, if the initialized string contains a return, CTRL-M, or a
linefeed, CTRL-J, character, Function 10 returns to the calling program without
giving the user the opportunity to edit the string.

The level of console editing supported by Function 10 differs for the banked
and nonbanked versions of CP/M 3. Refer to the CPIM Plus (CPIM Version 3)
Operating System User's Guide for a detailed description of console editing. In
the nonbanked version, Function 10 recognizes the following edit control
characters.

Nonbanked CP/M 3

-   rub/del Removes and echoes the last character; GENCPM can change this
    function to CTRL-H
-   CTRL-C Reboots when at the beginning of line; the Console Mode can disable
    this function
-   CTRL-E Causes physical end of line
-   CTRL-H Backspaces one character position; GENCPM can change this function
    to rub/del
-   CTRL-J (Line-feed) terminates input line
-   CTRL-M (Return) terminates input line
-   CTRL-P Echoes console output to the list device
-   CTRL-R Retypes the current line after new line
-   CTRL-U Removes current line after new line
-   CTRL-X Backspaces to beginning of current line

The banked version of CP/M 3 expands upon the editing provided in the
non-banked version. The functionality of the two versions is similar when the
cursor is positioned at the end of the line. However, in the banked version,
the user can move the cursor anywhere in the current line, insert characters,
delete characters, and perform other editing functions. In addition, the banked
version saves the previous command line; it can be recalled when the current
line is empty. In the banked version, Function 10 recognizes the following edit
control characters.

Banked CP/M 3

-   rub/del Removes and echoes the last character if at the end of the line;
    otherwise deletes the character to the left of the current cursor position;
    GENCPM can change this function to CTRL-H.
-   CTRL-A Moves cursor one character to the left.
-   CTRL-B Moves cursor to the beginning of the line when not at the beginning;
    otherwise moves cursor to the end of the line.
-   CTRL-C Reboots when at the beginning of line; the Console Mode can disable
    this function.
-   CTRL-E Causes physical end-of-line; if the cursor is positioned in the
    middle of a line, the characters at and to the right of the cursor are
    displayed on the next line.
-   CTRL-F Moves cursor one character to the right.
-   CTRL-G Deletes the character at the current cursor position when in the
    middle of the line; has no effect when the cursor is at the end of the
    line.
-   CTRL-H Backspaces one character position when positioned at the end of the
    line,; otherwise deletes the character to the left of the cursor; GENCPM
    can change this function to rub/del.
-   CTRL-J (Line-feed) terminates input; the cursor can be positioned anywhere
    in the line; the entire input line is accepted; sets the previous line
    buffer to the input line.
-   CTRL-K Deletes all characters to the right of the cursor along with the
    character at the cursor.
-   CTRL-M (Return) terminates input; the cursor can be positioned anywhere in
    the line; the entire input line is accepted; sets the previous line buffer
    to the input line.
-   CTRL-P Echoes console output to the list device.
-   CTRL-R Retypes the characters to the left of the cursor on the new line.
-   CTRL-U Updates the previous line buffer to contain the characters to the
    left of the cursor; deletes current line, and advances to new line.
-   CTRL-W Recalls previous line if current line is empty; otherwise moves
    cursor to end-of-line.
-   CTRL-X Deletes all characters to the left of the cursor.

For banked systems, Function 10 uses the console width field defined in the
System Control Block. If the console width is exceeded when the cursor is
positioned at the end of the line, Function 10 automatically advances to the
next line. The beginning of the line can be edited by entering a CTRL-R.

When a character is typed while the cursor is positioned in the middle of the
line, the typed character is inserted into the line. Characters at and to the
right of the cursor are shifted to the right. If the console width is exceeded,
the characters disappear off the right of the screen. However, these characters
are not lost. They reappear if characters are deleted out of the line, or if a
CTRL-E is typed.

BDOS function 11: GET CONSOLE STATUS

Entry Parameters:

-   C: $0B

Returned Value:

-   A: Console Status

The Get Console Status function checks to see if a character has been typed at
the logical console, CONIN:. If the Console Mode is in the default state,
Function 11 returns the value $01 in register A when a character is ready. If a
character is not ready, it returns a value of $00.

If the Console Mode is in CTRL-C Only Status mode, Function 11 returns the
value $01 in register A only if a CTRL-C has been typed at the console.

BDOS function 12: RETURN VERSION NUMBER

Entry Parameters:

-   C: $0C

Returned Value:

-   HL: Version Number

The Return Version Number function provides information that allows version
independent programming. It returns a two-byte value in register pair HL: H
contains $00 for CP/M and L contains $31, the BDOS file system version number.
Function 12 is useful for writing applications programs that must run on
multiple versions of CP/M and MP/M.

BDOS function 13: RESET DISK SYSTEM

Entry Parameters:

-   C: $0D

The Reset Disk System function restores the file system to a reset state where
all the disk drives are set to read-write (see Functions 28 and 29), the
default disk is set to drive A, and the default DMA address is reset to $0080.
This function can be used, for example, by an application program that requires
disk changes during operation. Function 37, Reset Drive, can also be used for
this purpose.

BDOS function 14: SELECT DISK

Entry Parameters:

-   C: $0E
-   E: Selected Disk

Returned Value:

-   A: Error Flag
-   H: Physical Error

The Select Disk function designates the disk drive named in register E as the
default disk for subsequent BDOS file operations. Register E is set to 0 for
drive A, 1 for drive B, and so on through 15 for drive P in a full 16-drive
system. In addition, Function 14 logs in the designated drive if it is
currently in the reset state. Logging-in a drive activates the drive's
directory until the next disk system reset or drive reset operation.

FCBs that specify drive code zero (dr = $00) automatically reference the
currently selected default drive. FCBs with drive code values between 1 and 16,
however, gnore the selected default drive and directly reference drives A
through P.

Upon return, register A contains a zero if the select operation was successful.
If a physical error was encountered, the select function performs different
actions depending on the BDOS error mode (see Function 45). If the BDOS error
mode is in the default mode, a message identifying the error is displayed at
the console, and the calling program is terminated. Otherwise, the select
function returns to the calling program with register A set to $FF and register
H set to one of the following

physical error codes:

-   01 Disk I/O Error
-   04 Invalid drive

BDOS function 15: OPEN FILE

Entry Parameters:

-   C: $0F
-   DE: FCB Address

Returned Value:

-   A: Directory Code
-   H: Physical or Extended Error

The Open File function activates the FCB for a file that exists in the disk
directory under the currently active user number or user zero. The calling
program passes the address of the FCB in register pair DE, with byte 0 of the
FCB specifying the drive, bytes 1 through 11 specifying the filename and
filetype, and byte 12 specifying the extent. Usually, byte 12 of the FCB is
initialized to zero.

If the file is password protected in Read mode, the correct password must be
placed in the first eight bytes of the current DMA, or have been previously
established as the default password (see Function 106). If the current record
field of the FCB, cr, is set to $FF, Function 15 returns the byte count of the
last record of the file in the cr field. You can set the last record byte count
for a file with Function 30, Set File Attributes. Note that the current record
field of the FCB, cr, must be zeroed by the calling program before beginning
read or write operations if the file is to be accessed sequentially from the
first record.

If the current user is non-zero, and the file to be opened does not exist under
the current user number, the open function searches user zero for the file. If
the file exists under user zero, and has the system attribute, t2', set, the
file is opened under user zero. Write operations are not supported for a file
that is opened under user zero in this manner.

If the open operation is successful, the user's FCB is activated for read and
write operations. The relevant directory information is copied from the
matching directory FCB into bytes d0 through dn of the FCB. If the file is
opened under user zero when the current user number is not zero, interface
attribute f8' is set to one in the user's FCB. In addition, if the referenced
file is password protected in Write mode, and the correct password was not
passed in the DMA, or did not match the default password, interface attribute
f7' is set to one. Write operations are not supported for an activated FCB if
interface attribute f7' or f8' is true.

When the open operation is successful, the open function also makes an Access
date and time stamp for the opened file when the following conditions are
satisfied: the referenced drive has a directory label that requests Access date
and time stamping, and the FCB extent number field is zero.

Upon return, the Open File function returns a directory code in register A with
the value $00 if the open was successful, or $FF, 255 decimal, if the file was
not found. Register H is set to zero in both of these cases. If a physical or
extended error was encountered, the Open File function performs different
actions depending on the BDOS error mode (see Function 45). If the BDOS error
mode is in the default mode, a message identifying the error is displayed at
the console and the program is terminated. Otherwise, the Open File function
returns to the calling program with register A set to $FF, and register H set
to one of the following physical or extended error codes:

-   01 : Disk I/O Error
-   04 : Invalid drive error
-   07 : File password error
-   09 : ? in the FCB filename or filetype field

BDOS function 16: CLOSE FILE

Entry Parameters:

-   C: $10
-   DE: FCB Address

Returned Value:

-   A: Directory Code
-   H: Physical or Extended Error

The Close File function performs the inverse of the Open File function. The
calling program passes the address of an FCB in register pair DE. The
referenced FCB must have been previously activated by a successful Open or Make
function call (see Functions 15 and 22). Interface attribute f5' specifies how
the file is to be closed as shown below:

-   f5' = 0 - Permanent close (default mode)
-   f5' = 1 - Partial close

A permanent close operation indicates that the program has completed file
operations on the file. A partial close operation updates the directory, but
indicates that the file is to be maintained in the open state.

If the referenced FCB contains new information because of write operations to
the FCB, the close function permanently records the new information in the
referenced disk directory. Note that the FCB does not contain new information,
and the directory update step is bypassed if only read or update operations
have been made to the referenced FCB.

Upon return, the close function returns a directory code in register A with the
value $00 if the close was successful,, or $FF, 255 Decimal, if the file was
not found. Register H is set to zero in both of these cases. If a physical or
extended error is encountered, the close function performs different actions
depending on the BDOS error mode (see Function 45). If the BDOS error mode is
in the default mode, a message identifying the error is displayed at the
console, and the calling program is terminated. Otherwise, the close function
returns to the calling program with register A set to $FF and register H set to
one of the following physical error codes:

-   01 Disk I/O error
-   02 Read/only disk
-   04 Invalid drive error

BDOS function 17: SEARCH FOR FIRST

Entry Parameters:

-   C: $11
-   DE: FCB Address

Returned Value:

-   A: Directory Code
-   H: Physical Error

The Search For First function scans the directory for a match with the FCB
addressed by register pair DE. Two types of searches can be performed. For
standard searches, the calling program initializes bytes 0 through 12 of the
referenced FCB, with byte 0 specifying the drive directory to be searched,
bytes 1 through 11 specifying the file or files to be searched for,, and byte
12 specifying the extent. Usually byte 12 is set to zero. An ASCII question
mark, 63 decimal, 3F hex, in any of the bytes 1 through 12 matches all entries
on the directory in the corresponding position. This facility, called ambiguous
reference, can be used to search for multiple files on the directory. When
called in the standard mode, the Search function scans for the first file entry
in the specified directory that matches the FCB, and belongs to the current
user number.

The Search For First function also initializes the Search For Next function.
After the Search function has located the first directory entry matching the
referenced FCB, the Search For Next function can be called repeatedly to locate
all remaining matching entries. In terms of execution sequence, however, the
Search For Next call must either follow a Search For First or Search For Next
call with no other intervening BDOS disk-related function calls.

If byte 0 of the referenced FCB is set to a question mark, the Search function
ignores the remainder of the referenced FCB, and locates the first directory
entry residing on the current default drive. All remaining directory entries
can be located by making multiple Search For Next calls. This type of search
operation is not usually made by application programs, but it does provide
complete flexibility to scan all current directory values. Note that this type
of search operation must be performed to access a drive's directory label.

Upon return, the Search function returns a Directory Code in register A with
the value 0 to 3 if the search is successful, or $FF, 255 Decimal, if a
matching directory entry is not found. Register H is set to zero in both of
these cases. For successful searches, the current DMA is also filled with the
directory record containing the matching entry, and the relative starting
position is A * 32 (that is, rotate the A register left 5 bits, or ADD A five
times). Although it is not usually required for application programs, the
directory information can be extracted from the buffer at this position.

If the directory has been initialized for date and time stamping by INITDIR,
then an SFCB resides in every fourth directory entry, and successful Directory
Codes are restricted to the values 0 to 2. For successful searches, if the
matching directory record is an extent zero entry, and if an SFCB resides at
offset 96 within the current DMA, contents of (DMA Address + 96) = $21, the
SFCB contains the date and time stamp information, and password mode for the
file. This information is located at the relative starting position of 97 + (A
* 10) within the current DMA in the following format:

-   0 - 3 Create or Access Date and Time Stamp Field
-   4 - 7 Update Date and Time Stamp Field
-   8 : Password Mode Field

If a physical error is encountered, the Search function performs different
actions depending on the BDOS error mode (see Function 45). If the BDOS error
mode is in the default mode, a message identifying the error is displayed at
the console, and the calling program is terminated. Otherwise, the Search
function returns to the calling program with register A set to $FF, and
register H set to one of the following physical error codes:

-   01 Disk I/O error
-   04 Invalid drive error

BDOS function 18: SEARCH FOR NEXT

Entry Parameters:

-   C: $12

Returned Value:

-   A: Directory Code
-   H: Physical Error

The Search For Next function is identical to the Search For First function,
except that the directory scan continues from the last entry that was matched.
Function 18 returns a Directory code in register A, analogous to Function 17.

Note: in execution sequence, a Function 18 call must follow either a Function
17 or another Function 18 call with no other intervening BDOS disk-related
function calls.

BDOS function 19: DELETE FILE

Entry Parameters:

-   C: $13
-   DE: FCB Address

Returned Value:

-   A: Directory Code
-   H: Extended or Physical Error

The Delete File function removes files or XFCBs that match the FCB addressed in
register pair DE. The filename and filetype can contain ambiguous references,
that is, question marks in bytes f1' through t3', but the dr byte cannot be
ambiguous, as it can in the Search and Search Next functions. Interface
attribute f5' specifies the type of delete operation that is performed.

-   f5' = 0 - Standard Delete (default mode)
-   f5' = 1 - Delete only XFCBs

If any of the files that the referenced FCB specify are password protected, the
correct password must be placed in the first eight bytes of the current DMA
buffer, or have been previously established as the default password (see
Function 106).

For standard delete operations, the Delete function removes all directory
entries belonging to files that match the referenced FCB. All disk directory
and data space owned by the deleted files is returned to free space, and
becomes available for allocation to other files. Directory XFCBs that were
owned by the deleted files are also removed from the directory. If interface
attribute f5' of the FCB is set to 1, Function 19 deletes only the directory
XFCBs that match the referenced FCB.

Note: if any of the files that match the input FCB specification fall the
password check, or are Read-Only, then the Delete function does not delete any
files or XFCBS. This applies to both types of delete operations.

In nonbanked systems, file passwords and XFCBs are not supported. Thus, if the
Delete function is called with interface attribute f5' set to true, the Delete
function performs no action but returns with register A set to zero.

Upon return, the Delete function returns a Directory Code in register A with
the value 0 if the delete is successful, or $FF, 255 Decimal, if no file that
matches the referenced FCB is found. Register H is set to zero in both of these
cases. If a physical, or extended error is encountered, the Delete function
performs different actions depending on the BDOS error mode (see Function 45).
If the BDOS error mode is the default mode, a message identifying the error is
displayed at the console and the calling program is terminated. Otherwise, the
Delete function returns to the calling program with register A set to $FF and
register H set to one of the following physical or extended error codes:

-   01 : Disk I/O error
-   02 : Read-Only disk
-   03 : Read-Only file
-   04 : Invalid drive error
-   07 : File password error

BDOS function 20: READ SEQUENTIAL

Entry Parameters:

-   C: $14
-   DE: FCB Address

Returned Value:

-   A: Error Code
-   H: Physical Error

The Read Sequential function reads the next 1 to 128 128-byte records from a
file into memory beginning at the current DMA address. The BDOS Multi-Sector
Count (see Function 44) determines the number of records to be read. The
default is one record. The FCB addressed by register pair DE must have been
previously activated by an Open or Make function call.

Function 20 reads each record from byte cr of the extent, then automatically
increments the cr field to the next record position. If the cr field overflows,
then the function automatically opens the next logical extent and resets the cr
field to 0 in preparation for the next read operation. The calling program must
set the cr field to 0 following the Open call if the intent is to read
sequentially from the beginning of the file. Upon return, the Read Sequential
function sets register A to zero if the read operation is successful.
Otherwise, register A contains an error code identifying the error as shown
below:

-   01 Reading unwritten data (end-of-file)
-   09 Invalid FCB
-   10 Media change occurred
-   255 Physical Error; refer to register H

Error Code 01 is returned if no data exists at the next record position of the
file. Usually, the no data situation is encountered at the end of a file.
However, it can also occur if an attempt is made to read a data block that has
not been previously written, or an extent which has not been created. These
situations are usually restricted to files created or appended with the BDOS
random write functions (see Functions 34 and 40).

Error Code 09 is returned if the FCB is invalidated by a previous BDOS close
call that returns an error.

Error Code 10 is returned if a media change occurs on the drive after the
referenced FCB is activated by a BDOS Open, or Make Call.

Error Code 255 is returned if a physical error is encountered and the BDOS
error mode is Return Error mode, or Return and Display Error mode (see Function
45). If the error mode is the default mode, a message identifying the physical
error is displayed at the console, and the calling program is terminated. When
a physical error is returned to the calling program, register H contains one of
the following error codes:

-   01 Disk I/O error
-   04 Invalid drive error

On all error returns except for physical error returns, A = 255, Function 20
sets register H to the number of records successfully read before the error is
encountered. This value can range from 0 to 127 depending on the current BDOS
Multi-Sector Count. It is always set to zero when the Multi-Sector Count is
equal to one.

BDOS function 21: WRITE SEQUENTIAL

Entry Parameters:

-   C: $15
-   DE: FCB Address

Returned Value:

-   A: Error Code
-   H: Physical Error

The Write Sequential function writes 1 to 128 128-byte data records, beginning
at the current DMA address into the file named by the FCB addressed in register
pair DE. The BDOS Multi-Sector Count (see Function 44) determines the number of
128 byte records that are written. The default is one record. The referenced
FCB must have been previously activated by a BDOS Open or Make function call.

Function 21 places the record into the file at the position indicated by the cr
byte of the FCB, and then automatically increments the cr byte to the next
record position. If the cr field overflows, the function automatically opens,
or creates the next logical extent, and resets the cr field to 0 in preparation
for the next write operation. If Function 21 is used to write to an existing
file, then the newly written records overlay those already existing in the
file. The calling program must set the cr field to 0 following an Open or Make
call if the intent is to write sequentially from the beginning of the file.

Function 21 makes an Update date and time for the file if the following
conditions are satisfied: the referenced drive has a directory label that
requests date and time stamping, and the file has not already been stamped for
update by a previous Make or Write function call.

Upon return, the Write Sequential function sets register A to zero if the write
operation is successful. Otherwise, register A contains an error code
identifying the error as shown below:

-   01 No available directory space
-   02 No available data block
-   09 Invalid FCB
-   10 Media change occurred
-   255 Physical Error : refer to register H

Error Code 01 is returned when the write function attempts to create a new
extent that requires a new directory entry, and no available directory entries
exist on the selected disk drive.

Error Code 02 is returned when the write command attempts to allocate a new
data block to the file, and no unallocated data blocks exist on the selected
disk drive.

Error Code 09 is returned if the FCB is invalidated by a previous BDOS close
call that returns an error.

Error Code 10 is returned if a media change occurs on the drive after the
referenced FCB is activated by a BDOS Open or Make call.

Error Code 255 is returned if a physical error is encountered and the BDOS
error mode is Return Error mode, or Return and Display Error mode (see Function
45). If the error mode is the default mode, a message identifying the physical
error is displayed at the console, and the calling program is terminated. When
a physical error is returned to the calling program, register H contains one of
the following error codes:

-   01 Disk I/O error
-   02 Read-Only disk
-   03 Read-Only file or File open from user 0 when the current user number is
    non-zero or File password protected in Write mode
-   04 Invalid drive error

On all error returns, except for physical error returns, A = 255, Function 21
sets register H to the number of records successfully written before the error
was encountered. This value can range from 0 to 127 depending on the current
BDOS Multi-Sector Count. It is always set to zero when the Multi-Sector Count
is set to one.

BDOS function 22: MAKE FILE

Entry Parameters:

-   C: $16
-   DE: FCB Address

Returned Value:

-   A: Directory Code
-   H: Physical or Extended Error

The Make File function creates a new directory entry for a file under the
current user number. It also creates an XFCB for the file if the referenced
drive has a directory label that enables password protection on the drive, and
the calling program assigns a password to the file.

The calling program passes the address of the FCB in register pair DE, with
byte 0 of the FCB specifying the drive, bytes 1 through 11 specifying the
filename and filctype, and byte 12 set to the extent number. Usually, byte 12
is set to zero. Byte 32 of the FCB, the cr field, must be initialized to zero,
before or after the Make call, if the intent is to write sequentially from the
beginning of the file.

Interface attribute f6' specifies whether a password is to be assigned to the
created file.

-   f6' = 0 - Do not assign password (default)
-   f6' = 1 - Assign password to created file

When attribute f6' is set to 1, the calling program must place the password in
the first 8 bytes of the current DMA buffer, and set byte 9 of the DMA buffer
to the password mode (see Function 102). Note that the Make function only
interrogates interface attribute f6' if passwords are activated on the
referenced drive. In nonbanked systems, file passwords are not supported, and
attribute f6' is never interrogated.

The Make function returns with an error if the referenced FCB names a file that
currently exists in the directory under the current user number.

If the Make function is successful, it activates the referenced FCB for file
operations by opening the FCB, and initializes both the directory entry and the
referenced FCB to an empty file. It also initializes all file attributes to
zero. In addition, Function 22 makes a Creation date and time stamp for the
file if the following conditions are satisfied: the referenced drive has a
directory label that requests Creation date and time stamping and the FCB
extent number field is equal to zero. Function 22 also makes an Update stamp if
the directory label requests update stamping and the FCB extent field is equal
to zero.

If the referenced drive contains a directory label that enables password
protection, and if interface attribute f6' has been set to 1, the Make function
creates an XFCB for the file. In addition, Function 22 also assigns the
password, and password mode placed in the first nine bytes of the DMA, to the
XFCB.

Upon return, the Make function returns a directory code in register A with the
value 0 if the make operation is successful, or $FF, 255 decimal, if no
directory space is available. Register H is set to zero in both of these cases.
If a physical or extended error is encountered, the Make function performs
different actions depending on the BDOS error mode (see Function 45). If the
BDOS error mode is the default mode, a message identifying the error is
displayed at the console, and the calling program is terminated. Otherwise, the
Make function returns to the calling program with register A set to $FF, and
register H set to one of the following physical or extended error codes:

-   01 : Disk I/O error
-   02 : Read-Only disk
-   04 : Invalid drive error
-   08 : File already exists
-   09 : ? in filename or filetype field

BDOS function 23: RENAME FILE

Entry Parameters:

-   C: $17
-   DE: FCB Address

Returned Value:

-   A: Directory Code
-   H: Physical or Extended Error

The Rename function uses the FCB, addressed by register pair DE, to change all
directory entries of the file specified by the filename in the first 16 bytes
of the FCB to the filename in the second 16 bytes. If the file specified by the
first filename is password protected, the correct password must be placed in
the first eight bytes of the current DMA buffer, or have been previously
established as the default password (see Function 106). The calling program
must also ensure that the filenames specified in the FCB are valid and
unambiguous, and that the new filename does not already exist on the drive.
Function 23 uses the dr code at byte 0 of the FCB to select the drive. The
drive code at byte 16 of the FCB is ignored.

Upon return, the Rename function returns a Directory Code in register A with
the value 0 if the rename is successful, or $0FF, 255 Decimal, if the file
named by the first filename in the FCB is not found. Register H is set to zero
in both of these cases. If a physical or extended error is encountered, the
Rename function performs different actions depending on the BDOS error mode
(see Function 45). If the BDOS error mode is the default mode, a message
identifying the error is displayed at the console and the program is
terminated. Otherwise, the Rename function returns to the calling program with
register A set to $0FF and register H set to one of the following physical or
extended error codes:

-   01 Disk I/O error
-   02 Read-Only disk
-   03 Read-Only file
-   04 Invalid drive error
-   07 File password error
-   08 File already exists
-   09 ? in filename or filetype field

BDOS function 24: RETURN LOGIN VECTOR

Entry Parameters:

-   C: $18

Returned Value:

-   HL: Login Vector

Function 24 returns the login vector in register pair HL. The login vector is a
16-bit value with the least significant bit of L corresponding to drive A, and
the highorder bit of H corresponding to the 16th drive, labelled P. A 0 bit
indicates that the drive is not on-line, while a 1 bit indicates the drive is
active. A drive is made active by either an explicit BDOS Select Disk call,
number 14, or an implicit selection when a BDOS file operation specifies a
non-zero dr byte in the FCB. Function 24 maintains compatibilty with earlier
releases since registers A and L contain the same values upon return.

BDOS function 25: RETURN CURRENT DISK

Entry Parameters:

-   C: $19

Returned Value:

-   A: Current Disk

Function 25 returns the currently selected default disk number in register A.
The disk numbers range from 0 through 15 corresponding to drives A through P.

BDOS function 26: SET DMA ADDRESS

Entry Parameters:

-   C: $1A
-   DE: DMA Address

DMA is an acronym for Direct Memory Address, which is often used in connection
with disk controllers that directly access the memory of the computer to
transfer data to and from the disk subsystem. Under CP/M 3, the current DMA is
usually defined as the buffer in memory where a record resides before a disk
write, and after a disk read operation. If the BDOS Multi-Sector Count is equal
to one (see Function 44), the size of the buffer is 128 bytes. However, if the
BDOS Multi-Sector Count is greater than one, the size of the buffer must equal
N * 128, where N equals the Multi-Sector Count.

Some BDOS functions also use the current DMA to pass parameters, and to return
values. For example, BDOS functions that check and assign file passwords
require that the password be placed in the current DMA. As another example,
Function 46, Get Disk Free Space, returns its results in the first 3 bytes of
the current DMA. When the current DMA is used in this context, the size of the
buffer in memory is determined by the specific requirements of the called
function.

When a transient program is initiated by the CCP, its DMA address is set to
$0080. The BDOS Reset Disk System function, Function 13, also sets the DMA
address to $0080. The Set DMA function can change this default value to another
memory address. The DMA address is set to the value passed in the register pair
DE. The DMA address remains at this value until it is changed by another Set
DMA Address, or Reset Disk System call.

BDOS function 27: GET ADDR(ALLOC)

Entry Parameters:

-   C: $1B

Returned Value:

-   HL: ALLOC Address

CP/M 3 maintains an allocation vector in main memory for each active disk
drive. Some programs use the information provided by the allocation vector to
determine the amount of free data space on a drive. Note, however, that the
allocation information might be inaccurate if the drive has been marked
Read-Only.

Function 27 returns in register pair HL, the base address of the allocation
vector for the currently selected drive. If a physical error is encountered
when the BDOS error mode is one of the return modes (see Function 45), Function
27 returns the value $FFFF in the register pair HL.

In banked CP/M 3 systems, the allocation vector can be placed in bank zero. In
this case, a transient program cannot access the allocation vector. However,
the BDOS function, Get Disk Free Space (Function 46), can be used to directly
return the number of free 128-byte records on a drive. The CP/M 3 utilities
that display a drive's free space, DIR and SHOW, use Function 46 for that
purpose.

BDOS function 28: WRITE PROTECT DISK

Entry Parameters:

-   C: $1C

The Write Protect Disk function provides temporary write protection for the
currently selected disk by marking the drive as Read-Only, No program can write
to a disk that is in the Read-Only state. A drive reset operation must be
performed for a Read-Only drive to restore it to the Read-Write state (see
Functions 13 and 37).

BDOS function 29: GET READ-ONLY VECTOR

Entry Parameters:

-   C: l$D

Returned Value:

-   HL: R/O Vector Value

Function 29 returns a bit vector in register pair HL that indicates which
drives have the temporary Read-Only bit set. The Read-Only bit can be set only
by a BDOS Write Protect Disk call.

The format of the bit vector is analogous to that of the login vector returned
by Function 24. The least significant bit corresponds to drive A, while the
most significant bit corresponds to drive P.

BDOS function 30: SET FILE ATTRIBUTES

Entry Parameters:

-   C: $1E
-   DE: FCB Address

Returned Value:

-   A: Directory Code
-   H: Physical or Extended error

By calling the Set File Attributes function, a program can modify a file's
attributes and set its last record byte count. Other BDOS functions can be
called to interrogate these file parameters, but only Function 30 can change
them. The file attributes that can be set or reset by Function 30 are fl'
through f4', Read-Only, t1', System, t2', and Archive, t3'. The register pair
DE addresses an FCB containing a filename with the appropriate attributes set
or reset. The calling program must ensure that it does not specify an ambiguous
filename. In addition, if the specified file is password totected, the correct
password must be placed in the first eight bytes of the current DMA buffer or
have been previously established as the default password (see Function 106).

Interface attribute f6' specifies whether the last record byte count of the
specified file is to be set:

-   f6' = 0 - Do not set byte count (default mode)
-   f6' = 1 - Set byte count

If interface attribute f6' is set, the calling program must set the cr field of
the referenced FCB to the byte count value. A program can access a file's byte
count value with the BDOS Open, Search, or Search Next functions.

Function 30 searches the referenced directory for entries belonging to the
current user number that matches the FCB specified name and type fields. The
function then updates the directory to contain the selected indicators, and if
interface attribute f6' is set, the specified byte count value. Note that the
last record byte count is maintained in byte 13 of a file's directory FCBS.

File attributes t1', t2', and t3' are defined by CP/M 3. (They are described in
Section 2.3.4.) Attributes fl' through f4' are not presently used, but can be
useful for application programs, because they are not involved in the matching
program used by the BDOS during Open File and Close File operations. Indicators
f5' through f8' are reserved for use as interface attributes.

Upon return, Function 30 returns a Directory Code in register A with the value
0 if the function is successful, or $FF, 255 Decimal, if the file specified by
the referenced FCB is not found. Register H is set to zero in both of these
cases. If a physical or extended error is encountered', the Set File Attributes
function performs different actions depending on the BDOS error mode (see
Function 45). If the BDOS error mode is the default mode, a message identifying
the error is displayed at the console, and the program is terminated.
Otherwise, Function 30 returns to the calling program with reg'ls-Ler A set to
$FF, and register H set to one of the following physical or extended error
codes:

-   01 Disk I/O error
-   02 Read-Only disk
-   04 Select error
-   07 File password error
-   09 ? in filename or filetype field

BDOS function 31: GET ADDR(DPB PARMS)

Entry Parameters:

-   C: $1F

Returned Value:

-   HL: DPB Address

Function 31 returns in register pair HL the address of the BIOS-resident Disk
Parameter Block, DPB, for the currently selected drive. (Refer to the CP/M Plus
(CP/M Version 3) Operating System System Guide for the format of the DPB). The
calling program can use this address to extract the disk parameter values.

If a physical error is encountered when the BDOS error mode is one of the
return modes (see Function 45), Function 31 returns the value $FFFF in the
register pair HL.

BDOS function 32: SET/GET USER CODE

Entry Parameters:

-   C: $20

Returned Value:

-   E: $FF (get) or User Code (set)
-   A: Current Code or (no value)

A program can change, or interrogate the currently active user number by
calling Function 32. If register E = $FF, then the value of the current user
number is returned in register A, where the value is in the range of 0 to 15.
If register E is not $FF, then the current user number is changed to the value
of E, modulo 16.

BDOS function 33: READ RANDOM

Entry Parameters:

-   C: $21
-   DE: FCB Address

Returned Value:

-   A: Error Code
-   H: Physical Error

The Read Random function is similar to the Read Sequential function except that
the read operation takes place at a particular random record number, selected
by the 24-bit value constructed from the three byte, r0, r1, r2, field
beginning at position 33 of the FCB. Note that the sequence of 24 bits is
stored with the least significant byte first, rO, the middle byte next, rl, and
the high byte last, r2. The random record number can range from 0 to 262,143.
This corresponds to a maximum value of 3 in byte r2.

To read a file with Function 33, the calling program must first open the base
extent, extent 0. This ensures that the FCB is properly initialized for
subsequent random access operations. The base extent may or may not contain any
allocated data. Function 33 reads the record specified by the random record
field into the current DMA address. The function automatically sets the logical
extent and current record values, but unlike the Read Sequential function, it
does not advance the current record number. Thus, a subsequent Read Random call
rereads the same record. After a random read operation, a file can be accessed
sequentially, starting from the current randomly accessed position. However,
the last randomly accessed record is reread or rewritten when switching from
random to sequential mode.

If the BDOS Multi-Sector Count is greater than one (see Function 44), the Read
Random function reads multiple consecutive records into memory beginning at the
current DMA. The rO, rl, and r2 field of the FCB is automatically incremented
to read each record. However, the FCBs random record number is restored to the
first record's value upon return to the calling program.

Upon return, the Read Random function sets register A to zero if the read
operation was successful. Otherwise, register A contains one of the following
error codes:

-   01 Reading unwritten data (end-of-file)
-   03 Cannot close current extent
-   04 Seek to unwritten extent
-   06 Random record number out of range
-   10 Media change occurred
-   255 Physical Error : refer to register H

Error Code 01 is returned if no data exists at the next record position of the
file. Usually, the no data situation is encountered at the end of a file.
However, it can also occur if an attempt is made to read a data block that has
not been previously written.

Error Code 03 is returned when the Read Random function cannot close the
current extent prior to moving to a new extent.

Error Code 04 is returned when a read random operation accesses an extent that
has not been created.

Error Code 06 is returned when byte 35, r2, of the referenced FCB is greater
than 3.

Error Code 10 is returned if a media change occurs on the drive after the
referenced FCB is activated by a BDOS Open or Make Call.

Error Code 255 is returned if a physical error is encountered, and the BDOS
error mode is one of the return modes (see Function 45). If the error mode is
the default mode, a message identifying the physical error is displayed at the
console, and the calling program is terminated. When a physical error is
returned to the calling program, register H contains one of the following error
codes:

-   01 Disk I/O error
-   04 Invalid drive error

On all error returns except for physical errors, A = 255, the Read Random
function sets register H to the number of records successfully read before the
error is encountered. This value can range from 0 to 127 depending on the
current BDOS Multi-Sector Count. It is always set to zero when the Multi-Sector
Count is equal to one.

BDOS function 34: WRITE RANDOM

Entry Parameters:

-   C: $22
-   DE: FCB Address

Returned Value:

-   A: Error Code
-   H: Physical Error

The Write Random function is analogous to the Read Random function, except that
data is written to the disk from the current DMA address. If the disk extent or
data block where the data is to be written is not already allocated, the BDOS
automatically performs the allocation before the write operation continues.

To write to a file using the Write Random function, the calling program must
first open the base extent, extent 0. This ensures that the FCB is properly
initialized for subsequent random access operations. If the file is empty, the
calling program must create the base extent with the Make File function before
calling Function 34. The base extent might or might not contain any allocated
data, but it does record the file in the directory, so that the file can be
displayed by the DIR utility.

The Write Random function sets the logical extent and current record positions
to correspond with the random record being written, but does not change the
random record number. Thus, sequential read or write operations can follow a
random write, with the current record being reread or rewritten as the calling
program switches from random to sequential mode.

Function 34 makes an Update date and time stamp for the file if the following
conditions are satisfied: the referenced drive has a directory label that
requests Update date and time stamping if the file has not already been stamped
for update by a previous BDOS Make or Write call.

If the BDOS Multi-Sector Count is greater than one (see Function 44), the Write
Random function reads multiple consecutive records into memory beginning at the
current DMA. The rO, rl, and r2 field of the FCB is automatically incremented
to write each record. However, the FCB's random record number is restored to
the first record's value when it returns to the calling program. Upon return,
the Write Random function sets register A to zero if the write operation is
successful. Otherwise, register A contains one of the following error codes:

-   02 No available data block
-   03 Cannot Close current extent
-   05 No available directory space
-   06 Random record number out of range
-   10 Media change occurred
-   255 Physical Error : refer to register H

Error Code 02 is returned when the write command attempts to allocate a new
data block to the file and no unallocated data blocks exist on the selected
disk drive.

Error Code 03 is returned when the Write Random function cannot close the
current extent prior to moving to a new extent.

Error Code 05 is returned when the write function attempts to create a new
extent that requires a new directory entry and no available directory entries
exist on the selected disk drive.

Error Code 06 is returned when byte 35, r2, of the referenced FCB is greater
than 3.

Error Code 10 is returned if a media change occurs on the drive after the
referenced FCB is activated by a BDOS Open or Make Call.

Error Code 255 is returned if a physical error is encountered and the BDOS
error mode is one of the return modes (see Function 45). If the error mode is
the default mode, a message identifying the physical error is displayed at the
console, and the calling program is terminated. When a physical error is
returned to the calling program, it is identified by register H as shown below:

-   01 Disk I/O error
-   02 Read-Only disk
-   03 Read-Only file or File open from user 0 when the current user number is
    nonzero or File password protected in Write mode
-   04 Invalid drive error

On all error returns, except for physical errors, A = 255, the Write Random
function sets register H to the number of records successfully written before
the error is encountered. This value can range from 0 to 127 depending on the
current BDOS Multi-Sector Count. It is always set to zero when the Multi-Sector
Count is equal to one.

BDOS function 35: COMPUTE FILE SIZE

Entry Parameters:

-   C: $23
-   DE: FCB Address

Returned Value:

-   A: Error Flag
-   H: Physical or Extended error
-   Random Record Field Set

The Compute File Size function determines the virtual file size, which is, in
effect, the address of the record immediately following the end of the file.
The virtual size of a file corresponds to the physical size if the file is
written sequentially. If the file is written in random mode, gaps might exist
in the allocation, and the file might contain fewer records than the indicated
size. For example, if a single record with record number 262,143, the CP/M 3
maximum is written to a file using the Write Random function, then the virtual
size of the file is 262,144 records even though only 1 data block 'is actually
allocated.

To compute file size, the calling program passes in register pair DE the
address of an FCB in random mode format, bytes rO, rl and r2 present. Note that
the FCB must contain an unambiguous filename and filetype. Function 35 sets the
random record field of the FCB to the random record number + 1 of the last
record in the file. If the r2 byte is set to 04, then the file contains the
maximum record count 262,144.

A program can append data to the end of an existing file by calling Function 35
to set the random record position to the end of file, and then performing a
sequence of random writes starting at the preset record address.

Note: the BDOS does not require that the file be open to use Function 35.
However, if the file has been written to, it must be closed before calling
Function 35. Otherwise, an incorrect file size might be returned.

Upon return, Function 35 returns a zero in register A if the file specified by
the referenced FCB is found, or an $FF in register A if the file is not found.
Register H is set to zero in both of these cases. If a physical error is
encountered, Function 35 performs different actions depending on the BDOS error
mode (see Function 45). If the BDOS error mode is the default mode, a message
identifying the error is displayed at the console and the program is
terminated. Otherwise, Function 35 returns to the calling program with register
A set to $FF, and register H set to one of the following physical errors:

-   01 Disk I/O error
-   04 Invalid drive error

BDOS function 36: SET RANDOM RECORD

Entry Parameters:

-   C: $24
-   DE: FCB Address

Returned Value:

-   Random Record Field Set

The Set Random Record function returns the random record number of the next
record to be accessed from a file that has been read or written sequentially to
a particular point. This value is returned in the random record field, bytes
rO, rl, and r2, of the FCB addressed by the register pair DE. Function 36 can
be useful in two ways,

First, it is often necessary to initially read and scan a sequential file to
extract the positions of various key fields. As each key is encountered,
Function 36 is called to compute the random record position for the data
corresponding to this key. If the data unit size is 128 bytes, the resulting
record number minus one is placed into a table with the key for later
retrieval. After scanning the entire file and tabularizing the keys and their
record numbers, you can move directly to a particular record by performing a
random read using the corresponding random record number that you saved
earlier. The scheme is easily generalized when variable record lengths are
involved, because the program need only store the buffer-relative byte position
along with the key and record number to find the exact starting position of the
keyed data at a later time.

A second use of Function 36 occurs when switching from a sequential read or
write over to random read or write. A file is sequentially accessed to a
particular point in the file, then Function 36 is called to set the record
number, and subsequent random read and write operations continue from the next
record in the file.

BDOS function 37: RESET DRIVE

Entry Parameters:

-   C: $25
-   DE: Drive Vector

Returned Value:

-   A: $00

The Reset Drive function programmatically restores specified drives to the
reset state. A reset drive is not logged-in and is in Read-Write status. The
passed parameter in register pair DE is a 16-bit vector of drives to be reset,
where the least significant bit corresponds to the first drive A, and the
high-order bit corresponds to the sixteenth drive, labelled P. Bit values of 1
indicate that the specified drive is to be reset.

BDOS function 38: ACCESS DRIVE

Entry Parameters:

-   C: $26

This is an MP/M function that is not supported under CP/M 3. If called, the
file system returns a zero In register A indicating that the access request is
successful.

BDOS function 39: FREE DRIVE

Entry Parameters:

-   C: $27

This is an MP/M function that is not supported under CP/M 3. If called, the
file system returns a zero In register A indicating that the free request is
successful.

BDOS function 40: WRITE RANDOM WITH ZERO FILL

Entry Parameters:

-   C: $28
-   DE: FCB address

Returned Value:

-   A: Error Code
-   H: Physical Error

The Write Random With Zero Fill function is identical to the Write Random
function (Function 34) with the exception that a previously unallocated data
block is filled with zeros before the record is written. If this function has
been used to create a file, records accessed by a read random operation that
contain all zeros identify unwritten random record numbers. Unwritten random
records in allocated data blocks of files created using the Write Random
function (Function 34) contain uninitialized data.

BDOS function 41: TEST AND WRITE RECORD

Entry Parameters:

-   C: $29
-   DE: FCB Address

Returned Value:

-   A: Error Code
-   H: Physical Error

The Test and Write Record function is an MP/M function that is not supported
under CP/M 3. If called, Function 41 returns with register A set to $FF and
register H set to zero.

BDOS function 42: LOCK RECORD

Entry Parameters:

-   C: $2A
-   DE: FCB Address

Returned Value:

-   A: $00

The Lock Record function is an MP/M II function that is supported under CP/M 3
only to provide compatibility between CP/M 3 and MP/M. It is intended for use
in situations where more than one running program has Read-Write access to a
common file. Because CP/M 3 is a single-user operating system in which only one
program can run at a time, this situation cannot occur. Thus, under CP/M 3,
Function 42 performs no action except to return the value $00 in register A
indicating that the record lock operation is successful.

BDOS function 43: UNLOCK RECORD

Entry Parameters:

-   C: $2B
-   DE: FCB Address

Returned Value:

-   A: $00

The Unlock Record function is an MP/M II function that is supported under CP/M
3 only to provide compatibility between CP/M 3 and MP/M. It is intended for use
in situations where more than one running program has Read-Write access to a
common file. Because CP/M 3 is a single-user operating system in which only one
program can run at a time, this situation cannot occur. Thus, under CP/M 3,
Function 43 performs no action except to return the value $00 in register A
indicating that the record unlock operation is successful.

BDOS function 44: SET MULTI-SECTOR COUNT

Entry Parameters:

-   C: $2C
-   E: Number of Sectors

Returned Value:

-   A: Return Code

The Set Multi-Sector Count function provides logical record blocking under CP/M
3. It enables a program to read and write from 1 to 128 records of 128 bytes at
a time during subsequent BDOS Read and Write functions.

Function 44 sets the Multi-Sector Count value for the calling program to the
value passed in register E. Once set, the specified Multi-Sector Count remains
in effect until the calling program makes another Set Multi-Sector Count
function call and changes the value. Note that the CCP sets the Multi-Sector
Count to one when it initiates a transient program.

The Multi-Sector Count affects BDOS error reporting for the BDOS Read and Write
functions. If an error interrupts these functions when the Multi-Sector is
greater than one, they return the number of records successfully read or
written in register H for all errors except for physical errors (A = 255).

Upon return, register A is set to zero if the specified value is in the range
of 1 to 128. Otherwise, register A is set to $FF.

BDOS function 45: SET BDOS ERROR MODE

Entry Parameters:

-   C: $2D
-   E: BDOS Error Mode

Returned Value:

-   None

Function 45 sets the BDOS error mode for the calling program to the mode
specified in register E. If register E is set to $FF, 255 decimal, the error
mode is set to Return Error mode. If register E is set to $FE, 254 decimal, the
error mode is set to Return and Display mode. If register E is set to any other
value, the error mode is set to the default mode.

The SET BDOS Error Mode function determines how physical and extended errors
(see Section 2.2.13) are handled for a program. The Error Mode can exist in
three modes: the default mode, Return Error mode, and Return and Display Error
mode. In the default mode, the BDOS displays a system message at the console
that identifies the error and terminates the calling program. In the return
modes, the BDOS sets register A to $FF, 255 decimal, places an error code that
identifies the physical or extended error in register H and returns to the
calling program. In Return and Display mode, the BDOS displays the system
message before returning to the calling program. No system messages are
displayed, however, when the BDOS is in Return Error mode.

BDOS function 46: GET DISK FREE SPACE

Entry Parameters:

-   C: $2E
-   E: Drive

Returned Value:

-   First 3 bytes of current DMA buffer
-   A: Error Flag
-   H: Physical Error

The Get Disk Free Space function determines the number of free sectors, 128
byte records, on the specified drive. The calling program passes the drive
number in register E, with 0 for drive A, 1 for B, and so on, through 15 for
drive P in a full 16drive system. Function 46 returns a binary number in the
first 3 bytes of the current DMA buffer. This number is returned in the
following format:

fso fsl fs2

Disk Free Space Field Format

fso = low byte
fsl = middle byte
fs2 = high byte
Note that the returned free space value might be inaccurate if the drive has
been marked Read-Only.

Upon return, register A is set to zero if the function is successful. However,
if the BDOS Error Mode is one of the return modes (see Function 45), and a
physical error is encountered, register A is set to $FF, 255 decimal, and
register H is set to one of the following values:

-   01 - Disk I/O error
-   04 - Invalid drive error

BDOS function 47: CHAIN TO PROGRAM

Entry Parameters:

-   C: $2F
-   E: Chain Flag

The Chain To Program function provides a means of chaining from one program to
the next without operator intervention. The calling program must place a
command line terminated by a null byte, OOH, in the default DMA buffer. If
register E is set to $FF, the CCP initializes the default drive and user number
to the current program values when it passes control to the specified transient
program. Otherwise, these parameters are set to the default CCP values. Note
that Function 108, Get/Set Program Return Code, can be used to pass a two byte
value to the chained program.

Function 47 does not return any values to the calling program and any
encountered errors are handled by the CCP.

BDOS function 48: FLUSH BUFFERS

Entry Parameters:

-   C: $30

Returned Value:

-   A: Error Flag
-   H: Physical Error

E: Purge Flag

The Flush Buffers function forces the write of any write-pending records
contained in internal blocking/deblocking buffers. If register E is set to $FF,
this function also purges all active data buffers. Programs that provide write
with read verify support need to purge internal buffers to ensure that
verifying reads actually access the disk instead of returning data that is
resident in internal data buffers. The CP/M 3 PIP utility is an example of such
a program.

Upon return, register A is set to zero if the flush operation is successful. If
a physical error is encountered, the Flush Buffers function performs different
actions depending on the BDOS error mode (see Function 45). If the BDOS error
mode is in the default mode,, a message identifying the error is displayed at
the console and the calling program is terminated. Otherwise, the Flush Buffers
function returns to the calling program with register A set to $FF and register
H set to the following physical error code:

-   0 1 Disk I/O error
-   02 Read/only disk
-   04 Invalid drive error

BDOS function 49: GET/SET SYSTEM CONTROL BLOCK

Entry Parameters:

-   C: $31
-   DE: SCB PB Address

Returned Value:

-   A: Returned Byte
-   HL: Returned Word

Function 49 allows access to parameters located in the CP/M 3 System Control
Block (SCB). The SCB is a 100-byte data structure residing within the BDOS that
contains flags and data used by the BDOS, CCP and other system components. Note
that Function 49 is a CP/M 3 specific function. Programs intended for both MP/M
11 and CP/M 3 should either avoid the use of this function or isolate calls to
this function in CP/M 3 version-dependent sections.

To use Function 49, the calling program passes the address of a data structure
called the SCB parameter block in register pair DE. This data structure
identifies the byte or word of the SCB to be updated or returned. The SCB
parameter block is defined as:

    SCBPB: DB OFFSET ; Offset within SCB
           DB SET ; 0FFH if setting a byte
           ; 0FEH if setting a word
           ; 001H - 0FDH are reserved
           ; 000H if a get operation
           DW VALUE ; Byte or word value to be set

The OFFSET parameter identifies the offset of the field within the SCB to be
updated or accessed. The SET parameter determines whether Function 49 is to set
a byte or word value in the SCB or if it is to return a byte from the SCB. The
VALUE parameter is used only in set calls. In addition, only the first byte of
VALUE is referenced in set byte calls.

Use caution when you set SCB fields. Some of these parameters reflect the
current state of the operating system. If they are set to invalid values,
software errors can result. In general, do not use Function 49 to set a system
parameter if another BDOS function can achieve the same result. For example,
Function 49 can be called to update the Current DMA Address field within the
SCB. This is not equivalent to making a Function 26, Set DMA Address call, and
updating the SCB Current DMA field in this way would result in system errors.
However, you can use Function 49 to return the Current DMA address. The System
Control Block is summarized in [table:91].

If Function 49 is called with the OFFSET parameter of the SCB parameter block
greater than $63, the function performs no action but returns with registers A
and HL set to zero.

BDOS function 50: DIRECT BIOS CALLS

Entry Parameters:

-   C: $32
-   DE: BIOS PB Address

Returned Value:

-   BIOS RETURN

Function 50 provides a direct BIOS call through the BDOS to the BIOS. The
calling program passes the address of a data structure called the BIOS
Parameter Block (BIOSPB) in register pair DE. The BIOSPB contains the BIOS
function number and register contents as shown below:

    BIOSPB: db FUNC ; BIOS function no.
            db AREG ; A register contents
            dw BCREG ; BC register contents
            dw DEREG ; DE register contents
            dw HLREG ; HL register contents

System Reset (Function 0) is equivalent to Function 50 with a BIOS function
number of 1.

Note that the register pair BIOSPB fields (BCREG, DEREG, HLREG) arc defined in
low byte, high byte order. For example, in the BCREG field, the first byte
contains the C register value, the second byte contains the B register value.
Under CP/M 3, direct BIOS calls via the BIOS jump vector are only supported for
the BIOS Console I/O and List functions. You must use Function 50 to call any
other

BIOS functions. In addition, Function 50 intercepts BIOS Function 27 (Select
Memory) calls and returns with register A set to zero. Refer to the CPIM Plus
(CP/M Version 3) Operating System System Guide for the definition of the BIOS
functions and their register passing and return conventions.

BDOS function 59: LOAD OVERLAY

Entry Parameters:

-   C: $3B
-   DE: FCB Address

Returned Value:

-   A: Error Code
-   H: Physical Error

Only transient programs with an RSX header can use the Load Overlay function
because BDOS Function 59 is supported by the LOADER module. The calling program
must have a header to force the LOADER to remain resident after the program is
loaded (see Section 1.3).

Function 59 loads either an absolute or relocatable module. Relocatable modules
are identified by a filetype of PRL. Function 59 does not call the loaded
module.

The referenced FCB must be successfully opened before Function 59 is called.
The load address is specified in the first two random record bytes of the FCB,
rO and rl. The LOADER returns an error if the load address is less than $100,
or if performing the requested load operation would overlay the LOADER, or any
other Resident System Extensions that have been previously loaded.

When loading relocatable files, the LOADER requires enough room at the load
address for the complete PRL file including the header and bit map (see
Appendix B). Otherwise an error is returned. Function 59 also returns an error
on PRL file load requests if the specified load address is not on a page
boundary.

Upon return, Function 59 sets register A to zero if the load operation is
successful. If the LOADER RSX is not resident in memory because the calling
program did not have a RSX header, the BDOS returns with register A set to $FF
and register H set to zero. If the LOADER detects an invalid load address, or
if insufficient memory is available to load the overlay, Function 59 returns
with register A set to $FE. All other error returns are consistent with the
error codes returned by BDOS Function 20, Read Sequential.

BDOS function 60: CALL RESIDENT SYSTEM EXTENSION

Entry Parameters:

-   C: $3C
-   DE: RSX PB Address

Returned Value:

-   A: Error Code
-   H: Physical Error

Function 60 is a special BDOS function that you use when you call Resident
System Extensions. The RSX subfunction is specified in a structure called the
RSX Parameter Block, defined as follows:

    RSXPB: db FUNC ; RSX Function number
           db NUMPARMS ; Number of word Parameters
           dw PARMETER1 ; Parameter I
           dw PARMETER2 ; Parameter 2
           . . .
           dw PARMETERN ; Parameter n

RSX modules filter all BDOS calls and capture RSX function calls that they can
handle. If there is no RSX module present in memory that can handle a specific
RSX function call, the call is not trapped, and the BDOS returns $FF in
registers A and L. RSX function numbers from 0 to 127 are available for CP/M 3
compatible software use. RSX function numbers 128 to 255 are reserved for
system use.

BDOS function 98: FREE BLOCKS

Entry Parameters:

-   C: $62

Returned Value:

-   A: Error Flag
-   H: Physical Error

The Free Blocks function scans all the currently logged-in drives, and for each
drive returns to free space all temporarily-allocated data blocks. A
temporarily-allocated data block is a block that has been allocated to a file
by a BDOS write operation but has not been permanently recorded in the
directory by a BDOS close operation. The CCP calls Function 98 when it receives
control following a system warm start. Be sure to close your file, particularly
any file you have written to, prior to calling Function 98.

In the nonbanked version of CP/M 3, Function 98 frees only temporarily
allocated blocks for systems that request double allocation vectors in GENCPM.

Upon return, register A is set to zero if Function 98 is successful. If a
physical error is encountered, the Free Blocks function performs different
actions depending on the BDOS error mode (see Function 45). If the BDOS error
mode is in the default mode, a message identifying the error is displayed at
the console and the calling program is terminated. Otherwise, the Free Blocks
function returns to the calling program with register A set to $FF and register
H set to the following physical error code:

-   04 : Invalid drive error

BDOS function 99: TRUNCATE FILE

Entry Parameters:

-   C: $63
-   DE: FCB Address

Returned Value:

-   A: Directory Code
-   H: Extended or Physical Error

The Truncate File function sets the last record of a file to the random record
number contained in the referenced FCB. The calling program passes the address
of the FCB in register pair DE, with byte 0 of the FCB specifying the drive,
bytes 1 through 11 specifying the filename and filetype, and bytes 33 through
35, rO, rl, and r2, specifying the last record number of the file. The last
record number is a 24 bit value, stored with the least significant byte first,
rO, the middle byte next, rl, and the high byte last, r2. This value can range
from 0 to 262,143, which corresponds to a maximum value of 3 in byte r2.

If the file specified by the referenced FCB is password protected, the correct
password must be placed in the first eight bytes of the current DMA buffer, or
have been previously established as the default password (see Function 106).

Function 99 requires that the file specified by the FCB not be open,
particularly if the file has been written to. In addition, any activated FCBs
naming the file are not valid after Function 99 is called. Close your file
before calling Function 99, and then reopen it after the call to continue
processing on the file.

Function 99 also requires that the random record number field of the referenced
FCB specify a value less than the current file size. In addition, if the file
is sparse, the random record field must specify a record in a region of the
file where data exists.

Upon return, the Truncate function returns a Directory Code in register A with
the value 0 if the Truncate function is successful, or $FF, 255 decimal, if the
file is not found or the record number is invalid. Register H is set to zero in
both of these cases. If a physical or extended error is encountered, the
Truncate function performs different actions depending on the BDOS error mode
(see Function 45). If the BDOS error mode is in the default mode, a message
identifying the error is displayed at the console and the program is
terminated. Otherwise, the Truncate function returns to the calling program
with register A set to $FF and register H set to one of the following physical
or extended error codes:

-   01 Disk I/O error
-   02 Read-Only disk
-   03 Read-Only file
-   04 Invalid drive error
-   07 File password error
-   09 ? in filename or filetype field

BDOS function 100: SET DIRECTORY LABEL

Entry Parameters:

-   C: $64
-   DE: FCB Address

Returned Value:

-   A: Directory Code
-   H: Physical or Extended Error

The Set Directory Label function creates a directory label, or updates the
existing directory label for the specified drive. The calling program passes in
register pair DE the address of an FCB containing the name, type, and extent
fields to be assigned to the directory label. The name and type fields of the
referenced FCB are not used to locate the directory label in the directory;
they are simply copied into the updated or created directory label. The extent
field of the FCB, byte 12, contains the user's specificat-on of the directory
label data byte. The definition of the directory label data byte is:

-   7 - Require passwords for password-protected files (Not supported in
    nonbanked CP/M 3 systems)
-   6 - Perform access date and time stamping
-   5 - Perform update date and time stamping
-   4 - Perform create date and time stamping
-   0 - Assign a new password to the directory label

If the current directory label is password protected, the correct password must
be placed in the first eight bytes of the current DMA, or have been previously
established as the default password (see Function 106). If bit 0, the low-order
bit, of byte 12 of the FCB is set to 1, it indicates that a new password for
the directory label has been placed in the second eight bytes of the current
DMA.

Note that Function 100 is implemented as an RSX, DIRLBL.RSX, in nonbanked CP/M
3 systems. If Function 100 is called in nonbanked systems when the DIRLBL.RSX
is not resident an error code of $0FF is returned.

Function 100 also requires that the referenced directory contain SFCBs to
activate date and time stamping on the drive. If an attempt is made to activate
date and time stamping when no SFCBs exist, Function 100 returns an error code
of $FF in register A and performs no action. The CP/M 3 INITDIR utility
initializes a directory for date and time stamping by placing an SFCB record in
every fourth entry of the directory.

Function 100 returns a Directory Code in register A with the value 0 if the
directory label create or update is successful, or $FF, 255 decimal, if no
space exists in the referenced directory to create a directory label, or if
date and time stamping was requested and the referenced directory did not
contain SFCBS. Register H is set to zero in both of these cases. If a physical
error or extended error is encountered, Function 100 performs different actions
depending on the BDOS error mode (see Function 45). If the BDOS error mode is
the default mode, a message identifying the error is displayed at the console
and the calling program is terminated. Otherwise, Function 100 returns to the
calling program with register A set to $FF and register H set to one of the
following physical or extended error codes:

-   01 Disk I/O error
-   02 Read-Only disk
-   04 Invalid drive error
-   07 File password error

BDOS function 101: RETURN DIRECTORY LABEL DATA

Entry Parameters:

-   C: $65
-   E: Drive

Returned Value:

-   A: Directory Label Data Byte
-   H: Physical Error

The Return Directory Label Data function returns the data byte of the directory
label for the specified drive. The calling program passes the drive number in
register E with 0 for drive A, 1 for drive B, and so on through 15 for drive P
in a full sixteen drive system. The format of the directory label data byte is
shown below:

-   7 - Require passwords for password protected files
-   6 - Perform access date and time stamping
-   5 - Perform update date and time stamping
-   4 - Perform create date and time stamping
-   0 - Directory label exists on drive

Function 101 returns the directory label data byte to the calling program in
register A. Register A equal to zero indicates that no directory label exists
on the specified drive. If a physical error is encountered by Function 101 when
the BDOS Error mode is in one of the return modes (see Function 45), this
function returns with register A set to $FF, 25S decimal, and register H set to
one of the following:

-   01 Disk I/O error
-   04 Invalid drive error

BDOS function 102: READ FILE DATE STAMPS AND PASSWORD MODE

Entry Parameters:

-   C: $66

-   DE: FCB Address

Returned Value:

-   A: Directory Code

-   H: Physical Error

Function 102 returns the date and time stamp information and password mode for
the specified file in byte 12 and bytes 24 through 32 of the specified FCB. The
calling program passes in register pair DE, the address of an FCB in which the
drive, filename, and filetype fields have been defined.

If Function 102 is successful, it sets the following fields in the referenced
FCB:

-   byte 12 : Password mode field

    -   7 - Read mode

    -   6 - Write mode

    -   4 - Delete mode

Byte 12 equal to zero indicates the file has not been assigned a password. In
nonbanked systems, byte 12 is always set to zero.

-   byte 24 - 27 Create or Access time stamp field

-   byte 28 - 31 Update time stamp field

The date stamp fields are set to binary zeros if a stamp has not been made. The
format of the time stamp fields is the same as the format of the date and time
structure described in Function 104.

Upon return, Function 102 returns a Directory Code in register A with the value
zero if the function is successful, or $FF, 255 decimal, if the specified file
is not found. Register H is set to zero in both of these cases. If a physical
or extended error is encountered, Function 102 performs different actions
depending on the BDOS error mode (see Function 45). If the BDOS error mode is
in the default mode, a message identifying the error is displayed at the
console and the calling program is terminated. Otherwise, Function 102 returns
to the calling program with register A set to $FF and register H set to one of
the following physical or extended error codes:

-   01 Disk I/O error

-   04 Invalid drive error

-   09 ? in filename or filetype field

BDOS function 103: WRITE FILE XFCB

Entry Parameters:

-   C: $67

-   DE: FCB Address

Returned Value:

-   A: Directory Code

-   H: Physical Error

The Write File XFCB function creates a new XFCB or updates the existing XFCB
for the specified file. The calling program passes in register pair DE the
address of an FCB in which the drive, name, type, and extent fields have been
defined. The extent field specifies the password mode and whether a new
password is to be assigned to the file. The format of the extent byte is shown
below:

FCB byte 12 (ex) : XFCB password mode

-   7 - Read mode

-   6 - Write mode

-   5 - Delete mode

-   0 - Assign new password to the file

If the specified file is currently password protected, the correct password
must reside in the first eight bytes of the current DMA, or have been
previously established as the default password (see Function 106). If bit 0 is
set to 1, the new password must reside in the second eight bytes of the current
DMA.

Upon return, Function 103 returns a Directory Code in register A with the value
zero if the XFCB create or update is successful, or $FF, 255 decimal, if no
directory label exists on the specified drive, or the file named in the FCB is
not found, or no space exists in the directory to create an XFCB. Function 103
also returns with $FF in register A if passwords are not enabled by the
referenced directory's label. On nonbanked systems, this function always
returns with register A = $FF because passwords are not supported. Register H
is set to zero in all of these cases. If a physical or extended error is
encountered, Function 103 performs different actions depending on the BDOS
error mode (see Function 45). If the BDOS error mode is the default mode, a
message identifying the error is displayed at the console and the calling
program is terminated. Otherwise, Function 103 returns to the calling program
with register A set to $FF and register H set to one of the following physical
or extended error codes:

-   01 Disk I/O error

-   02 Read-Only disk

-   04 Invalid drive error

-   07 File password error

-   09 ? in filename or filetype field

BDOS function 104: SET DATE AND TIME

Entry Parameters:

-   C: $68

-   DE: DAT Address

Returned Value:

-   none

The Set Date and Time function sets the system internal date and time. The
calling program passes the address of a 4-byte structure containing the date
and time specification in the register pair DE. The format of the date and time
(DAT) data structure is:

-   0 - 1 Date field

-   2 Hour field

-   3 Minute field

The date is represented as a 16-bit integer with day 1 corresponding to January
1, 1978. The time is represented as two bytes: hours and minutes are stored as
two BCD digits.

This function also sets the seconds field of the system date and time to zero.

BDOS function 105: GET DATE AND TIME

Entry Parameters:

-   C: $69

-   DE: DAT Address

Returned Value:

-   A: seconds

-   DAT set

The Get Date and Time function obtains the system internal date and time. The
calling program passes in register pair DE, the address of a 4-byte data
structure which receives the date and time values. The format of the date and
time, DAT, data structure is the same as the format described in Function 104.
Function 105 also returns the seconds field of the system date and time in
register A as a two digit BCD value.

BDOS function 106: SET DEFAULT PASSWORD

Entry Parameters:

-   C: $6A

-   DE: Password Address

Returned Value:

-   none

The Set Default Password function allows a program to specify a password value
before a file protected by the password is accessed. When the file system
accesses a password-protected file, it checks the current DMA, and the default
password for the correct value. If either value matches the file's password,
full access to the file is allowed. Note that this function performs no action
in nonbanked CP/M 3 systems because file passwords are not supported.

To make a Function 106 call, the calling program sets register pair DE to the
address of an 8-byte field containing the password.

BDOS function 107: RETURN SERIAL NUMBER

Entry Parameters:

-   C: $6B

-   DE: Serial Number Field

Returned Value:

-   Serial number field set

Function 107 returns the CP/M 3 serial number to the 6-byte field addressed by
register pair DE.

BDOS function 108: GET/SET PROGRAM RETURN CODE

Entry Parameters:

-   C: $6C

-   DE: $0FFFF (Get) or Program Return Code (Set)

Returned Value:

-   HL: Program Return Code or (no value)

CP/M 3 allows programs to set a return code before terminating. This provides a
mechanism for programs to pass an error code or value to a following job step
in batch environments. For example, Program Return Codes are used by the CCP in
CP/M 3's conditional command line batch facility. Conditional command lines are
command lines that begin with a colon, :. The execution of a conditional
command depends on the successful execution of the preceding command. The CCP
tests the return code of a terminating program to determine whether it
successfully completed or terminated in error. Program return codes can also be
used by programs to pass an error code or value to a chained program (see
Function 47, Chain To Program).

A program can set or interrogate the Program Return Code by calling Function
108. If re 'ster pair DE = $FFFF, then the current Program Return Code is
returned in register pair HL. Otherwise, Function 108 sets the Program Return
Code to the 'value contained in register pair DE. Program Return Codes are
defined in [table:92]

BDOS function 109: GET/SET CONSOLE MODE

Entry Parameters:

-   C: $6D

-   DE: $FFFF (Get) or Console Mode (Set)

Returned Value:

-   HL: Console Mode or (no value)

A program can set or interrogate the Console Mode by calling Function 109. If
register pair DE = $FFFF, then the current Console Mode is returned in register
HL. Otherwise, Function 109 sets the Console Mode to the value contained in
register pair DE.

The Console Mode is a 16-bit system parameter that determines the action of
certain BDOS Console I/O functions. The definition of the Console Mode is:

-   = 1 - CTRL-C only status for Function 1 1.
    = 0 - Normal status for Function 1 1.

-   = 1- Disable stop scroll, CTRL-S, start scroll, CTRL-Q, support.
    = 0-Enable stop scroll, start scroll support.

-   = 1- Raw console output mode. Disables tab expansion for Functions 2, 9
    and 111. Also disables printer echo, CTIRL-P, support.
    = 0 - Normal console output mode.

-   = 1 - Disable CTRL-C program termination
    = 0 - Enable CTRL-C program termination

-   -Console status mode for RSXs that perform console input redirection from a
    file. These bits determine how the RSX responds to console status requests.

    -   bit 8 = 0, bit 9 = 0 - conditional status

    -   bit 8 = 0, bit 9 = 1 - false status

    -   bit 8 = 1, bit 9 = 0 - true status

    -   bit 8 = 1, bit 9 = 1 - bypass redirection

Note that the Console Mode bits are numbered from right to left.

The CCP initializes the Console Mode to zero when it loads a program unless the
program has an RSX that overrides the default value. Refer to Section 2.2.1 for
detailed information on Console Mode.

BDOS function 110: GET/SET OUTPUT DELIMITER

Entry Parameters:

-   C: $6E

-   DE: $FFFF (Get) or

-   E: Output Delimiter (Set)

Returned Value:

-   A: Output Delimiter or (no value)

A program can set or interrogate the current Output Delimiter by calling
Function 110. If register pair DE = $FFFF, then the current Output Delimiter is
returned in register A. Otherwise, Function 110 sets the Output Delimiter to
the value contained in register E.

Function 110 sets the string delimiter for Function 9, Print String. The
default delimiter value is a dollar sign, $. The CCP restores the Output
Delimiter to the default value when a transient program is loaded.

BDOS function 111: PRINT BLOCK

Entry Parameters:

-   C: $6F

-   DE: CCB Address

Returned Value:

-   none

The Print Block function sends the character string located by the Character
Control Block, CCB, addressed in register pair DE, to the logical console,
CONOUT:. If the Console Mode is in the default state (see Section 2.2.1),
Function 111 expands tab characters, CTRL-I, in columns of eight characters. It
also checks for stop scroll, CTRL-S, start scroll, CTRL-Q, and echoes to the
logical list device, LST:, if printer echo, CTRL-P, has been invoked.

The CCB format is:

-   0 - 1 Address of character string (word value)

-   2 - 3 Length of character string (word value)

BDOS function 112: LIST BLOCK

Entry Parameters:

-   C: $70

-   DE: CCB Address

Returned Value:

-   none

The List Block function sends the character string located by the Character
Control Block, CCB, addressed in register pair DE, to the logical list device,
LST:.

The CCB format is:

-   0 - 1 Address of character string (word value)

-   2 - 3 Length of character string (word value)

BDOS function 152: PARSE FILENAME

Entry Parameters:

-   C: $98

-   DE: PFCB Address

Returned Value:

-   HL: Return code

-   Parsed file control block

The Parse Filename function parses an ASCII file specification and prepares a
File Control Block, FCB. The calling program passes the address of a data
structure called the Parse Filename Control Block, PFCB, in register pair DE.
The PFCB contains the address of the input ASCII filename string followed by
the address of the target FCB as shown below:

     PFCB: DW INPUT ; Address of input ASCII string
           DW FCB ; Address of target FCB

The maximum length of the input ASCII string to be parsed is 128 bytes. The
target FCB must be 36 bytes in length.

Function 152 assumes the input string contains file specifications in the
following form:

{d:}filename{.typ}{;password}

where items enclosed in curly brackets are optional. Function 152 also accepts
isolated drive specifications d: in the input string. When it encounters one,
it sets the filename, filetype, and password fields in the FCB to blank.

The Parse Filename function parses the first file specification it finds in the
input string. The function first eliminates leading blanks and tabs. The
function then assumes that the file specification ends on the first delimiter
it encounters that is out of context with the specific field it is parsing. For
instance, if it finds a colon, and it is not the second character of the file
specification, the colon delimits the entire file specification.

Function 152 recognizes the following characters as detimiters:

-   space

-   tab

-   return

-   nut]

-   ; (semicolon) - except before password field

-   = (equal)

-   < (less than)

-   > (greater than)

-   . (period) - except after filename and before filetype

-   : (colon) - except before filename and after drive

-   , (comma)

-   | (vertical bar)

-   ] (right square bracket)

If Function 152 encounters a non-graphic character in the range 1 through 31
not listed above, it treats the character as an error. The Parse Filename
function initializes the specified FCB shown in [table:93].

If an error occurs, Function 152 returns an $FFFF in register pair HL.

On a successful parse, the Parse Filename function checks the next item in the
input string. It skips over trailing blanks and tabs and looks at the next
character. If the character is a null or carriage return, it returns a 0
indicating the end of the input string. If the character is a delimiter, it
returns the address of the delimiter. If the character is not a delimiter, it
returns the address of the first trailing blank or tab.

If the first non-blank or non-tab character in the input string is a null, 0,
or carriage return, the Parse Filename function returns a zero indicating the
end of string.

If the Parse Filename function is to be used to parse a subsequent file
specification in the input string, the returned address must be advanced over
the delimiter before placing it in the PFCB.

@------------------------------------------------------------------------------
@node BIOS
@next PLUS3DOS
@prev BDOS
@toc SYS_TOC
@{r}ZX Spectrum Next Programming Notes
@{h2}BIOS

System Initialization Functions

This section defines the BIOS system initialization routines BOOT, WBOOT,
DEVTBL, DEVINI, and DRVTBL.

BIOS Function 0: BOOT

Get Control from Cold Start Loader and Initialize System
Entry Parameters: None
Returned Values: None

The BOOT entry point gets control from the Cold Start Loader in Bank 0 and is
responsible for basic system initialization. Any remaining hardware
initialization that is not done by the boot ROMS, the Cold Boot Loader, or the
LDRBIOS should be performed by the BOOT routine.

BIOS Function 1: WBOOT

Get Control When a Warm Start Occurs
Entry Parameters: None
Returned Values: None

The WBOOT entry point is entered when a warm start occurs. A warm start is
performed whenever a user program branches to location 0000H or attempts to
return to the CCP.

BIOS Function 20: DEVTBL

Return Address of Character I/O Table
Entry Parameters: None
Returned Values: HL=address of Chrtbl

The DEVTBL and DEVINI entry points allow you to support device assignment with
a flexible, yet completely optional system. It replaces the IOBYTE facility of
CP/M 2.2.

BIOS Function 21: DEVINI

Initialize Character I/O Device
Entry Parameters: C=device number, 0-15
Returned Values: None

The DEVINI routine initializes the physical character device specified in
register C to the baud rate contained in the appropriate entry of the CHRTBL.

BIOS Function 22: DRVTBL

Return Address of Disk Drive Table
Entry Parameters: None
Returned Values:

-   HL=Address of Drive Table of Disk Parameter Headers (DPH); Hashing can
    utilized if specified by the DPHs Referenced by this DRVTBL.

-   HL=$ffff if no Drive Table; GENCPM does not set up buffers. Hashing is
    supported.

-   HL=$fffe if no Drive Table; GENCPM does not set up buffers. Hashing is not
    supported.

The first instruction of this subroutine must be an LXI H,<address> where
<address> is one of the above returned values. The GENCPM utility accesses the
address in this instruction to locate the drive table and the disk parameter
data structures to determine which system configuration to use.

Character I/O Functions

This section defines the CP/M 3 character I/O routines CONST, CONIN, CONOUT,
LIST, AUXOUT, AUXIN, LISTST, CONOST, AUXIST, and AUXOST. CP/M 3 assumes all
simple character I/O operations are performed in eight-bit ASCII, upper and
lowercase, with no parity. An ASCII CTRL-Z ($1a) denotes an end-of-file
condition for an input device.

In CP/M 3, you can direct each of the five logical character devices to any
combination of up to twelve physical devices. Each of the five logical devices
has a 16-bit vector in the System Control Block (SCB) . Each bit of the vector
represents a physical device where bit 15 corresponds to device zero, and bit 4
is device eleven. Bits 0 through 3 are reserved for future system use.

BIOS Function 2: CONST

Sample the Status of the Console Input Device
Entry Parameters: None
Returned value:

-   A=$ff if a console character is ready to read

-   A=$00 if no console character is ready to read

Read the status of the currently assigned console device and return $ff in
register A if a character is ready to read, and $ff in register A if no console
characters are ready.

BIOS Function 3: CONIN

Read a Character from the Console
Entry Parameters: None
Returned Values: A=Console Character

Read the next console character into register A with no parity. If no console
character is ready, wait until a character is available before returning.

BIOS Function 4: CONOUT

Output Character to Console
Entry Parameters: C=Console Character
Returned Values: None

Send the character in register C to the console output device. The character is
in ASCII with no parity.

BIOS Function 5: LIST

Output Character to List Device
Entry Parameters: C=Character
Returned Values: None

Send the character from register C to the listing device. The character is in
ASCII with no parity.

BIOS Function 6: AUXOUT

Output a Character to the Auxiliary Output Device
Entry Parameters: C=Character
Returned Values: None

Send the character from register C to the currently assigned AUXOUT device. The
character is in ASCII with no parity.

BIOS Function 7: AUXIN

Read a Character from the Auxiliary Input Device
Entry Parameters: None
Returned Values: A=Character

Read the next character from the currently assigned AUXIN device into register
A with no parity. A returned ASCII CTRL-Z ($1a) reports an end-of-file.

BIOS Function 15: LISTST

Return the Ready Status of the List Device
Entry Parameters: None
Returned Values:

-   A=$00 if list device is not ready to accept a character

-   A=$ff if list device is ready to accept a character

BIOS Function 17: CONOST

Return Output Status of Console
Entry Parameters: None
Returned Values:

-   A=$ff if ready

-   A=$00 if not ready

The CONOST routine checks the status of the console. CONOST returns an $ff if
the console is ready to display another character. This entry point allows for
full polled handshaking communications support.

BIOS Function 18: AUXIST

Return Input Status of Auxiliary Port
Entry Parameters: None
Returned Values:

-   A=$ff if ready

-   A=$00 if not ready

The AUXIST routine checks the input status of the auxiliary port. This entry
point allows full polled handshaking for communications support using an
auxiliary port.

BIOS Function 19: AUXOST

Return Output Status of Auxiliary Port
Entry Parameters: None
Returned Values:

-   A=$ff if ready

-   A=$00 if not ready

The AUXOST routine checks the output status of the auxiliary port. This routine
allows full polled handshaking for communications support using an auxiliary
port.

Disk I/O Functions

This section defines the CP/M 3 BIOS disk I/O routines HOME, SELDSK, SETTRK,
SETSEC, SETDMA, READ, WRITE, SECTRN, MULTIO, and FLUSH.

BIOS Function 8: HOME

Select Track 00 of the Specified Drive
Entry Parameters: None
Returned Values: None

Return the disk head of the currently selected disk to the track 00 position.
Usually, you can translate the HOME call into a call on SETTRK with a parameter
of 0.

BIOS Function 9: SELDSK

Select the Specified Disk Drive
Entry Parameters:

-   C=Disk Drive (0-15)

-   E=Initial Select Flag

Returned Values:

-   HL=Address of Disk Parameter Header (DPH) if drive exists

-   HL=0000H if drive does not exist

Select the disk drive specified in register C for further operations, where
register C contains 0 for drive A, 1 for drive B, and so on to 15 for drive P.
On each disk select, SELDSK must return in HL the base address of a 25-byte
area called the Disk Parameter Header. If there is an attempt to select a
nonexistent drive, SELDSK returns HL=$0000 as an error indicator. On entry to
SELDSK, you can determine if it is the first time the specified disk is
selected. Bit 0, the least significant bit in register E, is set to 0 if the
drive has not been previously selected. This information is of interest in
systems that read configuration information from the disk to set up a dynamic
disk definition table.

BIOS Function 10: SETTRK

Set Specified Track Number
Entry Parameters: BC=Track Number
Returned Values: None

Register BC contains the track number for a subsequent disk access on the
currently selected drive. Normally, the track number is saved until the next
READ or WRITE occurs.

BIOS Function 11: SETSEC

Set Specified Sector Number
Entry Parameters: BC=Sector Number
Returned Values: None

Register BC contains the sector number for the subsequent disk access on the
currently selected drive. This number is the value returned by SECTRN. Usually,
you delay actual sector selection until a READ or WRITE operation occurs.

BIOS Function 12: SETDMA

Set Address for Subsequent Disk I/O
Entry Parameters: BC=Direct Memory Access Address
Returned Values: None

Register BC contains the DMA (Direct Memory Access) address for the subsequent
READ or WRITE operation. For example, if B = $00 and C = $80 when the BDOS
calls SETDMA, then the subsequent read operation reads its data starting at
$80, or the subsequent write operation gets its data from 80H, until the next
call to SETDMA occurs.

BIOS Function 13: READ

Read a Sector from the Specified Drive
Entry Parameters: None
Returned Values:

-   A=$00 if no errors occurred

-   A=$01 if nonrecoverable error condition occurred

-   A=$ff if media has changed

Assume the BDOS has selected the drive, set the track, set the sector, and
specified the DMA address. The READ subroutine attempts to read one sector
based upon these parameters, then returns one of the error codes in register A
as described above.

If the value in register A is $00, then CP/M 3 assumes that the disk operation
completed properly. If an error occurs, the BIOS should attempt several retries
to see if the error is recoverable before returning the error code.

If an error occurs in a system that supports automatic density selection, the
system should verify the density of the drive. If the density has changed,
return a $ff in the accumulator. This causes the BDOS to terminate the current
operation and relog in the disk.

BIOS Function 14: WRITE

Write a Sector to the Specified Disk
Entry Parameters: C=Deblocking Codes
Returned Values:

-   A=$00 if no error occurred

-   A=$01 if physical error occurred

-   A=$02 if disk is Read-Only

-   A=$ff if media has changed

Write the data from the currently selected DMA address to the currently
selected drive, track, and sector. Upon each call to WRITE, the BDOS provides
the following information in register C:

-   0 = deferred write

-   1 = nondeferred write

-   2 = deferred write to the first sector of a new data block

This information is provided for those BIOS implementations that do
blocking/deblocking in the BIOS instead of the BDOS.

BIOS Function 16: SECTRN

Translate Sector Number Given Translate Table Entry Parameters:

-   BC=Logical Sector Number

-   DE=Translate Table Address

Returned Values: HL=Physical Sector Number

SECTRN performs logical sequential sector address to physical sector
translation to improve the overall response of CP/M 3.

BIOS Function 23: MULTIO

Set Count of Consecutive Sectors for READ or WRITE
Entry Parameters: C=Multisector Count
Returned Values: None

To transfer logically consecutive disk sectors to or from contiguous memory
locations, the BDOS issues a MULTIO call, followed by a series of READ or WRITE
calls. This allows the BIOS to transfer multiple sectors in a single disk
operation. The maximum value of the sector count is dependent on the physical
sector size, ranging from 128 with 128-byte sectors, to 4 with 4096-byte
sectors. Thus, the BIOS can transfer up to 16K directly to or from the TPA with
a single operation.

BIOS Function 24: FLUSH

Force Physical Buffer Flushing for User-supported Deblocking
Entry Parameters: None
Returned Values:

-   A=$00 if no error occurred

-   A=$001 if physical error occurred

-   A=$002 if disk is Read-Only

The flush buffers entry point allows the system to force physical sector buffer
flushing when your BIOS is performing its own record blocking and deblocking.
The BDOS calls the FLUSH routine to ensure that no dirty buffers remain in
memory.

Memory Select and Move Functions

This section defines the memory management functions MOVE, XMOVE, SELMEM, and
SETBNK.

BIOS Function 25: MOVE

Memory-to-Memory Block Move
Entry Parameters:

-   HL=Destination address

-   DE=Source address

-   BC=Count

Returned Values: HL and DE must point to next bytes following move operation

The BDOS calls the MOVE routine to perform memory to memory block moves to
allow use of the Z80 LDIR instruction or special DMA hardware, if available.
Note that the arguments in HL and DE are reversed from the Z8O machine
instruction, necessitating the use of XCHG instructions on either side of the
LDIR. The BDOS uses this routine for all large memory copy operations. On
return, the HL and DE registers are expected to point to the next bytes
following the move.

Usually, the BDOS expects MOVE to transfer data within the currently selected
bank or common memory. However, if the BDOS calls the XMOVE entry point before
calling MOVE, the MOVE routine must perform an interbank transfer.

BIOS Function 27: SELMEM

Select Memory Bank
Entry Parameters: A=Memory Bank
Returned Values; None

The SELMEM entry point is only present in banked systems. The banked version of
the CP/M 3 BDOS calls SELMEM to select the current memory bank for further
instruction execution or buffer references. You must preserve or restore all
registers other than the accumulator, A, upon exit.

BIOS Function 28: SETBNK

Specify Bank for DMA Operation
Entry Parameters: A=Memory Bank
Returned Values: None

SETBNK only occurs in the banked version of CP/M 3. SETBNK specifies the bank
that the subsequent disk READ or WRITE routine must use for memory transfers.
The BDOS always makes a call to SETBNK to identify the DMA bank before
performing a READ or WRITE call. Note that the BDOS does not reference banks
other than 0 or 1 unless another bank is specified by the BANK field of a Data
Buffer Control Block (BCB).

BIOS Function 29: XMOVE

Set Banks for Following MOVE
Entry Parameters:

-   B=destination bank

-   C=source bank

Returned Values: None

XMOVE is provided for banked systems that support memory-to- memory DMA
transfers over the entire extended address range. Systems with this feature can
have their data buffers located in an alternate bank instead of in common
memory, as is usually required. An XMOVE call affects only the following MOVE
call. All subsequent MOVE calls apply to the memory selected by the latest call
to SELMEM. After a call to the XMOVE function, the following call to the MOVE
function is not more than 128 bytes of data.

Clock Support Function

This section defines the clock support function TIME.

BIOS Function 26: TIME

Get and Set Time
Entry Parameters: C=Time Get/Set Flag
Returned values: None

The BDOS calls the TIME function to indicate to the BIOS whether it has just
set the Time and Date fields in the SCB, or whether the BDOS is about to get
the Time and Date from the SCB. On entry to the TIME function, a zero in
register C indicates that the BIOS should update the Time and Date fields in
the SCB. A $ff in register C indicates that the BDOS has just set the Time and
Date in the SCB and the BIOS should update its clock. Upon exit, you must
restore register pairs HL and DE to their entry values.

@------------------------------------------------------------------------------
@node NEXTZXOS
@next PLUS2DOS
@prev BIOS
@toc SYS_TOC
@{r}ZX Spectrum Next Programming Notes
@{h2}NextZXOS

A ZX Spectrum I/O system supported by the ZX Spectrum Next. This Documentation
is largely from Garry Lancaster's DOCs at
https://gitlab.com/thesmog358/tbblue/blob/master/docs/nextzxos/NextZXOS_and_esxDOS_APIs.pdf.
Before making any calls disable writes to Layer 2 in the $0000-$3fff area with
port $123b.

@------------------------------------------------------------------------------
@node PLUS3DOS
@next PORTS
@prev NEXTZXOS
@toc SYS_TOC
@{r}ZX Spectrum Next Programming Notes
@{h2}+3DOS compatible API

Generally to make these calls, you need to set up: place ROM 2 at $0000-$3fff,
RAM bank 7 at $c000-$ffff, stack below $bfe0, and set up the parameters for the
call in the indicated registers. Call the function at its address. Then,
restore your system to its previous configuration. In general the carry bit of
F is cleared on error with the error code in A. Calls generally affect the
contnts of AF, BC, DE, HL, and IX leaving AF', BC', DE', HL', IY, and SP
intact. To simplify, descriptions will assume this is true and only indicate
exceptions to the rule.

$0056 IDE_STREAM_OPEN

Open stream to a channel

$0059 IDE_STREAM_CLOSE

Close stream and attached channel

$005c IDE_STREAM_IN

Get byte from current stream

$005f IDE_STREAM_OUT

Write byte to current stream

$0062 IDE_STREAM_PTR

Get or set pointer information for current stream

$00A0 IDE_VERSION

Get IDEDOS version number

$00A3 IDE_INTERFACE

Initialise card interfaces

$00A6 IDE_INIT

Initialise IDEDOS

$00A9 IDE_DRIVE

Get unit handle

$00AC IDE_SECTOR_READ

Low-level sector read

$00AF IDE_SECTOR_WRITE

Low-level sector write

$00B2 IDE_FORMAT

Format a partition

$00B5 IDE_PARTITION_FIND

Find named partition

$00B8 IDE_PARTITION_NEW

Create partition

$00BB IDE_PARTITION_INIT

Initialise partition

$00BE IDE_PARTITION_ERASE

Delete a partition

$00C1 IDE_PARTITION_RENAME

Rename a partition

$00C4 IDE_PARTITON_READ

Read a partition entry

$00C7 IDE_PARTITION_WRITE

Write a partition entry

$00CA IDE_PARTITION_WINFO

Write type-specific partition information

$00CD IDE_PARTITION_OPEN

Open a partition

$00D0 IDE_PARTITION_CLOSE

Close a partition

$00D3 IDE_PARTITION_GETINFO

Get byte from type-specific partition information

$00D6 IDE_PARTITION_SETINFO

Set byte in type-specific partition information

$00D9 (217) IDE_SWAP_OPEN

Open a swap partition (file)

$00DC IDE_SWAP_CLOSE

Close a swap partition

$00DF IDE_SWAP_OUT

Write block to swap partition

$00E2 IDE_SWAP_IN

Read block from swap partition

$00E5 (231) IDE_SWAP_EX

Exchange block with swap partition

Deprecated, use IDE_SWAP_IN and IDE_SWAP_OUT

$00E8 IDE_SWAP_POS

Get current block number in swap partition

$00EB IDE_SWAP_MOVE

Set current block number in swap partition

$00EE IDE_SWAP_RESIZE

Change block size of swap partition

$00F1 (241) IDE_DOS_MAP

Map drive to partition or physical device

$00F4 (244) IDE_DOS_UNMAP

Unmap drive

$00F7 (247) IDE_DOS_MAPPING

Get drive mapping

$00FA IDE_DOS_UNPERMANENT

Remove permanent drive mapping

$00FD (253) IDE_SNAPLOAD

Load a snapshot

$0100 DOS_INITIALISE

Initialise +3DOS

$0103 DOS_VERSION

Get +3DOS issue and version numbers

$0106 (262) DOS_OPEN

Create and/or open a file

$0109 DOS_CLOSE

Close a file

$010C DOS_ABANDON

Abandon a file

$010F DOS_REF_HEAD

Point at the header data for this file

$0112 DOS_READ

Read bytes into memory

$0115 DOS_WRITE

Write bytes from memory

$0118 DOS_BYTE_READ

Read a byte

$011B DOS_BYTE_WRITE

Write a byte

$011E (286) DOS_CATALOG

Catalog disk directory

$0121 (289) DOS_FREE_SPACE

Free space on disk

$0124 DOS_DELETE

Delete a file

$0127 DOS_RENAME

Rename a file

$012A DOS_BOOT

Boot an operating system or other program

$012D DOS_SET_DRIVE

Set/get default drive

$0130 DOS_SET_USER

Set/get default user number

$0133 (307) DOS_GET_POSITION

Get file pointer for random access

$0136 DOS_SET_POSITION

Set file pointer for random access

$0139 (313) DOS_GET_EOF

Get end of file position for random access

$013C DOS_GET_1346

Get memory usage in pages 1 3 4 6

$013F DOS_SET_1346

Re-allocate memory usage in pages 1 3 4 6

$0142 DOS_FLUSH

Bring disk up to date

$0145 DOS_SET_ACCESS

Change open file's access mode

$0148 DOS_SET_ATTRIBUTES

Change a file's attributes

$014B DOS_OPEN_DRIVE

Open a drive as a single file

$014E DOS_SET_MESSAGE

Enable/disable error messages

$0151 DOS_REF_XDPB

Point at XDPB for low level disk access

$0154 DOS_MAP_B

Map B: onto unit 0 or 1

$0157 DD_INTERFACE

Is the floppy disk driver interface present?

$015A DD_INIT

Initialise disk driver

$015D DD_SETUP

Specify drive parameters

$0160 DD_SET_RETRY

Set try/retry count

$0163 DD_READ_SECTOR

Read a sector

$0166 DD_WRITE_SECTOR

Write a sector

$0169 DD_CHECK_SECTOR

Check a sector

$016C DD_FORMAT

Format a track

$016F DD_READ_ID

Read a sector identifier

$0172 DD_TEST_UNSUITABLE

Test media suitability

$0175 DD_LOGIN

Log in disk, initialise XDPB

$0178 DD_SEL_FORMAT

Pre-initialise XDPB for DD FORMAT

$017B DD_ASK_1

Is unit 1 (external drive) present?

$017E DD_DRIVE_STATUS

Fetch drive status

$0181 DD_EQUIPMENT

What type of drive?

$0184 DD_ENCODE

Set intercept routine for copy protection

$0187 DD_L_XDPB

Initialise an XDPB from a disk specification

$018A DD_L_DPB

Initialise a DPB from a disk specification

$018D DD_L_SEEK

uPD765A seek driver

$0190 DD_L_READ

uPD765A read driver

$0193 DD_L_WRITE

uPD765A write driver

$0196 DD_L_ON_MOTOR

Motor on, wait for motor-on time

$0199 DD_L_T_OFF_MOTOR

Start the motor-off ticker

$019C DD_L_OFF_MOTOR

Turn the motor off

$01a2 IDE_IDENTIFY

Return IDE drive identity information

$01a5 IDE_PARTITIONS

Get number of open partitions

$01b1 (433) IDE_PATH

Create, delete, change or get directory

$01b4 (436) IDE_CAPACITY

Get card capacity

$01b7 (439) IDE_GET_LFN

Get long filename

Obtain a long file name and other file information.

$01ba (442) IDE_BROWSER

File browser

$01bd (445) IDE_BANK

Allocate or free 8K pages in ZX or DivMMC memory

$01c0 IDE_BASIC

Execute a BASIC command line

$01c3 IDE_WINDOW_LINEIN

Input line from current window stream

$01c6 IDE_WINDOW_STRING

Output string to current window stream

$01c9 IDE_INTEGER_VAR

Get or set NextBASIC integer variable

$01cc IDE_RTC

Query the real-time-clock module

$01cf IDE_DRIVER

Access the driver API

$01d2 IDE_MOUNT

Unmount/remount SD cards

$01d2 IDE_MOUNT

Unmount/remount SD cards

$01d5 IDE_MODE

Query NextBASIC display mode info, or change mode

$01d8 IDE_TOKENISER

Convert BASIC between plain text & tokenised forms

esxDOS compatible API

Next Extensions

$0085 DISK_FILEMAP

    unsigned char esx_disk_filemap(uint8_t handle,struct esx_filemap *fmap)

Obtain a map of card addresses describing the space occupies by the file. Can
be called multiple times if the buffer is filled, continuing from previous.

DISK_STREAM_BYTES

    void *esx_disk_stream_bytes(void *dst,uint16_t len)

$0087 DISK_STREAM_END

    unsigned char esx_disk_stream_end(void)

Stop current streaming operation.

DISK_STREAM_SECTORS

    void *esx_disk_stream_sectors(void *dst,uint8_t sectors)

$0086 DISK_STREAM_START

    unsigned char esx_disk_stream_start(struct esx_filemap_entry *entry)

Start reading from the card in streaming mode.

DOS_CATALOG

    unsigned char esx_dos_catalog(struct esx_cat *cat)

DOS_CATALOG_NEXT

    unsigned char esx_dos_catalog_next(struct esx_cat *cat)

DOS_GETSET_DRIVE

    unsigned char esx_dos_get_drive(void)
    unsigned char esx_dos_set_drive(unsigned char drive)

esxDOS compatible API

The esxDOS-compatible API is a bit simpler to use than the +3DOS-compatible
API.

To make a call, you only need to set up the entry parameters as indicated and
perform a RST $08; DEFB hook_code. On return, registers AF,BC,DE,HL will all be
changed. IX,IY and the alternate registers are never changed (except for
M_P3DOS).

(Note that the standard 48K BASIC ROM must be paged in to the bottom of memory,
but this is the usual situation after starting a machine code program with a
USR function call).

Notice that error codes are different from those returned by +3DOS calls, and
also the carry flag is SET for an error condition when returning from an esxDOS
call (instead of RESET, as is the case for +3DOS).

If desired, you can use the M_GETERR hook to generate a BASIC error report for
any error returned, or even use it to generate your own custom BASIC error
report.

All of the calls where a filename is specified will accept long filenames
(LFNs) and most will accept wildcards (for an operation such as F_OPEN where a
single file is always used, the first matching filename will be used).

$00A9 F_CHDIR

    unsigned char esx_f_chdir(unsigned char *pathname)

Change directory.

$00AF F_CHMOD

    unsigned char esx_f_chmod(unsigned char *filename, uint8_t attr_mask, uint8_t attr)

Modify file attributes.

$009BF_CLOSE

    unsigned char esx_f_close(unsigned char handle)

Close a file or directory.

F_CLOSEDIR

    unsigned char esx_f_closedir(unsigned char handle)

$00A0 F_FGETPOS

    uint32_t esx_f_fgetpos(unsigned char handle)

Get current file position.

$00A1 F_FSTAT

    unsigned char esx_f_fstat(unsigned char handle, struct esx_stat *es)

Get file information/status.

$00A2 F_FTRUNC

    unsigned char esx_f_ftrunc(unsigned char handle, uint32_t size)

Truncate/extend file.

F_GET_CANONICAL_PATH

    unsigned char esx_f_get_canonical_path(char *pathname, char *canonical)

$00A8 F_GETCWD

    unsigned char esx_f_getcwd(unsigned char *buf)

Get current working directory.

F_GETCWD_DRIVE

    unsigned char esx_f_getcwd_drive(unsigned char drive, char *buf)

$00B1 F_GETFREE

    uint32_t esx_f_getfree(void)

Gets free space on drive.

$00AA F_MKDIR

    unsigned char esx_f_mkdir(unsigned char *pathname)

Create directory.

$009A F_OPEN

    unsigned char esx_f_open(unsigned char *filename,unsigned char mode)

Open a file.

$00A3 F_OPENDIR

    unsigned char esx_f_opendir(unsigned char *dirname)
    unsigned char esx_f_opendir_ex(unsigned char *dirname,uint8_t mode)

Open directory.

$009A F_OPEN

    unsigned char esx_f_open_p3(unsigned char *filename,unsigned char mode,struct esx_p3_hdr *h)

Open a file.

$009D F_READ

    uint16_t esx_f_read(unsigned char handle, void *dst, size_t nbytes)

Read bytes from file.

$00A4 F_READDIR

    unsigned char esx_f_readdir(unsigned char handle,struct esx_dirent *dirent)

Read next directory entry.

$00B0 F_RENAME

    unsigned char esx_f_rename(unsigned char *old, unsigned char *new)

Rename or move a file.

$00A7 F_REWINDDIR

    unsigned char esx_f_rewinddir(unsigned char handle)

Rewind directory position to the start of the directory.

$00AB F_RMDIR

    unsigned char esx_f_rmdir(unsigned char *pathname)

Remove directory.

$009F F_SEEK

    uint32_t esx_f_seek(unsigned char handle, uint32_t distance, unsigned char whence)

Seek to position in file.

$00A6 F_SEEKDIR

    unsigned char esx_f_seekdir(unsigned char handle,uint32_t pos)

Set current directory position.

$00AC F_STAT

Get unopened file information/status.

$009C F_SYNC

    unsigned char esx_f_sync(unsigned char handle)

Sync file changes to disk.

$00A5 F_TELLDIR

    uint32_t esx_f_telldir(unsigned char handle)

Get current directory position.

$00AE F_TRUNC

    unsigned char esx_f_trunc(unsigned char *filename,uint32_t size)

Truncate/extend unopened file.

$00AD F_UNLINK

    unsigned char esx_f_unlink(unsigned char *filename)

Delete file.

$009E F_WRITE

    uint16_t esx_f_write(unsigned char handle, void *src, size_t nbytes)

Write bytes to file.

IDE_BANK_ALLOC

    unsigned char esx_ide_bank_alloc(unsigned char banktype)

IDE_BANK_AVAIL

    unsigned char esx_ide_bank_avail(unsigned char banktype)

IDE_BANK_FREE

    unsigned char esx_ide_bank_free(unsigned char banktype, unsigned char page)

IDE_BANK_RESERVE

    unsigned char esx_ide_bank_reserve(unsigned char banktype,unsigned char page)

IDE_BANK_TOTAL

    unsigned char esx_ide_bank_total(unsigned char banktype)

IDE_BROWSER

    unsigned char esx_ide_browser(uint8_t browsercaps, void *filetypes, char *help,char *dst_sfn, char *dst_lfn)

IDE_GET_LFN

    unsigned char esx_ide_get_lfn(struct esx_lfn *dir, struct esx_cat_entry *query)

IDE_MODE_GET

    unsigned char esx_ide_mode_get(struct esx_mode *mode)

IDE_MODE_SET

    unsigned char esx_ide_mode_set(struct esx_mode *mode)

$0088 M_DOSVER

Get API version/mode information.

$0092 M_DRVAPI

    unsigned char esx_m_drvapi(struct esx_drvapi *)

Access API for installable drivers.

$0095 M_ERRH

    void esx_m_errh(void (*handler)(uint8_t error))

Install error handler for dot command.
$008F M_EXECCMD

    uint16_t esx_m_execcmd(unsigned char *cmdline)

Execute a dot command.

$008E M_GETDATE

    unsigned char esx_m_getdate(struct dos_tm *)

Get the current date/time.

$0093 M_GETERR

    void esx_m_geterr(uint16_t error,unsigned char *msg)

$008D M_GETHANDLE

    unsigned char esx_m_gethandle(void)

Get the file handle of the currently running dot command

$0089 M_GETSETDRV

    unsigned char esx_m_getdrv(void)
    unsigned char esx_m_setdrv(unsigned char drive)

Get or set the default drive.

$0091 M_SETCAPS

    unsigned char esx_m_setcaps(unsigned char caps)

$008B M_TAPEIN

    unsigned char esx_m_tapein_close(void)
    unsigned char esx_m_tapein_flags(uint8_t flags)
    uint16_t esx_m_tapein_getpos(void)
    unsigned char esx_m_tapein_info(uint8_t *drive,unsigned char *filename)
    unsigned char esx_m_tapein_open(unsigned char *filename)
    unsigned char esx_m_tapein_setpos(uint16_t block)
    unsigned char esx_m_tapein_toggle_pause(void)

Tape input redirection control.

$008C M_TAPEOUT

    unsigned char esx_m_tapeout_close(void)
    unsigned char esx_m_tapeout_info(uint8_t *drive,unsigned char *filename)
    unsigned char esx_m_tapeout_open(unsigned char *appendname)
    unsigned char esx_m_tapeout_trunc(unsigned char *filename)

Tape output redirection control.

SLICE_DIRENT

    struct esx_dirent_slice *esx_slice_dirent(struct esx_dirent *)

EXTENDED_SNA_LOAD

    unsigned char extended_sna_load(unsigned char handle)

P3DOS_COPY_CSTR_TO_PSTR

    unsigned char *p3dos_copy_cstr_to_pstr(char *pdst, const char *csrc)

P3DOS_COPY_PSTR_TO_CSTR

    unsigned char *p3dos_copy_pstr_to_cstr(char *cdst, const char *psrc)

P3DOS_CSTR_TO_PSTR

    unsigned char *p3dos_cstr_to_pstr(unsigned char *s)

P3DOS_DOSNAME_FROM_CATNAME

    char *p3dos_dosname_from_catname(char *dosname, char *catname)

P3DOS_EDRV_FROM_PDRV

    unsigned char p3dos_edrv_from_pdrv(unsigned char pdrv)

P3DOS_PDRV_FROM_EDRV

    unsigned char p3dos_pdrv_from_edrv(unsigned char edrv)

P3DOS_PSTR_TO_CSTR

    unsigned char *p3dos_pstr_to_cstr(unsigned char *s)

@------------------------------------------------------------------------------
@node PORTS
@next REGISTERS
@prev SYSTEM
@{r}ZX Spectrum Next Programming Notes
@{h1}Ports

8-bit

Port $6B () DMA Control (Z80 Mode, 3.01.02)

Port $0F () DAC B

-   bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $1F () Kempston/Mega Drive Joystick 1/DAC A
Read

-   bit 7 = "start" button

-   bit 6 = A/X button

-   bit 5 = C/Z button

-   bit 4 = Fire/C/Y button

-   bit 3 = Up

-   bit 2 = Down

-   bit 1 = Left

-   bit 0 = Right

Disable with Nextreg $05
Write

-   bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $37 () Kempston/Mega Drive Joystick 2
Read

-   bit 7 = "start" button

-   bit 6 = A/X button

-   bit 5 = C/Z button

-   bit 4 = Fire/C/Y button

-   bit 3 = Up

-   bit 2 = Down

-   bit 1 = Left

-   bit 0 = Right

Disable with Nextreg $05
Write ($00 on reset, 3.01.04)

-   bits 7-6 = Select I/O Mode

    -   00 = Bit Bang

    -   01 = Clock

    -   10 = UART

    -   11 = Reserved (don't use)

-   bit 5 = Reserved, must be 0

-   bit 4 = Select Joystick Port for Read

    -   0 = Left

    -   1 = Right

-   bits 3-1 = Reserved, must be $00

-   bit 0 = Pin 7 state (both ports)

    -   Bit Bang - bit 0 on pin 7

    -   Clock - clock on pin 7
        0 = Slow clock (Fsys/2048 = 12.672 kHz)
        1 = Fast clock (Fsys/8 = 3.5 MHz)

    -   UART - Pin 7 = TX, Pin 9 = RX 0 = ESP
        1 = Pi

** A Runt clock may appear in the first cycle
The I/O mode should be set by writing this port first followed by enabling io
mo de on the joysticks with a write to nextreg 0x05.

Port $3F () DAC A

-   bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $4F () DAC C

-   bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $57 () Sprite Attributes
Byte 1

-   bits 7-0 = LSB of X coordinate (bit 8 is in byte 3)

Byte 2

-   bits 7-0 = LSB of Y coordinate (bit 8 is in byte 5)

Byte 3

-   bits 7-4 = Palette Offset

-   bit 3 = Enable X Mirror

-   bit 2 = Enable Y Mirror

-   bit 1 = Enable Roration

-   bit 0 = By Sprite Type

    -   Anchor = MSB of X coordinate

    -   Relative = Enable relative palette offset

Byte 4

-   bit 7 = Enable visibility

-   bit 6 = Enable Byte 5

-   bit 5-0 = Pattern Index ("name")

Byte 5 (optional)
Anchor

-   bit 7-6 = type and pattern

    -   00 = 8-bit color

    -   01 = relative

    -   10 = 4-bit color, lower half of pattern (bytes 0-127)

    -   11 = 4-bit color, upper half of pattern (byets 128-255)

-   bit 5 = Attached relative sprite type

    -   0 = composite

    -   1 = big sprite

-   bit 4-3 = X-axis scale factor

    -   00 = 1×

    -   01 = 2×

    -   10 = 4×

    -   11 = 8×

-   bit 2-1 = Y-axis scale factor

-   bit 0 = MSB of Y coordinate

Composite Relative

-   bits 7-6 = 01

-   bit 5 = N6
    8-bit

    -   Reserved, must be 0

    4-bit

    -   0 = lower half of pattern (bytes 0-127)

    -   1 = upper half of pattern (bytes 128-255)

-   bit 4-3 = X-axis scale factor

-   bit 2-1 = Y-axis scale factor

-   bit 0 = Enable relative pattern offset

Big-sprite Relative

-   bits 7-6 = 01

-   bit 5 = N6
    8-bit

    -   Reserved, must be 0

    4-bit

    -   0 = lower half of pattern (bytes 0-127)

    -   1 = upper half of pattern (bytes 128-255)

-   bit 4-1 = Reserved, must be 0

-   bit 0 = Enable relative pattern offset

Port $5B () Sprite Pattern
Load data into sprite pattern memory auto-incrementing. Port $303B can be used
to set the starting sprite pattern number.

Port $5F () DAC D

-   bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $6B () DMA Control (Next Mode, 3.01.02)

Port $DF () DAC A,D

-   bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $E3 () divMMC Control
Disable with bit 2 of Nextreg $09

-   bit 7 = conmem, enable divMMC memory

-   bit 6 = mapram, enable divMMC allRAM mode

-   bits 3-0 = bank, selected divMMC ram bank for $2000-$3FFF region

-   conmem can be used to manually control divMMC mapping. When enabled
    $0000-$1FFF contains esxDOS ROM or esxDOS page 3
    $2000-$3FFF contains esxDOS RAM page selected by bits 3-0

-   divMMC automatically maps itself in when instruction fetches hit specific
    addresses in the ROM. When this happens, the esxDOS ROM (or divMMC bank 3
    if mapram is set) appears in $0000-$1FFF and the selected divMMC bank
    appears as RAM in $2000-$3FFF

-   bit 6 can only be set, once set only a power cycle can reset it. nextreg
    $09 bit 3 can be set to reset this bit.

divMMC automapping is normally disabled by NextZXOS see nextreg $06 bit 4.
Port $E7 () SPI /CS (SD card, flash, rpi)
Disable with bit 2 of Nextreg $09

Port $EB () SPI /DATA (SD card, flash, rpi)
Disable with bit 2 of Nextreg $09

Port $F1 () DAC A (precedence over $xxFD)

-   bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $F3 () DAC B

-   bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $F9 () DAC C (precedence over $xxFD)

-   bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $FB () DAC A,D

-   bits 7-0 = DAC Value

Disable with bit 3 of Nextreg $08

Port $FE () ULA

-   bits 7-5 = Unused

-   bit 4 = enable ear output

-   bit 3 = enable mic output

-   bit 2-0 = border colour

Port $FF () Timex Sinclair/Floating Bus

-   bit 7 = memory paging (not on ZX Next)

-   bit 6 = Disable generation of interrupts

-   bit 5-3 = Hi-res mode color combination

    -   000 = Black on white (indexes 0, 135)

    -   001 = Blue on Yellow (indexes 1, 134)

    -   010 = Green on Magenta (indexes 2, 133)

    -   011 = Cyan on Red (indexes 3, 132)

    -   100 = Red on Cyan (indexes 4, 131)

    -   101 = Magenta on Green (indexes 5, 130)

    -   110 = Yellow on Blue (indexes 6, 129)

    -   111 = White on Black (indexes 7, 128)

-   bit 2-0 = ULA Mode

    -   000 = Normal ULA address

    -   001 = Alternate ULA address

    -   010 = Hi-color mode

    -   110 = Hi-res mode

Disable with bit 2 of Nextreg $08

16-bit

Port $103B () I2C SCL (rtc, rpi)

Port $113B () I2C SDA (rtc, rpi)

Port $123B () Layer 2
Bit 4 = 0

-   bits 7-6 = Video RAM bank select

    -   00 = first 16k

    -   01 = second 16k

    -   10 = third 16k

    -   11 = first 48k

-   bit 5 = Reserved, must be 0

-   bit 4 = 0

-   bit 3 = Shadow layer 2 select

-   bit 2 = Enable layer 2 read paging

-   bit 1 = Layer 2 visible (mirrored in register $69)

-   bit 0 = Enable layer 2 write paging

Bit 4 = 1

-   bits 7-5 = Reserved, must be 0

-   bit 4 = 1

-   bit 3 = Reserved, must be 0

-   bit 2-0 = 16k bank relative offset

Port $133B () UART tx
Read: UART Status

-   bits 7-4 = Reserved (0)

-   bit 3 = UART at least half full (3.01.09)

-   bit 2 = UART full

-   bit 1 = UART transmit busy

-   bit 0 = UART receive has data

Write: UART Transmit

Port $143B () UART rx
Read: UART Receive
Write: UART Prescalar

-   bit 7 = select prescalar part

    -   0 = Bits 6-0 of prescalar

    -   1 = Bits 13-7 of prescalar

-   bits 6-0 = Prescalar bits

Port $153B () UART select

-   bit 7 = Reserved (0)

-   bit 6 = UART select (0 on soft reset) **

    -   0 = ESP

    -   1 = Pi *

-   bit 5 = Reserved (0)

-   bit 4 = Prescalar valid in this write

-   bit 3 = Reserved (0)

-   bits 2-0 = Bits 16-14 of prescalar (0 on hard reset)

* Pi GPIO must be configured for UART, see nextreg $A0
** Either UART can be redirected to the joystick ports, see port $037

Port $153B () UART frame (upcoming)
($18 on hard reset)

-   bit 7 = Immediately reset Rx and Tx to idle and empty FIFOs

-   bit 6 = Assert break (Tx=0) when Tx reaches idle

-   bit 5 = Enable hardware flow control *

-   bits 4-3 = Number of bits in a frame

    -   00 = 5 bits

    -   01 = 6 bits

    -   10 = 7 bits

    -   11 = 8 bits

-   bit 2 = Enable parity

-   bit 1 = Parity

    -   0 = Even parity

    -   1 = Odd parity

-   bit 0 = Number of stop bits

    -   0 = 1 stop bit

    -   1 = 2 stop bits

Port $183B () CTC Channel 0

Port $193B () CTC Channel 1

Port $1A3B () CTC Channel 2

Port $1B3B () CTC Channel 3

Port $1C3B () CTC Channel 4

Port $1D3B () CTC Channel 5

Port $1E3B () CTC Channel 6

Port $183B () CTC Channel 7

Port $1FFD () Plus 3 Memory Paging Control

-   bits 7-3 = Unused, nust be 0

-   bit 2 = High bit of ROM selection (low bit is in Port $7FFD)

    -   00 = ROM0 = 128k editor and menu system

    -   01 = ROM1 = 128k syntax checker

    -   10 = ROM2 = +3DOS

    -   11 = ROM3 = 48k BASIC

-   bit 1 = Special mode: Low bit of memory configuration number

-   bit 0 = Paging mode

    -   0 = Normal

    -   1 = Special

You should echo writes to $5B67

Port $243B () Next Register Select

Port $253B () Next Register Data

Port $303B () Sprite Slot/Flags
Write: Sprite Slot Select
select sprite slot for Sprite Attribute and Sprite Pattern ports which
independently auto-increment
Read: Sprite status

-   bits 7-2 = reserved

-   bit 1 = Max sprites per line

-   bit 0 = Collision flag

Port $7FFD () Memory Paging Control

-   bits 6-7 = reserved

-   bit 5 = Lock memory paging

-   bit 4 = low bit of ROM Select (high bit is in Port $1FFD)

    -   00 = ROM0 = 128k editor and menu system

    -   01 = ROM1 = 128k syntax checker

    -   10 = ROM2 = +3DOS

    -   11 = ROM3 = 48k BASIC

-   bit 3 = Shadow screen toggle

-   bits 2-0 = LSB of Bank number for slot 4 (MSB is in Port $DFFD)

Disable with bit 5 port $7FFD

Port $7FFE () Keyboard 8 (read only)

-   bit 0: 'B'

-   bit 1: 'N'

-   bit 2: 'M'

-   bit 3: Symbol Shift

-   bit 4: Space

Port $BF3B () ULAplus register

-   bits 7-6 = Select register group

    -   00 = palette group

    -   01 = mode group

-   bits 5-0 = data

    -   If palette group, selects index 0-63 in ULAplus palette

    -   If mode group, ignored

Port $BFF5 () AY Info (3.01.09
(R)

-   bits 7-6 = Active AY chip

    -   01 = AY 0 active

    -   10 = AY 1 active

    -   11 = AY 2 active

-   bit 5 = Reserved

-   bits 4-0 = currently selected AY register

Port $BFFD () AY Data

Port $BFFE () Keyboard 7 (read only)

-   bit 0 = 'H'

-   bit 1 = 'J'

-   bit 2 = 'K'

-   bit 3 = 'L'

-   bit 4 = Enter

Port $DFFD () Next Memory Bank Select

-   bits 7-4 = Reserved, must be 0

-   bits 3-0 = MSB of bank number for slot 4 (LSB is in Port $7FFD)

Port $DFFE () Keyboard 6 (read only)

-   bit 0 = 'Y'

-   bit 1 = 'U'

-   bit 2 = 'I'

-   bit 3 = 'O'

-   bit 4 = 'P'

Port $EFF7 () Pentagon 1024 paging

-   bit 3 = 1 to overlay the bottom 16k with ram from 16k bank 0

-   bit 2 = 0 to enable Pentagon 1024 mapping and disable bit 5 port 0x7ffd
    locking, 1 to select standard zx128 mapping **

-   ** Applies only when pentagon 1024 mapping mode is enabled via nextreg
    0x8f.

Port $EFFE () Keyboard 5 (read only)

-   bit 0 = '6'

-   bit 1 = '7'

-   bit 2 = '8'

-   bit 3 = '9'

-   bit 4 = '0'

Port $F7FE () Keyboard 4 (read only)

-   bit 0 = '5'

-   bit 1 = '4'

-   bit 2 = '3'

-   bit 3 = '2'

-   bit 4 = '1'

Port $FADF () Kempston Mouse Buttons

-   bits 7-4 = Wheel delta since last read

-   bit 3 = fourth button

-   bit 2 = middle button

-   bit 1 = left button

-   bit 0 = right button

Port $FBDF () Kempston Mouse X

-   bits 7-0 = X coordinate of mouse

Port $FBFE () Keyboard 3 (read only)

-   bit 0 = 'T'

-   bit 1 = 'R'

-   bit 2 = 'E'

-   bit 3 = 'W'

-   bit 4 = 'Q'

Port $FDFE () Keyboard 2 (read only)

-   bit 0 = 'G'

-   bit 1 = 'F'

-   bit 2 = 'D'

-   bit 3 = 'S'

-   bit 4 = 'A'

Port $FEFE () Keyboard 1 (read only)

-   bit 0 = 'V'

-   bit 1 = 'C'

-   bit 2 = 'X'

-   bit 3 = 'Z'

-   bit 4 = Caps Shift

Port $FF3B () ULAplus data

-   If palette group, 8-bit (RRRGGGBB) value for current index

-   If mode group, bit 1 = enable ULAplus

Port $FFDF () Kempston Mouse Y

-   bits 7-0 = Y coordinate of mouse (0-192)

Port $FFFD () AY Control and AY register Select (3.01.09)
Read

-   bits 7-0 = data in selected register of active AY chip

Select Chip

-   bit 7 = 1

-   bit 6 = Enable left

-   bit 5 = Enable Right

-   bits 4-2 = Reserved, must be 1

-   bits 1-0 = AY chip select

    -   00 = Unused

    -   01 = AY 2

    -   10 = AY 1

    -   11 = AY 0

Select Register

-   bit 7 = 0

-   bits 6-5 = Reserved, must be 0

-   bits 4-0 = Register Number

@------------------------------------------------------------------------------
@node REGISTERS
@next EO2MN
@prev PORTS
@{r}ZX Spectrum Next Programming Notes
@{h1}Registers

ZX Spectrum Next Registers

The ZX Next stores configuration state in a field of registers. These registers
are accessible via two I/O ports or via the special nextreg instructions.

Port $243B (9275) is used to set the register number, listed below.

Port $253B (9531) is used to access the register value.

Some registers are accessible only during the initialization process.

Register (R) $00 () => Machine ID

-   00000001 = DE1A

-   00000010 = DE2A

-   00000101 = FBLABS

-   00000110 = VTRUCCO

-   00000111 = WXEDA

-   00001000 = EMULATORS

-   00001010 = ZX Spectrum Next

-   00001011 = Multicore

-   10101010 = ZX Spectrum Next Core on unAmiga

-   10111010 = ZX Spectrum Next Core on SiDi

-   11001010 = ZX Spectrum Next Core on MIST

-   11011010 = ZX Spectrum Next Core on MiSTer

-   11011010 = ZX Spectrum Next Core on unAmiga Reloaded

-   11101010 = ZX Spectrum Next Core on ZX-DOS

-   11111010 = ZX Spectrum Next Anti-brick

Register (R) $01 () => Core Version

-   bits 7-4 = Major version number

-   bits 3-0 = Minor version number

-   See register $0E for sub minor version number

Register (R/W) $02 () => Reset
Read

-   bit 7 = Expansion bus /RESET Asserted

-   bits 6-4 = Reserved

-   bit 3 = Indicates multiface NMI was generated by this nextreg (3.01.09)

-   bit 2 = Indicates divmmc NMI was generated by this nextreg (3.01.09)

-   bit 1 = Last reset was Hard reset

-   bit 0 = Last reset was Soft reset

Write

-   bit 7 = Generate/Release Expansion bus /RESET

-   bits 6-4 = Reserved, must be 0

-   bit 3 = Generate multiface NMI (write zero to clear)(3.01.09)

-   bit 2 = Generate divmmc NMI (write zero to clear)(3.01.09)

-   bit 1 = generate Hard reset (reboot)

-   bit 0 = generate Soft reset

Register (R/W) $03 () => Machine Type
A write to this register disables the boot rom in config mode
bits 2-0 select machine type when in config mode

-   bit 7 = (W) Display Timing change enable (allow changes to bits 6-4) (0 on
    hard reset)

-   bits 6-4 = Display Timing

-   bit 3 = Display Timing user lock control

-   Read

    -   0 = No user lock on display timing

    -   1 = User lock on display timing

-   Write

    -   1 = Apply user lock on display timing (0 on hard reset)

-   bits 2-0 = Machine Type (config mode only)
    determines roms loaded

-   Machine Types/Display Timings

    -   000 or 001 = ZX 48K

    -   010 = ZX 128K/+2 (Grey)

    -   011 = ZX +2A-B/+3e/Next Native

    -   100 = Pentagon 128K

Register (W) $04 () => Configuration Mapping

-   bits 7 = Reserved, must be 0

-   bits 6-0 = 16k SRAM bank mapping* ($00 on hard reset)

-   * Maps a 16k SRAM bank over the bottom 16k. Applies only in config mode
    when the bootrom is disabled

-   ** Odd multiples of 256k are unreliable if storing data in sram for the
    mext core started.

-   *** number of useful bits changed from 5 to 7 in coure 3.01.06

Register (R/W) $05 () => Peripheral 1 Settings

-   bits 7-6 = joystick 1 mode (MSB)

-   bits 5-4 = joystick 2 mode (MSB)

-   bit 3 = joystick 1 mode (LSB)

-   bit 2 = 50/60 Hz mode (0 = 50Hz, 1 = 60Hz)

-   bit 1 = joystick 2 mode (LSB)

-   bit 0 = Enable Scandoubler

Joystick modes

-   000 = Sinclair 2 (67890)

-   001 = Kempston 2 (port $37)

-   010 = Kempston 1 (port $1F)

-   011 = Megadrive 1 (port $1F)

-   100 = Cursor

-   101 = Megadrive 2 (port $37)

-   110 = Sinclair 1 (12345)

-   111 = I/O Mode (3.01.04) Both joysticks are places in I/O Mode if either is
    set to I/O Mode. The underlying joystick type is not changed and reads of
    this register will continue to return the last joystick type. Ehether the
    joystick is in io mode or not is invisible but this state can be cleared
    either through reset or by re-writing the gegister with joystick type not
    equal to 111. Recovery time for a normal joystick read after leaving I/O
    Mode is at most 64 scan lines.

Register (R/W) $06 () => Peripheral 2 Settings

-   bit 7 = F8 CPU Speed Hotkey Enable (1 on reset)

-   bit 6 = Enable classic audio mode (beep and tape to internal speaker, other
    audio to ear and HDMI, 3.01.02)

-   bit 5 = F3 50Hz/60Hz Hotkey Enable (1 on reset)

-   bit 4 = divMMC Automap/NMI Enable (0 on hard reset)

-   bit 3 = NMI Button Enable (0 on hard reset)

-   bit 2 = PS/2 Mode (0 = keyboard, 1 = mouse)

-   bits 1-0 = PSG Mode (00 = YM, 01 = AY, 11 = hold all PSGs in Reset)

Register (R/W) $07 () => Turbo mode
Read

-   bits 7-6 = Reserved

-   bits 5-4 = Current Actual CPU Speed

-   bits 3-2 = Reserved

-   bits 1-0 = Current Selected CPU Speed (00 on reset)

Write

-   bits 7-2 = Reserved, must be 0

-   bits 1-0 = Select CPU Speed

CPU Speeds

-   00 = 3.5MHz

-   01 = 7MHz

-   10 = 14MHz

-   11 = 28MHz

Register (R/W) $08 () => Peripheral 3 Settings

-   bit 7 = 128K Banking Unlock (inverse of port $7FFD, bit 5) (0 on reset)

-   bit 6 = Disable RAM and Port Contention (0 on reset)

-   bit 5 = PSG Stereo Mode Control (0 = ABC, 1 = ACB) (0 on hard reset)

-   bit 4 = Enable internal speaker (1 on hard reset)

-   bit 3 = Enable DACs (0 on hard reset)

-   bit 2 = Enable read of port $FF (Timex) (0 on hard reset)

-   bit 1 = Enable Multiple PSGs (0 on hard reset)

-   bit 0 = Enable Issue 2 Keyboard

Register (R/W) $09 () => Peripheral 4 setting:

-   bit 7 = PSG 2 Mono Enable (0 on hard reset)

-   bit 6 = PSG 1 Mono Enable (0 on hard reset)

-   bit 5 = PSG 0 Mono Enable (0 on hard reset)

-   bit 4 = Sprite ID lockstep enable (1 = Nextreg $34 and IO Port $303B are in
    lockstep, 0 on reset)

-   bit 3 = divMMC mapRAM bit Control (reset bit 7 of port $E3)

-   bit 2 = HDMI audio mute (0 on hard reset)

-   bits 1-0 = scanlines

    -   00 = scanlines off

    -   01 = scanlines 12.5%

    -   10 = scanlines 25%

    -   11 = scanlines 50%

-   In Sprite lockstep, NextREG $34 and Port $303B are in lockstep

Register (R/W) $0A () => Peripheral 5 setting:

-   bits 7-6 = Multiface type (00 on hard reset)

    -   00 = Multiface +3 (enable port 0x3F, disable port 0xBF)

    -   01 = Multiface 128 v87.2 (enable port 0xBF, disable port 0x3F)

    -   10 = Multiface 128 v87.12 (enable port 0x9F, disable port 0x1F)

    -   11 = Multiface 1 (enable port 0x9F, disable port 0x1F)

-   bits 5-4 = Reserved, must be zero

-   bit 3 = 1 to reverse left and right mouse buttons (3.01.07)

-   bit 2 = Reserved, must be 0

-   bits 1-0 = mouse dpi (00 on hard reset) (3.01.05)

    -   00 = low dpi

    -   01 = default

    -   10 = medium dpi

    -   11 = high dpi

Register (R) $0E () => Core Version (sub minor number)

-   bits 7-0 = Core sub minor version number

-   (see register $01 for the major and minor version number)

Register (R/W) $10 () => Core Boot
Read

-   bits 7-2 = Reserved

-   bit 1 = Drive button pressed

-   bit 0 = NMI button pressed

Write

-   bit 7 = Reboot FPGA using selected core (0 on reset)

-   bits 6-5 = Reserved, must be 0

-   bits 4-0 = Core ID

-   Core ID with bits 4-0 can only be set in configuration mode

Register (R/W) $11 () => Video Timing (writable in config mode only)

-   bits 7-3 = Reserved, must be 0

-   bits 2-0 = Mode (VGA = 0..6, HDMI = 7)

    -   000 = Base VGA timing, clk28 = 28000000

    -   001 = VGA setting 1, clk28 = 28571429

    -   010 = VGA setting 2, clk28 = 29464286

    -   011 = VGA setting 3, clk28 = 30000000

    -   100 = VGA setting 4, clk28 = 31000000

    -   101 = VGA setting 5, clk28 = 32000000

    -   110 = VGA setting 6, clk28 = 33000000

    -   111 = HDMI, clk28 = 27000000

-   50/60Hz selection depends on bit 2 of register $05

-   Only writable in config mode

Register (R/W) $12 () => Layer 2 Active RAM bank

-   bits 7-6 = Reserved, must be 0

-   bits 5-0 = RAM bank (point to bank 8 after a Reset, NextZXOS modifies to 9)

Register (R/W) $13 () => Layer 2 Shadow RAM bank

-   bits 7-6 = Reserved, must be 0

-   bits 5-0 = RAM bank (point to bank 11 after a Reset, NextZXOS modifies
    to 12)

Register (R/W) $14 () => Global transparency color

-   bits 7-0 = Transparency color value ($E3 after a reset)

(Note: this value is 8-bit, so the transparency is compared against only by the
MSB bits of the final 9-bit colour)
(Note2: this only affects Layer 2, ULA and LoRes. Sprites use register $4B for
transparency and tilemap uses nextreg $4C)

Register (R/W) $15 () => Sprite and Layer System Setup

-   bit 7 = LoRes mode (0 on reset)

-   bit 6 = Sprite priority (1 = sprite 0 on top, 0 = sprite 127 on top) (0 on
    reset)

-   bit 5 = Enable sprite clipping in over border mode (0 on reset)

-   bits 4-2 = set layers priorities (000 on reset)

    -   000 - S L U

    -   001 - L S U

    -   010 - S U L

    -   011 - L U S

    -   100 - U S L

    -   101 - U L S

    -   110 - S(U+L) ULA and Layer 2 combined, colours clamped to 7

    -   111 - S(U+L-5) ULA and Layer 2 combined, colours clamped to [0,7]

-   bit 1 = Enable Sprites Over border (0 on reset)

-   bit 0 = Enable Sprites (0 on reset)

Register (R/W) $16 () => Layer 2 Horizontal Scroll Control

-   bits 7-0 = X Offset (0-255)(0 on reset)

Register (R/W) $17 () => Layer 2 Vertical Scroll Control

-   bits 7-0 = Y Offset (0-191)(0 on reset)

Register (R/W) $18 () => Layer 2 Clip Window Definition

-   bits 7-0 = Coords of the clip window

    -   1st write - X1 position

    -   2nd write - X2 position

    -   3rd write - Y1 position

    -   4rd write - Y2 position

Reads do not advance the clip position
The values are 0,255,0,191 after a Reset

Register (R/W) $19 () => Sprite Clip Window Definition

-   bits 7-0 = Cood. of the clip window

    -   1st write - X1 position

    -   2nd write - X2 position

    -   3rd write - Y1 position

    -   4rd write - Y2 position

The values are 0,255,0,191 after a Reset
Reads do not advance the clip position

When the clip window is enabled for sprites in "over border" mode, the X coords
are internally doubled and the clip window origin is moved to the sprite origin
inside the border.

Register (R/W) $1A () => Layer 0 (ULA/LoRes) Clip Window Definition

-   bits 7-0 = Coord. of the clip window

    -   1st write = X1 position

    -   2nd write = X2 position

    -   3rd write = Y1 position

    -   4rd write = Y2 position

The values are 0,255,0,191 after a Reset
Reads do not advance the clip position

Register (R/W) $1B () => Layer 3 (Tilemap) Clip Window Definition

-   bits 7-0 = Coord. of the clip window

    -   1st write = X1 position

    -   2nd write = X2 position

    -   3rd write = Y1 position

    -   4rd write = Y2 position

The values are 0,159,0,255 after a Reset
Reads do not advance the clip position
The X coords are internally doubled.

Register (R/W) $1C () => Clip Window Control
Read

-   bits 7-6 = Layer 3 Clip Index

-   bits 5-4 = Layer 0/1 Clip Index

-   bits 3-2 = Sprite clip index

-   bits 1-0 = Layer 2 Clip Index

Write

-   bits 7-4 = Reserved, must be 0

-   bit 3 - reset Layer 3 clip index

-   bit 2 - reset Layer 0/1 clip index

-   bit 1 - reset sprite clip index.

-   bit 0 - reset Layer 2 clip index.

Register (R) $1E () => Active video line (MSB)

-   bits 7-1 = Reserved

-   bit 0 = Active line MSB

Register (R) $1F () => Active video line (LSB)

-   bits 7-0 = Active line LSB (0-255)

Register (R/W) $22 () => Line Interrupt control

-   bit 7 = (R) ULA asserting interrupt

-   bit 7 = (W) Reserved, must be 0

-   bits 6-3 = Reserved, must be 0

-   bit 2 = Disable ULA Interrupt (0 on reset)

-   bit 1 = Enable Line Interrupt (0 on reset)

-   bit 0 = MSB of Line Interrupt line value (0 on reset)

Register (R/W) $23 () => Line Interrupt value LSB

-   bits 7-0 = Line Interrupt line value LSB (0-255)(0 on reset)

Register (R/W) $26 () => ULA Horizontal Scroll Control

-   bits 7-0 = ULA X Offset (0-255) (0 on reset)

Register (R/W) $27 () => ULA Vertical Scroll Control

-   bits 7-0 = ULA Y Offset (0-191) (0 on reset)

Register (R/W) $28 () => Stored Palette Value and PS/2 Keymap Address MSB
Read

-   bits 7-0 = Stored palette value (see NextREG $44)

Write

-   bits 7-1 = Reserved, must be 0

-   bit 0 = PS/2 Keymap Address MSB

Register (W) $29 () => PS/2 Keymap Address LSB

-   bits 7-0 = PS/2 Keymap Address LSB

Register (W) $2A () => PS/2 Keymap Data MSB

-   bits 7-1 = Reserved, must be 0

-   bit 0 = PS/2 Keymap Data MSB

Register (W) $2B () => PS/2 Keymap Data LSB

-   bits 7-0 = PS/2 Keymap Data LSB

(writing this register auto-increments the address)

Register (R/W) $2C () => DAC B Mirror (Left)/ I2S Left Sample MSB
Read

-   bits 7-0 = I2S Left Sample MSB

Write

-   bits 7-0 = 8-bit sample left DAC ($80 on reset)

Register (R/W) $2D () => DAC A+D Mirror (mono/ I2S Sample LSB
Read

-   bits 7-0 = I2S Last Sample LSB

Write

-   bits 7-0 = 8-bit sample DACs A + D ($80 on reset)

Register (R/W) $2E () => DAC C Mirror (Right/ I2S Risht Sample MSB
Read

-   bits 7-0 = I2S Right Sameple MSB

Write

-   bits 7-0 = 8-bit sample Right DACs C ($80 on reset)

Register (R/W) $2F () => Layer 3 (Tilemap) Horizontal Scroll Control MSB

-   bits 7-2 = Reserved, must be 0

-   bits 1-0 = X Offset MSB ($00 on reset)

Meaningful Range is 0-319 in 40 char mode, 0-639 in 80 char mode

Register (R/W) $30 () => Layer 3 (Tilemap) Horizontal Scroll Control LSB

-   bits 7-0 = X Offset LSB ($00 on reset)

Meaningful range is 0-319 in 40 char mode, 0-639 in 80 char mode

Register (R/W) $31 () => Layer 3 (Tilemap) Vertical Scroll Control

-   bits 7-0 = Y Offset (0-255) )$00 on reset)

Register (R/W) $32 () => Layer 1,0 (LoRes) Horizontal Scroll Control)

-   bits 7-0 = X Offset (0-255) ($00 on reset)

Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and
smoothness as Layer 2.

Register (R/W) $33 () => Layer 1,0 (LoRes) Vertical Scroll Control)

-   bits 7-0 = Y Offset (0-191) ($00 on reset)

Layer 1,0 (LoRes) scrolls in "half-pixels" at the same resolution and
smoothness as Layer 2.

Register (R/W) $34 () => Sprite Number
Lockstep (NextReg $09 bit 4 set)

-   bit 7 = Pattern address offset (Add 128 to pattern address)

-   bits 6-0 = Sprite number 0-127, Pattern number 0-63

-   effectively performs an out to port $303B

No Lockstep (NextReg $09 bit 4 clear)

-   bit 7 = Reserved, must be 0

-   bits 6-0 = Sprite number 0-127

This register selects which sprite has its attributes connected to the sprite
attribute registers

Register (W) $35 () => Sprite Attribute 0

-   bits 7-0 = Sprite X coordinate LSB (MSB in NextReg $37)

Register (W) $36 () => Sprite Attribute 1

-   bits 7-0 = Sprite Y coordinate LSB (MSB in NextReg $39)

Register (W) $37 () => Sprite Attribute 2

-   bits 7-4 = 4-bit Palette offset

-   bit 3 = Enable horizontal mirror (reverse)

-   bit 2 = Enable vertical mirror (reverse)

-   bit 1 = Enable 90^(O) Clockwise Rotation

Normal Sprites

-   bit 0 = X coordinate MSB

Relative Sprites

-   bit 0 = Palette offset is relative to anchor sprite

Rotation is applied before mirroring

Register (W) $38 () => Sprite Attribute 3

-   bit 7 = Enable Visiblity

-   bit 6 = Enable Attribute 4 (0 = Attribute 4 effectively $00)

-   bits 5-0 = Sprite Pattern Number

Register (W) $39 () => Sprite Attribute 4
Normal Sprites

-   bit 7 = 4-bit pattern switch (0 = 8-bit sprite, 1 = 4-bit sprite)

-   bit 6 = Pattern number bit-7 for 4-bit, 0 for 8-bit

-   bit 5 = Type of attached relative sprites (0 = Composite, 1 = Unified)

-   bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)

-   bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)

-   bit 0 = MSB of Y coordinate

Relative, Composite Sprites

-   bit 7-6 = 01

-   bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit

-   bits 4-3 = X scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)

-   bits 2-1 = Y scaling (00 = 1x, 01 = 2x, 10 = 4x, 11 = 8x)

-   bit 0 = Pattern number is relative to anchor

Relative, Unified Sprites

-   bit 7-6 = 01

-   bit 5 = Pattern number bit-7 for 4-bit, 0 for 8-bit

-   bits 4-1 = 0000

-   bit 0 = Pattern number is relative to anchor

Register (R/W) $40 () => Palette Index Select

-   bits 7-0 = Palette Index Number

Selects the palette index to change the associated colour

For ULA only, INKs are mapped to indices 0 through 7, BRIGHT INKs to indices 8
through 15, PAPERs to indices 16 through 23 and BRIGHT PAPERs to indices 24
through 31. In EnhancedULA mode, INKs come from a subset of indices from 0
through 127 and PAPERs from a subset of indices from 128 through 255.

The number of active indices depends on the number of attribute bits assigned
to INK and PAPER out of the attribute byte.

In ULAplus mode, the last 64 entries (indices 192 to 255) hold the ULAplus
palette. The ULA always takes border colour from PAPER for standard ULA and
Enhanced ULA

Register (R/W) $41 () => 8-bit Palette Data

-   bits 7-0 = Colour Entry in RRRGGGBB format

The lower blue bit of the 9-bit internal colour will be the logical or of bits
0 and 1 of the 8-bit entry. After each write, the palette index auto-increments
if aut-increment has been enabled (NextReg $43 bit 7), Reads do not
auto-increment.

Register (R/W) $42 () => ULANext Attribute Byte Format

-   bits 7-0 = Attribute byte's INK representation mask (7 on reset)

The mask can only indicate a solid sequence of bits on the right side of the
attribute byte (1, 3, 7, 15, 31, 63, 127 or 255).

INKs are mapped to base index 0 in the palette and PAPERs and border are mapped
to base index 128 in the palette.

The 255 value enables the full ink colour mode making all the palette entries
INK. PAPER and border both take on the fallback colour (nextreg $4A) in this
mode.

Register (R/W) $43 () => Palette Control

-   bit 7 = Disable palette write auto-increment.

-   bits 6-4 = Select palette for reading or writing:

    -   000 = ULA first palette

    -   100 = ULA second palette

    -   001 = Layer 2 first palette

    -   101 = Layer 2 second palette

    -   010 = Sprite first palette

    -   110 = Sprite second palette

    -   011 = Layer 3 first palette

    -   111 = Layer 3 second palette

-   bit 3 = Select Sprite palette (0 = first palette, 1 = second palette)

-   bit 2 = Select Layer 2 palette (0 = first palette, 1 = second palette)

-   bit 1 = Select ULA palette (0 = first palette, 1 = second palette)

-   bit 0 = Enable EnhancedULA mode if 1. (0 after a reset)

Register (R/W) $44 () => 9-bit Palette Data
Non Level 2

-   1st write

-   bits 7-0 = MSB (RRRGGGBB)

-   2nd write

-   bits 7-1 = Reserved, must be 0

-   bit 0 = LSB (B)

Level 2

-   1st write

-   bits 7-0 = MSB (RRRGGGBB)

-   2nd write

-   bit 7 = Priority

-   bits 6-1 = Reserved, must be 0

-   bit 0 = LSB (B)

9-bit Palette Data is entered in two consecutive writes; the second write
autoincrements the palette index if auto-increment is enabled in NextREG $43
bit 7

If writing an L2 palette, the second write's D7 holds the L2 priority bit which
if set (1) brings the colour defined at that index on top of all other layers.
If you also need the same colour in regular priority (for example: for
enviromental masking) you will have to set it up again, this time with no
priority.

Reads return the second byte and do not autoincrement. Writes to nextreg $40,
$41, $41, or $43 reset to the first write.

Register (R/W) $4A () => Fallback Colour Value

-   bits 7-0 = 8-bit colour if all layers are transparent ($E3 on reset)

(black on reset = 0)

Register (R/W) $4B () => Sprite Transparency Index

-   bits 7-0 = Index value ($E3 if reset)

For 4-bit sprites only the bottom 4-bits are relevant.

Register (R/W) $4C () => Level 3 Transparency Index

-   bits 7-4 = Reserved, must be 0

-   bits 3-0 = Index value ($0F on reset)

Register (R/W) $50 () => MMU Slot 0 Control

-   bits 7-0 = 8k RAM page at position $0000 to $1FFF ($ff on reset)

Pages can be from 0 to 223 on a fully expanded Next.
A 255 value causes the ROM to become visible.

Register (R/W) $51 () => MMU Slot 1 Control

-   bits 7-0 = 8k RAM page at position $2000 to $3FFF ($ff on reset)

Pages can be from 0 to 223 on a fully expanded Next.
A 255 value causes the ROM to become visible.

Register (R/W) $52 () => MMU Slot 2 Control

-   bits 7-0 = 8k RAM page at position $4000 to $5FFF ($0A on reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $53 () => MMU Slot 3 Control

-   bits 7-0 = 8k RAM page at position $6000 to $7FFF ($0B on reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $54 () => MMU Slot 4 Control

-   bits 7-0 = 8k RAM page at position $8000 to $9FFF ($04 on reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $55 () => MMU Slot 5 Control

-   bits 7-0 = 8k RAM page at position $A000 to $BFFF ($05 on reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $56 () => MMU Slot 6 Control

-   bits 7-0 = 8k RAM page at position $C000 to $DFFF ($00 on reset)

Pages can be from 0 to 223 on a fully expanded Next.

Register (R/W) $57 () => MMU Slot 7 Control

-   bits 7-0 = 8k RAM page at position $E000 to $FFFF ($01 on reset)

Pages can be from 0 to 223 on a fully expanded Next.

Writing to ports $1FFD, $7FFD and $DFFD writes $FF to MMU0 and MMU1 and writes
appropriate values to MMU6 and MMU7 to map in the selected 16k bank.

+3 special modes override the MMUs if used.

Register (W) $60 () => Copper Data 8-bit Write

-   bits 7-0 = Byte to write to copper instruction memory

Note that each copper instruction is two bytes long, after a write, the coppen
address is auto-incremented to the next memory position.

After a write, the index is auto-incremented to the next memory position.

Register (W) $61 () => Copper Address LSB

-   bits 7-0 = Copper instruction memory address LSB (0 on reset)

Register (W) $62 () => Copper Control

-   bits 7-6 = Start Control

    -   00 = Copper fully stopped

    -   01 = Copper start, execute the list from index 0, and loop to the start

    -   10 = Copper start, execute the list from last point, and loop to the
        start

    -   11 = Copper start, execute the list from index 0, and restart the list
        when the raster reaches position (0,0)

-   bits 2-0 = Copper instruction memory address (MSB) (0 on reset)

Register (W) $63 () => Copper Data 16-bit Write

-   bits 7-0 = Byte to write to copper instruction memory

The 16-bit value is written in pairs. The first 8-bits are the MSB and are
destined for an even copper instruction address. The sesond 8-bits are the LSB
and are destined for an odd copper instruction address.

After each write, the copper address is auto-incremented to the next memory
position.

After a write to an odd address, the all 16-bits are written to copper memory
at once.

Register (R/W) $64 () => Vertical Line Count Offset (3.01.05)

-   bits 7-0 = Offset added to the vertical line counter

-   affects copper, line interrupt and active line count.
    Normally the ula's pixel row 0 aligns with vertical line count 0. With a
    non-zero offset, the ula's pixel row 0 will align with the vertical line
    offset.
    Eg, if the offset is 32 then vertical line 32 will correspond to the first
    pixel row in the ula and vertical line 0 will align with the first pixel
    row of the tilemap and sprites.

* Since a change in offset takes effect when the ula reaches row 0, the change
can take up to one frame to occur.

Register (R/W) $68 () => ULA Control

-   bit 7 = Disable ULA output (0 on reset)

-   bit 6-5 = Color blending control for layering modes 6 & 7 (3.01.01)

    -   00 = ULA as blend colour

    -   01 = No blending

    -   10 = ULA/Tilemap mix result as blend colour

    -   11 = Tilemap as blend colour

-   bit 4 = Cancel entries in 8x5 matrix for extended keys (3.01.04)

-   bit 3 = Enable ULAplus (0 on reset)

-   bit 2 = Enable ULA half pixel scroll (0 on reset)

-   may change

-   bit 1 = Reserved (must be 0)

-   bit 0 = Enable stencil mode (0 on reset)

-   When ULA and Layer 3 are enabled, if either are transparent, the result is
    transparent, otherwise the result is the logical AND of both colours.

Register (R/W) $69 () => Display Control 1

-   bit 7 = Layer 2 Enable (Port $123B bit 1 alias)

-   bit 6 = ULA Shadow display enable (Port $7FFD bit 3 alias)

-   bits 5-0 = Timex alias (Port $FF alias)

Register (R/W) $6A () => Layer 1,0 (LoRes) Control

-   bits 7-6 = reserved, must be 0

-   bit 5 = Enable Radistan (16-colour) (0 on reset)

-   bit 4 = Radistan DFILE switch (xor with bit 0 of port $ff) (0 on reset)

-   bits 3-0 = Radistsan palette offset (0 on reset)

-   bits 1-0 = ULAplus palette offset (0 on reset)

Register (R/W) $6B () => Layer 3 (Tilemap) Control

-   bit 7 = Layer 3 Enable (0 on reset)

-   bit 6 = Layer 3 Size control (0 on reset)

    -   0 = 40x32

    -   1 = 80x32

-   bit 5 = Disable Arrtibute Entry (0 on reset)

-   bit 4 = palette select (0 on reset)

-   bit 3 = Enable Text mode (1-bit tilemap) (0 on reset)

-   bit 2 = Reserved, must be 0

-   bit 1 = Activate 512 tile mode (0 on reset)

-   bit 0 = Enable Layer 3 on top of ULA (0 on reset)

Register (R/W) $6C () => Default Layer 3 Attribute*

-   bits 7-4 = Palette Offset ($00 on reset)

-   bit 3 = X mirror (0 on reset)

-   bit 2 = Y mirror (0 on reset)

-   bit 1 = Rotate (0 on reset)

-   bit 0 = Bit 8 of the tile number (512 tile mode) (0 on reset)

-   bit 0 = ULA over tilemap (256 tile mode) (0 on reset)

*Active tile attribute if bit 5 of nextreg $6B is set.

Register (R/W) $6E () => Layer 3 Tilemap Base Address

-   bit 7 = Bank Select (3.01.08)

    -   0 = Bank 5

    -   1 = Bank 7

-   bit 6 = Reserved, must be 0

-   bits 5-0 = MSB of address of the tilemap in Bank 5 (16k) or 7 (8k) ($2C on
    reset)

Soft Reset default $2C - This is because the address is $6C00 so the MSB is
$6C. But the stored value is only the lower 6 bits so it's an offset into the
16k Bank 5. To calculate therefore subtract $40 leaving you with $2C.

The value written is an offset into the 16k Bank 5 or the 8k lower half of Bank
7 allowinf the tilemap to be placed at any multiple of 256 bytes.

Register (R/W) $6F () => Layer 3 Tile Definitions Base Address

-   bit 7 = Select bank (3.01.08)

    -   0 = Bank 5

    -   1 = Bank 7

-   bit 6 = Reserved, must be 0

-   bits 5-0 = MSB of address of the tile definitions in Bank 5 (16k) or 7 (8k)
    ($0C on reset)

Soft Reset default $0C - This is because the address is $4C00 so the MSB is
$4C. But the stored value is only the lower 6 bits so it's an offset into the
16k Bank 5. To calculate therefore subtract $40 leaving you with $0C.

The value written is an offset into the 16k Bank 5 or the 8k lower half of Bank
7 allowing the tilemap to be placed at any multiple of 256 bytes.

Register (R/W) $70 () => Layer 2 Control

-   bits 7-6 = Reserved, must be 0

-   bits 5-4 = Resolution (00 on soft reset)

    -   00 = 256 x 192 x 256

    -   01 = 320 x 256 x 256

    -   10 = 640 x 256 x 16

    -   11 = Do not use

-   bits 3-0 = Palette offset ($0 on soft reset)

Register (R/W) $71 () => Layer 2 X Scroll MSB

-   bits 7-1 = Reserved, must be 0

-   bits 0 = MSB of X Offset

Register (W) $75 () => Sprite Attribute 0 (Auto-incrementing)
See nextreg $35

Register (W) $76 () => Sprite Attribute 1 (Auto-incrementing)
See nextreg $36

Register (W) $77 () => Sprite Attribute 2 (Auto-incrementing)
See nextreg $37

Register (W) $78 () => Sprite Attribute 3 (Auto-incrementing)
See nextreg $38

Register (W) $79 () => Sprite Attribute 4 (Auto-incrementing)
See nextreg $39

Register (R/W) $7F () => User Register 0

-   bits 7-0 = User Register ($FF on hard reset)

Caution NextReg numbers above $7F are inaccessible to the Copper

Register (R/W) $80 () => Expansion Bus Enable
Immediate

-   bit 7 = Expansion Bus Enable (0 on hard reset)(3.01.07)

-   bit 6 = Enable ROMCS ROM replacement from divmmc banks 14/15 (experimental,
    3.01.03)

-   bit 5 = I/O cycle Disable/Ignore /IORQULA (0 on hard reset)

-   bit 4 = Memory cycle Disable/Ignore /ROMCS (0 on hard reset)

After Soft Reset (Copied into bits 7-4)

-   bit 3 = Expansion Bus Enable (0 on hard reset)

-   bit 2 = Enable ROMCS ROM replacement from divmmc banks 14/15 (experimental,
    3.01.03)

-   bit 1 = I/O cycle Disable/Ignore /IORQULA (0 on hard reset)

-   bit 0 = Memory cycle Disable/Ignore /ROMCS (0 on hard reset)

Register (R/W) $81 () => Expansion Bus Control

-   bit 7 = (R) Expansion bus /ROMCS asserted

-   bit 6 = Allow peripherials to override the ULA on some even port reads
    ($00-$0E)(Rotoronics Wafadrive)(3.01.07)

-   bit 5 = Disable expansion bus NMI debounce (Opus Discovery)(3.01.07)

-   bit 4 = (W) Propagate max CPU clock at all times (0 on hard reset)

-   bits 3-2 = Reserved, must be 0

-   bits 1-0 = Max CPU Speed when Expansion Bus is enabled ($00 on hard reset,
    currently fixed at $00)

    -   00 = 3.5 MHz

    -   01 = 7 MHz

    -   10 = 14 MHz

    -   11 = 28 MHz

Register (R/W) $82 () => Internal Port decoding control 1/4

-   bit 7 = Enable Kempston Port 2 (Port $37) (1 on reset)

-   bit 6 = Enable Kempston Port 1 (Port $1F) (1 on reset)

-   bit 5 = Enable DMA (Port $6B) (1 on reset)

-   bit 4 = Enable +3 Floating Bus (1 on reset)

-   bit 3 = Enable +3 Paging (Port $1FFD) (1 on reset)

-   bit 2 = Enable Next Memory Paging (Port $DFFD) (1 on reset)

-   bit 1 = Enable Paging (Port $7FFD) (1 on reset)

-   bit 0 = Enable Timex (Port $FF) (1 on reset)

Register (R/W) $83 () => Internal Port decoding control 2/4

-   bit 7 = Enable Layer 2 (Port $123B) (1 on reset)

-   bit 6 = Enable Sprites (Ports $57, $5B, $303B) (1 on reset)

-   bit 5 = Enable Kempston Mouse (Ports $FADF, $FBDF, $FFDF) (1 on reset)

-   bit 4 = Enable UART (Ports $133B, $143B, $153B) (1 on reset)

-   bit 3 = Enable SPI (Ports $E7, $EB) (1 on reset)

-   bit 2 = Enable I2C (Ports $103B, $113B) (1 on reset)

-   bit 1 = Enable Multiface (two variable ports) (1 on reset)

-   bit 0 = Enable divMMC (Port $E3) (1 on reset)

Register (R/W) $84 () => Internal Port decoding control 3/4

-   bit 7 = Enable SPECdrum Mono DAC (Port $DF) (1 on reset)

-   bit 6 = Enable Covox/GS Mono DAC (Port $B3) (1 on reset)

-   bit 5 = Enable Pentagon/ATM DAC (Port $FB) (1 on reset)

-   bit 4 = Enable Covox Stereo DAC (Ports $0F, $4F) (1 on reset)

-   bit 3 = Enable Profi/Covox Stereo DAC (Ports $3F, $5F) (1 on reset)

-   bit 2 = Enable Soundrive DAC Mode 2 (Ports $F1, $F3, $F9, $FB) (1 on reset)

-   bit 1 = Enable Soundrive DAC Mode 1 (Ports $0F, $1F, $4F, $5F) (1 on reset)

-   bit 0 = Enable AY (Ports $FFFD, $BFFD) (1 on reset)

Register (R/W) $85 () => Internal Port decoding control 4/4

-   bit 7 = Enable configuration of port decoding on soft reset (3.01.01)

-   bits 6-4 = Reserved

-   bit 3 = Enable Z80 CTC ports $183B, $193B, $1A3B, $1B3B, $1C3B, $1D3B,
    $1E3B, and $1F3B

-   bit 2 = Enable Pentagon 1024 memory port $EFF7

-   bit 1 = Enable DMA port $0B (3.01.02)

-   bit 0 = Enable ULAplus (Ports $BF3B, $FF3B) (1 on reset)

Register (R/W) $86 () => Expansion Port decoding control 1/4

-   bit 7 = Enable Kempston Port 2 (Port $37) (1 on reset)

-   bit 6 = Enable Kempston Port 1 (Port $1F) (1 on reset)

-   bit 5 = Enable DMA (Port $6B) (1 on reset)

-   bit 4 = Enable +3 Floating Bus (1 on reset)

-   bit 3 = Enable +3 Paging (Port $1FFD) (1 on reset)

-   bit 2 = Enable Next Memory Paging (Port $DFFD) (1 on reset)

-   bit 1 = Enable Paging (Port $7FFD) (1 on reset)

-   bit 0 = Enable Timex (Port $FF) (1 on reset)

Register (R/W) $87 () => Expansion Port decoding control 2/4

-   bit 7 = Enable Layer 2 (Port $123B) (1 on reset)

-   bit 6 = Enable Sprites (Ports $57, $5B, $303B) (1 on reset)

-   bit 5 = Enable Kempston Mouse (Ports $FADF, $FBDF, $FFDF) (1 on reset)

-   bit 4 = Enable UART (Ports $133B, $143B, $153B) (1 on reset)

-   bit 3 = Enable SPI (Ports $E7, $EB) (1 on reset)

-   bit 2 = Enable I2C (Ports $103B, $113B) (1 on reset)

-   bit 1 = Enable Multiface (two variable ports) (1 on reset)

-   bit 0 = Enable divMMC (Port $E3) (1 on reset)

Register (R/W) $88 () => Expansion Port decoding control 3/4

-   bit 7 = Enable SPECdrum Mono DAC (Port $DF) (1 on reset)

-   bit 6 = Enable Covox/GS Mono DAC (Port $B3) (1 on reset)

-   bit 5 = Enable Pentagon/ATM DAC (Port $FB) (1 on reset)

-   bit 4 = Enable Covox Stereo DAC (Ports $0F, $4F) (1 on reset)

-   bit 3 = Enable Profi/Covox Stereo DAC (Ports $3F, $5F) (1 on reset)

-   bit 2 = Enable Soundrive DAC Mode 2 (Ports $F1, $F3, $F9, $FB) (1 on reset)

-   bit 1 = Enable Soundrive DAC Mode 1 (Ports $0F, $1F, $4F, $5F) (1 on reset)

-   bit 0 = Enable AY (Ports $FFFD, $BFFD) (1 on reset)

Register (R/W) $89 () => Expansion Port decoding control 4/4

-   bit 7 = Enable configuration of port decoding on soft reset (3.01.01)

-   bits 6-4 = Reserved

-   bit 3 = Enable Z80 CTC ports $183B, $193B, $1A3B, $1B3B, $1C3B, $1D3B,
    $1E3B, and $1F3B

-   bit 2 = Enable Pentagon 1024 memory port $EFF7

-   bit 1 = Enable DMA port $0B (3.01.02)

-   bit 0 = Enable ULAplus (Ports $BF3B, $FF3B) (1 on reset)

The Internal Port Decoding Enables always apply.

When the Expansion Bus is enabled, the Expansion Bus Port Decoding Enables are
logically ANDed with the Internal Enables. A result of 0 for the corresponding
bit indicates the internal device is disabled. If the Expansion Bus is enabled,
this allows I/O cycles for disabled ports to propagate to the Expansion Bus,
otherwise corresponding I/O cycles to the Expansion Bus are filtered.

Register (R/W) $8A () => Expansion Bus I/O Propagate Control

-   bits 7-3 = Reserved, must be 0

-   bit 4 = Propagate port $FF I/O Cycles (0 on hard reset, 3.01.02)

-   bit 3 = Propagate port $1FFD I/O Cycles (0 on hard reset)

-   bit 2 = Propagate port $DFFD I/O Cycles (0 on hard reset)

-   bit 1 = Propagate port $7FFD I/O Cycles (0 on hard reset)

-   bit 0 = Propagate port $FE I/O Cycles (1 on hard reset, 3.01.03: 0 on hard
    reset)

Register (R/W) $8C () => Alternate ROM
Immediate

-   bit 7 = Alt ROM Enable (0 on hard reset)

-   bit 6 = Alt ROM visible ONLY during writes (0 on hard reset)

-   bit 5 = Reserved, must be 0

-   bit 4 = 48k ROM Lock (0 on hard reset)

After Soft Reset (copied into bits 7-4)

-   bit 3 = Alt ROM Enable (0 on hard reset)

-   bit 2 = Alt ROM visible ONLY during writes (0 on hard reset)

-   bit 1 = Reserved, must be 0

-   bit 0 = 48k ROM Lock (0 on hard reset)

Register (R/W) $8E () => Spectrum 128k Memory Mapping (3.01.01)

-   bit 7 = Bank number bit 3 (port $dffd bit 0)

-   bit 6-4 = Bank number bits 2-0 (port $7ffd bits 2-0)

-   bit 3 = Enable change ram page (read as 1)

-   bit 2 = Paging mode (port $1ffd bit 0)

    -   0 = Normal paging mode

    -   1 = Special paging mode (lot bit of memory configuration)

-   Normal Paging Mode

-   bits 1-0 = ROM selection (port $1ffd bit 1 and $7ffd bit 4)

-   Special (all RAM) Paging Mode

-   bits 1-0 = RAM configuration selection (port $1ffd bits 2-1)

Writes can affect all ports $7ffd, $dffd, and $1ffd
Writes can always change the ROM/allRAM mapping
Writes immediately change the current MMU mapping as if by port write.

Register (R/W) $8F () => Memory Mapping Mode (3.01.06)

-   bits 7-2 = Reserved, must be zero

-   bits 1-0 = Mapping mode applied

    -   00 = Standard ZX 128k +3

    -   01 = Profi (removed in 3.01.09)

    -   10 = Pentagon 512k

    -   11 = Pentagon 1024k (limited to 768k on 1MB machines)

* Standard ZX 128k +3 = principally ports $7FFD, $DFFD, and $1FFD
* Pentagon 512k = principally port $7FFD
* Pentagon 1024k = principally ports $7FFD and $EFF7
** The mapping modes affect how ports $7FFD, $DFFD, $1FFD, and $EFF7 carry out
memory paging, see ports

Register (R/W) $90 () => Pi GPIO output enable 1/4

-   bit 7 = Enable Pin 7 (0 on reset)

-   bit 6 = Enable Pin 6 (0 on reset)

-   bit 5 = Enable Pin 5 (0 on reset)

-   bit 4 = Enable Pin 4 (0 on reset)

-   bit 3 = Enable Pin 3 (0 on reset)

-   bit 2 = Enable Pin 2 (0 on reset)

-   bit 1 = Enable Pin 1 (cannot be enabled) (0 on reset)

-   bit 0 = Enable Pin 0 (cannot be enabled) (0 on reset)

Register (R/W) $91 () => Pi GPIO output enable 2/4

-   bit 7 = Enable Pin 15 (0 on reset)

-   bit 6 = Enable Pin 14 (0 on reset)

-   bit 5 = Enable Pin 13 (0 on reset)

-   bit 4 = Enable Pin 12 (0 on reset)

-   bit 3 = Enable Pin 11 (0 on reset)

-   bit 2 = Enable Pin 10 (0 on reset)

-   bit 1 = Enable Pin 9 (0 on reset)

-   bit 0 = Enable Pin 8 (0 on reset)

Register (R/W) $92 () => Pi GPIO output enable 3/4

-   bit 7 = Enable Pin 23 (0 on reset)

-   bit 6 = Enable Pin 22 (0 on reset)

-   bit 5 = Enable Pin 21 (0 on reset)

-   bit 4 = Enable Pin 20 (0 on reset)

-   bit 3 = Enable Pin 19 (0 on reset)

-   bit 2 = Enable Pin 18 (0 on reset)

-   bit 1 = Enable Pin 17 (0 on reset)

-   bit 0 = Enable Pin 16 (0 on reset)

Register (R/W) $93 () => Pi GPIO output enable 4/4

-   bits 7-4 = Reserved

-   bit 3 = Enable Pin 27 (0 on reset)

-   bit 2 = Enable Pin 26 (0 on reset)

-   bit 1 = Enable Pin 25 (0 on reset)

-   bit 0 = Enable Pin 24 (0 on reset)

Register (R/W) $98 () => Pi GPIO Pin State 1/4

-   bit 7 = Pin 7 Data (1 on reset)

-   bit 6 = Pin 6 Data (1 on reset)

-   bit 5 = Pin 5 Data (1 on reset)

-   bit 4 = Pin 4 Data (1 on reset)

-   bit 3 = Pin 3 Data (1 on reset)

-   bit 2 = Pin 2 Data (1 on reset)

-   bit 1 = Pin 1 Data (1 on reset)

-   bit 0 = Pin 0 Data (1 on reset)

Register (R/W) $99 () => Pi GPIO Pin State 2/4

-   bit 7 = Pin 15 Data (1 on reset)

-   bit 6 = Pin 14 Data (1 on reset)

-   bit 5 = Pin 13 Data (1 on reset)

-   bit 4 = Pin 12 Data (1 on reset)

-   bit 3 = Pin 11 Data (1 on reset)

-   bit 2 = Pin 10 Data (1 on reset)

-   bit 1 = Pin 9 Data (1 on reset)

-   bit 0 = Pin 8 Data (1 on reset)

Register (R/W) $9A () => Pi GPIO Pin State 3/4

-   bit 7 = Pin 23 Data (1 on reset)

-   bit 6 = Pin 22 Data (1 on reset)

-   bit 5 = Pin 21 Data (1 on reset)

-   bit 4 = Pin 20 Data (1 on reset)

-   bit 3 = Pin 19 Data (1 on reset)

-   bit 2 = Pin 18 Data (1 on reset)

-   bit 1 = Pin 17 Data (1 on reset)

-   bit 0 = Pin 16 Data (1 on reset)

Register (R/W) $9B () => Pi GPIO Pin State 4/4

-   bits 7-4 = Reserved

-   bit 3 = Pin 27 Data (1 on reset)

-   bit 2 = Pin 26 Data (1 on reset)

-   bit 1 = Pin 25 Data (1 on reset)

-   bit 0 = Pin 24 Data (1 on reset)

Register (R/W) $A0 () => Pi Peripheral Enable

-   bits 7-6 = Reserved, must be 0

-   bit 5 = Enable UART on GPIO 14, 15 (0 on reset)*

-   bit 4 = Communication Type (0 on reset)

    -   0 = Rx to GPIO 15, Tx to GPIO 14 (Pi)

    -   1 = Rx to GPIO 14, Tx to GPIO 15 (Pi Hats)

-   bit 3 = Enable I2C on GPIO 2, 3 (0 on reset)*

-   bits 2-1 = Reserved, must be 0

-   bit 0 = Enable SPI on GPIO 7, 8, 9, 10, 11 (0 on reset)*

*Overrides GPIO Enables

Register (R/W) $A2 () => Pi I2S Audio Control

-   bits 7-6 = I2S State ($00 on reset)

    -   00 = I2S Disabled

    -   01 = I2S is mono, source R

    -   10 = I2S is mono, source L

    -   11 = I2S is stereo

-   bit 5 = Reserved, must be 0

-   bit 4 = Audio Flow Direction (0 on reset)

    -   0 = PCM_DOUT to Pi, PCM_DIN from Pi (Hats)

    -   1 = PCM_DOUT from Pi, PCM_DIN to Pi (Pi)

-   bit 3 = Mute left (0 on reset)

-   bit 2 = Mute right (0 on reset)

-   bit 1 = Slave mode, Reserved must be 1 (remove in 3.01.05)

-   bit 0 = Direct I2S audio to EAR on port $FE (0 on reset)

Register (R/W) $A3 () => Pi I2S Clock Divide (Master Mode) (removed in 3.01.05)

-   bits 7-0 = Clock divide value ($0B on reset)

Divider=538461/Rate-1 or
Rate=538461/(Divider+1)

Register (R/W) $A8 () => ESP WiFi GPIO Output Enable

-   bits 7-3 = Reserved, must be sero

-   bit 2 = GPIO2 output enable (fixed at 0, GPIO2 is read-only)

-   bit 1 = Reserved, must be zero

-   bit 0 = GPIO0 output enable (fixed at 0, GPIO2 is read-only)

Register (R/W) $A9 () => ESP WiFi GPIO

-   bits 7-3 = Reserved, must be sero

-   bit 2 = Read/Write GPIO2 (reset = 1)

-   bit 1 = Reserved, must be zero

-   bit 0 = Read/Write GPIO0 (reset = 1)

Register (R) $B0 () => Extended Keys 0 (3.01.04)

-   bit 7 = 1 if ; pressed

-   bit 6 = 1 if p̈ressed

-   bit 5 = 1 if , pressed

-   bit 4 = 1 if . pressed

-   bit 3 = 1 if UP pressed

-   bit 2 = 1 if DOWN pressed

-   bit 1 = 1 if LEFT pressed

-   bit 0 = 1 if RIGHT pressed

Register (R) $B1 () => Extended Keys 1 (3.01.04)

-   bit 7 = 1 if DELETE pressed

-   bit 6 = 1 if EDIT pressed

-   bit 5 = 1 if BREAK pressed

-   bit 4 = 1 if INV VIDEO pressed

-   bit 3 = 1 if TRUE VIDEO pressed

-   bit 2 = 1 if GRAPH pressed

-   bit 1 = 1 if CAPS LOCK pressed

-   bit 0 = 1 if EXTEND pressed

Register (R/W) $C0 () => Interrupt Control (3.01.09)
($00 on reset)

-   bits 7-5 = Programmable portion of IM2 vector *

-   bit 4 = Reserved, must be 0

-   bit 3 = Enable stackless /NMI response

-   bits 2-1 = Reserved, must be 0

-   bit 0 = Maskable interrupt mode

    -   0 - pulse

    -   1 - IM2

* In IM2 mode vector generated is:

-   bits 7-5 = nextreg $C0 bits 7-5

-   bits 4-1 = Interrupt source

    -   0 - line interrupt (highest priority)

    -   1 - UART 0 Rx

    -   2 - UART 1 Rx

    -   3-10 - CTC channels 0-7

    -   11 - ULA

    -   12 - UART 0 Tx

    -   13 - UART 1 Tx (lowest priority)

-   bit 0 = 0

Register (R/W) $C2 () => /NMI Return Address LSB (3.01.09)
($00 on reset)

Register (R/W) $C3 () => /NMI Return Address MSB (3.01.09)
($00 on reset)

Register (R/W) $C4 () => Interrupt Enable 0 (3.01.08)
($83 on reset)

-   bit 7 = Expansion bus /INT

-   bits 6-2 = Reserved must be zero

-   bit 1 = Line

-   bit 0 = ULA

Register (R/W) $C5 () => Interrupt Enable 1 (3.01.08)
($00 on reset)

-   bit 7 = ctc channel 7 zc/to

-   bit 6 = ctc channel 6 zc/to

-   bit 5 = ctc channel 5 zc/to

-   bit 4 = ctc channel 4 zc/to

-   bit 3 = ctc channel 3 zc/to

-   bit 2 = ctc channel 2 zc/to

-   bit 1 = ctc channel 1 zc/to

-   bit 0 = ctc channel 0 zc/to

Register (W) $C6 () => Interrupt Enable 2 (3.01.08)
($00 on reset)

-   bit 7 = Reserved, must be 0

-   bit 6 = UART1 Tx empty

-   bit 5 = UART1 Rx half full *

-   bit 4 = UART1 Rx available *

-   bit 3 = Reserved, must be 0

-   bit 2 = UART0 Tx empty

-   bit 1 = UART0 Rx half full *

-   bit 0 = UART0 Rx available *

* For each UART, Rx half full and Rx available are shared interrupts

Register (W) $C7 () => Reserved (3.01.09)

Register (R/W) $C8 () => Interrupt Status 0 (3.01.09)
($00 on reset)

-   bits 7-2 = Reserved, must be zero

-   bit 1 = Line

-   bit 0 = ULA

* Set bits indicate the device generated an interrupt in the past * Writes
clear bits where bits are set except in IM2 mode

Register (R/W) $C9 () => Interrupt Status 1 (3.01.09)

-   bit 7 = ctc channel 7 zc/to

-   bit 6 = ctc channel 6 zc/to

-   bit 5 = ctc channel 5 zc/to

-   bit 4 = ctc channel 4 zc/to

-   bit 3 = ctc channel 3 zc/to

-   bit 2 = ctc channel 2 zc/to

-   bit 1 = ctc channel 1 zc/to

-   bit 0 = ctc channel 0 zc/to

* Set bits indicate the device generated an interrupt in the past * Writes
clear bits where bits are set except in IM2 mode

Register (R/W) $CA () => Interrupt Status 2 (3.01.09) ($00 on reset)

-   bit 7 = Reserved, must be zero

-   bit 6 = UART1 Tx empty

-   bit 5 = UART1 Rx almost full *

-   bit 4 = UART1 Rx available *

-   bit 3 = Reserved must be zero

-   bit 2 = UART0 Tx empty

-   bit 1 = UART0 Rx almost full *

-   bit 0 = UART0 Rx available *

* For each UART Rx half full and Rx available are shared interrupts ** Set bits
indicate the device generated an interrupt in the past ** Writes clear bits
where bits are set except in IM2 mode

Register (W) $CB () => Reserved (3.01.09)

Register (R/W) $CC () => DMA Interrupt Enable 0 (3.01.09) ($00 on reset)

-   bits 7-2 = Reserved, must be 0

-   bit 1 = Line

-   bit 0 = ULA

* Set bits indicate the specified interrupt will interrupt a DMA operation when
in IM2 mode

Register (R/W) $CD () => DMA Interrupt Enable 1 (3.01.09) ($00 on reset)

-   bit 7 = CTC channel 7 zc/to

-   bit 6 = CTC channel 6 zc/to

-   bit 5 = CTC channel 5 zc/to

-   bit 4 = CTC channel 4 zc/to

-   bit 3 = CTC channel 3 zc/to

-   bit 2 = CTC channel 2 zc/to

-   bit 1 = CTC channel 1 zc/to

-   bit 0 = CTC channel 0 zc/to

* Set bits indicate the corresponding interrupt will interrupt a DMA operation
when in IM2 mode

Register (R/W) $CE () => DMA Interrupt Enable 2 (3.01.09) ($00 on reset)

-   bit 7 = Reserved, must be 0

-   bit 6 = UART1 Tx empty

-   bit 5 = UART1 Rx half full

-   bit 4 = UART1 Rx available

-   bit 3 = Reserved, must be 0

-   bit 2 = UART0 Tx empty

-   bit 1 = UART0 Tx half full

-   bit 0 = UART0 Tx available

* Set bits indicate the corresponding interrupt will interrupt a DMA operation
when in IM2 mode.

Register (W) $CF () => Reserved (3.01.09)

Register (W) $FF () => Debug LEDs (DE-1, DE-2 am Multicore only)

AY-3-8912

(R/W) $00 (0) => Channel A fine tune

-   bits 7-0 = Channel A frequency bits 7-0

(R/W) $01 (1) => Channel A coarse tune

-   bits 7-4 = Reserved

-   bits 4-0 = Channel A frequency bits 11-8

(R/W) $02 (0) => Channel B fine tune

-   bits 7-0 = Channel A frequency bits 7-0

(R/W) $03 (1) => Channel B coarse tune

-   bits 7-4 = Reserved

-   bits 4-0 = Channel A frequency bits 11-8

(R/W) $04 (0) => Channel C fine tune

-   bits 7-0 = Channel A frequency bits 7-0

(R/W) $05 (1) => Channel C coarse tune

-   bits 7-4 = Reserved

-   bits 4-0 = Channel A frequency bits 11-8

(R/W) $06 (6) => Noise period

-   bits 7-5 = Reserved

-   bits 4-0 = Noise period to noise generator

(R/W) $07 (7) => Mixer control I/O Enable

-   Active low (0=enable, 1= disable)

-   bit 7-6: Reserved

-   bit 5: Channel C noise enable

-   bit 4: Channel B noise enable

-   bit 3: Channel A noise enable

-   bit 2: Channel C tone enable

-   bit 1: Channel B tone enable

-   bit 0: Channel A tone enable

(R/W) $0A (10) => Channel A amplitude

-   bits 7-5 = Reserved

-   bit 4 = Amplitude mode

    -   0=fixed amplitude

    -   1=use envelope generator (bits 0-3 ignored)

-   bits 0-3 = value of fixed amplitude

(R/W) $0B (11) => Channel B amplitude

-   like channel A amplitude

(R/W) $0C (12) => Channel C amplitude

-   like channel A amplitude

(R/W) $0D (13) => Envelope period fine

-   bits 7-0 = Envelop period LSB

(R/W) $0E (14) => Envelope period coarse

-   bits 7-0 = Envelop period MSB

(R/W) $0F (15) => Envelope shape

-   bits 7-4 = Reserved

-   bit 3 = Continue

    -   0=drop to amplitude 0 after 1 cycle

    -   1=use 'Hold' value

-   bit 2 = Attack

    -   0=generator counts down

    -   1=generator counts up

-   bit 1-0 = Alternate & Hold

    -   00=generator resets after each cycle

    -   01=hold final value

    -   10=generator reverses direction each cycle

    -   11=hold initial value

zxDMA

@------------------------------------------------------------------------------
@node EO2MN
@next MN2EO
@prev REGISTERS
@{r}ZX Spectrum Next Programming Notes
@{h1}Extended Opcodes to Mnemonics

Single Byte Opcodes

&&&&&&&&&

&&&&&&&&&

&&&&&&&&&

&&&&&&&&&

&&&&&&&&&

&&&&&&&&&

&&&&&&&&&

&&&&&&&&&

$CBxx Bit Operations

&&&&&&&

&&&&&&&

&&&&&&&

&&&&&&&

&&&&&&&

&&&&&&&

&&&&&&&

&&&&&&&

$DDxx IX

&&&&&&&

&&&&&&&

&&&&&&&

$EDxx Block/Port

&&&&&&&

* ZX Spectrum Next extension

&&&&&&&

&&&&&&&

* ZX Spectrum Next extension

$FDxx IY

&&&&&&&

&&&&&&&

&&&&&&&

$DDCBxx IX Bit Operations

&&&&&&&

$FDCBxx IY Bit Operations

&&&&&&&

@------------------------------------------------------------------------------
@node MN2EO
@next FORMATS
@prev EO2MN
@{r}ZX Spectrum Next Programming Notes
@{h1}Mnemonics to Extended Opcodes

@------------------------------------------------------------------------------
@node FORMATS
@next CALLS
@prev MN2EO
@{r}ZX Spectrum Next Programming Notes
@{h1}File Formats

AKY

Music file

BAS

Basic file

BMP

Windows bitmap. On the ZX Spectrum next, these must be uncompressed and 8 bpp.

DSK

Disk image

ESP

Update file for Wi-Fi module

GDE

ZX Spectrum Next Guide hypertext file

MC

A Timex hi-color image. Like .shc, but the bitmap and colour map are stored in
display order.

MLT

A Timex hi-color image. Like .shc, but the colour map is stored in display
order.

MOD

Modtracker music file (requires Pi accelerator to play).

NDR

Nexdaw music file

NEX

ZX Spectrum Next executable file.

NXI

A version of a 256x192x8 layer 2 image.

-   bytes 0-511 - palette data

-   bytes 512-49663 - image data

O

ZX-80 executable file

P3D

Disk image file

PT3

Protracker 3 music file

P

ZX-81 executable file

SDH

Music file (requires Pi accelerator to play)

SID

Commodore 64 SID music file (requires Pi accelerator to play)

SCR

ZX Spectrum screen dump

In basic form a 6912 byte file containing the bitmap and colour map for a
standard spectrum image. May have ULAPlus or ULANext color data appended.

ULAplus

-   bytes 0-6143 - bitmap: memory order

-   bytes 6144-6911 - colour map: memory order

-   bytes 6912-6975 - ULAPlus palette data

ULANext

-   bytes 0-6143 - bitmap: memory order

-   bytes 6144-6911 - colour map: memory order

-   byte 6912 - ULANext mode

-   bytes 6913-between 6228 and 7426 - ULANext palette data, size is dependent
    on specific ULANext mode and 8 or 9 bit palette entries.

      ------ ----- ------- ------- -------
      mode     ink   paper   8-bit   9-bit
      $01        2     128     130     260
      $03        4      64      68     136
      $07        8      32      40      80
      $0F       16      16      32      64
      $1F       32       8      40      80
      $3F       64       4      68     136
      $7F      128       2     130     260
      $FF      256       1     257     514
      ------ ----- ------- ------- -------

SHC

Timex hi-color screen dump

In basic form the 12,288 byte file containing the bitmap and colour map for a
Timex hi-color image. May have ULAPlus or ULANext color data appended.

ULAplus

-   bytes 0-6143 - bitmap: memory order

-   bytes 6144-12287 - colour map: memory order

-   bytes 12288-12351 - ULAPlus palette data

ULANext

-   bytes 0-6143 - bitmap: memory order

-   bytes 6144-12287 - colour map: memory order

-   byte 12288 - ULANext mode

-   bytes 12289-between 12304 and 12802 - ULANext palette data, size is
    dependent on specific ULANext mode and 8 or 9 bit palette entries.

      ------ ----- ------- ------- -------
      mode     ink   paper   8-bit   9-bit
      $01        2     128     130     260
      $03        4      64      68     136
      $07        8      32      40      80
      $0F       16      16      32      64
      $1F       32       8      40      80
      $3F       64       4      68     136
      $7F      128       2     130     260
      $FF      256       1     257     514
      ------ ----- ------- ------- -------

SHR

Timex hi-resolution screen dump.

A 12,288 or 12,289 byte file containing a memory dump of the two 6k screen
areas used by Timex hi-resolution mode in memory order with an optional byte
indicating teh colours used.

SL2

ZX Spectrum Next layer 2 screen dump

In its most basic standard form, this is a 49,152 byte file contaning the
memory for the image data.

256x192x8

-   bytes 0-49151 - image data: row dominant

-   optional bytes 49152-49407 or 49663 - palette data (256 bytes for 8-bit
    entries, 512 bytes for 9-bit entries)

320x256x8

-   bytes 0-81919 - image data: column dominant

-   optional bytes 81920-82175 or 82431 - palette data (256 bytes for 8-bit
    entries, 512 bytes for 9-bit entries)

640x256x4

-   bytes 0-81919 - image data: column dominant, nybbles in adjacent columns

-   optional bytes 81920-81935 or 81951 - palette data (16 bytes for 8-bit
    entries, 32 bytes for 9-bit entries)

SLR

ZX Spectrum Next low-resolution screen dump.

Basic standard form 12,288 byte file contaning the memory for the two 6k areas
for 128x96x8 image files

192x96x8

-   bytes 0-12287 - image data: row dominant

-   optional bytes 12288-12543 or 12799 - palette data (256 bytes for 8-bit
    entries, 512 bytes for 9-bit entries)

192x96x4 (Radistan)

-   bytes 0-6143 - image data: row dominant

-   optional bytes 6144-6159 or 6175 - palette data (16 bytes for 8-bit
    entries, 32 bytes for 9-bit entries)

SNA

ZX Spectrum memory snapshot

SND

Music file (requires Pi accelerator to play)

SNX

Extended ZX Spectrum memory snapshot to be run in ZX Spectrum Next mode

SPR

Sprite file

TAP

ZX Spectrum tape image

TXT,DOC,ASM,INI,CFG,MD

Text files

TZX

ZX Spectrum tape image (able to handle custom tape formats). Requires Pi
accelerator to load.

WAV

PCM audio file

XM

XM tracker music file (requires Pi accelerator to play)

Z3 to Z8

Inform interactive fiction files

Z80

ZX Spectrum memory snapshot

ZIP

Zip compressed file

@------------------------------------------------------------------------------
@node CALLS
@prev FORMATS
@{r}ZX Spectrum Next Programming Notes
@{h1}Call Tables

BDOS Call Table

BIOS Call Table

NextZXOS Calls

+3DOS Compatible Calls

Filesystem Calls

  -------------------- ---------- ----------------------------------------------
  DOS_VERSION          $0103 ()   Get +3DOS issue and version numbers
  *DOS_OPEN            $0106 ()   Create and/or open a file
  DOS_CLOSE            $0109 ()   Close a file
  DOS_ABANDON          $010C ()   Abandon a file
  DOS_REF_HEAD         $010F ()   Point at the header data for this file
  DOS_READ             $0112 ()   Read bytes into memory
  DOS_WRITE            $0115 ()   Write bytes from memory
  DOS_BYTE_READ        $0118 ()   Read a byte
  DOS_BYTE_WRITE       $011B ()   Write a byte
  *DOS_CATALOG         $011E ()   Catalog disk directory
  *DOS_FREE_SPACE      $0121 ()   Free space on disk
  DOS_DELETE           $0124 ()   Delete a file
  DOS_RENAME           $0127 ()   Rename a file
  DOS_BOOT             $012A ()   Boot an operating system or other program
  DOS_SET_DRIVE        $012D ()   Set/get default drive
  DOS_SET_USER         $0130 ()   Set/get default user number
  *DOS_GET_POSITION    $0133 ()   Get file pointer for random access
  DOS_SET_POSITION     $0136 ()   Set file pointer for random access
  *DOS_GET_EOF         $0139 ()   Get end of file position for random access
  DOS_GET_1346         $013C ()   Get memory usage in pages 1, 3, 4, 6
  DOS_SET_1346         $013F ()   Re-allocate memory usage in pages 1, 3, 4, 6
  DOS_FLUSH            $0142 ()   Bring disk up to date
  DOS_SET_ACCESS       $0145 ()   Change open file's access mode
  DOS_SET_ATTRIBUTES   $0148 ()   Change a file's attributes
  DOS_SET_MESSAGE      $014E ()   Enable/disable error messages
  -------------------- ---------- ----------------------------------------------

  ----------- ---------- ----------------------------------------------
  DD_L_XDPB   $0187 ()   Initialise an XDPB from a disk specification
  DD_L_DPB    $018A ()   Initialise a DPB from a disk specification
  ----------- ---------- ----------------------------------------------

System Calls

  ---------------- ---------- ------------------
  DOS_INITIALISE   $0100 ()   Initialise +3DOS
  ---------------- ---------- ------------------

  --------------------- ---------- -------------------------------
  IDE_INTERFACE         $00A3 ()   Initialise card interfaces
  IDE_INIT              $00A6 ()   Initialise IDEDOS
  IDE_DRIVE             $00A9 ()   Get unit handle
  *IDE_SECTOR_READ      $00AC ()   Low-level sector read
  *IDE_SECTOR_WRITE     $00AF ()   Low-level sector write
  IDE_PARTITON_READ     $00C4 ()   Read a partition entry
  IDE_PARTITION_OPEN    $00CD ()   Open a partition
  IDE_PARTITION_CLOSE   $00D0 ()   Close a partition
  IDE_PARTITIONS        $01A5 ()   Get number of open partitions
  --------------------- ---------- -------------------------------

Unimplemented Calls

  ---------------- ---------- -------------------------------
  DOS_OPEN_DRIVE   $014B ()   Open a drive as a single file
  DOS_MAP_B        $0154 ()   Map B: onto unit 0 or 1
  ---------------- ---------- -------------------------------

  -------------------- ---------- ----------------------------------------------
  DD_INTERFACE         $0157 ()   Is the floppy disk driver interface present?
  DD_INIT              $015A ()   Initialise disk driver
  DD_SETUP             $015D ()   Specify drive parameters
  DD_SET_RETRY         $0160 ()   Set try/retry count
  DD_READ_SECTOR       $0163 ()   Read a sector
  DD_WRITE_SECTOR      $0166 ()   Write a sector
  DD_CHECK_SECTOR      $0169 ()   Check a sector
  DD_FORMAT            $016C ()   Format a track
  DD_READ_ID           $016F ()   Read a sector identifier
  DD_TEST_UNSUITABLE   $0172 ()   Test media suitability
  DD_LOGIN             $0175 ()   Log in disk, initialise XDPB
  DD_SEL_FORMAT        $0178 ()   Pre-initialise XDPB for DD FORMAT
  DD_ASK_1             $017B ()   Is unit 1 & external drive & present?
  DD_DRIVE_STATUS      $017E ()   Fetch drive status
  DD_EQUIPMENT         $0181 ()   What type of drive?
  DD_ENCODE            $0184 ()   Set intercept routine for copy protection
  DD_L_SEEK            $018D ()   uPD765A seek driver
  DD_L_READ            $0190 ()   uPD765A read driver
  DD_L_WRITE           $0193 ()   uPD765A write driver
  DD_L_ON_MOTOR        $0196 ()   Motor on, wait for motor-on time
  DD_L_T_OFF_MOTOR     $0199 ()   Start the motor-off ticker
  DD_L_OFF_MOTOR       $019C ()   Turn the motor off
  -------------------- ---------- ----------------------------------------------

  ----------------------- ---------- ---------------------------------------------------
  IDE_FORMAT              $00B2 ()   Format a partition
  IDE_PARTITION_NEW       $00B8 ()   Create partition
  IDE_PARTITION_INIT      $00BB ()   Initialise partition
  IDE_PARTITION_ERASE     $00BE ()   Delete a partition
  IDE_PARTITION_RENAME    $00C1 ()   Rename a partition
  IDE_PARTITION_WRITE     $00C7 ()   Write a partition entry
  IDE_PARTITION_WINFO     $00CA ()   Write type-specific partition information
  IDE_PARTITION_GETINFO   $00D3 ()   Get byte from type-specific partition information
  IDE_PARTITION_SETINFO   $00D6 ()   Set byte in type-specific partition information
  IDE_DOS_UNPERMANENT     $00FA ()   Remove permanent drive mapping
  IDE_IDENTIFY            $01A2 ()   Return IDE drive identity information
  ----------------------- ---------- ---------------------------------------------------

+3DOS compatible error codes

Recoverable disk errors

  --- ------------ ----------------------------------------
  0   rc_ready     Drive not ready
  1   rc_wp        Disk is write protected
  2   rc_seek      Seek fail
  3   rc_crc       CRC data error
  4   rc_nodata    No data
  5   rc_mark      Missing address mark
  6   rc_unrecog   Unrecognised disk format
  7   rc_unknown   Unknown disk error
  8   rc_diskchg   Disk changed whilst +3DOS was using it
  9   rc_unsuit    Unsuitable media for drive
  --- ------------ ----------------------------------------

Non-recoverable errors

  ---- ------------- --------------------------------------------------
  20   rc_badname    Bad filename
  21   rc_badparam   Bad parameter
  22   rc_nodrive    Drive not found
  23   rc_nofile     File not found
  24   rc_exists     File already exists
  25   rc_eof        End of file
  26   rc_diskfull   Disk full
  27   rc_dirfull    Directory full
  28   rc_ro         Read-only file
  29   rc_number     File number not open (or open with wrong access)
  30   rc_denied     Access denied
  31   rc_norename   Cannot rename between drives
  32   rc_extent     Extent missing
  33   rc_uncached   Uncached
  34   rc_toobig     File too big
  35   rc_notboot    Disk not bootable
  36   rc_inuse      Drive in use
  ---- ------------- --------------------------------------------------

  ---- ----------------- ---------------------------------
  56   rc_invpartition   Invalid partition
  57   rc_partexist      Partition already exists
  58   rc_notimp         Not implemented
  59   rc_partopen       Partition open
  60   rc_nohandle       Out of handles
  61   rc_notswap        Not a swap partition
  62   rc_mapped         Drive already mapped
  63   rc_noxdpb         No XDPB
  64   rc_noswap         No suitable swap partition
  65   rc_invdevice      Invalid device
  67   rc_cmdphase       Command phase error
  68   rc_dataphase      Data phase error
  69   rc_notdir         Not a directory
  74   rc_fragmented     File is fragmented, use .DEFRAG
  ---- ----------------- ---------------------------------

esxDOS Compatible Calls

Low-level calls

  ---------------- -------- ----------------------------
  disk_filemap     $85 ()   obtain file allocation map
  disk_strmstart   $86 ()   start streaming operation
  disk_strmend     $87 ()   end streaming operation
  ---------------- -------- ----------------------------

Miscellaneous calls

  -------------- -------- ---------------------------------------
  m_dosversion   $88 ()   get NextZXOS version/mode information
  m_getsetdrv    $89 ()   get/set default drive
  m_tapein       $8B ()   tape redirection control (input)
  m_tapeout      $8C ()   tape redirection control (output)
  m_gethandle    $8D ()   get handle for current dot command
  m_getdate      $8E ()   get current date/time
  m_execcmd      $8F ()   execute a dot command
  m_setcaps      $91 ()   set additional capabilities
  m_drvapi       $92 ()   access API for installable drivers
  m_geterr       $93 ()   get or generate error message
  m_p3dos        $94 ()   execute +3DOS/IDEDOS/NextZXOS call
  m_errh         $95 ()   register dot command error handler
  -------------- -------- ---------------------------------------

File calls

  ------------- -------- -------------------------------
  f_open        $9A ()   open file
  f_close       $9B ()   close file
  f_sync        $9C ()   sync file changes to disk
  f_read        $9D ()   read file
  f_write       $9E ()   write file
  f_seek        $9F ()   set file position
  f_fgetpos     $A0 ()   get file position
  f_fstat       $A1 ()   get open file information
  f_ftruncate   $A2 ()   truncate/extend open file
  f_opendir     $A3 ()   open directory for reading
  f_readdir     $A4 ()   read directory entry
  f_telldir     $A5 ()   get directory position
  f_seekdir     $A6 ()   set directory position
  f_rewinddir   $A7 ()   rewind to start of directory
  f_getcwd      $A8 ()   get current working directory
  f_chdir       $A9 ()   change directory
  f_mkdir       $AA ()   make directory
  f_rmdir       $AB ()   remove directory
  f_stat        $AC ()   get unopen file information
  f_unlink      $AD ()   delete file
  f_truncate    $AE ()   truncate/extend unopen file
  f_chmod       $AF ()   change file attributes
  f_rename      $B0 ()   rename/move file
  f_getfree     $B1 ()   get free space
  ------------- -------- -------------------------------
